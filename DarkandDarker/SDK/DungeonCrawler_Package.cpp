/**
 * Name: DarkAndDarker-Playtest
 * Version: Playtest_3_Hotfix_3
 */

#include "../SDK.h"

namespace CG
{
	// --------------------------------------------------
	// # Structs Functions
	// --------------------------------------------------
	/**
	 * Function:
	 * 		RVA    -> 0x01720B30
	 * 		Name   -> Function DungeonCrawler.AccountLink.UnbindMsgAll
	 * 		Flags  -> (Native, Public)
	 * Parameters:
	 * 		class UObject*                                     InObject                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UAccountLink::UnbindMsgAll(class UObject* InObject)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.AccountLink.UnbindMsgAll");
		
		UAccountLink_UnbindMsgAll_Params params {};
		params.InObject = InObject;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01720A60
	 * 		Name   -> Function DungeonCrawler.AccountLink.UnbindMsg
	 * 		Flags  -> (Native, Public)
	 * Parameters:
	 * 		class UScriptStruct*                               InMsgType                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UObject*                                     InObject                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UAccountLink::UnbindMsg(class UScriptStruct* InMsgType, class UObject* InObject)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.AccountLink.UnbindMsg");
		
		UAccountLink_UnbindMsg_Params params {};
		params.InMsgType = InMsgType;
		params.InObject = InObject;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01720A40
	 * 		Name   -> Function DungeonCrawler.AccountLink.TerminateBase
	 * 		Flags  -> (Native, Public)
	 */
	void UAccountLink::TerminateBase()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.AccountLink.TerminateBase");
		
		UAccountLink_TerminateBase_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D3C640
	 * 		Name   -> Function DungeonCrawler.AccountLink.BroadcastMsgBlueprint
	 * 		Flags  -> (Native, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		int32_t                                            InMsg                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UAccountLink::BroadcastMsgBlueprint(int32_t InMsg)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.AccountLink.BroadcastMsgBlueprint");
		
		UAccountLink_BroadcastMsgBlueprint_Params params {};
		params.InMsg = InMsg;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UAccountLink.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UAccountLink::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.AccountLink");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01720B30
	 * 		Name   -> Function DungeonCrawler.AccountLinkAll.UnbindMsgAll
	 * 		Flags  -> (Native, Public)
	 * Parameters:
	 * 		class UObject*                                     InObject                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UAccountLinkAll::UnbindMsgAll(class UObject* InObject)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.AccountLinkAll.UnbindMsgAll");
		
		UAccountLinkAll_UnbindMsgAll_Params params {};
		params.InObject = InObject;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01720A60
	 * 		Name   -> Function DungeonCrawler.AccountLinkAll.UnbindMsg
	 * 		Flags  -> (Native, Public)
	 * Parameters:
	 * 		class UScriptStruct*                               InMsgType                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UObject*                                     InObject                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UAccountLinkAll::UnbindMsg(class UScriptStruct* InMsgType, class UObject* InObject)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.AccountLinkAll.UnbindMsg");
		
		UAccountLinkAll_UnbindMsg_Params params {};
		params.InMsgType = InMsgType;
		params.InObject = InObject;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01720A40
	 * 		Name   -> Function DungeonCrawler.AccountLinkAll.TerminateBase
	 * 		Flags  -> (Native, Public)
	 */
	void UAccountLinkAll::TerminateBase()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.AccountLinkAll.TerminateBase");
		
		UAccountLinkAll_TerminateBase_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D3C640
	 * 		Name   -> Function DungeonCrawler.AccountLinkAll.BroadcastMsgBlueprint
	 * 		Flags  -> (Native, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		int32_t                                            InMsg                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UAccountLinkAll::BroadcastMsgBlueprint(int32_t InMsg)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.AccountLinkAll.BroadcastMsgBlueprint");
		
		UAccountLinkAll_BroadcastMsgBlueprint_Params params {};
		params.InMsg = InMsg;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UAccountLinkAll.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UAccountLinkAll::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.AccountLinkAll");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01720B30
	 * 		Name   -> Function DungeonCrawler.AccountSession.UnbindMsgAll
	 * 		Flags  -> (Native, Public)
	 * Parameters:
	 * 		class UObject*                                     InObject                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UAccountSession::UnbindMsgAll(class UObject* InObject)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.AccountSession.UnbindMsgAll");
		
		UAccountSession_UnbindMsgAll_Params params {};
		params.InObject = InObject;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01720A60
	 * 		Name   -> Function DungeonCrawler.AccountSession.UnbindMsg
	 * 		Flags  -> (Native, Public)
	 * Parameters:
	 * 		class UScriptStruct*                               InMsgType                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UObject*                                     InObject                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UAccountSession::UnbindMsg(class UScriptStruct* InMsgType, class UObject* InObject)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.AccountSession.UnbindMsg");
		
		UAccountSession_UnbindMsg_Params params {};
		params.InMsgType = InMsgType;
		params.InObject = InObject;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01720A40
	 * 		Name   -> Function DungeonCrawler.AccountSession.TerminateBase
	 * 		Flags  -> (Native, Public)
	 */
	void UAccountSession::TerminateBase()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.AccountSession.TerminateBase");
		
		UAccountSession_TerminateBase_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D3C640
	 * 		Name   -> Function DungeonCrawler.AccountSession.BroadcastMsgBlueprint
	 * 		Flags  -> (Native, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		int32_t                                            InMsg                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UAccountSession::BroadcastMsgBlueprint(int32_t InMsg)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.AccountSession.BroadcastMsgBlueprint");
		
		UAccountSession_BroadcastMsgBlueprint_Params params {};
		params.InMsg = InMsg;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UAccountSession.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UAccountSession::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.AccountSession");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDCDataAssetBase.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDCDataAssetBase::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCDataAssetBase");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UActorStatusUIData.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UActorStatusUIData::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.ActorStatusUIData");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UArtDataPlayerCharacter.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UArtDataPlayerCharacter::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.ArtDataPlayerCharacter");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UArtDataMonster.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UArtDataMonster::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.ArtDataMonster");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UArtDataAoe.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UArtDataAoe::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.ArtDataAoe");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UArtDataProps.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UArtDataProps::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.ArtDataProps");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UArtDataItem.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UArtDataItem::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.ArtDataItem");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UArtDataAnimatedItem.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UArtDataAnimatedItem::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.ArtDataAnimatedItem");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UArtDataWeapon.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UArtDataWeapon::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.ArtDataWeapon");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UArtDataArmor.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UArtDataArmor::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.ArtDataArmor");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UArtDataUtility.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UArtDataUtility::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.ArtDataUtility");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UArtDataAccessory.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UArtDataAccessory::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.ArtDataAccessory");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UArtDataMisc.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UArtDataMisc::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.ArtDataMisc");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UArtDataProjectile.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UArtDataProjectile::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.ArtDataProjectile");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UArtDataSkill.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UArtDataSkill::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.ArtDataSkill");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UArtDataSpell.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UArtDataSpell::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.ArtDataSpell");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UArtDataPerk.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UArtDataPerk::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.ArtDataPerk");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UArtDataMerchant.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UArtDataMerchant::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.ArtDataMerchant");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UArtDataEmote.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UArtDataEmote::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.ArtDataEmote");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01724500
	 * 		Name   -> Function DungeonCrawler.AsyncTaskAttributeChanged.ListenForAttributesChange
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UAbilitySystemComponent*                     AbilitySystemComponent                                     (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		TArray<struct FGameplayAttribute>                  Attributes                                                 (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
	 */
	class UAsyncTaskAttributeChanged* UAsyncTaskAttributeChanged::STATIC_ListenForAttributesChange(class UAbilitySystemComponent* AbilitySystemComponent, TArray<struct FGameplayAttribute> Attributes)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.AsyncTaskAttributeChanged.ListenForAttributesChange");
		
		UAsyncTaskAttributeChanged_ListenForAttributesChange_Params params {};
		params.AbilitySystemComponent = AbilitySystemComponent;
		params.Attributes = Attributes;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017242F0
	 * 		Name   -> Function DungeonCrawler.AsyncTaskAttributeChanged.ListenForAttributeChange
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UAbilitySystemComponent*                     AbilitySystemComponent                                     (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FGameplayAttribute                          Attribute                                                  (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UAsyncTaskAttributeChanged* UAsyncTaskAttributeChanged::STATIC_ListenForAttributeChange(class UAbilitySystemComponent* AbilitySystemComponent, const struct FGameplayAttribute& Attribute)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.AsyncTaskAttributeChanged.ListenForAttributeChange");
		
		UAsyncTaskAttributeChanged_ListenForAttributeChange_Params params {};
		params.AbilitySystemComponent = AbilitySystemComponent;
		params.Attribute = Attribute;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01723E50
	 * 		Name   -> Function DungeonCrawler.AsyncTaskAttributeChanged.EndTask
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void UAsyncTaskAttributeChanged::EndTask()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.AsyncTaskAttributeChanged.EndTask");
		
		UAsyncTaskAttributeChanged_EndTask_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UAsyncTaskAttributeChanged.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UAsyncTaskAttributeChanged::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.AsyncTaskAttributeChanged");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01724640
	 * 		Name   -> Function DungeonCrawler.AsyncTaskCooldownChanged.ListenForCooldownChange
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UAbilitySystemComponent*                     AbilitySystemComponent                                     (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FGameplayTagContainer                       CooldownTags                                               (Parm, NativeAccessSpecifierPublic)
	 * 		bool                                               UseServerCooldown                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UAsyncTaskCooldownChanged* UAsyncTaskCooldownChanged::STATIC_ListenForCooldownChange(class UAbilitySystemComponent* AbilitySystemComponent, const struct FGameplayTagContainer& CooldownTags, bool UseServerCooldown)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.AsyncTaskCooldownChanged.ListenForCooldownChange");
		
		UAsyncTaskCooldownChanged_ListenForCooldownChange_Params params {};
		params.AbilitySystemComponent = AbilitySystemComponent;
		params.CooldownTags = CooldownTags;
		params.UseServerCooldown = UseServerCooldown;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01723E70
	 * 		Name   -> Function DungeonCrawler.AsyncTaskCooldownChanged.EndTask
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void UAsyncTaskCooldownChanged::EndTask()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.AsyncTaskCooldownChanged.EndTask");
		
		UAsyncTaskCooldownChanged_EndTask_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UAsyncTaskCooldownChanged.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UAsyncTaskCooldownChanged::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.AsyncTaskCooldownChanged");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01724870
	 * 		Name   -> Function DungeonCrawler.AsyncTaskEffectInhibitionChanged.ListenForGameplayInhibitionChange
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UAbilitySystemComponent*                     AbilitySystemComponent                                     (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FGameplayTag                                EffectGameplayTag                                          (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UAsyncTaskEffectInhibitionChanged* UAsyncTaskEffectInhibitionChanged::STATIC_ListenForGameplayInhibitionChange(class UAbilitySystemComponent* AbilitySystemComponent, const struct FGameplayTag& EffectGameplayTag)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.AsyncTaskEffectInhibitionChanged.ListenForGameplayInhibitionChange");
		
		UAsyncTaskEffectInhibitionChanged_ListenForGameplayInhibitionChange_Params params {};
		params.AbilitySystemComponent = AbilitySystemComponent;
		params.EffectGameplayTag = EffectGameplayTag;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01723E90
	 * 		Name   -> Function DungeonCrawler.AsyncTaskEffectInhibitionChanged.EndTask
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void UAsyncTaskEffectInhibitionChanged::EndTask()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.AsyncTaskEffectInhibitionChanged.EndTask");
		
		UAsyncTaskEffectInhibitionChanged_EndTask_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UAsyncTaskEffectInhibitionChanged.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UAsyncTaskEffectInhibitionChanged::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.AsyncTaskEffectInhibitionChanged");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017247A0
	 * 		Name   -> Function DungeonCrawler.AsyncTaskEffectStackChanged.ListenForGameplayEffectStackChange
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UAbilitySystemComponent*                     AbilitySystemComponent                                     (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FGameplayTag                                EffectGameplayTag                                          (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UAsyncTaskEffectStackChanged* UAsyncTaskEffectStackChanged::STATIC_ListenForGameplayEffectStackChange(class UAbilitySystemComponent* AbilitySystemComponent, const struct FGameplayTag& EffectGameplayTag)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.AsyncTaskEffectStackChanged.ListenForGameplayEffectStackChange");
		
		UAsyncTaskEffectStackChanged_ListenForGameplayEffectStackChange_Params params {};
		params.AbilitySystemComponent = AbilitySystemComponent;
		params.EffectGameplayTag = EffectGameplayTag;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01723EB0
	 * 		Name   -> Function DungeonCrawler.AsyncTaskEffectStackChanged.EndTask
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void UAsyncTaskEffectStackChanged::EndTask()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.AsyncTaskEffectStackChanged.EndTask");
		
		UAsyncTaskEffectStackChanged_EndTask_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UAsyncTaskEffectStackChanged.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UAsyncTaskEffectStackChanged::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.AsyncTaskEffectStackChanged");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01724DD0
	 * 		Name   -> Function DungeonCrawler.AsyncTaskWaitGAActivated.WaitForAbilityActivateWithTagRequirements
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class AActor*                                      TargetActor                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FGameplayTagRequirements                    TagRequirements                                            (Parm, NativeAccessSpecifierPublic)
	 * 		bool                                               IncludeTriggeredAbilities                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               TriggerOnce                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UAsyncTaskWaitGAActivated* UAsyncTaskWaitGAActivated::STATIC_WaitForAbilityActivateWithTagRequirements(class AActor* TargetActor, const struct FGameplayTagRequirements& TagRequirements, bool IncludeTriggeredAbilities, bool TriggerOnce)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.AsyncTaskWaitGAActivated.WaitForAbilityActivateWithTagRequirements");
		
		UAsyncTaskWaitGAActivated_WaitForAbilityActivateWithTagRequirements_Params params {};
		params.TargetActor = TargetActor;
		params.TagRequirements = TagRequirements;
		params.IncludeTriggeredAbilities = IncludeTriggeredAbilities;
		params.TriggerOnce = TriggerOnce;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01724FD0
	 * 		Name   -> Function DungeonCrawler.AsyncTaskWaitGAActivated.WaitForAbilityActivate_Query
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class AActor*                                      TargetActor                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FGameplayTagQuery                           Query                                                      (Parm, NativeAccessSpecifierPublic)
	 * 		bool                                               IncludeTriggeredAbilities                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               TriggerOnce                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UAsyncTaskWaitGAActivated* UAsyncTaskWaitGAActivated::STATIC_WaitForAbilityActivate_Query(class AActor* TargetActor, const struct FGameplayTagQuery& Query, bool IncludeTriggeredAbilities, bool TriggerOnce)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.AsyncTaskWaitGAActivated.WaitForAbilityActivate_Query");
		
		UAsyncTaskWaitGAActivated_WaitForAbilityActivate_Query_Params params {};
		params.TargetActor = TargetActor;
		params.Query = Query;
		params.IncludeTriggeredAbilities = IncludeTriggeredAbilities;
		params.TriggerOnce = TriggerOnce;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01724C30
	 * 		Name   -> Function DungeonCrawler.AsyncTaskWaitGAActivated.WaitForAbilityActivate
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class AActor*                                      TargetActor                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FGameplayTag                                WithTag                                                    (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FGameplayTag                                WithoutTag                                                 (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               IncludeTriggeredAbilities                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               TriggerOnce                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UAsyncTaskWaitGAActivated* UAsyncTaskWaitGAActivated::STATIC_WaitForAbilityActivate(class AActor* TargetActor, const struct FGameplayTag& WithTag, const struct FGameplayTag& WithoutTag, bool IncludeTriggeredAbilities, bool TriggerOnce)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.AsyncTaskWaitGAActivated.WaitForAbilityActivate");
		
		UAsyncTaskWaitGAActivated_WaitForAbilityActivate_Params params {};
		params.TargetActor = TargetActor;
		params.WithTag = WithTag;
		params.WithoutTag = WithoutTag;
		params.IncludeTriggeredAbilities = IncludeTriggeredAbilities;
		params.TriggerOnce = TriggerOnce;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01724940
	 * 		Name   -> Function DungeonCrawler.AsyncTaskWaitGAActivated.OnAbilityActivate
	 * 		Flags  -> (Final, Native, Protected)
	 * Parameters:
	 * 		class UGameplayAbility*                            ActivatedAbility                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UAsyncTaskWaitGAActivated::OnAbilityActivate(class UGameplayAbility* ActivatedAbility)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.AsyncTaskWaitGAActivated.OnAbilityActivate");
		
		UAsyncTaskWaitGAActivated_OnAbilityActivate_Params params {};
		params.ActivatedAbility = ActivatedAbility;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UAsyncTaskWaitGAActivated.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UAsyncTaskWaitGAActivated::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.AsyncTaskWaitGAActivated");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017252F0
	 * 		Name   -> Function DungeonCrawler.AsyncTaskWaitGAEnded.WaitForAbilityEndWithTagRequirements
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class AActor*                                      TargetActor                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FGameplayTagRequirements                    TagRequirements                                            (Parm, NativeAccessSpecifierPublic)
	 * 		bool                                               TriggerOnce                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UAsyncTaskWaitGAEnded* UAsyncTaskWaitGAEnded::STATIC_WaitForAbilityEndWithTagRequirements(class AActor* TargetActor, const struct FGameplayTagRequirements& TagRequirements, bool TriggerOnce)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.AsyncTaskWaitGAEnded.WaitForAbilityEndWithTagRequirements");
		
		UAsyncTaskWaitGAEnded_WaitForAbilityEndWithTagRequirements_Params params {};
		params.TargetActor = TargetActor;
		params.TagRequirements = TagRequirements;
		params.TriggerOnce = TriggerOnce;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017254A0
	 * 		Name   -> Function DungeonCrawler.AsyncTaskWaitGAEnded.WaitForAbilityEnd_Query
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class AActor*                                      TargetActor                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FGameplayTagQuery                           Query                                                      (Parm, NativeAccessSpecifierPublic)
	 * 		bool                                               TriggerOnce                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UAsyncTaskWaitGAEnded* UAsyncTaskWaitGAEnded::STATIC_WaitForAbilityEnd_Query(class AActor* TargetActor, const struct FGameplayTagQuery& Query, bool TriggerOnce)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.AsyncTaskWaitGAEnded.WaitForAbilityEnd_Query");
		
		UAsyncTaskWaitGAEnded_WaitForAbilityEnd_Query_Params params {};
		params.TargetActor = TargetActor;
		params.Query = Query;
		params.TriggerOnce = TriggerOnce;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017251A0
	 * 		Name   -> Function DungeonCrawler.AsyncTaskWaitGAEnded.WaitForAbilityEnd
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class AActor*                                      TargetActor                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FGameplayTag                                WithTag                                                    (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FGameplayTag                                WithoutTag                                                 (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               TriggerOnce                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UAsyncTaskWaitGAEnded* UAsyncTaskWaitGAEnded::STATIC_WaitForAbilityEnd(class AActor* TargetActor, const struct FGameplayTag& WithTag, const struct FGameplayTag& WithoutTag, bool TriggerOnce)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.AsyncTaskWaitGAEnded.WaitForAbilityEnd");
		
		UAsyncTaskWaitGAEnded_WaitForAbilityEnd_Params params {};
		params.TargetActor = TargetActor;
		params.WithTag = WithTag;
		params.WithoutTag = WithoutTag;
		params.TriggerOnce = TriggerOnce;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01724A60
	 * 		Name   -> Function DungeonCrawler.AsyncTaskWaitGAEnded.OnAbilityEnded
	 * 		Flags  -> (Final, Native, Protected, HasOutParms)
	 * Parameters:
	 * 		struct FAbilityEndedData                           AbilityEndedData                                           (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UAsyncTaskWaitGAEnded::OnAbilityEnded(const struct FAbilityEndedData& AbilityEndedData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.AsyncTaskWaitGAEnded.OnAbilityEnded");
		
		UAsyncTaskWaitGAEnded_OnAbilityEnded_Params params {};
		params.AbilityEndedData = AbilityEndedData;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UAsyncTaskWaitGAEnded.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UAsyncTaskWaitGAEnded::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.AsyncTaskWaitGAEnded");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01725620
	 * 		Name   -> Function DungeonCrawler.AsyncTaskWaitGameplayEvent.WaitGameplayEventToActor
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class AActor*                                      TargetActor                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FGameplayTag                                EventTag                                                   (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               OnlyTriggerOnce                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               OnlyMatchExact                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UAsyncTaskWaitGameplayEvent* UAsyncTaskWaitGameplayEvent::STATIC_WaitGameplayEventToActor(class AActor* TargetActor, const struct FGameplayTag& EventTag, bool OnlyTriggerOnce, bool OnlyMatchExact)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.AsyncTaskWaitGameplayEvent.WaitGameplayEventToActor");
		
		UAsyncTaskWaitGameplayEvent_WaitGameplayEventToActor_Params params {};
		params.TargetActor = TargetActor;
		params.EventTag = EventTag;
		params.OnlyTriggerOnce = OnlyTriggerOnce;
		params.OnlyMatchExact = OnlyMatchExact;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> DelegateFunction DungeonCrawler.AsyncTaskWaitGameplayEvent.EventReceivedDelegate__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 * Parameters:
	 * 		struct FGameplayEventData                          Payload                                                    (Parm, NativeAccessSpecifierPublic)
	 */
	void UAsyncTaskWaitGameplayEvent::EventReceivedDelegate__DelegateSignature(const struct FGameplayEventData& Payload)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction DungeonCrawler.AsyncTaskWaitGameplayEvent.EventReceivedDelegate__DelegateSignature");
		
		UAsyncTaskWaitGameplayEvent_EventReceivedDelegate__DelegateSignature_Params params {};
		params.Payload = Payload;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UAsyncTaskWaitGameplayEvent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UAsyncTaskWaitGameplayEvent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.AsyncTaskWaitGameplayEvent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01724BA0
	 * 		Name   -> Function DungeonCrawler.AttackInputManagerComponent.SetAttackEnabled
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		bool                                               bIsAttackEnabled                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UAttackInputManagerComponent::SetAttackEnabled(bool bIsAttackEnabled)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.AttackInputManagerComponent.SetAttackEnabled");
		
		UAttackInputManagerComponent_SetAttackEnabled_Params params {};
		params.bIsAttackEnabled = bIsAttackEnabled;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01724B00
	 * 		Name   -> Function DungeonCrawler.AttackInputManagerComponent.OnAbilityEnded
	 * 		Flags  -> (Final, Native, Private, HasOutParms)
	 * Parameters:
	 * 		struct FAbilityEndedData                           AbilityEndedData                                           (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UAttackInputManagerComponent::OnAbilityEnded(const struct FAbilityEndedData& AbilityEndedData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.AttackInputManagerComponent.OnAbilityEnded");
		
		UAttackInputManagerComponent_OnAbilityEnded_Params params {};
		params.AbilityEndedData = AbilityEndedData;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017249D0
	 * 		Name   -> Function DungeonCrawler.AttackInputManagerComponent.OnAbilityActivate
	 * 		Flags  -> (Final, Native, Private)
	 * Parameters:
	 * 		class UGameplayAbility*                            ActivatedAbility                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UAttackInputManagerComponent::OnAbilityActivate(class UGameplayAbility* ActivatedAbility)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.AttackInputManagerComponent.OnAbilityActivate");
		
		UAttackInputManagerComponent_OnAbilityActivate_Params params {};
		params.ActivatedAbility = ActivatedAbility;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01724260
	 * 		Name   -> Function DungeonCrawler.AttackInputManagerComponent.HandleAttackInput
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		struct FGameplayTag                                InputTag                                                   (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UAttackInputManagerComponent::HandleAttackInput(const struct FGameplayTag& InputTag)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.AttackInputManagerComponent.HandleAttackInput");
		
		UAttackInputManagerComponent_HandleAttackInput_Params params {};
		params.InputTag = InputTag;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017241D0
	 * 		Name   -> Function DungeonCrawler.AttackInputManagerComponent.GetCurrentTriggerTag
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		struct FGameplayTag                                TriggerTag                                                 (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FGameplayTag UAttackInputManagerComponent::GetCurrentTriggerTag(const struct FGameplayTag& TriggerTag)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.AttackInputManagerComponent.GetCurrentTriggerTag");
		
		UAttackInputManagerComponent_GetCurrentTriggerTag_Params params {};
		params.TriggerTag = TriggerTag;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01723ED0
	 * 		Name   -> Function DungeonCrawler.AttackInputManagerComponent.EventReceived
	 * 		Flags  -> (Final, Native, Protected)
	 * Parameters:
	 * 		struct FGameplayEventData                          EventData                                                  (Parm, NativeAccessSpecifierPublic)
	 */
	void UAttackInputManagerComponent::EventReceived(const struct FGameplayEventData& EventData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.AttackInputManagerComponent.EventReceived");
		
		UAttackInputManagerComponent_EventReceived_Params params {};
		params.EventData = EventData;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UAttackInputManagerComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UAttackInputManagerComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.AttackInputManagerComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0172F4C0
	 * 		Name   -> Function DungeonCrawler.BTDecorator_DCGameBlackboard.UnbindMsgAll
	 * 		Flags  -> (Native, Public)
	 * Parameters:
	 * 		class UObject*                                     InObject                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UBTDecorator_DCGameBlackboard::UnbindMsgAll(class UObject* InObject)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.BTDecorator_DCGameBlackboard.UnbindMsgAll");
		
		UBTDecorator_DCGameBlackboard_UnbindMsgAll_Params params {};
		params.InObject = InObject;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0172F320
	 * 		Name   -> Function DungeonCrawler.BTDecorator_DCGameBlackboard.UnbindMsg
	 * 		Flags  -> (Native, Public)
	 * Parameters:
	 * 		class UScriptStruct*                               InMsgType                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UObject*                                     InObject                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UBTDecorator_DCGameBlackboard::UnbindMsg(class UScriptStruct* InMsgType, class UObject* InObject)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.BTDecorator_DCGameBlackboard.UnbindMsg");
		
		UBTDecorator_DCGameBlackboard_UnbindMsg_Params params {};
		params.InMsgType = InMsgType;
		params.InObject = InObject;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0172F2D0
	 * 		Name   -> Function DungeonCrawler.BTDecorator_DCGameBlackboard.TerminateBase
	 * 		Flags  -> (Native, Public)
	 */
	void UBTDecorator_DCGameBlackboard::TerminateBase()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.BTDecorator_DCGameBlackboard.TerminateBase");
		
		UBTDecorator_DCGameBlackboard_TerminateBase_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D3C640
	 * 		Name   -> Function DungeonCrawler.BTDecorator_DCGameBlackboard.BroadcastMsgBlueprint
	 * 		Flags  -> (Native, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		int32_t                                            InMsg                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UBTDecorator_DCGameBlackboard::BroadcastMsgBlueprint(int32_t InMsg)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.BTDecorator_DCGameBlackboard.BroadcastMsgBlueprint");
		
		UBTDecorator_DCGameBlackboard_BroadcastMsgBlueprint_Params params {};
		params.InMsg = InMsg;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UBTDecorator_DCGameBlackboard.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UBTDecorator_DCGameBlackboard::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.BTDecorator_DCGameBlackboard");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UBTDecorator_DCGameCheckGameState.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UBTDecorator_DCGameCheckGameState::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.BTDecorator_DCGameCheckGameState");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UBTD_CheckGameplayTagsOnActorAbortObservers.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UBTD_CheckGameplayTagsOnActorAbortObservers::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.BTD_CheckGameplayTagsOnActorAbortObservers");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UBTD_RandomCooldown.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UBTD_RandomCooldown::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.BTD_RandomCooldown");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0172F550
	 * 		Name   -> Function DungeonCrawler.BTService_DCGameBase.UnbindMsgAll
	 * 		Flags  -> (Native, Public)
	 * Parameters:
	 * 		class UObject*                                     InObject                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UBTService_DCGameBase::UnbindMsgAll(class UObject* InObject)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.BTService_DCGameBase.UnbindMsgAll");
		
		UBTService_DCGameBase_UnbindMsgAll_Params params {};
		params.InObject = InObject;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0172F3F0
	 * 		Name   -> Function DungeonCrawler.BTService_DCGameBase.UnbindMsg
	 * 		Flags  -> (Native, Public)
	 * Parameters:
	 * 		class UScriptStruct*                               InMsgType                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UObject*                                     InObject                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UBTService_DCGameBase::UnbindMsg(class UScriptStruct* InMsgType, class UObject* InObject)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.BTService_DCGameBase.UnbindMsg");
		
		UBTService_DCGameBase_UnbindMsg_Params params {};
		params.InMsgType = InMsgType;
		params.InObject = InObject;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0172F300
	 * 		Name   -> Function DungeonCrawler.BTService_DCGameBase.TerminateBase
	 * 		Flags  -> (Native, Public)
	 */
	void UBTService_DCGameBase::TerminateBase()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.BTService_DCGameBase.TerminateBase");
		
		UBTService_DCGameBase_TerminateBase_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D3C640
	 * 		Name   -> Function DungeonCrawler.BTService_DCGameBase.BroadcastMsgBlueprint
	 * 		Flags  -> (Native, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		int32_t                                            InMsg                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UBTService_DCGameBase::BroadcastMsgBlueprint(int32_t InMsg)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.BTService_DCGameBase.BroadcastMsgBlueprint");
		
		UBTService_DCGameBase_BroadcastMsgBlueprint_Params params {};
		params.InMsg = InMsg;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UBTService_DCGameBase.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UBTService_DCGameBase::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.BTService_DCGameBase");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0172F550
	 * 		Name   -> Function DungeonCrawler.BTTask_DCGameBase.UnbindMsgAll
	 * 		Flags  -> (Native, Public)
	 * Parameters:
	 * 		class UObject*                                     InObject                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UBTTask_DCGameBase::UnbindMsgAll(class UObject* InObject)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.BTTask_DCGameBase.UnbindMsgAll");
		
		UBTTask_DCGameBase_UnbindMsgAll_Params params {};
		params.InObject = InObject;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0172F3F0
	 * 		Name   -> Function DungeonCrawler.BTTask_DCGameBase.UnbindMsg
	 * 		Flags  -> (Native, Public)
	 * Parameters:
	 * 		class UScriptStruct*                               InMsgType                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UObject*                                     InObject                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UBTTask_DCGameBase::UnbindMsg(class UScriptStruct* InMsgType, class UObject* InObject)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.BTTask_DCGameBase.UnbindMsg");
		
		UBTTask_DCGameBase_UnbindMsg_Params params {};
		params.InMsgType = InMsgType;
		params.InObject = InObject;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0172F300
	 * 		Name   -> Function DungeonCrawler.BTTask_DCGameBase.TerminateBase
	 * 		Flags  -> (Native, Public)
	 */
	void UBTTask_DCGameBase::TerminateBase()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.BTTask_DCGameBase.TerminateBase");
		
		UBTTask_DCGameBase_TerminateBase_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D3C640
	 * 		Name   -> Function DungeonCrawler.BTTask_DCGameBase.BroadcastMsgBlueprint
	 * 		Flags  -> (Native, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		int32_t                                            InMsg                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UBTTask_DCGameBase::BroadcastMsgBlueprint(int32_t InMsg)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.BTTask_DCGameBase.BroadcastMsgBlueprint");
		
		UBTTask_DCGameBase_BroadcastMsgBlueprint_Params params {};
		params.InMsg = InMsg;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UBTTask_DCGameBase.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UBTTask_DCGameBase::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.BTTask_DCGameBase");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UBTTask_DCGameAnnounce.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UBTTask_DCGameAnnounce::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.BTTask_DCGameAnnounce");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UBTTask_DCGameAnnounceArray.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UBTTask_DCGameAnnounceArray::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.BTTask_DCGameAnnounceArray");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UBTTask_DCGameCheckGameStart.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UBTTask_DCGameCheckGameStart::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.BTTask_DCGameCheckGameStart");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UBTTask_DCGameExecuteGameResult.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UBTTask_DCGameExecuteGameResult::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.BTTask_DCGameExecuteGameResult");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UBTTask_DCGameExitAllPlayer.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UBTTask_DCGameExitAllPlayer::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.BTTask_DCGameExitAllPlayer");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UBTTask_DCGameFloorRule.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UBTTask_DCGameFloorRule::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.BTTask_DCGameFloorRule");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UBTTask_DCGameServerTravel.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UBTTask_DCGameServerTravel::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.BTTask_DCGameServerTravel");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UBTTask_DCGameState.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UBTTask_DCGameState::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.BTTask_DCGameState");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.BTT_BlueprintBase.OnTaskFinished
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 * Parameters:
	 * 		class AAIController*                               OwnerController                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class APawn*                                       ControlledPawn                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EBTNodeResult                                      TaskResult                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UBTT_BlueprintBase::OnTaskFinished(class AAIController* OwnerController, class APawn* ControlledPawn, EBTNodeResult TaskResult)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.BTT_BlueprintBase.OnTaskFinished");
		
		UBTT_BlueprintBase_OnTaskFinished_Params params {};
		params.OwnerController = OwnerController;
		params.ControlledPawn = ControlledPawn;
		params.TaskResult = TaskResult;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UBTT_BlueprintBase.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UBTT_BlueprintBase::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.BTT_BlueprintBase");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UBTT_CustomRunBehavior.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UBTT_CustomRunBehavior::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.BTT_CustomRunBehavior");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UCharacterCreateAttributeWidgetData.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UCharacterCreateAttributeWidgetData::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.CharacterCreateAttributeWidgetData");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017C2930
	 * 		Name   -> Function DungeonCrawler.DCWidgetBase.UnbindMsgOwner
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UScriptStruct*                               InMsgType                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UDCWidgetBase::UnbindMsgOwner(class UScriptStruct* InMsgType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCWidgetBase.UnbindMsgOwner");
		
		UDCWidgetBase_UnbindMsgOwner_Params params {};
		params.InMsgType = InMsgType;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017C2910
	 * 		Name   -> Function DungeonCrawler.DCWidgetBase.UnbindMsgAllOwner
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void UDCWidgetBase::UnbindMsgAllOwner()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCWidgetBase.UnbindMsgAllOwner");
		
		UDCWidgetBase_UnbindMsgAllOwner_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01793B60
	 * 		Name   -> Function DungeonCrawler.DCWidgetBase.UnbindMsgAll
	 * 		Flags  -> (Native, Public)
	 * Parameters:
	 * 		class UObject*                                     InObject                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UDCWidgetBase::UnbindMsgAll(class UObject* InObject)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCWidgetBase.UnbindMsgAll");
		
		UDCWidgetBase_UnbindMsgAll_Params params {};
		params.InObject = InObject;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01793A90
	 * 		Name   -> Function DungeonCrawler.DCWidgetBase.UnbindMsg
	 * 		Flags  -> (Native, Public)
	 * Parameters:
	 * 		class UScriptStruct*                               InMsgType                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UObject*                                     InObject                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UDCWidgetBase::UnbindMsg(class UScriptStruct* InMsgType, class UObject* InObject)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCWidgetBase.UnbindMsg");
		
		UDCWidgetBase_UnbindMsg_Params params {};
		params.InMsgType = InMsgType;
		params.InObject = InObject;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01793A60
	 * 		Name   -> Function DungeonCrawler.DCWidgetBase.TerminateBase
	 * 		Flags  -> (Native, Public)
	 */
	void UDCWidgetBase::TerminateBase()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCWidgetBase.TerminateBase");
		
		UDCWidgetBase_TerminateBase_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017C1DD0
	 * 		Name   -> Function DungeonCrawler.DCWidgetBase.IsSpectating
	 * 		Flags  -> (Final, Native, Protected, BlueprintCallable)
	 */
	bool UDCWidgetBase::IsSpectating()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCWidgetBase.IsSpectating");
		
		UDCWidgetBase_IsSpectating_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017C1390
	 * 		Name   -> Function DungeonCrawler.DCWidgetBase.GetOwningBaseInterfaceBlueprint
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void UDCWidgetBase::GetOwningBaseInterfaceBlueprint()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCWidgetBase.GetOwningBaseInterfaceBlueprint");
		
		UDCWidgetBase_GetOwningBaseInterfaceBlueprint_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D3C640
	 * 		Name   -> Function DungeonCrawler.DCWidgetBase.BroadcastMsgBlueprint
	 * 		Flags  -> (Native, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		int32_t                                            InMsg                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UDCWidgetBase::BroadcastMsgBlueprint(int32_t InMsg)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCWidgetBase.BroadcastMsgBlueprint");
		
		UDCWidgetBase_BroadcastMsgBlueprint_Params params {};
		params.InMsg = InMsg;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017C0DB0
	 * 		Name   -> Function DungeonCrawler.DCWidgetBase.BindMsgOwner
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UScriptStruct*                               InMsgType                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UBindMsgNode*                                InMsgDynamicDelegate                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UDCWidgetBase::BindMsgOwner(class UScriptStruct* InMsgType, class UBindMsgNode* InMsgDynamicDelegate)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCWidgetBase.BindMsgOwner");
		
		UDCWidgetBase_BindMsgOwner_Params params {};
		params.InMsgType = InMsgType;
		params.InMsgDynamicDelegate = InMsgDynamicDelegate;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDCWidgetBase.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDCWidgetBase::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCWidgetBase");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UCharacterCreateAttributeWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UCharacterCreateAttributeWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.CharacterCreateAttributeWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UCharacterCreateClassItemWidgetData.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UCharacterCreateClassItemWidgetData::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.CharacterCreateClassItemWidgetData");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UCharacterCreateClassItemWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UCharacterCreateClassItemWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.CharacterCreateClassItemWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UCharacterCreatePerkItemWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UCharacterCreatePerkItemWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.CharacterCreatePerkItemWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0172F200
	 * 		Name   -> Function DungeonCrawler.CharacterCreateWidget.OnTextChangedNickName
	 * 		Flags  -> (Final, Native, Protected, HasOutParms)
	 * Parameters:
	 * 		class FText                                        InNickName                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UCharacterCreateWidget::OnTextChangedNickName(const class FText& InNickName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.CharacterCreateWidget.OnTextChangedNickName");
		
		UCharacterCreateWidget_OnTextChangedNickName_Params params {};
		params.InNickName = InNickName;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0172F050
	 * 		Name   -> Function DungeonCrawler.CharacterCreateWidget.OnGenderClicked
	 * 		Flags  -> (Final, Native, Protected, BlueprintCallable)
	 * Parameters:
	 * 		EDCGender                                          Gender                                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UCharacterCreateWidget::OnGenderClicked(EDCGender Gender)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.CharacterCreateWidget.OnGenderClicked");
		
		UCharacterCreateWidget_OnGenderClicked_Params params {};
		params.Gender = Gender;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0172EF40
	 * 		Name   -> Function DungeonCrawler.CharacterCreateWidget.HandleExitButtonClicked
	 * 		Flags  -> (Final, Native, Protected, BlueprintCallable)
	 */
	void UCharacterCreateWidget::HandleExitButtonClicked()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.CharacterCreateWidget.HandleExitButtonClicked");
		
		UCharacterCreateWidget_HandleExitButtonClicked_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0172EF20
	 * 		Name   -> Function DungeonCrawler.CharacterCreateWidget.HandleConfirmButtonClicked
	 * 		Flags  -> (Final, Native, Protected, BlueprintCallable)
	 */
	void UCharacterCreateWidget::HandleConfirmButtonClicked()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.CharacterCreateWidget.HandleConfirmButtonClicked");
		
		UCharacterCreateWidget_HandleConfirmButtonClicked_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UCharacterCreateWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UCharacterCreateWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.CharacterCreateWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01757650
	 * 		Name   -> Function DungeonCrawler.DCDataComponent.OnRep_AssetId
	 * 		Flags  -> (Final, Native, Private, HasDefaults)
	 * Parameters:
	 * 		struct FPrimaryAssetId                             PrevAssetId                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UDCDataComponent::OnRep_AssetId(const struct FPrimaryAssetId& PrevAssetId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCDataComponent.OnRep_AssetId");
		
		UDCDataComponent_OnRep_AssetId_Params params {};
		params.PrevAssetId = PrevAssetId;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDCDataComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDCDataComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCDataComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDCCharacterDataComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDCCharacterDataComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCCharacterDataComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDCCharacterPartsComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDCCharacterPartsComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCCharacterPartsComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UCharacterSelectCharacterListWidgetData.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UCharacterSelectCharacterListWidgetData::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.CharacterSelectCharacterListWidgetData");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0172F110
	 * 		Name   -> Function DungeonCrawler.CharacterSelectCharListWidget.OnSelectedCharacterId
	 * 		Flags  -> (Final, Native, Protected, BlueprintCallable)
	 * Parameters:
	 * 		class FString                                      CharacterId                                                (ConstParm, Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UCharacterSelectCharListWidget::OnSelectedCharacterId(const class FString& CharacterId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.CharacterSelectCharListWidget.OnSelectedCharacterId");
		
		UCharacterSelectCharListWidget_OnSelectedCharacterId_Params params {};
		params.CharacterId = CharacterId;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.CharacterSelectCharListWidget.OnPageNumber
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 * Parameters:
	 * 		int32_t                                            CurrentPage                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            MaxPage                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UCharacterSelectCharListWidget::OnPageNumber(int32_t CurrentPage, int32_t MaxPage)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.CharacterSelectCharListWidget.OnPageNumber");
		
		UCharacterSelectCharListWidget_OnPageNumber_Params params {};
		params.CurrentPage = CurrentPage;
		params.MaxPage = MaxPage;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0172F0F0
	 * 		Name   -> Function DungeonCrawler.CharacterSelectCharListWidget.OnListRightButtonClicked
	 * 		Flags  -> (Final, Native, Protected, BlueprintCallable)
	 */
	void UCharacterSelectCharListWidget::OnListRightButtonClicked()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.CharacterSelectCharListWidget.OnListRightButtonClicked");
		
		UCharacterSelectCharListWidget_OnListRightButtonClicked_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0172F0D0
	 * 		Name   -> Function DungeonCrawler.CharacterSelectCharListWidget.OnListLeftButtonClicked
	 * 		Flags  -> (Final, Native, Protected, BlueprintCallable)
	 */
	void UCharacterSelectCharListWidget::OnListLeftButtonClicked()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.CharacterSelectCharListWidget.OnListLeftButtonClicked");
		
		UCharacterSelectCharListWidget_OnListLeftButtonClicked_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0172EFC0
	 * 		Name   -> Function DungeonCrawler.CharacterSelectCharListWidget.OnCharacterSlotListViewItemClicked
	 * 		Flags  -> (Final, Native, Protected, BlueprintCallable)
	 * Parameters:
	 * 		class UObject*                                     Obj                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UCharacterSelectCharListWidget::OnCharacterSlotListViewItemClicked(class UObject* Obj)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.CharacterSelectCharListWidget.OnCharacterSlotListViewItemClicked");
		
		UCharacterSelectCharListWidget_OnCharacterSlotListViewItemClicked_Params params {};
		params.Obj = Obj;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.CharacterSelectCharListWidget.OnCharacterSlotData
	 * 		Flags  -> (Event, Protected, HasOutParms, BlueprintEvent)
	 * Parameters:
	 * 		struct FCharacterSlotData                          NewValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		struct FCharacterSlotData                          OldValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UCharacterSelectCharListWidget::OnCharacterSlotData(const struct FCharacterSlotData& NewValue, const struct FCharacterSlotData& OldValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.CharacterSelectCharListWidget.OnCharacterSlotData");
		
		UCharacterSelectCharListWidget_OnCharacterSlotData_Params params {};
		params.NewValue = NewValue;
		params.OldValue = OldValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0172EF00
	 * 		Name   -> Function DungeonCrawler.CharacterSelectCharListWidget.HandleCharacterDeleteClicked
	 * 		Flags  -> (Final, Native, Protected, BlueprintCallable)
	 */
	void UCharacterSelectCharListWidget::HandleCharacterDeleteClicked()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.CharacterSelectCharListWidget.HandleCharacterDeleteClicked");
		
		UCharacterSelectCharListWidget_HandleCharacterDeleteClicked_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0172EEE0
	 * 		Name   -> Function DungeonCrawler.CharacterSelectCharListWidget.HandleCharacterCreateClicked
	 * 		Flags  -> (Final, Native, Protected, BlueprintCallable)
	 */
	void UCharacterSelectCharListWidget::HandleCharacterCreateClicked()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.CharacterSelectCharListWidget.HandleCharacterCreateClicked");
		
		UCharacterSelectCharListWidget_HandleCharacterCreateClicked_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0172EEB0
	 * 		Name   -> Function DungeonCrawler.CharacterSelectCharListWidget.GetSelectedCharacterWidgetData
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	class UCharacterSelectCharacterSlotWidgetData* UCharacterSelectCharListWidget::GetSelectedCharacterWidgetData()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.CharacterSelectCharListWidget.GetSelectedCharacterWidgetData");
		
		UCharacterSelectCharListWidget_GetSelectedCharacterWidgetData_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UCharacterSelectCharListWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UCharacterSelectCharListWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.CharacterSelectCharListWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UCharacterSelectCharacterSlotWidgetData.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UCharacterSelectCharacterSlotWidgetData::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.CharacterSelectCharacterSlotWidgetData");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.CharacterSelectCharSlotWidget.OnFMsgWidgetStreamingModeNotifyBlueprint
	 * 		Flags  -> (Event, Protected, HasOutParms, BlueprintEvent)
	 * Parameters:
	 * 		struct FMsgWidgetStreamingModeNotify               InMsg                                                      (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UCharacterSelectCharSlotWidget::OnFMsgWidgetStreamingModeNotifyBlueprint(const struct FMsgWidgetStreamingModeNotify& InMsg)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.CharacterSelectCharSlotWidget.OnFMsgWidgetStreamingModeNotifyBlueprint");
		
		UCharacterSelectCharSlotWidget_OnFMsgWidgetStreamingModeNotifyBlueprint_Params params {};
		params.InMsg = InMsg;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.CharacterSelectCharSlotWidget.OnCharacterSlot
	 * 		Flags  -> (Event, Protected, HasOutParms, BlueprintEvent)
	 * Parameters:
	 * 		struct FCharacterSlot                              NewValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		struct FCharacterSlot                              OldValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UCharacterSelectCharSlotWidget::OnCharacterSlot(const struct FCharacterSlot& NewValue, const struct FCharacterSlot& OldValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.CharacterSelectCharSlotWidget.OnCharacterSlot");
		
		UCharacterSelectCharSlotWidget_OnCharacterSlot_Params params {};
		params.NewValue = NewValue;
		params.OldValue = OldValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UCharacterSelectCharSlotWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UCharacterSelectCharSlotWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.CharacterSelectCharSlotWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UCharacterSelectGroupWidgetBase.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UCharacterSelectGroupWidgetBase::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.CharacterSelectGroupWidgetBase");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0172EFA0
	 * 		Name   -> Function DungeonCrawler.CharacterSelectWidget.HandleOptionButtonClicked
	 * 		Flags  -> (Final, Native, Protected, BlueprintCallable)
	 */
	void UCharacterSelectWidget::HandleOptionButtonClicked()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.CharacterSelectWidget.HandleOptionButtonClicked");
		
		UCharacterSelectWidget_HandleOptionButtonClicked_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0172EF80
	 * 		Name   -> Function DungeonCrawler.CharacterSelectWidget.HandleLobbyButtonClicked
	 * 		Flags  -> (Final, Native, Protected, BlueprintCallable)
	 */
	void UCharacterSelectWidget::HandleLobbyButtonClicked()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.CharacterSelectWidget.HandleLobbyButtonClicked");
		
		UCharacterSelectWidget_HandleLobbyButtonClicked_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0172EF60
	 * 		Name   -> Function DungeonCrawler.CharacterSelectWidget.HandleExitButtonClicked
	 * 		Flags  -> (Final, Native, Protected, BlueprintCallable)
	 */
	void UCharacterSelectWidget::HandleExitButtonClicked()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.CharacterSelectWidget.HandleExitButtonClicked");
		
		UCharacterSelectWidget_HandleExitButtonClicked_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00A199E0
	 * 		Name   -> Function DungeonCrawler.CharacterSelectWidget.HandleCreditsButtonClicked
	 * 		Flags  -> (Final, Native, Protected, BlueprintCallable)
	 */
	void UCharacterSelectWidget::HandleCreditsButtonClicked()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.CharacterSelectWidget.HandleCreditsButtonClicked");
		
		UCharacterSelectWidget_HandleCreditsButtonClicked_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UCharacterSelectWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UCharacterSelectWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.CharacterSelectWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.CharacterStatusDetailWidget.OnWill
	 * 		Flags  -> (Event, Protected, HasOutParms, BlueprintEvent)
	 * Parameters:
	 * 		struct FGameplayAttributeData                      NewValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		struct FGameplayAttributeData                      OldValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UCharacterStatusDetailWidget::OnWill(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.CharacterStatusDetailWidget.OnWill");
		
		UCharacterStatusDetailWidget_OnWill_Params params {};
		params.NewValue = NewValue;
		params.OldValue = OldValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.CharacterStatusDetailWidget.OnWeightLimitMod
	 * 		Flags  -> (Event, Protected, HasOutParms, BlueprintEvent)
	 * Parameters:
	 * 		struct FGameplayAttributeData                      NewValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		struct FGameplayAttributeData                      OldValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UCharacterStatusDetailWidget::OnWeightLimitMod(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.CharacterStatusDetailWidget.OnWeightLimitMod");
		
		UCharacterStatusDetailWidget_OnWeightLimitMod_Params params {};
		params.NewValue = NewValue;
		params.OldValue = OldValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.CharacterStatusDetailWidget.OnWeightLimitBase
	 * 		Flags  -> (Event, Protected, HasOutParms, BlueprintEvent)
	 * Parameters:
	 * 		struct FGameplayAttributeData                      NewValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		struct FGameplayAttributeData                      OldValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UCharacterStatusDetailWidget::OnWeightLimitBase(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.CharacterStatusDetailWidget.OnWeightLimitBase");
		
		UCharacterStatusDetailWidget_OnWeightLimitBase_Params params {};
		params.NewValue = NewValue;
		params.OldValue = OldValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.CharacterStatusDetailWidget.OnWeightLimitAdd
	 * 		Flags  -> (Event, Protected, HasOutParms, BlueprintEvent)
	 * Parameters:
	 * 		struct FGameplayAttributeData                      NewValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		struct FGameplayAttributeData                      OldValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UCharacterStatusDetailWidget::OnWeightLimitAdd(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.CharacterStatusDetailWidget.OnWeightLimitAdd");
		
		UCharacterStatusDetailWidget_OnWeightLimitAdd_Params params {};
		params.NewValue = NewValue;
		params.OldValue = OldValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.CharacterStatusDetailWidget.OnWeightLimit
	 * 		Flags  -> (Event, Protected, HasOutParms, BlueprintEvent)
	 * Parameters:
	 * 		struct FGameplayAttributeData                      NewValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		struct FGameplayAttributeData                      OldValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UCharacterStatusDetailWidget::OnWeightLimit(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.CharacterStatusDetailWidget.OnWeightLimit");
		
		UCharacterStatusDetailWidget_OnWeightLimit_Params params {};
		params.NewValue = NewValue;
		params.OldValue = OldValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.CharacterStatusDetailWidget.OnWeight
	 * 		Flags  -> (Event, Protected, HasOutParms, BlueprintEvent)
	 * Parameters:
	 * 		struct FGameplayAttributeData                      NewValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		struct FGameplayAttributeData                      OldValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UCharacterStatusDetailWidget::OnWeight(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.CharacterStatusDetailWidget.OnWeight");
		
		UCharacterStatusDetailWidget_OnWeight_Params params {};
		params.NewValue = NewValue;
		params.OldValue = OldValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.CharacterStatusDetailWidget.OnUtilityEffectivenessMod
	 * 		Flags  -> (Event, Protected, HasOutParms, BlueprintEvent)
	 * Parameters:
	 * 		struct FGameplayAttributeData                      NewValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		struct FGameplayAttributeData                      OldValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UCharacterStatusDetailWidget::OnUtilityEffectivenessMod(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.CharacterStatusDetailWidget.OnUtilityEffectivenessMod");
		
		UCharacterStatusDetailWidget_OnUtilityEffectivenessMod_Params params {};
		params.NewValue = NewValue;
		params.OldValue = OldValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.CharacterStatusDetailWidget.OnUtilityEffectivenessBase
	 * 		Flags  -> (Event, Protected, HasOutParms, BlueprintEvent)
	 * Parameters:
	 * 		struct FGameplayAttributeData                      NewValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		struct FGameplayAttributeData                      OldValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UCharacterStatusDetailWidget::OnUtilityEffectivenessBase(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.CharacterStatusDetailWidget.OnUtilityEffectivenessBase");
		
		UCharacterStatusDetailWidget_OnUtilityEffectivenessBase_Params params {};
		params.NewValue = NewValue;
		params.OldValue = OldValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.CharacterStatusDetailWidget.OnUtilityEffectivenessAdd
	 * 		Flags  -> (Event, Protected, HasOutParms, BlueprintEvent)
	 * Parameters:
	 * 		struct FGameplayAttributeData                      NewValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		struct FGameplayAttributeData                      OldValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UCharacterStatusDetailWidget::OnUtilityEffectivenessAdd(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.CharacterStatusDetailWidget.OnUtilityEffectivenessAdd");
		
		UCharacterStatusDetailWidget_OnUtilityEffectivenessAdd_Params params {};
		params.NewValue = NewValue;
		params.OldValue = OldValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.CharacterStatusDetailWidget.OnUtilityEffectiveness
	 * 		Flags  -> (Event, Protected, HasOutParms, BlueprintEvent)
	 * Parameters:
	 * 		struct FGameplayAttributeData                      NewValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		struct FGameplayAttributeData                      OldValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UCharacterStatusDetailWidget::OnUtilityEffectiveness(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.CharacterStatusDetailWidget.OnUtilityEffectiveness");
		
		UCharacterStatusDetailWidget_OnUtilityEffectiveness_Params params {};
		params.NewValue = NewValue;
		params.OldValue = OldValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.CharacterStatusDetailWidget.OnStrength
	 * 		Flags  -> (Event, Protected, HasOutParms, BlueprintEvent)
	 * Parameters:
	 * 		struct FGameplayAttributeData                      NewValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		struct FGameplayAttributeData                      OldValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UCharacterStatusDetailWidget::OnStrength(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.CharacterStatusDetailWidget.OnStrength");
		
		UCharacterStatusDetailWidget_OnStrength_Params params {};
		params.NewValue = NewValue;
		params.OldValue = OldValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.CharacterStatusDetailWidget.OnSpellPayload
	 * 		Flags  -> (Event, Protected, HasOutParms, BlueprintEvent)
	 * Parameters:
	 * 		struct FGameplayAttributeData                      NewValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		struct FGameplayAttributeData                      OldValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UCharacterStatusDetailWidget::OnSpellPayload(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.CharacterStatusDetailWidget.OnSpellPayload");
		
		UCharacterStatusDetailWidget_OnSpellPayload_Params params {};
		params.NewValue = NewValue;
		params.OldValue = OldValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.CharacterStatusDetailWidget.OnSpellCastingSpeed
	 * 		Flags  -> (Event, Protected, HasOutParms, BlueprintEvent)
	 * Parameters:
	 * 		struct FGameplayAttributeData                      NewValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		struct FGameplayAttributeData                      OldValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UCharacterStatusDetailWidget::OnSpellCastingSpeed(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.CharacterStatusDetailWidget.OnSpellCastingSpeed");
		
		UCharacterStatusDetailWidget_OnSpellCastingSpeed_Params params {};
		params.NewValue = NewValue;
		params.OldValue = OldValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.CharacterStatusDetailWidget.OnSpellCapacityMod
	 * 		Flags  -> (Event, Protected, HasOutParms, BlueprintEvent)
	 * Parameters:
	 * 		struct FGameplayAttributeData                      NewValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		struct FGameplayAttributeData                      OldValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UCharacterStatusDetailWidget::OnSpellCapacityMod(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.CharacterStatusDetailWidget.OnSpellCapacityMod");
		
		UCharacterStatusDetailWidget_OnSpellCapacityMod_Params params {};
		params.NewValue = NewValue;
		params.OldValue = OldValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.CharacterStatusDetailWidget.OnSpellCapacityBase
	 * 		Flags  -> (Event, Protected, HasOutParms, BlueprintEvent)
	 * Parameters:
	 * 		struct FGameplayAttributeData                      NewValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		struct FGameplayAttributeData                      OldValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UCharacterStatusDetailWidget::OnSpellCapacityBase(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.CharacterStatusDetailWidget.OnSpellCapacityBase");
		
		UCharacterStatusDetailWidget_OnSpellCapacityBase_Params params {};
		params.NewValue = NewValue;
		params.OldValue = OldValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.CharacterStatusDetailWidget.OnSpellCapacityAdd
	 * 		Flags  -> (Event, Protected, HasOutParms, BlueprintEvent)
	 * Parameters:
	 * 		struct FGameplayAttributeData                      NewValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		struct FGameplayAttributeData                      OldValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UCharacterStatusDetailWidget::OnSpellCapacityAdd(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.CharacterStatusDetailWidget.OnSpellCapacityAdd");
		
		UCharacterStatusDetailWidget_OnSpellCapacityAdd_Params params {};
		params.NewValue = NewValue;
		params.OldValue = OldValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.CharacterStatusDetailWidget.OnSpellCapacity
	 * 		Flags  -> (Event, Protected, HasOutParms, BlueprintEvent)
	 * Parameters:
	 * 		struct FGameplayAttributeData                      NewValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		struct FGameplayAttributeData                      OldValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UCharacterStatusDetailWidget::OnSpellCapacity(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.CharacterStatusDetailWidget.OnSpellCapacity");
		
		UCharacterStatusDetailWidget_OnSpellCapacity_Params params {};
		params.NewValue = NewValue;
		params.OldValue = OldValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.CharacterStatusDetailWidget.OnSecondaryWeaponImpactPower
	 * 		Flags  -> (Event, Protected, HasOutParms, BlueprintEvent)
	 * Parameters:
	 * 		float                                              NewValue                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              OldValue                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UCharacterStatusDetailWidget::OnSecondaryWeaponImpactPower(float NewValue, float OldValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.CharacterStatusDetailWidget.OnSecondaryWeaponImpactPower");
		
		UCharacterStatusDetailWidget_OnSecondaryWeaponImpactPower_Params params {};
		params.NewValue = NewValue;
		params.OldValue = OldValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.CharacterStatusDetailWidget.OnSecondaryAbilityWidgetArray
	 * 		Flags  -> (Event, Protected, HasOutParms, BlueprintEvent)
	 * Parameters:
	 * 		TArray<class UItemTooltipStatWidgetData*>          NewValue                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		TArray<class UItemTooltipStatWidgetData*>          OldValue                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UCharacterStatusDetailWidget::OnSecondaryAbilityWidgetArray(TArray<class UItemTooltipStatWidgetData*> NewValue, TArray<class UItemTooltipStatWidgetData*> OldValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.CharacterStatusDetailWidget.OnSecondaryAbilityWidgetArray");
		
		UCharacterStatusDetailWidget_OnSecondaryAbilityWidgetArray_Params params {};
		params.NewValue = NewValue;
		params.OldValue = OldValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.CharacterStatusDetailWidget.OnResourcefulness
	 * 		Flags  -> (Event, Protected, HasOutParms, BlueprintEvent)
	 * Parameters:
	 * 		struct FGameplayAttributeData                      NewValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		struct FGameplayAttributeData                      OldValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UCharacterStatusDetailWidget::OnResourcefulness(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.CharacterStatusDetailWidget.OnResourcefulness");
		
		UCharacterStatusDetailWidget_OnResourcefulness_Params params {};
		params.NewValue = NewValue;
		params.OldValue = OldValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.CharacterStatusDetailWidget.OnRegularInteractionSpeedBase
	 * 		Flags  -> (Event, Protected, HasOutParms, BlueprintEvent)
	 * Parameters:
	 * 		struct FGameplayAttributeData                      NewValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		struct FGameplayAttributeData                      OldValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UCharacterStatusDetailWidget::OnRegularInteractionSpeedBase(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.CharacterStatusDetailWidget.OnRegularInteractionSpeedBase");
		
		UCharacterStatusDetailWidget_OnRegularInteractionSpeedBase_Params params {};
		params.NewValue = NewValue;
		params.OldValue = OldValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.CharacterStatusDetailWidget.OnRegularInteractionSpeed
	 * 		Flags  -> (Event, Protected, HasOutParms, BlueprintEvent)
	 * Parameters:
	 * 		struct FGameplayAttributeData                      NewValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		struct FGameplayAttributeData                      OldValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UCharacterStatusDetailWidget::OnRegularInteractionSpeed(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.CharacterStatusDetailWidget.OnRegularInteractionSpeed");
		
		UCharacterStatusDetailWidget_OnRegularInteractionSpeed_Params params {};
		params.NewValue = NewValue;
		params.OldValue = OldValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.CharacterStatusDetailWidget.OnProjectileReductionMod
	 * 		Flags  -> (Event, Protected, HasOutParms, BlueprintEvent)
	 * Parameters:
	 * 		struct FGameplayAttributeData                      NewValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		struct FGameplayAttributeData                      OldValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UCharacterStatusDetailWidget::OnProjectileReductionMod(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.CharacterStatusDetailWidget.OnProjectileReductionMod");
		
		UCharacterStatusDetailWidget_OnProjectileReductionMod_Params params {};
		params.NewValue = NewValue;
		params.OldValue = OldValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.CharacterStatusDetailWidget.OnPrimaryWeaponImpactPower
	 * 		Flags  -> (Event, Protected, HasOutParms, BlueprintEvent)
	 * Parameters:
	 * 		float                                              NewValue                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              OldValue                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UCharacterStatusDetailWidget::OnPrimaryWeaponImpactPower(float NewValue, float OldValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.CharacterStatusDetailWidget.OnPrimaryWeaponImpactPower");
		
		UCharacterStatusDetailWidget_OnPrimaryWeaponImpactPower_Params params {};
		params.NewValue = NewValue;
		params.OldValue = OldValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.CharacterStatusDetailWidget.OnPrimaryAbilityWidgetArray
	 * 		Flags  -> (Event, Protected, HasOutParms, BlueprintEvent)
	 * Parameters:
	 * 		TArray<class UItemTooltipStatWidgetData*>          NewValue                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		TArray<class UItemTooltipStatWidgetData*>          OldValue                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UCharacterStatusDetailWidget::OnPrimaryAbilityWidgetArray(TArray<class UItemTooltipStatWidgetData*> NewValue, TArray<class UItemTooltipStatWidgetData*> OldValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.CharacterStatusDetailWidget.OnPrimaryAbilityWidgetArray");
		
		UCharacterStatusDetailWidget_OnPrimaryAbilityWidgetArray_Params params {};
		params.NewValue = NewValue;
		params.OldValue = OldValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.CharacterStatusDetailWidget.OnPrestigeItemDrop
	 * 		Flags  -> (Event, Protected, HasOutParms, BlueprintEvent)
	 * Parameters:
	 * 		struct FGameplayAttributeData                      NewValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		struct FGameplayAttributeData                      OldValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UCharacterStatusDetailWidget::OnPrestigeItemDrop(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.CharacterStatusDetailWidget.OnPrestigeItemDrop");
		
		UCharacterStatusDetailWidget_OnPrestigeItemDrop_Params params {};
		params.NewValue = NewValue;
		params.OldValue = OldValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.CharacterStatusDetailWidget.OnPhysicalReductionMod
	 * 		Flags  -> (Event, Protected, HasOutParms, BlueprintEvent)
	 * Parameters:
	 * 		struct FGameplayAttributeData                      NewValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		struct FGameplayAttributeData                      OldValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UCharacterStatusDetailWidget::OnPhysicalReductionMod(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.CharacterStatusDetailWidget.OnPhysicalReductionMod");
		
		UCharacterStatusDetailWidget_OnPhysicalReductionMod_Params params {};
		params.NewValue = NewValue;
		params.OldValue = OldValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.CharacterStatusDetailWidget.OnPhysicalReductionBonus
	 * 		Flags  -> (Event, Protected, HasOutParms, BlueprintEvent)
	 * Parameters:
	 * 		struct FGameplayAttributeData                      NewValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		struct FGameplayAttributeData                      OldValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UCharacterStatusDetailWidget::OnPhysicalReductionBonus(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.CharacterStatusDetailWidget.OnPhysicalReductionBonus");
		
		UCharacterStatusDetailWidget_OnPhysicalReductionBonus_Params params {};
		params.NewValue = NewValue;
		params.OldValue = OldValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.CharacterStatusDetailWidget.OnPhysicalReductionArmorRating
	 * 		Flags  -> (Event, Protected, HasOutParms, BlueprintEvent)
	 * Parameters:
	 * 		struct FGameplayAttributeData                      NewValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		struct FGameplayAttributeData                      OldValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UCharacterStatusDetailWidget::OnPhysicalReductionArmorRating(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.CharacterStatusDetailWidget.OnPhysicalReductionArmorRating");
		
		UCharacterStatusDetailWidget_OnPhysicalReductionArmorRating_Params params {};
		params.NewValue = NewValue;
		params.OldValue = OldValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.CharacterStatusDetailWidget.OnPhysicalReduction
	 * 		Flags  -> (Event, Protected, HasOutParms, BlueprintEvent)
	 * Parameters:
	 * 		struct FGameplayAttributeData                      NewValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		struct FGameplayAttributeData                      OldValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UCharacterStatusDetailWidget::OnPhysicalReduction(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.CharacterStatusDetailWidget.OnPhysicalReduction");
		
		UCharacterStatusDetailWidget_OnPhysicalReduction_Params params {};
		params.NewValue = NewValue;
		params.OldValue = OldValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.CharacterStatusDetailWidget.OnPhysicalPower
	 * 		Flags  -> (Event, Protected, HasOutParms, BlueprintEvent)
	 * Parameters:
	 * 		struct FGameplayAttributeData                      NewValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		struct FGameplayAttributeData                      OldValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UCharacterStatusDetailWidget::OnPhysicalPower(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.CharacterStatusDetailWidget.OnPhysicalPower");
		
		UCharacterStatusDetailWidget_OnPhysicalPower_Params params {};
		params.NewValue = NewValue;
		params.OldValue = OldValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.CharacterStatusDetailWidget.OnPhysicalHealBase
	 * 		Flags  -> (Event, Protected, HasOutParms, BlueprintEvent)
	 * Parameters:
	 * 		struct FGameplayAttributeData                      NewValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		struct FGameplayAttributeData                      OldValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UCharacterStatusDetailWidget::OnPhysicalHealBase(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.CharacterStatusDetailWidget.OnPhysicalHealBase");
		
		UCharacterStatusDetailWidget_OnPhysicalHealBase_Params params {};
		params.NewValue = NewValue;
		params.OldValue = OldValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.CharacterStatusDetailWidget.OnPhysicalDamageWeaponSecondary
	 * 		Flags  -> (Event, Protected, HasOutParms, BlueprintEvent)
	 * Parameters:
	 * 		struct FGameplayAttributeData                      NewValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		struct FGameplayAttributeData                      OldValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UCharacterStatusDetailWidget::OnPhysicalDamageWeaponSecondary(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.CharacterStatusDetailWidget.OnPhysicalDamageWeaponSecondary");
		
		UCharacterStatusDetailWidget_OnPhysicalDamageWeaponSecondary_Params params {};
		params.NewValue = NewValue;
		params.OldValue = OldValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.CharacterStatusDetailWidget.OnPhysicalDamageWeaponPrimary
	 * 		Flags  -> (Event, Protected, HasOutParms, BlueprintEvent)
	 * Parameters:
	 * 		struct FGameplayAttributeData                      NewValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		struct FGameplayAttributeData                      OldValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UCharacterStatusDetailWidget::OnPhysicalDamageWeaponPrimary(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.CharacterStatusDetailWidget.OnPhysicalDamageWeaponPrimary");
		
		UCharacterStatusDetailWidget_OnPhysicalDamageWeaponPrimary_Params params {};
		params.NewValue = NewValue;
		params.OldValue = OldValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.CharacterStatusDetailWidget.OnPhysicalDamageTrue
	 * 		Flags  -> (Event, Protected, HasOutParms, BlueprintEvent)
	 * Parameters:
	 * 		struct FGameplayAttributeData                      NewValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		struct FGameplayAttributeData                      OldValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UCharacterStatusDetailWidget::OnPhysicalDamageTrue(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.CharacterStatusDetailWidget.OnPhysicalDamageTrue");
		
		UCharacterStatusDetailWidget_OnPhysicalDamageTrue_Params params {};
		params.NewValue = NewValue;
		params.OldValue = OldValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.CharacterStatusDetailWidget.OnPhysicalDamageModPhysicalPower
	 * 		Flags  -> (Event, Protected, HasOutParms, BlueprintEvent)
	 * Parameters:
	 * 		struct FGameplayAttributeData                      NewValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		struct FGameplayAttributeData                      OldValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UCharacterStatusDetailWidget::OnPhysicalDamageModPhysicalPower(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.CharacterStatusDetailWidget.OnPhysicalDamageModPhysicalPower");
		
		UCharacterStatusDetailWidget_OnPhysicalDamageModPhysicalPower_Params params {};
		params.NewValue = NewValue;
		params.OldValue = OldValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.CharacterStatusDetailWidget.OnPhysicalDamageModBonus
	 * 		Flags  -> (Event, Protected, HasOutParms, BlueprintEvent)
	 * Parameters:
	 * 		struct FGameplayAttributeData                      NewValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		struct FGameplayAttributeData                      OldValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UCharacterStatusDetailWidget::OnPhysicalDamageModBonus(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.CharacterStatusDetailWidget.OnPhysicalDamageModBonus");
		
		UCharacterStatusDetailWidget_OnPhysicalDamageModBonus_Params params {};
		params.NewValue = NewValue;
		params.OldValue = OldValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.CharacterStatusDetailWidget.OnPhysicalDamageMod
	 * 		Flags  -> (Event, Protected, HasOutParms, BlueprintEvent)
	 * Parameters:
	 * 		struct FGameplayAttributeData                      NewValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		struct FGameplayAttributeData                      OldValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UCharacterStatusDetailWidget::OnPhysicalDamageMod(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.CharacterStatusDetailWidget.OnPhysicalDamageMod");
		
		UCharacterStatusDetailWidget_OnPhysicalDamageMod_Params params {};
		params.NewValue = NewValue;
		params.OldValue = OldValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.CharacterStatusDetailWidget.OnPhysicalDamageBase
	 * 		Flags  -> (Event, Protected, HasOutParms, BlueprintEvent)
	 * Parameters:
	 * 		struct FGameplayAttributeData                      NewValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		struct FGameplayAttributeData                      OldValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UCharacterStatusDetailWidget::OnPhysicalDamageBase(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.CharacterStatusDetailWidget.OnPhysicalDamageBase");
		
		UCharacterStatusDetailWidget_OnPhysicalDamageBase_Params params {};
		params.NewValue = NewValue;
		params.OldValue = OldValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.CharacterStatusDetailWidget.OnPhysicalDamageAdd
	 * 		Flags  -> (Event, Protected, HasOutParms, BlueprintEvent)
	 * Parameters:
	 * 		struct FGameplayAttributeData                      NewValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		struct FGameplayAttributeData                      OldValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UCharacterStatusDetailWidget::OnPhysicalDamageAdd(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.CharacterStatusDetailWidget.OnPhysicalDamageAdd");
		
		UCharacterStatusDetailWidget_OnPhysicalDamageAdd_Params params {};
		params.NewValue = NewValue;
		params.OldValue = OldValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.CharacterStatusDetailWidget.OnMoveSpeedWithModifier
	 * 		Flags  -> (Event, Protected, HasOutParms, BlueprintEvent)
	 * Parameters:
	 * 		struct FGameplayAttributeData                      NewValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		struct FGameplayAttributeData                      OldValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UCharacterStatusDetailWidget::OnMoveSpeedWithModifier(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.CharacterStatusDetailWidget.OnMoveSpeedWithModifier");
		
		UCharacterStatusDetailWidget_OnMoveSpeedWithModifier_Params params {};
		params.NewValue = NewValue;
		params.OldValue = OldValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.CharacterStatusDetailWidget.OnMoveSpeedMod
	 * 		Flags  -> (Event, Protected, HasOutParms, BlueprintEvent)
	 * Parameters:
	 * 		struct FGameplayAttributeData                      NewValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		struct FGameplayAttributeData                      OldValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UCharacterStatusDetailWidget::OnMoveSpeedMod(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.CharacterStatusDetailWidget.OnMoveSpeedMod");
		
		UCharacterStatusDetailWidget_OnMoveSpeedMod_Params params {};
		params.NewValue = NewValue;
		params.OldValue = OldValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.CharacterStatusDetailWidget.OnMoveSpeedBase
	 * 		Flags  -> (Event, Protected, HasOutParms, BlueprintEvent)
	 * Parameters:
	 * 		struct FGameplayAttributeData                      NewValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		struct FGameplayAttributeData                      OldValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UCharacterStatusDetailWidget::OnMoveSpeedBase(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.CharacterStatusDetailWidget.OnMoveSpeedBase");
		
		UCharacterStatusDetailWidget_OnMoveSpeedBase_Params params {};
		params.NewValue = NewValue;
		params.OldValue = OldValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.CharacterStatusDetailWidget.OnMoveSpeedAdd
	 * 		Flags  -> (Event, Protected, HasOutParms, BlueprintEvent)
	 * Parameters:
	 * 		struct FGameplayAttributeData                      NewValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		struct FGameplayAttributeData                      OldValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UCharacterStatusDetailWidget::OnMoveSpeedAdd(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.CharacterStatusDetailWidget.OnMoveSpeedAdd");
		
		UCharacterStatusDetailWidget_OnMoveSpeedAdd_Params params {};
		params.NewValue = NewValue;
		params.OldValue = OldValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.CharacterStatusDetailWidget.OnMoveSpeed
	 * 		Flags  -> (Event, Protected, HasOutParms, BlueprintEvent)
	 * Parameters:
	 * 		struct FGameplayAttributeData                      NewValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		struct FGameplayAttributeData                      OldValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UCharacterStatusDetailWidget::OnMoveSpeed(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.CharacterStatusDetailWidget.OnMoveSpeed");
		
		UCharacterStatusDetailWidget_OnMoveSpeed_Params params {};
		params.NewValue = NewValue;
		params.OldValue = OldValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.CharacterStatusDetailWidget.OnMaxHealthMod
	 * 		Flags  -> (Event, Protected, HasOutParms, BlueprintEvent)
	 * Parameters:
	 * 		struct FGameplayAttributeData                      NewValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		struct FGameplayAttributeData                      OldValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UCharacterStatusDetailWidget::OnMaxHealthMod(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.CharacterStatusDetailWidget.OnMaxHealthMod");
		
		UCharacterStatusDetailWidget_OnMaxHealthMod_Params params {};
		params.NewValue = NewValue;
		params.OldValue = OldValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.CharacterStatusDetailWidget.OnMaxHealthBase
	 * 		Flags  -> (Event, Protected, HasOutParms, BlueprintEvent)
	 * Parameters:
	 * 		struct FGameplayAttributeData                      NewValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		struct FGameplayAttributeData                      OldValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UCharacterStatusDetailWidget::OnMaxHealthBase(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.CharacterStatusDetailWidget.OnMaxHealthBase");
		
		UCharacterStatusDetailWidget_OnMaxHealthBase_Params params {};
		params.NewValue = NewValue;
		params.OldValue = OldValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.CharacterStatusDetailWidget.OnMaxHealthAdd
	 * 		Flags  -> (Event, Protected, HasOutParms, BlueprintEvent)
	 * Parameters:
	 * 		struct FGameplayAttributeData                      NewValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		struct FGameplayAttributeData                      OldValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UCharacterStatusDetailWidget::OnMaxHealthAdd(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.CharacterStatusDetailWidget.OnMaxHealthAdd");
		
		UCharacterStatusDetailWidget_OnMaxHealthAdd_Params params {};
		params.NewValue = NewValue;
		params.OldValue = OldValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.CharacterStatusDetailWidget.OnMaxHealth
	 * 		Flags  -> (Event, Protected, HasOutParms, BlueprintEvent)
	 * Parameters:
	 * 		struct FGameplayAttributeData                      NewValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		struct FGameplayAttributeData                      OldValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UCharacterStatusDetailWidget::OnMaxHealth(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.CharacterStatusDetailWidget.OnMaxHealth");
		
		UCharacterStatusDetailWidget_OnMaxHealth_Params params {};
		params.NewValue = NewValue;
		params.OldValue = OldValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.CharacterStatusDetailWidget.OnMagicResistance
	 * 		Flags  -> (Event, Protected, HasOutParms, BlueprintEvent)
	 * Parameters:
	 * 		struct FGameplayAttributeData                      NewValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		struct FGameplayAttributeData                      OldValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UCharacterStatusDetailWidget::OnMagicResistance(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.CharacterStatusDetailWidget.OnMagicResistance");
		
		UCharacterStatusDetailWidget_OnMagicResistance_Params params {};
		params.NewValue = NewValue;
		params.OldValue = OldValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.CharacterStatusDetailWidget.OnMagicPenetration
	 * 		Flags  -> (Event, Protected, HasOutParms, BlueprintEvent)
	 * Parameters:
	 * 		struct FGameplayAttributeData                      NewValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		struct FGameplayAttributeData                      OldValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UCharacterStatusDetailWidget::OnMagicPenetration(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.CharacterStatusDetailWidget.OnMagicPenetration");
		
		UCharacterStatusDetailWidget_OnMagicPenetration_Params params {};
		params.NewValue = NewValue;
		params.OldValue = OldValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.CharacterStatusDetailWidget.OnMagicalReductionMod
	 * 		Flags  -> (Event, Protected, HasOutParms, BlueprintEvent)
	 * Parameters:
	 * 		struct FGameplayAttributeData                      NewValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		struct FGameplayAttributeData                      OldValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UCharacterStatusDetailWidget::OnMagicalReductionMod(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.CharacterStatusDetailWidget.OnMagicalReductionMod");
		
		UCharacterStatusDetailWidget_OnMagicalReductionMod_Params params {};
		params.NewValue = NewValue;
		params.OldValue = OldValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.CharacterStatusDetailWidget.OnMagicalReductionMagicResistance
	 * 		Flags  -> (Event, Protected, HasOutParms, BlueprintEvent)
	 * Parameters:
	 * 		struct FGameplayAttributeData                      NewValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		struct FGameplayAttributeData                      OldValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UCharacterStatusDetailWidget::OnMagicalReductionMagicResistance(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.CharacterStatusDetailWidget.OnMagicalReductionMagicResistance");
		
		UCharacterStatusDetailWidget_OnMagicalReductionMagicResistance_Params params {};
		params.NewValue = NewValue;
		params.OldValue = OldValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.CharacterStatusDetailWidget.OnMagicalReductionBonus
	 * 		Flags  -> (Event, Protected, HasOutParms, BlueprintEvent)
	 * Parameters:
	 * 		struct FGameplayAttributeData                      NewValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		struct FGameplayAttributeData                      OldValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UCharacterStatusDetailWidget::OnMagicalReductionBonus(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.CharacterStatusDetailWidget.OnMagicalReductionBonus");
		
		UCharacterStatusDetailWidget_OnMagicalReductionBonus_Params params {};
		params.NewValue = NewValue;
		params.OldValue = OldValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.CharacterStatusDetailWidget.OnMagicalReduction
	 * 		Flags  -> (Event, Protected, HasOutParms, BlueprintEvent)
	 * Parameters:
	 * 		struct FGameplayAttributeData                      NewValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		struct FGameplayAttributeData                      OldValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UCharacterStatusDetailWidget::OnMagicalReduction(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.CharacterStatusDetailWidget.OnMagicalReduction");
		
		UCharacterStatusDetailWidget_OnMagicalReduction_Params params {};
		params.NewValue = NewValue;
		params.OldValue = OldValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.CharacterStatusDetailWidget.OnMagicalPower
	 * 		Flags  -> (Event, Protected, HasOutParms, BlueprintEvent)
	 * Parameters:
	 * 		struct FGameplayAttributeData                      NewValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		struct FGameplayAttributeData                      OldValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UCharacterStatusDetailWidget::OnMagicalPower(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.CharacterStatusDetailWidget.OnMagicalPower");
		
		UCharacterStatusDetailWidget_OnMagicalPower_Params params {};
		params.NewValue = NewValue;
		params.OldValue = OldValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.CharacterStatusDetailWidget.OnMagicalInteractionSpeed
	 * 		Flags  -> (Event, Protected, HasOutParms, BlueprintEvent)
	 * Parameters:
	 * 		struct FGameplayAttributeData                      NewValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		struct FGameplayAttributeData                      OldValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UCharacterStatusDetailWidget::OnMagicalInteractionSpeed(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.CharacterStatusDetailWidget.OnMagicalInteractionSpeed");
		
		UCharacterStatusDetailWidget_OnMagicalInteractionSpeed_Params params {};
		params.NewValue = NewValue;
		params.OldValue = OldValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.CharacterStatusDetailWidget.OnMagicalHealBase
	 * 		Flags  -> (Event, Protected, HasOutParms, BlueprintEvent)
	 * Parameters:
	 * 		struct FGameplayAttributeData                      NewValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		struct FGameplayAttributeData                      OldValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UCharacterStatusDetailWidget::OnMagicalHealBase(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.CharacterStatusDetailWidget.OnMagicalHealBase");
		
		UCharacterStatusDetailWidget_OnMagicalHealBase_Params params {};
		params.NewValue = NewValue;
		params.OldValue = OldValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.CharacterStatusDetailWidget.OnMagicalDamageTrue
	 * 		Flags  -> (Event, Protected, HasOutParms, BlueprintEvent)
	 * Parameters:
	 * 		struct FGameplayAttributeData                      NewValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		struct FGameplayAttributeData                      OldValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UCharacterStatusDetailWidget::OnMagicalDamageTrue(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.CharacterStatusDetailWidget.OnMagicalDamageTrue");
		
		UCharacterStatusDetailWidget_OnMagicalDamageTrue_Params params {};
		params.NewValue = NewValue;
		params.OldValue = OldValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.CharacterStatusDetailWidget.OnMagicalDamageModMagicalPower
	 * 		Flags  -> (Event, Protected, HasOutParms, BlueprintEvent)
	 * Parameters:
	 * 		struct FGameplayAttributeData                      NewValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		struct FGameplayAttributeData                      OldValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UCharacterStatusDetailWidget::OnMagicalDamageModMagicalPower(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.CharacterStatusDetailWidget.OnMagicalDamageModMagicalPower");
		
		UCharacterStatusDetailWidget_OnMagicalDamageModMagicalPower_Params params {};
		params.NewValue = NewValue;
		params.OldValue = OldValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.CharacterStatusDetailWidget.OnMagicalDamageModBonus
	 * 		Flags  -> (Event, Protected, HasOutParms, BlueprintEvent)
	 * Parameters:
	 * 		struct FGameplayAttributeData                      NewValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		struct FGameplayAttributeData                      OldValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UCharacterStatusDetailWidget::OnMagicalDamageModBonus(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.CharacterStatusDetailWidget.OnMagicalDamageModBonus");
		
		UCharacterStatusDetailWidget_OnMagicalDamageModBonus_Params params {};
		params.NewValue = NewValue;
		params.OldValue = OldValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.CharacterStatusDetailWidget.OnMagicalDamageMod
	 * 		Flags  -> (Event, Protected, HasOutParms, BlueprintEvent)
	 * Parameters:
	 * 		struct FGameplayAttributeData                      NewValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		struct FGameplayAttributeData                      OldValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UCharacterStatusDetailWidget::OnMagicalDamageMod(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.CharacterStatusDetailWidget.OnMagicalDamageMod");
		
		UCharacterStatusDetailWidget_OnMagicalDamageMod_Params params {};
		params.NewValue = NewValue;
		params.OldValue = OldValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.CharacterStatusDetailWidget.OnMagicalDamageBase
	 * 		Flags  -> (Event, Protected, HasOutParms, BlueprintEvent)
	 * Parameters:
	 * 		struct FGameplayAttributeData                      NewValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		struct FGameplayAttributeData                      OldValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UCharacterStatusDetailWidget::OnMagicalDamageBase(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.CharacterStatusDetailWidget.OnMagicalDamageBase");
		
		UCharacterStatusDetailWidget_OnMagicalDamageBase_Params params {};
		params.NewValue = NewValue;
		params.OldValue = OldValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.CharacterStatusDetailWidget.OnMagicalDamageAdd
	 * 		Flags  -> (Event, Protected, HasOutParms, BlueprintEvent)
	 * Parameters:
	 * 		struct FGameplayAttributeData                      NewValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		struct FGameplayAttributeData                      OldValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UCharacterStatusDetailWidget::OnMagicalDamageAdd(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.CharacterStatusDetailWidget.OnMagicalDamageAdd");
		
		UCharacterStatusDetailWidget_OnMagicalDamageAdd_Params params {};
		params.NewValue = NewValue;
		params.OldValue = OldValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.CharacterStatusDetailWidget.OnKnowledge
	 * 		Flags  -> (Event, Protected, HasOutParms, BlueprintEvent)
	 * Parameters:
	 * 		struct FGameplayAttributeData                      NewValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		struct FGameplayAttributeData                      OldValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UCharacterStatusDetailWidget::OnKnowledge(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.CharacterStatusDetailWidget.OnKnowledge");
		
		UCharacterStatusDetailWidget_OnKnowledge_Params params {};
		params.NewValue = NewValue;
		params.OldValue = OldValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.CharacterStatusDetailWidget.OnItemEquipSpeed
	 * 		Flags  -> (Event, Protected, HasOutParms, BlueprintEvent)
	 * Parameters:
	 * 		struct FGameplayAttributeData                      NewValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		struct FGameplayAttributeData                      OldValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UCharacterStatusDetailWidget::OnItemEquipSpeed(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.CharacterStatusDetailWidget.OnItemEquipSpeed");
		
		UCharacterStatusDetailWidget_OnItemEquipSpeed_Params params {};
		params.NewValue = NewValue;
		params.OldValue = OldValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.CharacterStatusDetailWidget.OnImpactPower
	 * 		Flags  -> (Event, Protected, HasOutParms, BlueprintEvent)
	 * Parameters:
	 * 		struct FGameplayAttributeData                      NewValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		struct FGameplayAttributeData                      OldValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UCharacterStatusDetailWidget::OnImpactPower(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.CharacterStatusDetailWidget.OnImpactPower");
		
		UCharacterStatusDetailWidget_OnImpactPower_Params params {};
		params.NewValue = NewValue;
		params.OldValue = OldValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.CharacterStatusDetailWidget.OnHealth
	 * 		Flags  -> (Event, Protected, HasOutParms, BlueprintEvent)
	 * Parameters:
	 * 		struct FGameplayAttributeData                      NewValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		struct FGameplayAttributeData                      OldValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UCharacterStatusDetailWidget::OnHealth(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.CharacterStatusDetailWidget.OnHealth");
		
		UCharacterStatusDetailWidget_OnHealth_Params params {};
		params.NewValue = NewValue;
		params.OldValue = OldValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.CharacterStatusDetailWidget.OnHeadshotReductionMod
	 * 		Flags  -> (Event, Protected, HasOutParms, BlueprintEvent)
	 * Parameters:
	 * 		struct FGameplayAttributeData                      NewValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		struct FGameplayAttributeData                      OldValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UCharacterStatusDetailWidget::OnHeadshotReductionMod(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.CharacterStatusDetailWidget.OnHeadshotReductionMod");
		
		UCharacterStatusDetailWidget_OnHeadshotReductionMod_Params params {};
		params.NewValue = NewValue;
		params.OldValue = OldValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.CharacterStatusDetailWidget.OnDebuffDurationMod
	 * 		Flags  -> (Event, Protected, HasOutParms, BlueprintEvent)
	 * Parameters:
	 * 		struct FGameplayAttributeData                      NewValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		struct FGameplayAttributeData                      OldValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UCharacterStatusDetailWidget::OnDebuffDurationMod(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.CharacterStatusDetailWidget.OnDebuffDurationMod");
		
		UCharacterStatusDetailWidget_OnDebuffDurationMod_Params params {};
		params.NewValue = NewValue;
		params.OldValue = OldValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.CharacterStatusDetailWidget.OnBuffDurationMod
	 * 		Flags  -> (Event, Protected, HasOutParms, BlueprintEvent)
	 * Parameters:
	 * 		struct FGameplayAttributeData                      NewValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		struct FGameplayAttributeData                      OldValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UCharacterStatusDetailWidget::OnBuffDurationMod(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.CharacterStatusDetailWidget.OnBuffDurationMod");
		
		UCharacterStatusDetailWidget_OnBuffDurationMod_Params params {};
		params.NewValue = NewValue;
		params.OldValue = OldValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.CharacterStatusDetailWidget.OnArmorRating
	 * 		Flags  -> (Event, Protected, HasOutParms, BlueprintEvent)
	 * Parameters:
	 * 		struct FGameplayAttributeData                      NewValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		struct FGameplayAttributeData                      OldValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UCharacterStatusDetailWidget::OnArmorRating(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.CharacterStatusDetailWidget.OnArmorRating");
		
		UCharacterStatusDetailWidget_OnArmorRating_Params params {};
		params.NewValue = NewValue;
		params.OldValue = OldValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.CharacterStatusDetailWidget.OnArmorPenetration
	 * 		Flags  -> (Event, Protected, HasOutParms, BlueprintEvent)
	 * Parameters:
	 * 		struct FGameplayAttributeData                      NewValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		struct FGameplayAttributeData                      OldValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UCharacterStatusDetailWidget::OnArmorPenetration(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.CharacterStatusDetailWidget.OnArmorPenetration");
		
		UCharacterStatusDetailWidget_OnArmorPenetration_Params params {};
		params.NewValue = NewValue;
		params.OldValue = OldValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.CharacterStatusDetailWidget.OnAgility
	 * 		Flags  -> (Event, Protected, HasOutParms, BlueprintEvent)
	 * Parameters:
	 * 		struct FGameplayAttributeData                      NewValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		struct FGameplayAttributeData                      OldValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UCharacterStatusDetailWidget::OnAgility(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.CharacterStatusDetailWidget.OnAgility");
		
		UCharacterStatusDetailWidget_OnAgility_Params params {};
		params.NewValue = NewValue;
		params.OldValue = OldValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.CharacterStatusDetailWidget.OnActionSpeed
	 * 		Flags  -> (Event, Protected, HasOutParms, BlueprintEvent)
	 * Parameters:
	 * 		struct FGameplayAttributeData                      NewValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		struct FGameplayAttributeData                      OldValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UCharacterStatusDetailWidget::OnActionSpeed(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.CharacterStatusDetailWidget.OnActionSpeed");
		
		UCharacterStatusDetailWidget_OnActionSpeed_Params params {};
		params.NewValue = NewValue;
		params.OldValue = OldValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UCharacterStatusDetailWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UCharacterStatusDetailWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.CharacterStatusDetailWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.CharacterStatusWidget.OnWill
	 * 		Flags  -> (Event, Protected, HasOutParms, BlueprintEvent)
	 * Parameters:
	 * 		struct FGameplayAttributeData                      NewValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		struct FGameplayAttributeData                      OldValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UCharacterStatusWidget::OnWill(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.CharacterStatusWidget.OnWill");
		
		UCharacterStatusWidget_OnWill_Params params {};
		params.NewValue = NewValue;
		params.OldValue = OldValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.CharacterStatusWidget.OnWeightLimitMod
	 * 		Flags  -> (Event, Protected, HasOutParms, BlueprintEvent)
	 * Parameters:
	 * 		struct FGameplayAttributeData                      NewValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		struct FGameplayAttributeData                      OldValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UCharacterStatusWidget::OnWeightLimitMod(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.CharacterStatusWidget.OnWeightLimitMod");
		
		UCharacterStatusWidget_OnWeightLimitMod_Params params {};
		params.NewValue = NewValue;
		params.OldValue = OldValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.CharacterStatusWidget.OnWeightLimitBase
	 * 		Flags  -> (Event, Protected, HasOutParms, BlueprintEvent)
	 * Parameters:
	 * 		struct FGameplayAttributeData                      NewValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		struct FGameplayAttributeData                      OldValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UCharacterStatusWidget::OnWeightLimitBase(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.CharacterStatusWidget.OnWeightLimitBase");
		
		UCharacterStatusWidget_OnWeightLimitBase_Params params {};
		params.NewValue = NewValue;
		params.OldValue = OldValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.CharacterStatusWidget.OnWeightLimitAdd
	 * 		Flags  -> (Event, Protected, HasOutParms, BlueprintEvent)
	 * Parameters:
	 * 		struct FGameplayAttributeData                      NewValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		struct FGameplayAttributeData                      OldValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UCharacterStatusWidget::OnWeightLimitAdd(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.CharacterStatusWidget.OnWeightLimitAdd");
		
		UCharacterStatusWidget_OnWeightLimitAdd_Params params {};
		params.NewValue = NewValue;
		params.OldValue = OldValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.CharacterStatusWidget.OnWeightLimit
	 * 		Flags  -> (Event, Protected, HasOutParms, BlueprintEvent)
	 * Parameters:
	 * 		struct FGameplayAttributeData                      NewValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		struct FGameplayAttributeData                      OldValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UCharacterStatusWidget::OnWeightLimit(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.CharacterStatusWidget.OnWeightLimit");
		
		UCharacterStatusWidget_OnWeightLimit_Params params {};
		params.NewValue = NewValue;
		params.OldValue = OldValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.CharacterStatusWidget.OnWeight
	 * 		Flags  -> (Event, Protected, HasOutParms, BlueprintEvent)
	 * Parameters:
	 * 		struct FGameplayAttributeData                      NewValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		struct FGameplayAttributeData                      OldValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UCharacterStatusWidget::OnWeight(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.CharacterStatusWidget.OnWeight");
		
		UCharacterStatusWidget_OnWeight_Params params {};
		params.NewValue = NewValue;
		params.OldValue = OldValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.CharacterStatusWidget.OnUtilityEffectivenessMod
	 * 		Flags  -> (Event, Protected, HasOutParms, BlueprintEvent)
	 * Parameters:
	 * 		struct FGameplayAttributeData                      NewValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		struct FGameplayAttributeData                      OldValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UCharacterStatusWidget::OnUtilityEffectivenessMod(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.CharacterStatusWidget.OnUtilityEffectivenessMod");
		
		UCharacterStatusWidget_OnUtilityEffectivenessMod_Params params {};
		params.NewValue = NewValue;
		params.OldValue = OldValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.CharacterStatusWidget.OnUtilityEffectivenessBase
	 * 		Flags  -> (Event, Protected, HasOutParms, BlueprintEvent)
	 * Parameters:
	 * 		struct FGameplayAttributeData                      NewValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		struct FGameplayAttributeData                      OldValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UCharacterStatusWidget::OnUtilityEffectivenessBase(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.CharacterStatusWidget.OnUtilityEffectivenessBase");
		
		UCharacterStatusWidget_OnUtilityEffectivenessBase_Params params {};
		params.NewValue = NewValue;
		params.OldValue = OldValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.CharacterStatusWidget.OnUtilityEffectivenessAdd
	 * 		Flags  -> (Event, Protected, HasOutParms, BlueprintEvent)
	 * Parameters:
	 * 		struct FGameplayAttributeData                      NewValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		struct FGameplayAttributeData                      OldValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UCharacterStatusWidget::OnUtilityEffectivenessAdd(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.CharacterStatusWidget.OnUtilityEffectivenessAdd");
		
		UCharacterStatusWidget_OnUtilityEffectivenessAdd_Params params {};
		params.NewValue = NewValue;
		params.OldValue = OldValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.CharacterStatusWidget.OnUtilityEffectiveness
	 * 		Flags  -> (Event, Protected, HasOutParms, BlueprintEvent)
	 * Parameters:
	 * 		struct FGameplayAttributeData                      NewValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		struct FGameplayAttributeData                      OldValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UCharacterStatusWidget::OnUtilityEffectiveness(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.CharacterStatusWidget.OnUtilityEffectiveness");
		
		UCharacterStatusWidget_OnUtilityEffectiveness_Params params {};
		params.NewValue = NewValue;
		params.OldValue = OldValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.CharacterStatusWidget.OnStrength
	 * 		Flags  -> (Event, Protected, HasOutParms, BlueprintEvent)
	 * Parameters:
	 * 		struct FGameplayAttributeData                      NewValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		struct FGameplayAttributeData                      OldValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UCharacterStatusWidget::OnStrength(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.CharacterStatusWidget.OnStrength");
		
		UCharacterStatusWidget_OnStrength_Params params {};
		params.NewValue = NewValue;
		params.OldValue = OldValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.CharacterStatusWidget.OnSpellPayload
	 * 		Flags  -> (Event, Protected, HasOutParms, BlueprintEvent)
	 * Parameters:
	 * 		struct FGameplayAttributeData                      NewValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		struct FGameplayAttributeData                      OldValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UCharacterStatusWidget::OnSpellPayload(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.CharacterStatusWidget.OnSpellPayload");
		
		UCharacterStatusWidget_OnSpellPayload_Params params {};
		params.NewValue = NewValue;
		params.OldValue = OldValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.CharacterStatusWidget.OnSpellCapacityMod
	 * 		Flags  -> (Event, Protected, HasOutParms, BlueprintEvent)
	 * Parameters:
	 * 		struct FGameplayAttributeData                      NewValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		struct FGameplayAttributeData                      OldValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UCharacterStatusWidget::OnSpellCapacityMod(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.CharacterStatusWidget.OnSpellCapacityMod");
		
		UCharacterStatusWidget_OnSpellCapacityMod_Params params {};
		params.NewValue = NewValue;
		params.OldValue = OldValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.CharacterStatusWidget.OnSpellCapacityBase
	 * 		Flags  -> (Event, Protected, HasOutParms, BlueprintEvent)
	 * Parameters:
	 * 		struct FGameplayAttributeData                      NewValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		struct FGameplayAttributeData                      OldValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UCharacterStatusWidget::OnSpellCapacityBase(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.CharacterStatusWidget.OnSpellCapacityBase");
		
		UCharacterStatusWidget_OnSpellCapacityBase_Params params {};
		params.NewValue = NewValue;
		params.OldValue = OldValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.CharacterStatusWidget.OnSpellCapacityAdd
	 * 		Flags  -> (Event, Protected, HasOutParms, BlueprintEvent)
	 * Parameters:
	 * 		struct FGameplayAttributeData                      NewValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		struct FGameplayAttributeData                      OldValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UCharacterStatusWidget::OnSpellCapacityAdd(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.CharacterStatusWidget.OnSpellCapacityAdd");
		
		UCharacterStatusWidget_OnSpellCapacityAdd_Params params {};
		params.NewValue = NewValue;
		params.OldValue = OldValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.CharacterStatusWidget.OnSpellCapacity
	 * 		Flags  -> (Event, Protected, HasOutParms, BlueprintEvent)
	 * Parameters:
	 * 		struct FGameplayAttributeData                      NewValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		struct FGameplayAttributeData                      OldValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UCharacterStatusWidget::OnSpellCapacity(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.CharacterStatusWidget.OnSpellCapacity");
		
		UCharacterStatusWidget_OnSpellCapacity_Params params {};
		params.NewValue = NewValue;
		params.OldValue = OldValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.CharacterStatusWidget.OnResourcefulness
	 * 		Flags  -> (Event, Protected, HasOutParms, BlueprintEvent)
	 * Parameters:
	 * 		struct FGameplayAttributeData                      NewValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		struct FGameplayAttributeData                      OldValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UCharacterStatusWidget::OnResourcefulness(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.CharacterStatusWidget.OnResourcefulness");
		
		UCharacterStatusWidget_OnResourcefulness_Params params {};
		params.NewValue = NewValue;
		params.OldValue = OldValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.CharacterStatusWidget.OnMaxHealthMod
	 * 		Flags  -> (Event, Protected, HasOutParms, BlueprintEvent)
	 * Parameters:
	 * 		struct FGameplayAttributeData                      NewValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		struct FGameplayAttributeData                      OldValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UCharacterStatusWidget::OnMaxHealthMod(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.CharacterStatusWidget.OnMaxHealthMod");
		
		UCharacterStatusWidget_OnMaxHealthMod_Params params {};
		params.NewValue = NewValue;
		params.OldValue = OldValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.CharacterStatusWidget.OnMaxHealthBase
	 * 		Flags  -> (Event, Protected, HasOutParms, BlueprintEvent)
	 * Parameters:
	 * 		struct FGameplayAttributeData                      NewValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		struct FGameplayAttributeData                      OldValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UCharacterStatusWidget::OnMaxHealthBase(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.CharacterStatusWidget.OnMaxHealthBase");
		
		UCharacterStatusWidget_OnMaxHealthBase_Params params {};
		params.NewValue = NewValue;
		params.OldValue = OldValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.CharacterStatusWidget.OnMaxHealthAdd
	 * 		Flags  -> (Event, Protected, HasOutParms, BlueprintEvent)
	 * Parameters:
	 * 		struct FGameplayAttributeData                      NewValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		struct FGameplayAttributeData                      OldValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UCharacterStatusWidget::OnMaxHealthAdd(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.CharacterStatusWidget.OnMaxHealthAdd");
		
		UCharacterStatusWidget_OnMaxHealthAdd_Params params {};
		params.NewValue = NewValue;
		params.OldValue = OldValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.CharacterStatusWidget.OnMaxHealth
	 * 		Flags  -> (Event, Protected, HasOutParms, BlueprintEvent)
	 * Parameters:
	 * 		struct FGameplayAttributeData                      NewValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		struct FGameplayAttributeData                      OldValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UCharacterStatusWidget::OnMaxHealth(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.CharacterStatusWidget.OnMaxHealth");
		
		UCharacterStatusWidget_OnMaxHealth_Params params {};
		params.NewValue = NewValue;
		params.OldValue = OldValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.CharacterStatusWidget.OnKnowledge
	 * 		Flags  -> (Event, Protected, HasOutParms, BlueprintEvent)
	 * Parameters:
	 * 		struct FGameplayAttributeData                      NewValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		struct FGameplayAttributeData                      OldValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UCharacterStatusWidget::OnKnowledge(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.CharacterStatusWidget.OnKnowledge");
		
		UCharacterStatusWidget_OnKnowledge_Params params {};
		params.NewValue = NewValue;
		params.OldValue = OldValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.CharacterStatusWidget.OnHealth
	 * 		Flags  -> (Event, Protected, HasOutParms, BlueprintEvent)
	 * Parameters:
	 * 		struct FGameplayAttributeData                      NewValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		struct FGameplayAttributeData                      OldValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UCharacterStatusWidget::OnHealth(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.CharacterStatusWidget.OnHealth");
		
		UCharacterStatusWidget_OnHealth_Params params {};
		params.NewValue = NewValue;
		params.OldValue = OldValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.CharacterStatusWidget.OnAgility
	 * 		Flags  -> (Event, Protected, HasOutParms, BlueprintEvent)
	 * Parameters:
	 * 		struct FGameplayAttributeData                      NewValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		struct FGameplayAttributeData                      OldValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UCharacterStatusWidget::OnAgility(const struct FGameplayAttributeData& NewValue, const struct FGameplayAttributeData& OldValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.CharacterStatusWidget.OnAgility");
		
		UCharacterStatusWidget_OnAgility_Params params {};
		params.NewValue = NewValue;
		params.OldValue = OldValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UCharacterStatusWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UCharacterStatusWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.CharacterStatusWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01734260
	 * 		Name   -> Function DungeonCrawler.ChatEditWidgetBase.OnTextCommitted
	 * 		Flags  -> (Final, Native, Private, HasOutParms)
	 * Parameters:
	 * 		class FText                                        InText                                                     (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		ETextCommit                                        InCommitMethod                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UChatEditWidgetBase::OnTextCommitted(const class FText& InText, ETextCommit InCommitMethod)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.ChatEditWidgetBase.OnTextCommitted");
		
		UChatEditWidgetBase_OnTextCommitted_Params params {};
		params.InText = InText;
		params.InCommitMethod = InCommitMethod;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01734190
	 * 		Name   -> Function DungeonCrawler.ChatEditWidgetBase.OnTextChanged
	 * 		Flags  -> (Final, Native, Private, HasOutParms)
	 * Parameters:
	 * 		class FText                                        InText                                                     (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UChatEditWidgetBase::OnTextChanged(const class FText& InText)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.ChatEditWidgetBase.OnTextChanged");
		
		UChatEditWidgetBase_OnTextChanged_Params params {};
		params.InText = InText;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UChatEditWidgetBase.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UChatEditWidgetBase::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.ChatEditWidgetBase");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01734380
	 * 		Name   -> Function DungeonCrawler.ChatSetWidgetBase.SetChatKeyboardFocus
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void UChatSetWidgetBase::SetChatKeyboardFocus()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.ChatSetWidgetBase.SetChatKeyboardFocus");
		
		UChatSetWidgetBase_SetChatKeyboardFocus_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017340B0
	 * 		Name   -> Function DungeonCrawler.ChatSetWidgetBase.OnChatEditFocus
	 * 		Flags  -> (Native, Event, Protected, BlueprintEvent)
	 * Parameters:
	 * 		bool                                               InbFocus                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UChatSetWidgetBase::OnChatEditFocus(bool InbFocus)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.ChatSetWidgetBase.OnChatEditFocus");
		
		UChatSetWidgetBase_OnChatEditFocus_Params params {};
		params.InbFocus = InbFocus;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01733F60
	 * 		Name   -> Function DungeonCrawler.ChatSetWidgetBase.OnChatDataCommitted
	 * 		Flags  -> (Native, Event, Protected, HasOutParms, BlueprintEvent)
	 * Parameters:
	 * 		struct FChatData                                   InChatData                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UChatSetWidgetBase::OnChatDataCommitted(const struct FChatData& InChatData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.ChatSetWidgetBase.OnChatDataCommitted");
		
		UChatSetWidgetBase_OnChatDataCommitted_Params params {};
		params.InChatData = InChatData;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01733E80
	 * 		Name   -> Function DungeonCrawler.ChatSetWidgetBase.OnChatDataChanged
	 * 		Flags  -> (Native, Event, Protected, HasOutParms, BlueprintEvent)
	 * Parameters:
	 * 		class FText                                        InText                                                     (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UChatSetWidgetBase::OnChatDataChanged(const class FText& InText)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.ChatSetWidgetBase.OnChatDataChanged");
		
		UChatSetWidgetBase_OnChatDataChanged_Params params {};
		params.InText = InText;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UChatSetWidgetBase.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UChatSetWidgetBase::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.ChatSetWidgetBase");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UChatWidgetData.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UChatWidgetData::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.ChatWidgetData");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01734160
	 * 		Name   -> Function DungeonCrawler.ChatWidgetBase.OnRightClicked
	 * 		Flags  -> (Native, Protected)
	 */
	void UChatWidgetBase::OnRightClicked()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.ChatWidgetBase.OnRightClicked");
		
		UChatWidgetBase_OnRightClicked_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.ChatWidgetBase.OnChatRecordData
	 * 		Flags  -> (Event, Protected, HasOutParms, BlueprintEvent)
	 * Parameters:
	 * 		struct FChatRecord                                 NewValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		struct FChatRecord                                 OldValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UChatWidgetBase::OnChatRecordData(const struct FChatRecord& NewValue, const struct FChatRecord& OldValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.ChatWidgetBase.OnChatRecordData");
		
		UChatWidgetBase_OnChatRecordData_Params params {};
		params.NewValue = NewValue;
		params.OldValue = OldValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.ChatWidgetBase.FilterStreamingMode
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 * Parameters:
	 * 		class FString                                      OriginalStr                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class FString UChatWidgetBase::FilterStreamingMode(const class FString& OriginalStr)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.ChatWidgetBase.FilterStreamingMode");
		
		UChatWidgetBase_FilterStreamingMode_Params params {};
		params.OriginalStr = OriginalStr;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UChatWidgetBase.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UChatWidgetBase::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.ChatWidgetBase");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UClassGroupWidgetBase.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UClassGroupWidgetBase::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.ClassGroupWidgetBase");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UClassIconGroupWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UClassIconGroupWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.ClassIconGroupWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UClassIconWidgetData.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UClassIconWidgetData::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.ClassIconWidgetData");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01734140
	 * 		Name   -> Function DungeonCrawler.ClassIconWidget.OnClickedClassIconButton
	 * 		Flags  -> (Final, Native, Protected, BlueprintCallable)
	 */
	void UClassIconWidget::OnClickedClassIconButton()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.ClassIconWidget.OnClickedClassIconButton");
		
		UClassIconWidget_OnClickedClassIconButton_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UClassIconWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UClassIconWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.ClassIconWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UPerkListWidgetBase.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UPerkListWidgetBase::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.PerkListWidgetBase");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017343A0
	 * 		Name   -> Function DungeonCrawler.ClassPerkListWidgetBase.SetSelectedSlotIndex
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		int32_t                                            InSlotIndex                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UClassPerkListWidgetBase::SetSelectedSlotIndex(int32_t InSlotIndex)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.ClassPerkListWidgetBase.SetSelectedSlotIndex");
		
		UClassPerkListWidgetBase_SetSelectedSlotIndex_Params params {};
		params.InSlotIndex = InSlotIndex;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.ClassPerkListWidgetBase.OnFMsgWidgetClassSlotUnLockLevelNotifyBlueprint
	 * 		Flags  -> (Event, Protected, HasOutParms, BlueprintEvent)
	 * Parameters:
	 * 		struct FMsgWidgetClassSlotUnLockLevelNotify        InMsg                                                      (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UClassPerkListWidgetBase::OnFMsgWidgetClassSlotUnLockLevelNotifyBlueprint(const struct FMsgWidgetClassSlotUnLockLevelNotify& InMsg)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.ClassPerkListWidgetBase.OnFMsgWidgetClassSlotUnLockLevelNotifyBlueprint");
		
		UClassPerkListWidgetBase_OnFMsgWidgetClassSlotUnLockLevelNotifyBlueprint_Params params {};
		params.InMsg = InMsg;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.ClassPerkListWidgetBase.OnFMsgWidgetClassLevelNotifyBlueprint
	 * 		Flags  -> (Event, Protected, HasOutParms, BlueprintEvent)
	 * Parameters:
	 * 		struct FMsgWidgetClassLevelNotify                  InMsg                                                      (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UClassPerkListWidgetBase::OnFMsgWidgetClassLevelNotifyBlueprint(const struct FMsgWidgetClassLevelNotify& InMsg)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.ClassPerkListWidgetBase.OnFMsgWidgetClassLevelNotifyBlueprint");
		
		UClassPerkListWidgetBase_OnFMsgWidgetClassLevelNotifyBlueprint_Params params {};
		params.InMsg = InMsg;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.ClassPerkListWidgetBase.OnFMsgWidgetClassEquipablePerkEmptySlotsMarkNotifyBlueprint
	 * 		Flags  -> (Event, Protected, HasOutParms, BlueprintEvent)
	 * Parameters:
	 * 		struct FMsgWidgetClassEquipablePerkEmptySlotsMarkNotify InMsg                                                      (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UClassPerkListWidgetBase::OnFMsgWidgetClassEquipablePerkEmptySlotsMarkNotifyBlueprint(const struct FMsgWidgetClassEquipablePerkEmptySlotsMarkNotify& InMsg)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.ClassPerkListWidgetBase.OnFMsgWidgetClassEquipablePerkEmptySlotsMarkNotifyBlueprint");
		
		UClassPerkListWidgetBase_OnFMsgWidgetClassEquipablePerkEmptySlotsMarkNotifyBlueprint_Params params {};
		params.InMsg = InMsg;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01733E40
	 * 		Name   -> Function DungeonCrawler.ClassPerkListWidgetBase.GetSelectedSlotPerkId
	 * 		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable)
	 */
	struct FPrimaryAssetId UClassPerkListWidgetBase::GetSelectedSlotPerkId()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.ClassPerkListWidgetBase.GetSelectedSlotPerkId");
		
		UClassPerkListWidgetBase_GetSelectedSlotPerkId_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01733E10
	 * 		Name   -> Function DungeonCrawler.ClassPerkListWidgetBase.GetSelectedSlotIndex
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	int32_t UClassPerkListWidgetBase::GetSelectedSlotIndex()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.ClassPerkListWidgetBase.GetSelectedSlotIndex");
		
		UClassPerkListWidgetBase_GetSelectedSlotIndex_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UClassPerkListWidgetBase.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UClassPerkListWidgetBase::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.ClassPerkListWidgetBase");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UClassSelectAttributeItemWidgetData.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UClassSelectAttributeItemWidgetData::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.ClassSelectAttributeItemWidgetData");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UClassSelectAttributeItemWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UClassSelectAttributeItemWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.ClassSelectAttributeItemWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UClassSelectItemWidgetData.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UClassSelectItemWidgetData::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.ClassSelectItemWidgetData");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UClassSelectItemWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UClassSelectItemWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.ClassSelectItemWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UClassSelectPerkItemWidgetData.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UClassSelectPerkItemWidgetData::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.ClassSelectPerkItemWidgetData");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UClassSelectPerkItemWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UClassSelectPerkItemWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.ClassSelectPerkItemWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01751C60
	 * 		Name   -> Function DungeonCrawler.ClassSelectWidget.OnPlayerCharacterId
	 * 		Flags  -> (Native, Event, Protected, HasOutParms, HasDefaults, BlueprintEvent)
	 * Parameters:
	 * 		struct FPrimaryAssetId                             NewValue                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FPrimaryAssetId                             OldValue                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UClassSelectWidget::OnPlayerCharacterId(const struct FPrimaryAssetId& NewValue, const struct FPrimaryAssetId& OldValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.ClassSelectWidget.OnPlayerCharacterId");
		
		UClassSelectWidget_OnPlayerCharacterId_Params params {};
		params.NewValue = NewValue;
		params.OldValue = OldValue;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01751C20
	 * 		Name   -> Function DungeonCrawler.ClassSelectWidget.OnClassSelectButtonClicked
	 * 		Flags  -> (Final, Native, Private)
	 */
	void UClassSelectWidget::OnClassSelectButtonClicked()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.ClassSelectWidget.OnClassSelectButtonClicked");
		
		UClassSelectWidget_OnClassSelectButtonClicked_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UClassSelectWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UClassSelectWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.ClassSelectWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction USkillListWidgetBase.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* USkillListWidgetBase::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.SkillListWidgetBase");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017343A0
	 * 		Name   -> Function DungeonCrawler.ClassSkillListWidgetBase.SetSelectedSlotIndex
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		int32_t                                            InSlotIndex                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UClassSkillListWidgetBase::SetSelectedSlotIndex(int32_t InSlotIndex)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.ClassSkillListWidgetBase.SetSelectedSlotIndex");
		
		UClassSkillListWidgetBase_SetSelectedSlotIndex_Params params {};
		params.InSlotIndex = InSlotIndex;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.ClassSkillListWidgetBase.OnFMsgWidgetClassSlotUnLockLevelNotifyBlueprint
	 * 		Flags  -> (Event, Protected, HasOutParms, BlueprintEvent)
	 * Parameters:
	 * 		struct FMsgWidgetClassSlotUnLockLevelNotify        InMsg                                                      (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UClassSkillListWidgetBase::OnFMsgWidgetClassSlotUnLockLevelNotifyBlueprint(const struct FMsgWidgetClassSlotUnLockLevelNotify& InMsg)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.ClassSkillListWidgetBase.OnFMsgWidgetClassSlotUnLockLevelNotifyBlueprint");
		
		UClassSkillListWidgetBase_OnFMsgWidgetClassSlotUnLockLevelNotifyBlueprint_Params params {};
		params.InMsg = InMsg;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.ClassSkillListWidgetBase.OnFMsgWidgetClassLevelNotifyBlueprint
	 * 		Flags  -> (Event, Protected, HasOutParms, BlueprintEvent)
	 * Parameters:
	 * 		struct FMsgWidgetClassLevelNotify                  InMsg                                                      (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UClassSkillListWidgetBase::OnFMsgWidgetClassLevelNotifyBlueprint(const struct FMsgWidgetClassLevelNotify& InMsg)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.ClassSkillListWidgetBase.OnFMsgWidgetClassLevelNotifyBlueprint");
		
		UClassSkillListWidgetBase_OnFMsgWidgetClassLevelNotifyBlueprint_Params params {};
		params.InMsg = InMsg;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.ClassSkillListWidgetBase.OnFMsgWidgetClassEquipableSkillEmptySlotsMarkNotifyBlueprint
	 * 		Flags  -> (Event, Protected, HasOutParms, BlueprintEvent)
	 * Parameters:
	 * 		struct FMsgWidgetClassEquipableSkillEmptySlotsMarkNotify InMsg                                                      (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UClassSkillListWidgetBase::OnFMsgWidgetClassEquipableSkillEmptySlotsMarkNotifyBlueprint(const struct FMsgWidgetClassEquipableSkillEmptySlotsMarkNotify& InMsg)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.ClassSkillListWidgetBase.OnFMsgWidgetClassEquipableSkillEmptySlotsMarkNotifyBlueprint");
		
		UClassSkillListWidgetBase_OnFMsgWidgetClassEquipableSkillEmptySlotsMarkNotifyBlueprint_Params params {};
		params.InMsg = InMsg;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01751BE0
	 * 		Name   -> Function DungeonCrawler.ClassSkillListWidgetBase.GetSelectedSlotSkillId
	 * 		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable)
	 */
	struct FPrimaryAssetId UClassSkillListWidgetBase::GetSelectedSlotSkillId()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.ClassSkillListWidgetBase.GetSelectedSlotSkillId");
		
		UClassSkillListWidgetBase_GetSelectedSlotSkillId_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01733E10
	 * 		Name   -> Function DungeonCrawler.ClassSkillListWidgetBase.GetSelectedSlotIndex
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	int32_t UClassSkillListWidgetBase::GetSelectedSlotIndex()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.ClassSkillListWidgetBase.GetSelectedSlotIndex");
		
		UClassSkillListWidgetBase_GetSelectedSlotIndex_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UClassSkillListWidgetBase.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UClassSkillListWidgetBase::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.ClassSkillListWidgetBase");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01818410
	 * 		Name   -> Function DungeonCrawler.SpellSlotWidgetBase.SetSpellData
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		struct FSpellData                                  InSpellData                                                (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 * 		struct FDesignDataSpell                            InDesignDataSpell                                          (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void USpellSlotWidgetBase::SetSpellData(const struct FSpellData& InSpellData, const struct FDesignDataSpell& InDesignDataSpell)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.SpellSlotWidgetBase.SetSpellData");
		
		USpellSlotWidgetBase_SetSpellData_Params params {};
		params.InSpellData = InSpellData;
		params.InDesignDataSpell = InDesignDataSpell;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x018182A0
	 * 		Name   -> Function DungeonCrawler.SpellSlotWidgetBase.Reset
	 * 		Flags  -> (Final, Native, Public)
	 */
	void USpellSlotWidgetBase::Reset()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.SpellSlotWidgetBase.Reset");
		
		USpellSlotWidgetBase_Reset_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.SpellSlotWidgetBase.OnSpellDataChanged
	 * 		Flags  -> (Event, Protected, HasOutParms, BlueprintEvent)
	 * Parameters:
	 * 		struct FSpellData                                  InSpellData                                                (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 * 		struct FDesignDataSpell                            InDesignDataSpell                                          (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void USpellSlotWidgetBase::OnSpellDataChanged(const struct FSpellData& InSpellData, const struct FDesignDataSpell& InDesignDataSpell)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.SpellSlotWidgetBase.OnSpellDataChanged");
		
		USpellSlotWidgetBase_OnSpellDataChanged_Params params {};
		params.InSpellData = InSpellData;
		params.InDesignDataSpell = InDesignDataSpell;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.SpellSlotWidgetBase.OnSetSpellArtData
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 * Parameters:
	 * 		class UArtDataSpell*                               InArtSpellData                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void USpellSlotWidgetBase::OnSetSpellArtData(class UArtDataSpell* InArtSpellData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.SpellSlotWidgetBase.OnSetSpellArtData");
		
		USpellSlotWidgetBase_OnSetSpellArtData_Params params {};
		params.InArtSpellData = InArtSpellData;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.SpellSlotWidgetBase.OnReset
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 */
	void USpellSlotWidgetBase::OnReset()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.SpellSlotWidgetBase.OnReset");
		
		USpellSlotWidgetBase_OnReset_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction USpellSlotWidgetBase.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* USpellSlotWidgetBase::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.SpellSlotWidgetBase");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction USpellCapacitySlotWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* USpellCapacitySlotWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.SpellCapacitySlotWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UClassSpellCapacitySlotWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UClassSpellCapacitySlotWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.ClassSpellCapacitySlotWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.SpellCapacityWidgetBase.OnSpellCapacityChanged
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 * Parameters:
	 * 		float                                              InSpellCurrentCapacity                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              InSpellMaxCapacity                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void USpellCapacityWidgetBase::OnSpellCapacityChanged(float InSpellCurrentCapacity, float InSpellMaxCapacity)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.SpellCapacityWidgetBase.OnSpellCapacityChanged");
		
		USpellCapacityWidgetBase_OnSpellCapacityChanged_Params params {};
		params.InSpellCurrentCapacity = InSpellCurrentCapacity;
		params.InSpellMaxCapacity = InSpellMaxCapacity;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction USpellCapacityWidgetBase.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* USpellCapacityWidgetBase::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.SpellCapacityWidgetBase");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.ClassSpellCapacityWidget.OnSpellListChanged
	 * 		Flags  -> (Event, Protected, HasOutParms, BlueprintEvent)
	 * Parameters:
	 * 		TArray<struct FSpellData>                          InSpellDataArray                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UClassSpellCapacityWidget::OnSpellListChanged(TArray<struct FSpellData> InSpellDataArray)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.ClassSpellCapacityWidget.OnSpellListChanged");
		
		UClassSpellCapacityWidget_OnSpellListChanged_Params params {};
		params.InSpellDataArray = InSpellDataArray;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UClassSpellCapacityWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UClassSpellCapacityWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.ClassSpellCapacityWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UClassSpellEquippedWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UClassSpellEquippedWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.ClassSpellEquippedWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGameGroupWidgetBase.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGameGroupWidgetBase::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.GameGroupWidgetBase");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction USpellListWidgetBase.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* USpellListWidgetBase::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.SpellListWidgetBase");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.ClassSpellListWidget.OnShowEquippableSlot
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 */
	void UClassSpellListWidget::OnShowEquippableSlot()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.ClassSpellListWidget.OnShowEquippableSlot");
		
		UClassSpellListWidget_OnShowEquippableSlot_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.ClassSpellListWidget.OnHideEquippableSlot
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 */
	void UClassSpellListWidget::OnHideEquippableSlot()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.ClassSpellListWidget.OnHideEquippableSlot");
		
		UClassSpellListWidget_OnHideEquippableSlot_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UClassSpellListWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UClassSpellListWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.ClassSpellListWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.ClassSpellSkillListWidgetBase.OnFMsgWidgetClassSlotUnLockLevelNotifyBlueprint
	 * 		Flags  -> (Event, Protected, HasOutParms, BlueprintEvent)
	 * Parameters:
	 * 		struct FMsgWidgetClassSlotUnLockLevelNotify        InMsg                                                      (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UClassSpellSkillListWidgetBase::OnFMsgWidgetClassSlotUnLockLevelNotifyBlueprint(const struct FMsgWidgetClassSlotUnLockLevelNotify& InMsg)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.ClassSpellSkillListWidgetBase.OnFMsgWidgetClassSlotUnLockLevelNotifyBlueprint");
		
		UClassSpellSkillListWidgetBase_OnFMsgWidgetClassSlotUnLockLevelNotifyBlueprint_Params params {};
		params.InMsg = InMsg;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.ClassSpellSkillListWidgetBase.OnFMsgWidgetClassLevelNotifyBlueprint
	 * 		Flags  -> (Event, Protected, HasOutParms, BlueprintEvent)
	 * Parameters:
	 * 		struct FMsgWidgetClassLevelNotify                  InMsg                                                      (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UClassSpellSkillListWidgetBase::OnFMsgWidgetClassLevelNotifyBlueprint(const struct FMsgWidgetClassLevelNotify& InMsg)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.ClassSpellSkillListWidgetBase.OnFMsgWidgetClassLevelNotifyBlueprint");
		
		UClassSpellSkillListWidgetBase_OnFMsgWidgetClassLevelNotifyBlueprint_Params params {};
		params.InMsg = InMsg;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UClassSpellSkillListWidgetBase.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UClassSpellSkillListWidgetBase::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.ClassSpellSkillListWidgetBase");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.ClassTabMenuWidget.OnLobbyCharacterInfoUpdated_BP
	 * 		Flags  -> (Event, Protected, HasOutParms, HasDefaults, BlueprintEvent)
	 * Parameters:
	 * 		struct FPrimaryAssetId                             CharacterClassId                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UClassTabMenuWidget::OnLobbyCharacterInfoUpdated_BP(const struct FPrimaryAssetId& CharacterClassId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.ClassTabMenuWidget.OnLobbyCharacterInfoUpdated_BP");
		
		UClassTabMenuWidget_OnLobbyCharacterInfoUpdated_BP_Params params {};
		params.CharacterClassId = CharacterClassId;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01751C40
	 * 		Name   -> Function DungeonCrawler.ClassTabMenuWidget.OnLobbyCharacterInfoUpdated
	 * 		Flags  -> (Final, Native, Private)
	 */
	void UClassTabMenuWidget::OnLobbyCharacterInfoUpdated()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.ClassTabMenuWidget.OnLobbyCharacterInfoUpdated");
		
		UClassTabMenuWidget_OnLobbyCharacterInfoUpdated_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UClassTabMenuWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UClassTabMenuWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.ClassTabMenuWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UClassUnEquipmentPerkandSkillItemWidgetData.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UClassUnEquipmentPerkandSkillItemWidgetData::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.ClassUnEquipmentPerkandSkillItemWidgetData");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01751BA0
	 * 		Name   -> Function DungeonCrawler.ClassUnEquipmentPerkandSkillListWidget.GetSelectedSkillId
	 * 		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable)
	 */
	struct FPrimaryAssetId UClassUnEquipmentPerkandSkillListWidget::GetSelectedSkillId()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.ClassUnEquipmentPerkandSkillListWidget.GetSelectedSkillId");
		
		UClassUnEquipmentPerkandSkillListWidget_GetSelectedSkillId_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01751B60
	 * 		Name   -> Function DungeonCrawler.ClassUnEquipmentPerkandSkillListWidget.GetSelectedPerkId
	 * 		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable)
	 */
	struct FPrimaryAssetId UClassUnEquipmentPerkandSkillListWidget::GetSelectedPerkId()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.ClassUnEquipmentPerkandSkillListWidget.GetSelectedPerkId");
		
		UClassUnEquipmentPerkandSkillListWidget_GetSelectedPerkId_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UClassUnEquipmentPerkandSkillListWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UClassUnEquipmentPerkandSkillListWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.ClassUnEquipmentPerkandSkillListWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UClassUnEquipmentSpellItemWidgetData.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UClassUnEquipmentSpellItemWidgetData::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.ClassUnEquipmentSpellItemWidgetData");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UClassUnEquipmentSpellListWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UClassUnEquipmentSpellListWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.ClassUnEquipmentSpellListWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UClassUnEquipmentSpellTierItemWidgetData.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UClassUnEquipmentSpellTierItemWidgetData::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.ClassUnEquipmentSpellTierItemWidgetData");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UClassUnEquipmentSpellTierListWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UClassUnEquipmentSpellTierListWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.ClassUnEquipmentSpellTierListWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction USubSystemReplyMsg.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* USubSystemReplyMsg::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.SubSystemReplyMsg");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01751E50
	 * 		Name   -> Function DungeonCrawler.ClientAccountSubsystem.UnbindMsgAll
	 * 		Flags  -> (Native, Public)
	 * Parameters:
	 * 		class UObject*                                     InObject                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UClientAccountSubsystem::UnbindMsgAll(class UObject* InObject)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.ClientAccountSubsystem.UnbindMsgAll");
		
		UClientAccountSubsystem_UnbindMsgAll_Params params {};
		params.InObject = InObject;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01751D80
	 * 		Name   -> Function DungeonCrawler.ClientAccountSubsystem.UnbindMsg
	 * 		Flags  -> (Native, Public)
	 * Parameters:
	 * 		class UScriptStruct*                               InMsgType                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UObject*                                     InObject                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UClientAccountSubsystem::UnbindMsg(class UScriptStruct* InMsgType, class UObject* InObject)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.ClientAccountSubsystem.UnbindMsg");
		
		UClientAccountSubsystem_UnbindMsg_Params params {};
		params.InMsgType = InMsgType;
		params.InObject = InObject;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01751D60
	 * 		Name   -> Function DungeonCrawler.ClientAccountSubsystem.TerminateBase
	 * 		Flags  -> (Native, Public)
	 */
	void UClientAccountSubsystem::TerminateBase()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.ClientAccountSubsystem.TerminateBase");
		
		UClientAccountSubsystem_TerminateBase_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D3C640
	 * 		Name   -> Function DungeonCrawler.ClientAccountSubsystem.BroadcastMsgBlueprint
	 * 		Flags  -> (Native, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		int32_t                                            InMsg                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UClientAccountSubsystem::BroadcastMsgBlueprint(int32_t InMsg)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.ClientAccountSubsystem.BroadcastMsgBlueprint");
		
		UClientAccountSubsystem_BroadcastMsgBlueprint_Params params {};
		params.InMsg = InMsg;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UClientAccountSubsystem.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UClientAccountSubsystem::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.ClientAccountSubsystem");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01751E50
	 * 		Name   -> Function DungeonCrawler.ClientPartySubsystem.UnbindMsgAll
	 * 		Flags  -> (Native, Public)
	 * Parameters:
	 * 		class UObject*                                     InObject                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UClientPartySubsystem::UnbindMsgAll(class UObject* InObject)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.ClientPartySubsystem.UnbindMsgAll");
		
		UClientPartySubsystem_UnbindMsgAll_Params params {};
		params.InObject = InObject;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01751D80
	 * 		Name   -> Function DungeonCrawler.ClientPartySubsystem.UnbindMsg
	 * 		Flags  -> (Native, Public)
	 * Parameters:
	 * 		class UScriptStruct*                               InMsgType                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UObject*                                     InObject                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UClientPartySubsystem::UnbindMsg(class UScriptStruct* InMsgType, class UObject* InObject)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.ClientPartySubsystem.UnbindMsg");
		
		UClientPartySubsystem_UnbindMsg_Params params {};
		params.InMsgType = InMsgType;
		params.InObject = InObject;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01751D60
	 * 		Name   -> Function DungeonCrawler.ClientPartySubsystem.TerminateBase
	 * 		Flags  -> (Native, Public)
	 */
	void UClientPartySubsystem::TerminateBase()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.ClientPartySubsystem.TerminateBase");
		
		UClientPartySubsystem_TerminateBase_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D3C640
	 * 		Name   -> Function DungeonCrawler.ClientPartySubsystem.BroadcastMsgBlueprint
	 * 		Flags  -> (Native, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		int32_t                                            InMsg                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UClientPartySubsystem::BroadcastMsgBlueprint(int32_t InMsg)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.ClientPartySubsystem.BroadcastMsgBlueprint");
		
		UClientPartySubsystem_BroadcastMsgBlueprint_Params params {};
		params.InMsg = InMsg;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UClientPartySubsystem.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UClientPartySubsystem::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.ClientPartySubsystem");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01751E50
	 * 		Name   -> Function DungeonCrawler.ClientShopSubsystem.UnbindMsgAll
	 * 		Flags  -> (Native, Public)
	 * Parameters:
	 * 		class UObject*                                     InObject                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UClientShopSubsystem::UnbindMsgAll(class UObject* InObject)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.ClientShopSubsystem.UnbindMsgAll");
		
		UClientShopSubsystem_UnbindMsgAll_Params params {};
		params.InObject = InObject;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01751D80
	 * 		Name   -> Function DungeonCrawler.ClientShopSubsystem.UnbindMsg
	 * 		Flags  -> (Native, Public)
	 * Parameters:
	 * 		class UScriptStruct*                               InMsgType                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UObject*                                     InObject                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UClientShopSubsystem::UnbindMsg(class UScriptStruct* InMsgType, class UObject* InObject)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.ClientShopSubsystem.UnbindMsg");
		
		UClientShopSubsystem_UnbindMsg_Params params {};
		params.InMsgType = InMsgType;
		params.InObject = InObject;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01751D60
	 * 		Name   -> Function DungeonCrawler.ClientShopSubsystem.TerminateBase
	 * 		Flags  -> (Native, Public)
	 */
	void UClientShopSubsystem::TerminateBase()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.ClientShopSubsystem.TerminateBase");
		
		UClientShopSubsystem_TerminateBase_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D3C640
	 * 		Name   -> Function DungeonCrawler.ClientShopSubsystem.BroadcastMsgBlueprint
	 * 		Flags  -> (Native, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		int32_t                                            InMsg                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UClientShopSubsystem::BroadcastMsgBlueprint(int32_t InMsg)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.ClientShopSubsystem.BroadcastMsgBlueprint");
		
		UClientShopSubsystem_BroadcastMsgBlueprint_Params params {};
		params.InMsg = InMsg;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UClientShopSubsystem.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UClientShopSubsystem::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.ClientShopSubsystem");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.CommemorativePlaqueTextWidget.UpdateCommenorativePlaqueText
	 * 		Flags  -> (Event, Protected, HasOutParms, HasDefaults, BlueprintEvent)
	 * Parameters:
	 * 		TArray<class FText>                                InText                                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     Location                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UCommemorativePlaqueTextWidget::UpdateCommenorativePlaqueText(TArray<class FText> InText, const struct FVector& Location)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.CommemorativePlaqueTextWidget.UpdateCommenorativePlaqueText");
		
		UCommemorativePlaqueTextWidget_UpdateCommenorativePlaqueText_Params params {};
		params.InText = InText;
		params.Location = Location;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01758060
	 * 		Name   -> Function DungeonCrawler.CommemorativePlaqueTextWidget.SnedWidgetToggleMsg
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void UCommemorativePlaqueTextWidget::SnedWidgetToggleMsg()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.CommemorativePlaqueTextWidget.SnedWidgetToggleMsg");
		
		UCommemorativePlaqueTextWidget_SnedWidgetToggleMsg_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01757BF0
	 * 		Name   -> Function DungeonCrawler.CommemorativePlaqueTextWidget.SetCommemorativePlaqueText
	 * 		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FPrimaryAssetId                             ScriptId                                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     Location                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UCommemorativePlaqueTextWidget::SetCommemorativePlaqueText(const struct FPrimaryAssetId& ScriptId, const struct FVector& Location)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.CommemorativePlaqueTextWidget.SetCommemorativePlaqueText");
		
		UCommemorativePlaqueTextWidget_SetCommemorativePlaqueText_Params params {};
		params.ScriptId = ScriptId;
		params.Location = Location;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UCommemorativePlaqueTextWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UCommemorativePlaqueTextWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.CommemorativePlaqueTextWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.DCCommonButtonBase.SetButtonText
	 * 		Flags  -> (Event, Public, HasOutParms, BlueprintCallable, BlueprintEvent)
	 * Parameters:
	 * 		class FText                                        InButtonText                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UDCCommonButtonBase::SetButtonText(const class FText& InButtonText)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCCommonButtonBase.SetButtonText");
		
		UDCCommonButtonBase_SetButtonText_Params params {};
		params.InButtonText = InButtonText;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0177DCC0
	 * 		Name   -> Function DungeonCrawler.DCCommonButtonBase.PlayClickSound
	 * 		Flags  -> (Final, Native, Private)
	 */
	void UDCCommonButtonBase::PlayClickSound()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCCommonButtonBase.PlayClickSound");
		
		UDCCommonButtonBase_PlayClickSound_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0177D9A0
	 * 		Name   -> Function DungeonCrawler.DCCommonButtonBase.OnCommonButtonClicked
	 * 		Flags  -> (Final, Native, Private)
	 */
	void UDCCommonButtonBase::OnCommonButtonClicked()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCCommonButtonBase.OnCommonButtonClicked");
		
		UDCCommonButtonBase_OnCommonButtonClicked_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDCCommonButtonBase.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDCCommonButtonBase::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCCommonButtonBase");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01757FD0
	 * 		Name   -> Function DungeonCrawler.CommonButtonLWidget.SetSwitchOn
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bSetOn                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UCommonButtonLWidget::SetSwitchOn(bool bSetOn)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.CommonButtonLWidget.SetSwitchOn");
		
		UCommonButtonLWidget_SetSwitchOn_Params params {};
		params.bSetOn = bSetOn;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01757D10
	 * 		Name   -> Function DungeonCrawler.CommonButtonLWidget.SetDisableTitleText
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class FText                                        InText                                                     (Parm, NativeAccessSpecifierPublic)
	 */
	void UCommonButtonLWidget::SetDisableTitleText(const class FText& InText)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.CommonButtonLWidget.SetDisableTitleText");
		
		UCommonButtonLWidget_SetDisableTitleText_Params params {};
		params.InText = InText;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01757A20
	 * 		Name   -> Function DungeonCrawler.CommonButtonLWidget.SetAbleTitleText
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class FText                                        InText                                                     (Parm, NativeAccessSpecifierPublic)
	 */
	void UCommonButtonLWidget::SetAbleTitleText(const class FText& InText)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.CommonButtonLWidget.SetAbleTitleText");
		
		UCommonButtonLWidget_SetAbleTitleText_Params params {};
		params.InText = InText;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UCommonButtonLWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UCommonButtonLWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.CommonButtonLWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UCommonButtonMWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UCommonButtonMWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.CommonButtonMWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01757EE0
	 * 		Name   -> Function DungeonCrawler.CommonButtonPopupWidget.SetOnText
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class FString                                      TextTitleOn                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UCommonButtonPopupWidget::SetOnText(const class FString& TextTitleOn)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.CommonButtonPopupWidget.SetOnText");
		
		UCommonButtonPopupWidget_SetOnText_Params params {};
		params.TextTitleOn = TextTitleOn;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01757DF0
	 * 		Name   -> Function DungeonCrawler.CommonButtonPopupWidget.SetNormalText
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class FString                                      TextTitleNormal                                            (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UCommonButtonPopupWidget::SetNormalText(const class FString& TextTitleNormal)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.CommonButtonPopupWidget.SetNormalText");
		
		UCommonButtonPopupWidget_SetNormalText_Params params {};
		params.TextTitleNormal = TextTitleNormal;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01757B00
	 * 		Name   -> Function DungeonCrawler.CommonButtonPopupWidget.SetAllText
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class FString                                      TextTitle                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UCommonButtonPopupWidget::SetAllText(const class FString& TextTitle)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.CommonButtonPopupWidget.SetAllText");
		
		UCommonButtonPopupWidget_SetAllText_Params params {};
		params.TextTitle = TextTitle;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UCommonButtonPopupWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UCommonButtonPopupWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.CommonButtonPopupWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UCommonButtonSWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UCommonButtonSWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.CommonButtonSWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UCommonButtonXLWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UCommonButtonXLWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.CommonButtonXLWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UPopupDataBase.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UPopupDataBase::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.PopupDataBase");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UCommonPopupBase.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UCommonPopupBase::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.CommonPopupBase");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UCommonPopupManageWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UCommonPopupManageWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.CommonPopupManageWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UPopupDataSWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UPopupDataSWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.PopupDataSWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.CommonPopupSWidget.OnRemovePopup
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 */
	void UCommonPopupSWidget::OnRemovePopup()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.CommonPopupSWidget.OnRemovePopup");
		
		UCommonPopupSWidget_OnRemovePopup_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.CommonPopupSWidget.OnCreatePopup
	 * 		Flags  -> (Event, Protected, HasOutParms, BlueprintEvent)
	 * Parameters:
	 * 		struct FPopupSWidgetData                           PopupSWidgetData                                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UCommonPopupSWidget::OnCreatePopup(const struct FPopupSWidgetData& PopupSWidgetData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.CommonPopupSWidget.OnCreatePopup");
		
		UCommonPopupSWidget_OnCreatePopup_Params params {};
		params.PopupSWidgetData = PopupSWidgetData;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01756850
	 * 		Name   -> Function DungeonCrawler.CommonPopupSWidget.HandleSingleButtonClicked
	 * 		Flags  -> (Final, Native, Protected)
	 */
	void UCommonPopupSWidget::HandleSingleButtonClicked()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.CommonPopupSWidget.HandleSingleButtonClicked");
		
		UCommonPopupSWidget_HandleSingleButtonClicked_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01756870
	 * 		Name   -> Function DungeonCrawler.CommonPopupSWidget.HandleRightButtonClicked
	 * 		Flags  -> (Final, Native, Protected)
	 */
	void UCommonPopupSWidget::HandleRightButtonClicked()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.CommonPopupSWidget.HandleRightButtonClicked");
		
		UCommonPopupSWidget_HandleRightButtonClicked_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01756850
	 * 		Name   -> Function DungeonCrawler.CommonPopupSWidget.HandleLeftButtonClicked
	 * 		Flags  -> (Final, Native, Protected)
	 */
	void UCommonPopupSWidget::HandleLeftButtonClicked()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.CommonPopupSWidget.HandleLeftButtonClicked");
		
		UCommonPopupSWidget_HandleLeftButtonClicked_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UCommonPopupSWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UCommonPopupSWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.CommonPopupSWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01757A00
	 * 		Name   -> Function DungeonCrawler.ContainerInventoryGroupWidget.ResetContainerInventoryWidgets
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void UContainerInventoryGroupWidget::ResetContainerInventoryWidgets()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.ContainerInventoryGroupWidget.ResetContainerInventoryWidgets");
		
		UContainerInventoryGroupWidget_ResetContainerInventoryWidgets_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01757320
	 * 		Name   -> Function DungeonCrawler.ContainerInventoryGroupWidget.OnPopItemSelectWidget
	 * 		Flags  -> (Final, Native, Protected, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FItemData                                   ItemData                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		struct FVector2D                                   DropScreenPos                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      OldOwnerActor                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UContainerInventoryGroupWidget::OnPopItemSelectWidget(const struct FItemData& ItemData, const struct FVector2D& DropScreenPos, class AActor* OldOwnerActor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.ContainerInventoryGroupWidget.OnPopItemSelectWidget");
		
		UContainerInventoryGroupWidget_OnPopItemSelectWidget_Params params {};
		params.ItemData = ItemData;
		params.DropScreenPos = DropScreenPos;
		params.OldOwnerActor = OldOwnerActor;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01756C60
	 * 		Name   -> Function DungeonCrawler.ContainerInventoryGroupWidget.OnItemDropDetected
	 * 		Flags  -> (Final, Native, Protected, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FItemData                                   ItemData                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		struct FVector2D                                   DropScreenPos                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      OldOwnerActor                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UContainerInventoryGroupWidget::OnItemDropDetected(const struct FItemData& ItemData, const struct FVector2D& DropScreenPos, class AActor* OldOwnerActor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.ContainerInventoryGroupWidget.OnItemDropDetected");
		
		UContainerInventoryGroupWidget_OnItemDropDetected_Params params {};
		params.ItemData = ItemData;
		params.DropScreenPos = DropScreenPos;
		params.OldOwnerActor = OldOwnerActor;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UContainerInventoryGroupWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UContainerInventoryGroupWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.ContainerInventoryGroupWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01758080
	 * 		Name   -> Function DungeonCrawler.ContainerInventoryWidget.UpdateItemCanBeSet
	 * 		Flags  -> (Final, Native, Private, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		struct FItemData                                   InItemData                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		int32_t                                            SlotId                                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UContainerInventoryWidget::UpdateItemCanBeSet(const struct FItemData& InItemData, int32_t SlotId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.ContainerInventoryWidget.UpdateItemCanBeSet");
		
		UContainerInventoryWidget_UpdateItemCanBeSet_Params params {};
		params.InItemData = InItemData;
		params.SlotId = SlotId;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01757500
	 * 		Name   -> Function DungeonCrawler.ContainerInventoryWidget.OnRemoveItem
	 * 		Flags  -> (Final, Native, Public, HasOutParms)
	 * Parameters:
	 * 		struct FItemData                                   InItemData                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UContainerInventoryWidget::OnRemoveItem(const struct FItemData& InItemData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.ContainerInventoryWidget.OnRemoveItem");
		
		UContainerInventoryWidget_OnRemoveItem_Params params {};
		params.InItemData = InItemData;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017570C0
	 * 		Name   -> Function DungeonCrawler.ContainerInventoryWidget.OnMoveItem
	 * 		Flags  -> (Final, Native, Public, HasOutParms)
	 * Parameters:
	 * 		struct FItemData                                   OldItemData                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		struct FItemData                                   NewItemData                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UContainerInventoryWidget::OnMoveItem(const struct FItemData& OldItemData, const struct FItemData& NewItemData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.ContainerInventoryWidget.OnMoveItem");
		
		UContainerInventoryWidget_OnMoveItem_Params params {};
		params.OldItemData = OldItemData;
		params.NewItemData = NewItemData;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01756E40
	 * 		Name   -> Function DungeonCrawler.ContainerInventoryWidget.OnItemWidgetDropOrLeave
	 * 		Flags  -> (Final, Native, Protected, BlueprintCallable)
	 */
	void UContainerInventoryWidget::OnItemWidgetDropOrLeave()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.ContainerInventoryWidget.OnItemWidgetDropOrLeave");
		
		UContainerInventoryWidget_OnItemWidgetDropOrLeave_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01756AC0
	 * 		Name   -> Function DungeonCrawler.ContainerInventoryWidget.OnItemDragDetected
	 * 		Flags  -> (Final, Native, Protected, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FItemData                                   ItemData                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		struct FVector2D                                   DragScreenPos                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UContainerInventoryWidget::OnItemDragDetected(const struct FItemData& ItemData, const struct FVector2D& DragScreenPos)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.ContainerInventoryWidget.OnItemDragDetected");
		
		UContainerInventoryWidget_OnItemDragDetected_Params params {};
		params.ItemData = ItemData;
		params.DragScreenPos = DragScreenPos;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01756960
	 * 		Name   -> Function DungeonCrawler.ContainerInventoryWidget.OnAddItem
	 * 		Flags  -> (Final, Native, Public, HasOutParms)
	 * Parameters:
	 * 		struct FItemData                                   InItemData                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	class UItemWidget* UContainerInventoryWidget::OnAddItem(const struct FItemData& InItemData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.ContainerInventoryWidget.OnAddItem");
		
		UContainerInventoryWidget_OnAddItem_Params params {};
		params.InItemData = InItemData;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01756890
	 * 		Name   -> Function DungeonCrawler.ContainerInventoryWidget.InitializeContainerInventoryWidget
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		class UInventoryComponent*                         InInventoryComponent                                       (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UAccountLink*                                InAccountLink                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UContainerInventoryWidget::InitializeContainerInventoryWidget(class UInventoryComponent* InInventoryComponent, class UAccountLink* InAccountLink)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.ContainerInventoryWidget.InitializeContainerInventoryWidget");
		
		UContainerInventoryWidget_InitializeContainerInventoryWidget_Params params {};
		params.InInventoryComponent = InInventoryComponent;
		params.InAccountLink = InAccountLink;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017567B0
	 * 		Name   -> Function DungeonCrawler.ContainerInventoryWidget.GetSlotIdByScreenPosition
	 * 		Flags  -> (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FVector2D                                   ScreenPos                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	int32_t UContainerInventoryWidget::GetSlotIdByScreenPosition(const struct FVector2D& ScreenPos)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.ContainerInventoryWidget.GetSlotIdByScreenPosition");
		
		UContainerInventoryWidget_GetSlotIdByScreenPosition_Params params {};
		params.ScreenPos = ScreenPos;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017565D0
	 * 		Name   -> Function DungeonCrawler.ContainerInventoryWidget.CanSetItemAt
	 * 		Flags  -> (Final, Native, Public, HasOutParms)
	 * Parameters:
	 * 		struct FItemData                                   ItemData                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		int32_t                                            SlotId                                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UContainerInventoryWidget::CanSetItemAt(const struct FItemData& ItemData, int32_t SlotId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.ContainerInventoryWidget.CanSetItemAt");
		
		UContainerInventoryWidget_CanSetItemAt_Params params {};
		params.ItemData = ItemData;
		params.SlotId = SlotId;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UContainerInventoryWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UContainerInventoryWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.ContainerInventoryWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.ContainerSlotWidget.OnSetNewItem
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		bool                                               bFullfilledAll                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UContainerSlotWidget::OnSetNewItem(bool bFullfilledAll)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.ContainerSlotWidget.OnSetNewItem");
		
		UContainerSlotWidget_OnSetNewItem_Params params {};
		params.bFullfilledAll = bFullfilledAll;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.ContainerSlotWidget.OnRemoveItem
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 */
	void UContainerSlotWidget::OnRemoveItem()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.ContainerSlotWidget.OnRemoveItem");
		
		UContainerSlotWidget_OnRemoveItem_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.ContainerSlotWidget.OnOverlapItemWidget
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		bool                                               bCanSetItem                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UContainerSlotWidget::OnOverlapItemWidget(bool bCanSetItem)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.ContainerSlotWidget.OnOverlapItemWidget");
		
		UContainerSlotWidget_OnOverlapItemWidget_Params params {};
		params.bCanSetItem = bCanSetItem;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.ContainerSlotWidget.OnLeaveItemWidget
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 */
	void UContainerSlotWidget::OnLeaveItemWidget()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.ContainerSlotWidget.OnLeaveItemWidget");
		
		UContainerSlotWidget_OnLeaveItemWidget_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UContainerSlotWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UContainerSlotWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.ContainerSlotWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017576F0
	 * 		Name   -> Function DungeonCrawler.ContextMenuHolderInterface.OnRightClicked
	 * 		Flags  -> (Native, Public, BlueprintCallable)
	 */
	void UContextMenuHolderInterface::OnRightClicked()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.ContextMenuHolderInterface.OnRightClicked");
		
		UContextMenuHolderInterface_OnRightClicked_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UContextMenuHolderInterface.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UContextMenuHolderInterface::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.ContextMenuHolderInterface");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01757CF0
	 * 		Name   -> Function DungeonCrawler.ContextMenuWidgetBase.SetContextMenuWidgetPosition
	 * 		Flags  -> (Final, Native, Protected, BlueprintCallable)
	 */
	void UContextMenuWidgetBase::SetContextMenuWidgetPosition()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.ContextMenuWidgetBase.SetContextMenuWidgetPosition");
		
		UContextMenuWidgetBase_SetContextMenuWidgetPosition_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017579E0
	 * 		Name   -> Function DungeonCrawler.ContextMenuWidgetBase.RequestCloseMenu
	 * 		Flags  -> (Final, Native, Protected, BlueprintCallable)
	 */
	void UContextMenuWidgetBase::RequestCloseMenu()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.ContextMenuWidgetBase.RequestCloseMenu");
		
		UContextMenuWidgetBase_RequestCloseMenu_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UContextMenuWidgetBase.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UContextMenuWidgetBase::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.ContextMenuWidgetBase");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UContextOptionListEntryWidgetData.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UContextOptionListEntryWidgetData::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.ContextOptionListEntryWidgetData");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017579A0
	 * 		Name   -> Function DungeonCrawler.ContextOptionListEntryWidgetBase.OnSelect
	 * 		Flags  -> (Final, Native, Private)
	 */
	void UContextOptionListEntryWidgetBase::OnSelect()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.ContextOptionListEntryWidgetBase.OnSelect");
		
		UContextOptionListEntryWidgetBase_OnSelect_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UContextOptionListEntryWidgetBase.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UContextOptionListEntryWidgetBase::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.ContextOptionListEntryWidgetBase");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017FE880
	 * 		Name   -> Function DungeonCrawler.ItemWidget.SetItemOwnerActor
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class AActor*                                      InItemOwnedActor                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UItemWidget::SetItemOwnerActor(class AActor* InItemOwnedActor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.ItemWidget.SetItemOwnerActor");
		
		UItemWidget_SetItemOwnerActor_Params params {};
		params.InItemOwnedActor = InItemOwnedActor;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017FE7A0
	 * 		Name   -> Function DungeonCrawler.ItemWidget.SetItemIcon
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		class UTexture2D*                                  ItemIconTexture                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FItemInventorySize                          ItemInventorySize                                          (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UItemWidget::SetItemIcon(class UTexture2D* ItemIconTexture, const struct FItemInventorySize& ItemInventorySize)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.ItemWidget.SetItemIcon");
		
		UItemWidget_SetItemIcon_Params params {};
		params.ItemIconTexture = ItemIconTexture;
		params.ItemInventorySize = ItemInventorySize;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017FE650
	 * 		Name   -> Function DungeonCrawler.ItemWidget.SetItemData
	 * 		Flags  -> (Native, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		struct FItemData                                   NewItemData                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UItemWidget::SetItemData(const struct FItemData& NewItemData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.ItemWidget.SetItemData");
		
		UItemWidget_SetItemData_Params params {};
		params.NewItemData = NewItemData;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.ItemWidget.OnSetItemRequirementsFulfilledStatus
	 * 		Flags  -> (Event, Public, HasOutParms, HasDefaults, BlueprintEvent)
	 * Parameters:
	 * 		bool                                               bFufilled                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FPrimaryAssetId                             PlayerCharacterId                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UDCAttributeSet*                             AttributeSet                                               (ConstParm, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		TArray<struct FPrimaryAssetId>                     PerkIdArray                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UItemWidget::OnSetItemRequirementsFulfilledStatus(bool bFufilled, const struct FPrimaryAssetId& PlayerCharacterId, class UDCAttributeSet* AttributeSet, TArray<struct FPrimaryAssetId> PerkIdArray)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.ItemWidget.OnSetItemRequirementsFulfilledStatus");
		
		UItemWidget_OnSetItemRequirementsFulfilledStatus_Params params {};
		params.bFufilled = bFufilled;
		params.PlayerCharacterId = PlayerCharacterId;
		params.AttributeSet = AttributeSet;
		params.PerkIdArray = PerkIdArray;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.ItemWidget.OnItemData
	 * 		Flags  -> (Event, Protected, HasOutParms, BlueprintEvent)
	 * Parameters:
	 * 		struct FItemData                                   NewItemData                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		struct FItemData                                   OldItemData                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UItemWidget::OnItemData(const struct FItemData& NewItemData, const struct FItemData& OldItemData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.ItemWidget.OnItemData");
		
		UItemWidget_OnItemData_Params params {};
		params.NewItemData = NewItemData;
		params.OldItemData = OldItemData;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017FE1F0
	 * 		Name   -> Function DungeonCrawler.ItemWidget.GetItemIconImage
	 * 		Flags  -> (Final, Native, Public, Const)
	 */
	class UImage* UItemWidget::GetItemIconImage()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.ItemWidget.GetItemIconImage");
		
		UItemWidget_GetItemIconImage_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UItemWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UItemWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.ItemWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017579C0
	 * 		Name   -> Function DungeonCrawler.ControllableItemWidget.QuickMoveItem
	 * 		Flags  -> (Final, Native, Protected)
	 */
	void UControllableItemWidget::QuickMoveItem()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.ControllableItemWidget.QuickMoveItem");
		
		UControllableItemWidget_QuickMoveItem_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01757710
	 * 		Name   -> Function DungeonCrawler.ControllableItemWidget.OnRightMouseButtonDown
	 * 		Flags  -> (Native, Protected, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		struct FGeometry                                   MyGeometry                                                 (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		struct FPointerEvent                               MouseEvent                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		bool                                               bInventoryDropButtonPressed                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bInventorySplitButtonPressed                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FEventReply UControllableItemWidget::OnRightMouseButtonDown(const struct FGeometry& MyGeometry, const struct FPointerEvent& MouseEvent, bool bInventoryDropButtonPressed, bool bInventorySplitButtonPressed)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.ControllableItemWidget.OnRightMouseButtonDown");
		
		UControllableItemWidget_OnRightMouseButtonDown_Params params {};
		params.MyGeometry = MyGeometry;
		params.MouseEvent = MouseEvent;
		params.bInventoryDropButtonPressed = bInventoryDropButtonPressed;
		params.bInventorySplitButtonPressed = bInventorySplitButtonPressed;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01756ED0
	 * 		Name   -> Function DungeonCrawler.ControllableItemWidget.OnLeftMouseButtonDown
	 * 		Flags  -> (Native, Protected, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		struct FGeometry                                   MyGeometry                                                 (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		struct FPointerEvent                               MouseEvent                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	struct FEventReply UControllableItemWidget::OnLeftMouseButtonDown(const struct FGeometry& MyGeometry, const struct FPointerEvent& MouseEvent)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.ControllableItemWidget.OnLeftMouseButtonDown");
		
		UControllableItemWidget_OnLeftMouseButtonDown_Params params {};
		params.MyGeometry = MyGeometry;
		params.MouseEvent = MouseEvent;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01756E60
	 * 		Name   -> Function DungeonCrawler.ControllableItemWidget.OnLeftMouseButtonDoubleClick
	 * 		Flags  -> (Native, Protected, BlueprintCallable)
	 */
	struct FEventReply UControllableItemWidget::OnLeftMouseButtonDoubleClick()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.ControllableItemWidget.OnLeftMouseButtonDoubleClick");
		
		UControllableItemWidget_OnLeftMouseButtonDoubleClick_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01756790
	 * 		Name   -> Function DungeonCrawler.ControllableItemWidget.DropOneItem
	 * 		Flags  -> (Final, Native, Protected)
	 */
	void UControllableItemWidget::DropOneItem()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.ControllableItemWidget.DropOneItem");
		
		UControllableItemWidget_DropOneItem_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01756770
	 * 		Name   -> Function DungeonCrawler.ControllableItemWidget.DropAllItem
	 * 		Flags  -> (Final, Native, Protected)
	 */
	void UControllableItemWidget::DropAllItem()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.ControllableItemWidget.DropAllItem");
		
		UControllableItemWidget_DropAllItem_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UControllableItemWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UControllableItemWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.ControllableItemWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDCCrashReport.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDCCrashReport::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCCrashReport");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017644F0
	 * 		Name   -> Function DungeonCrawler.DCActorBase.UnbindMsgAll
	 * 		Flags  -> (Native, Public)
	 * Parameters:
	 * 		class UObject*                                     InObject                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ADCActorBase::UnbindMsgAll(class UObject* InObject)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCActorBase.UnbindMsgAll");
		
		ADCActorBase_UnbindMsgAll_Params params {};
		params.InObject = InObject;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01763F40
	 * 		Name   -> Function DungeonCrawler.DCActorBase.UnbindMsg
	 * 		Flags  -> (Native, Public)
	 * Parameters:
	 * 		class UScriptStruct*                               InMsgType                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UObject*                                     InObject                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ADCActorBase::UnbindMsg(class UScriptStruct* InMsgType, class UObject* InObject)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCActorBase.UnbindMsg");
		
		ADCActorBase_UnbindMsg_Params params {};
		params.InMsgType = InMsgType;
		params.InObject = InObject;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01763DF0
	 * 		Name   -> Function DungeonCrawler.DCActorBase.TerminateBase
	 * 		Flags  -> (Native, Public)
	 */
	void ADCActorBase::TerminateBase()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCActorBase.TerminateBase");
		
		ADCActorBase_TerminateBase_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.DCActorBase.ReceivePreInitializeComponents
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 */
	void ADCActorBase::ReceivePreInitializeComponents()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCActorBase.ReceivePreInitializeComponents");
		
		ADCActorBase_ReceivePreInitializeComponents_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D3C640
	 * 		Name   -> Function DungeonCrawler.DCActorBase.BroadcastMsgBlueprint
	 * 		Flags  -> (Native, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		int32_t                                            InMsg                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ADCActorBase::BroadcastMsgBlueprint(int32_t InMsg)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCActorBase.BroadcastMsgBlueprint");
		
		ADCActorBase_BroadcastMsgBlueprint_Params params {};
		params.InMsg = InMsg;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ADCActorBase.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ADCActorBase::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCActorBase");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ADCAbilityActorBase.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ADCAbilityActorBase::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCAbilityActorBase");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01798CD0
	 * 		Name   -> Function DungeonCrawler.DCInteractableActorBase.InteractSucceed
	 * 		Flags  -> (Native, Event, Protected, BlueprintEvent)
	 * Parameters:
	 * 		class AActor*                                      Interacter                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FGameplayTag                                StateTag                                                   (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FGameplayTag                                TriggerTag                                                 (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FHitResult                                  HitResult                                                  (Parm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	void ADCInteractableActorBase::InteractSucceed(class AActor* Interacter, const struct FGameplayTag& StateTag, const struct FGameplayTag& TriggerTag, const struct FHitResult& HitResult)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCInteractableActorBase.InteractSucceed");
		
		ADCInteractableActorBase_InteractSucceed_Params params {};
		params.Interacter = Interacter;
		params.StateTag = StateTag;
		params.TriggerTag = TriggerTag;
		params.HitResult = HitResult;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.DCInteractableActorBase.InteractStarted
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 * Parameters:
	 * 		class AActor*                                      Interacter                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FGameplayTag                                EventTag                                                   (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ADCInteractableActorBase::InteractStarted(class AActor* Interacter, const struct FGameplayTag& EventTag)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCInteractableActorBase.InteractStarted");
		
		ADCInteractableActorBase_InteractStarted_Params params {};
		params.Interacter = Interacter;
		params.EventTag = EventTag;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.DCInteractableActorBase.InteractLost
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 * Parameters:
	 * 		class AActor*                                      Interacter                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ADCInteractableActorBase::InteractLost(class AActor* Interacter)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCInteractableActorBase.InteractLost");
		
		ADCInteractableActorBase_InteractLost_Params params {};
		params.Interacter = Interacter;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.DCInteractableActorBase.InteractFound
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 * Parameters:
	 * 		class AActor*                                      Interacter                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UPrimitiveComponent*                         InteractPart                                               (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ADCInteractableActorBase::InteractFound(class AActor* Interacter, class UPrimitiveComponent* InteractPart)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCInteractableActorBase.InteractFound");
		
		ADCInteractableActorBase_InteractFound_Params params {};
		params.Interacter = Interacter;
		params.InteractPart = InteractPart;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.DCInteractableActorBase.InteractFailed
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 * Parameters:
	 * 		class AActor*                                      Interacter                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FGameplayTag                                EventTag                                                   (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ADCInteractableActorBase::InteractFailed(class AActor* Interacter, const struct FGameplayTag& EventTag)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCInteractableActorBase.InteractFailed");
		
		ADCInteractableActorBase_InteractFailed_Params params {};
		params.Interacter = Interacter;
		params.EventTag = EventTag;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ADCInteractableActorBase.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ADCInteractableActorBase::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCInteractableActorBase");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ADCAbilityInteractableActorBase.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ADCAbilityInteractableActorBase::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCAbilityInteractableActorBase");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0175F980
	 * 		Name   -> Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.SetMovementStateGameplayTag
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class AActor*                                      InActor                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FGameplayTag                                InGameplayTag                                              (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UDCAbilitySystemBlueprintLibrary::STATIC_SetMovementStateGameplayTag(class AActor* InActor, const struct FGameplayTag& InGameplayTag)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.SetMovementStateGameplayTag");
		
		UDCAbilitySystemBlueprintLibrary_SetMovementStateGameplayTag_Params params {};
		params.InActor = InActor;
		params.InGameplayTag = InGameplayTag;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0175F8B0
	 * 		Name   -> Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.SetModeGameplayTag
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class AActor*                                      InActor                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FGameplayTag                                InGameplayTag                                              (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UDCAbilitySystemBlueprintLibrary::STATIC_SetModeGameplayTag(class AActor* InActor, const struct FGameplayTag& InGameplayTag)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.SetModeGameplayTag");
		
		UDCAbilitySystemBlueprintLibrary_SetModeGameplayTag_Params params {};
		params.InActor = InActor;
		params.InGameplayTag = InGameplayTag;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0175F7E0
	 * 		Name   -> Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.SetAnimationStateGameplayTag
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class AActor*                                      InActor                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FGameplayTag                                InGameplayTag                                              (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UDCAbilitySystemBlueprintLibrary::STATIC_SetAnimationStateGameplayTag(class AActor* InActor, const struct FGameplayTag& InGameplayTag)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.SetAnimationStateGameplayTag");
		
		UDCAbilitySystemBlueprintLibrary_SetAnimationStateGameplayTag_Params params {};
		params.InActor = InActor;
		params.InGameplayTag = InGameplayTag;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0175F680
	 * 		Name   -> Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.SendGameplayEventToActorOverride
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		class AActor*                                      Actor                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FGameplayTag                                EventTag                                                   (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		TArray<struct FDCGameplayEffectData>               InOverrideGameplayEffectDataArray                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UDCAbilitySystemBlueprintLibrary::STATIC_SendGameplayEventToActorOverride(class AActor* Actor, const struct FGameplayTag& EventTag, TArray<struct FDCGameplayEffectData> InOverrideGameplayEffectDataArray)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.SendGameplayEventToActorOverride");
		
		UDCAbilitySystemBlueprintLibrary_SendGameplayEventToActorOverride_Params params {};
		params.Actor = Actor;
		params.EventTag = EventTag;
		params.InOverrideGameplayEffectDataArray = InOverrideGameplayEffectDataArray;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0175F5C0
	 * 		Name   -> Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.RemoveLooseGameplayTagAll
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class AActor*                                      InActor                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FGameplayTag                                GameplayTag                                                (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UDCAbilitySystemBlueprintLibrary::STATIC_RemoveLooseGameplayTagAll(class AActor* InActor, const struct FGameplayTag& GameplayTag)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.RemoveLooseGameplayTagAll");
		
		UDCAbilitySystemBlueprintLibrary_RemoveLooseGameplayTagAll_Params params {};
		params.InActor = InActor;
		params.GameplayTag = GameplayTag;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0175F4F0
	 * 		Name   -> Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.RemoveGameplayTag
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class AActor*                                      InActor                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FGameplayTag                                InGameplayTag                                              (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UDCAbilitySystemBlueprintLibrary::STATIC_RemoveGameplayTag(class AActor* InActor, const struct FGameplayTag& InGameplayTag)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.RemoveGameplayTag");
		
		UDCAbilitySystemBlueprintLibrary_RemoveGameplayTag_Params params {};
		params.InActor = InActor;
		params.InGameplayTag = InGameplayTag;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0175F3A0
	 * 		Name   -> Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.RemoveGameplayCueLocal
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class AActor*                                      InActor                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FGameplayTag                                GameplayCueTag                                             (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UDCAbilitySystemBlueprintLibrary::STATIC_RemoveGameplayCueLocal(class AActor* InActor, const struct FGameplayTag& GameplayCueTag)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.RemoveGameplayCueLocal");
		
		UDCAbilitySystemBlueprintLibrary_RemoveGameplayCueLocal_Params params {};
		params.InActor = InActor;
		params.GameplayCueTag = GameplayCueTag;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0175F2E0
	 * 		Name   -> Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.RemoveGameplayCue
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class AActor*                                      InActor                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FGameplayTag                                GameplayCueTag                                             (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UDCAbilitySystemBlueprintLibrary::STATIC_RemoveGameplayCue(class AActor* InActor, const struct FGameplayTag& GameplayCueTag)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.RemoveGameplayCue");
		
		UDCAbilitySystemBlueprintLibrary_RemoveGameplayCue_Params params {};
		params.InActor = InActor;
		params.GameplayCueTag = GameplayCueTag;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0175EFE0
	 * 		Name   -> Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.ParseOptionGameplayTag
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class FString                                      InOptionStr                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FString                                      InOptionKey                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FGameplayTag UDCAbilitySystemBlueprintLibrary::STATIC_ParseOptionGameplayTag(const class FString& InOptionStr, const class FString& InOptionKey)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.ParseOptionGameplayTag");
		
		UDCAbilitySystemBlueprintLibrary_ParseOptionGameplayTag_Params params {};
		params.InOptionStr = InOptionStr;
		params.InOptionKey = InOptionKey;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0175EB20
	 * 		Name   -> Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.MatchesQuery
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class AActor*                                      InActor                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FGameplayTagQuery                           InTagQuery                                                 (Parm, NativeAccessSpecifierPublic)
	 */
	bool UDCAbilitySystemBlueprintLibrary::STATIC_MatchesQuery(class AActor* InActor, const struct FGameplayTagQuery& InTagQuery)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.MatchesQuery");
		
		UDCAbilitySystemBlueprintLibrary_MatchesQuery_Params params {};
		params.InActor = InActor;
		params.InTagQuery = InTagQuery;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0175EA50
	 * 		Name   -> Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.IsMatchingAbilityActivated
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class AActor*                                      InActor                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FGameplayTag                                InGameplayTag                                              (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UDCAbilitySystemBlueprintLibrary::STATIC_IsMatchingAbilityActivated(class AActor* InActor, const struct FGameplayTag& InGameplayTag)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.IsMatchingAbilityActivated");
		
		UDCAbilitySystemBlueprintLibrary_IsMatchingAbilityActivated_Params params {};
		params.InActor = InActor;
		params.InGameplayTag = InGameplayTag;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0175E8C0
	 * 		Name   -> Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.GiveAbilities
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		class UObject*                                     SourceObject                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      InActor                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		TArray<struct FDCGameplayAbilityData>              InGameplayAbilityDataArray                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	TArray<struct FGameplayAbilitySpecHandle> UDCAbilitySystemBlueprintLibrary::STATIC_GiveAbilities(class UObject* SourceObject, class AActor* InActor, TArray<struct FDCGameplayAbilityData> InGameplayAbilityDataArray)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.GiveAbilities");
		
		UDCAbilitySystemBlueprintLibrary_GiveAbilities_Params params {};
		params.SourceObject = SourceObject;
		params.InActor = InActor;
		params.InGameplayAbilityDataArray = InGameplayAbilityDataArray;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0175E770
	 * 		Name   -> Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.GetSocketLocationBySocketName
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		class FName                                        SocketName                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UObject*                                     Object                                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      AvatarActor                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     OutSocketLocation                                          (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UDCAbilitySystemBlueprintLibrary::STATIC_GetSocketLocationBySocketName(const class FName& SocketName, class UObject* Object, class AActor* AvatarActor, struct FVector* OutSocketLocation)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.GetSocketLocationBySocketName");
		
		UDCAbilitySystemBlueprintLibrary_GetSocketLocationBySocketName_Params params {};
		params.SocketName = SocketName;
		params.Object = Object;
		params.AvatarActor = AvatarActor;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutSocketLocation != nullptr)
			*OutSocketLocation = params.OutSocketLocation;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0175E610
	 * 		Name   -> Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.GetSetByCallerValueInContainerSpecArray
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FGameplayTag                                InEventTag                                                 (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FGameplayTag                                InSetByCallerDataTag                                       (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		TArray<struct FDCGameplayEffectContainerSpec>      InEffectHandle                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	float UDCAbilitySystemBlueprintLibrary::STATIC_GetSetByCallerValueInContainerSpecArray(const struct FGameplayTag& InEventTag, const struct FGameplayTag& InSetByCallerDataTag, TArray<struct FDCGameplayEffectContainerSpec> InEffectHandle)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.GetSetByCallerValueInContainerSpecArray");
		
		UDCAbilitySystemBlueprintLibrary_GetSetByCallerValueInContainerSpecArray_Params params {};
		params.InEventTag = InEventTag;
		params.InSetByCallerDataTag = InSetByCallerDataTag;
		params.InEffectHandle = InEffectHandle;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0175E490
	 * 		Name   -> Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.GetSetByCallerValueInContainer
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FGameplayTag                                InEventTag                                                 (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FGameplayTag                                InSetByCallerDataTag                                       (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		TArray<struct FDCGameplayEffectContainer>          InEffectContainer                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	float UDCAbilitySystemBlueprintLibrary::STATIC_GetSetByCallerValueInContainer(const struct FGameplayTag& InEventTag, const struct FGameplayTag& InSetByCallerDataTag, TArray<struct FDCGameplayEffectContainer> InEffectContainer)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.GetSetByCallerValueInContainer");
		
		UDCAbilitySystemBlueprintLibrary_GetSetByCallerValueInContainer_Params params {};
		params.InEventTag = InEventTag;
		params.InSetByCallerDataTag = InSetByCallerDataTag;
		params.InEffectContainer = InEffectContainer;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0175E3A0
	 * 		Name   -> Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.GetOwnedGameplayTags
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		class AActor*                                      InActor                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FGameplayTagContainer                       TagContainer                                               (Parm, OutParm, NativeAccessSpecifierPublic)
	 */
	void UDCAbilitySystemBlueprintLibrary::STATIC_GetOwnedGameplayTags(class AActor* InActor, struct FGameplayTagContainer* TagContainer)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.GetOwnedGameplayTags");
		
		UDCAbilitySystemBlueprintLibrary_GetOwnedGameplayTags_Params params {};
		params.InActor = InActor;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (TagContainer != nullptr)
			*TagContainer = params.TagContainer;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0175E2D0
	 * 		Name   -> Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.GetMatchingAbilityActivatedCount
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class AActor*                                      InActor                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FGameplayTag                                InGameplayTag                                              (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	int32_t UDCAbilitySystemBlueprintLibrary::STATIC_GetMatchingAbilityActivatedCount(class AActor* InActor, const struct FGameplayTag& InGameplayTag)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.GetMatchingAbilityActivatedCount");
		
		UDCAbilitySystemBlueprintLibrary_GetMatchingAbilityActivatedCount_Params params {};
		params.InActor = InActor;
		params.InGameplayTag = InGameplayTag;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0175E110
	 * 		Name   -> Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.GetItemDataFromDesignData
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		struct FDesignDataItem                             InDesignDataItem                                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		struct FItemData                                   OutItemData                                                (Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UDCAbilitySystemBlueprintLibrary::STATIC_GetItemDataFromDesignData(const struct FDesignDataItem& InDesignDataItem, struct FItemData* OutItemData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.GetItemDataFromDesignData");
		
		UDCAbilitySystemBlueprintLibrary_GetItemDataFromDesignData_Params params {};
		params.InDesignDataItem = InDesignDataItem;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutItemData != nullptr)
			*OutItemData = params.OutItemData;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0175E000
	 * 		Name   -> Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.GetGrantedTag
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		struct FGameplayEffectSpecHandle                   SpecHandle                                                 (Parm, NativeAccessSpecifierPublic)
	 */
	struct FGameplayTagContainer UDCAbilitySystemBlueprintLibrary::STATIC_GetGrantedTag(const struct FGameplayEffectSpecHandle& SpecHandle)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.GetGrantedTag");
		
		UDCAbilitySystemBlueprintLibrary_GetGrantedTag_Params params {};
		params.SpecHandle = SpecHandle;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0175DF30
	 * 		Name   -> Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.GetGameplayEffectSetByCallerValue
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		struct FGameplayTag                                InSetByCallerTag                                           (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            InSetByCallerValue                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	float UDCAbilitySystemBlueprintLibrary::STATIC_GetGameplayEffectSetByCallerValue(const struct FGameplayTag& InSetByCallerTag, int32_t InSetByCallerValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.GetGameplayEffectSetByCallerValue");
		
		UDCAbilitySystemBlueprintLibrary_GetGameplayEffectSetByCallerValue_Params params {};
		params.InSetByCallerTag = InSetByCallerTag;
		params.InSetByCallerValue = InSetByCallerValue;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0175DD30
	 * 		Name   -> Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.GetGameplayEffectDescDataItem
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		struct FDesignDataItem                             InDesignDataItem                                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		struct FDesignDataGameplayEffect                   InDesignDataGameplayEffect                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		struct FItemDataGameplayEffect                     InItemDataGameplayEffect                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		TArray<struct FGameplayEffectDescData>             OutGameplayEffectDescDataArray                             (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	 */
	void UDCAbilitySystemBlueprintLibrary::STATIC_GetGameplayEffectDescDataItem(const struct FDesignDataItem& InDesignDataItem, const struct FDesignDataGameplayEffect& InDesignDataGameplayEffect, const struct FItemDataGameplayEffect& InItemDataGameplayEffect, TArray<struct FGameplayEffectDescData>* OutGameplayEffectDescDataArray)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.GetGameplayEffectDescDataItem");
		
		UDCAbilitySystemBlueprintLibrary_GetGameplayEffectDescDataItem_Params params {};
		params.InDesignDataItem = InDesignDataItem;
		params.InDesignDataGameplayEffect = InDesignDataGameplayEffect;
		params.InItemDataGameplayEffect = InItemDataGameplayEffect;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutGameplayEffectDescDataArray != nullptr)
			*OutGameplayEffectDescDataArray = params.OutGameplayEffectDescDataArray;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0175DC20
	 * 		Name   -> Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.GetGameplayEffectDescData
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		struct FDesignDataGameplayEffect                   InDesignDataGameplayEffect                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		TArray<struct FGameplayEffectDescData>             OutGameplayEffectDescDataArray                             (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	 */
	void UDCAbilitySystemBlueprintLibrary::STATIC_GetGameplayEffectDescData(const struct FDesignDataGameplayEffect& InDesignDataGameplayEffect, TArray<struct FGameplayEffectDescData>* OutGameplayEffectDescDataArray)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.GetGameplayEffectDescData");
		
		UDCAbilitySystemBlueprintLibrary_GetGameplayEffectDescData_Params params {};
		params.InDesignDataGameplayEffect = InDesignDataGameplayEffect;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutGameplayEffectDescDataArray != nullptr)
			*OutGameplayEffectDescDataArray = params.OutGameplayEffectDescDataArray;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0175DAC0
	 * 		Name   -> Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.GetGameplayEffectData
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		struct FDesignDataGameplayEffect                   InDesignDataGameplayEffect                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		struct FDCGameplayEffectData                       OutGameplayEffectData                                      (Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UDCAbilitySystemBlueprintLibrary::STATIC_GetGameplayEffectData(const struct FDesignDataGameplayEffect& InDesignDataGameplayEffect, struct FDCGameplayEffectData* OutGameplayEffectData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.GetGameplayEffectData");
		
		UDCAbilitySystemBlueprintLibrary_GetGameplayEffectData_Params params {};
		params.InDesignDataGameplayEffect = InDesignDataGameplayEffect;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutGameplayEffectData != nullptr)
			*OutGameplayEffectData = params.OutGameplayEffectData;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0175D960
	 * 		Name   -> Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.GetEffectSpec
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		struct FGameplayEffectSpecHandle                   SpecHandle                                                 (Parm, NativeAccessSpecifierPublic)
	 * 		struct FGameplayEffectSpec                         OutEffectSpec                                              (Parm, OutParm, NativeAccessSpecifierPublic)
	 */
	void UDCAbilitySystemBlueprintLibrary::STATIC_GetEffectSpec(const struct FGameplayEffectSpecHandle& SpecHandle, struct FGameplayEffectSpec* OutEffectSpec)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.GetEffectSpec");
		
		UDCAbilitySystemBlueprintLibrary_GetEffectSpec_Params params {};
		params.SpecHandle = SpecHandle;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutEffectSpec != nullptr)
			*OutEffectSpec = params.OutEffectSpec;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0175D8D0
	 * 		Name   -> Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.GetCurrentMontageSectionName
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class AActor*                                      InActor                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class FName UDCAbilitySystemBlueprintLibrary::STATIC_GetCurrentMontageSectionName(class AActor* InActor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.GetCurrentMontageSectionName");
		
		UDCAbilitySystemBlueprintLibrary_GetCurrentMontageSectionName_Params params {};
		params.InActor = InActor;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0175D6B0
	 * 		Name   -> Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.GetAttributeDisplayName
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FGameplayAttribute                          Attribute                                                  (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class FText UDCAbilitySystemBlueprintLibrary::STATIC_GetAttributeDisplayName(class UObject* WorldContextObject, const struct FGameplayAttribute& Attribute)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.GetAttributeDisplayName");
		
		UDCAbilitySystemBlueprintLibrary_GetAttributeDisplayName_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.Attribute = Attribute;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0175D490
	 * 		Name   -> Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.GetActorAttributeValue
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class AActor*                                      InActor                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FGameplayAttribute                          InAttribute                                                (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	float UDCAbilitySystemBlueprintLibrary::STATIC_GetActorAttributeValue(class AActor* InActor, const struct FGameplayAttribute& InAttribute)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.GetActorAttributeValue");
		
		UDCAbilitySystemBlueprintLibrary_GetActorAttributeValue_Params params {};
		params.InActor = InActor;
		params.InAttribute = InAttribute;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0175D390
	 * 		Name   -> Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.FindSocketOwningMeshComponent
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class FName                                        SocketName                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UObject*                                     Object                                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      AvatarActor                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class USkeletalMeshComponent* UDCAbilitySystemBlueprintLibrary::STATIC_FindSocketOwningMeshComponent(const class FName& SocketName, class UObject* Object, class AActor* AvatarActor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.FindSocketOwningMeshComponent");
		
		UDCAbilitySystemBlueprintLibrary_FindSocketOwningMeshComponent_Params params {};
		params.SocketName = SocketName;
		params.Object = Object;
		params.AvatarActor = AvatarActor;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0175CFC0
	 * 		Name   -> Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.ExecuteGameplayCueLocal
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		class AActor*                                      InActor                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FGameplayTag                                GameplayCueTag                                             (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FGameplayCueParameters                      GameplayCueParameters                                      (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	void UDCAbilitySystemBlueprintLibrary::STATIC_ExecuteGameplayCueLocal(class AActor* InActor, const struct FGameplayTag& GameplayCueTag, const struct FGameplayCueParameters& GameplayCueParameters)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.ExecuteGameplayCueLocal");
		
		UDCAbilitySystemBlueprintLibrary_ExecuteGameplayCueLocal_Params params {};
		params.InActor = InActor;
		params.GameplayCueTag = GameplayCueTag;
		params.GameplayCueParameters = GameplayCueParameters;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0175CDC0
	 * 		Name   -> Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.ExecuteGameplayCue
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		class AActor*                                      InActor                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FGameplayTag                                GameplayCueTag                                             (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FGameplayCueParameters                      GameplayCueParameters                                      (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	void UDCAbilitySystemBlueprintLibrary::STATIC_ExecuteGameplayCue(class AActor* InActor, const struct FGameplayTag& GameplayCueTag, const struct FGameplayCueParameters& GameplayCueParameters)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.ExecuteGameplayCue");
		
		UDCAbilitySystemBlueprintLibrary_ExecuteGameplayCue_Params params {};
		params.InActor = InActor;
		params.GameplayCueTag = GameplayCueTag;
		params.GameplayCueParameters = GameplayCueParameters;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0175CC70
	 * 		Name   -> Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.EffectContextSetSoundDataPrimaryAssetId
	 * 		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FGameplayEffectContextHandle                EffectContext                                              (Parm, NativeAccessSpecifierPublic)
	 * 		struct FPrimaryAssetId                             PrimaryAssetId                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UDCAbilitySystemBlueprintLibrary::STATIC_EffectContextSetSoundDataPrimaryAssetId(const struct FGameplayEffectContextHandle& EffectContext, const struct FPrimaryAssetId& PrimaryAssetId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.EffectContextSetSoundDataPrimaryAssetId");
		
		UDCAbilitySystemBlueprintLibrary_EffectContextSetSoundDataPrimaryAssetId_Params params {};
		params.EffectContext = EffectContext;
		params.PrimaryAssetId = PrimaryAssetId;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0175CB60
	 * 		Name   -> Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.EffectContextGetSoundDataPrimaryAssetId
	 * 		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FGameplayEffectContextHandle                EffectContext                                              (Parm, NativeAccessSpecifierPublic)
	 */
	struct FPrimaryAssetId UDCAbilitySystemBlueprintLibrary::STATIC_EffectContextGetSoundDataPrimaryAssetId(const struct FGameplayEffectContextHandle& EffectContext)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.EffectContextGetSoundDataPrimaryAssetId");
		
		UDCAbilitySystemBlueprintLibrary_EffectContextGetSoundDataPrimaryAssetId_Params params {};
		params.EffectContext = EffectContext;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0175CA60
	 * 		Name   -> Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.EffectContextGetSoundData
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FGameplayEffectContextHandle                EffectContext                                              (Parm, NativeAccessSpecifierPublic)
	 */
	class USoundData* UDCAbilitySystemBlueprintLibrary::STATIC_EffectContextGetSoundData(const struct FGameplayEffectContextHandle& EffectContext)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.EffectContextGetSoundData");
		
		UDCAbilitySystemBlueprintLibrary_EffectContextGetSoundData_Params params {};
		params.EffectContext = EffectContext;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0175C8B0
	 * 		Name   -> Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.DCEffectContextSetSoundDataPrimaryAssetId
	 * 		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FDCGameplayEffectContext                    EffectContext                                              (Parm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 * 		struct FPrimaryAssetId                             PrimaryAssetId                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UDCAbilitySystemBlueprintLibrary::STATIC_DCEffectContextSetSoundDataPrimaryAssetId(const struct FDCGameplayEffectContext& EffectContext, const struct FPrimaryAssetId& PrimaryAssetId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.DCEffectContextSetSoundDataPrimaryAssetId");
		
		UDCAbilitySystemBlueprintLibrary_DCEffectContextSetSoundDataPrimaryAssetId_Params params {};
		params.EffectContext = EffectContext;
		params.PrimaryAssetId = PrimaryAssetId;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0175C6E0
	 * 		Name   -> Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.DCEffectContextSetOrigin
	 * 		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FDCGameplayEffectContext                    EffectContext                                              (Parm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     Origin                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UDCAbilitySystemBlueprintLibrary::STATIC_DCEffectContextSetOrigin(const struct FDCGameplayEffectContext& EffectContext, const struct FVector& Origin)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.DCEffectContextSetOrigin");
		
		UDCAbilitySystemBlueprintLibrary_DCEffectContextSetOrigin_Params params {};
		params.EffectContext = EffectContext;
		params.Origin = Origin;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0175C590
	 * 		Name   -> Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.DCEffectContextHasHitResult
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FDCGameplayEffectContext                    EffectContext                                              (Parm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	bool UDCAbilitySystemBlueprintLibrary::STATIC_DCEffectContextHasHitResult(const struct FDCGameplayEffectContext& EffectContext)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.DCEffectContextHasHitResult");
		
		UDCAbilitySystemBlueprintLibrary_DCEffectContextHasHitResult_Params params {};
		params.EffectContext = EffectContext;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0175C440
	 * 		Name   -> Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.DCEffectContextGetSourceObject
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FDCGameplayEffectContext                    EffectContext                                              (Parm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	class UObject* UDCAbilitySystemBlueprintLibrary::STATIC_DCEffectContextGetSourceObject(const struct FDCGameplayEffectContext& EffectContext)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.DCEffectContextGetSourceObject");
		
		UDCAbilitySystemBlueprintLibrary_DCEffectContextGetSourceObject_Params params {};
		params.EffectContext = EffectContext;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0175C2D0
	 * 		Name   -> Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.DCEffectContextGetSoundDataPrimaryAssetId
	 * 		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FDCGameplayEffectContext                    EffectContext                                              (Parm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	struct FPrimaryAssetId UDCAbilitySystemBlueprintLibrary::STATIC_DCEffectContextGetSoundDataPrimaryAssetId(const struct FDCGameplayEffectContext& EffectContext)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.DCEffectContextGetSoundDataPrimaryAssetId");
		
		UDCAbilitySystemBlueprintLibrary_DCEffectContextGetSoundDataPrimaryAssetId_Params params {};
		params.EffectContext = EffectContext;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0175C010
	 * 		Name   -> Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.DCEffectContextGetOriginalInstigatorActor
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FDCGameplayEffectContext                    EffectContext                                              (Parm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	class AActor* UDCAbilitySystemBlueprintLibrary::STATIC_DCEffectContextGetOriginalInstigatorActor(const struct FDCGameplayEffectContext& EffectContext)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.DCEffectContextGetOriginalInstigatorActor");
		
		UDCAbilitySystemBlueprintLibrary_DCEffectContextGetOriginalInstigatorActor_Params params {};
		params.EffectContext = EffectContext;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0175C160
	 * 		Name   -> Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.DCEffectContextGetOrigin
	 * 		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FDCGameplayEffectContext                    EffectContext                                              (Parm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	struct FVector UDCAbilitySystemBlueprintLibrary::STATIC_DCEffectContextGetOrigin(const struct FDCGameplayEffectContext& EffectContext)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.DCEffectContextGetOrigin");
		
		UDCAbilitySystemBlueprintLibrary_DCEffectContextGetOrigin_Params params {};
		params.EffectContext = EffectContext;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0175C010
	 * 		Name   -> Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.DCEffectContextGetInstigatorActor
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FDCGameplayEffectContext                    EffectContext                                              (Parm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	class AActor* UDCAbilitySystemBlueprintLibrary::STATIC_DCEffectContextGetInstigatorActor(const struct FDCGameplayEffectContext& EffectContext)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.DCEffectContextGetInstigatorActor");
		
		UDCAbilitySystemBlueprintLibrary_DCEffectContextGetInstigatorActor_Params params {};
		params.EffectContext = EffectContext;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0175BE30
	 * 		Name   -> Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.DCEffectContextGetHitResult
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FDCGameplayEffectContext                    EffectContext                                              (Parm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	struct FHitResult UDCAbilitySystemBlueprintLibrary::STATIC_DCEffectContextGetHitResult(const struct FDCGameplayEffectContext& EffectContext)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.DCEffectContextGetHitResult");
		
		UDCAbilitySystemBlueprintLibrary_DCEffectContextGetHitResult_Params params {};
		params.EffectContext = EffectContext;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0175BCE0
	 * 		Name   -> Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.DCEffectContextGetEffectCauser
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FDCGameplayEffectContext                    EffectContext                                              (Parm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	class AActor* UDCAbilitySystemBlueprintLibrary::STATIC_DCEffectContextGetEffectCauser(const struct FDCGameplayEffectContext& EffectContext)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.DCEffectContextGetEffectCauser");
		
		UDCAbilitySystemBlueprintLibrary_DCEffectContextGetEffectCauser_Params params {};
		params.EffectContext = EffectContext;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0175B970
	 * 		Name   -> Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.DCEffectContextAddHitResult
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		struct FDCGameplayEffectContext                    EffectContext                                              (Parm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 * 		struct FHitResult                                  HitResult                                                  (Parm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 * 		bool                                               bReset                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UDCAbilitySystemBlueprintLibrary::STATIC_DCEffectContextAddHitResult(const struct FDCGameplayEffectContext& EffectContext, const struct FHitResult& HitResult, bool bReset)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.DCEffectContextAddHitResult");
		
		UDCAbilitySystemBlueprintLibrary_DCEffectContextAddHitResult_Params params {};
		params.EffectContext = EffectContext;
		params.HitResult = HitResult;
		params.bReset = bReset;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0175B8F0
	 * 		Name   -> Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.ClearAllAbilities
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class AActor*                                      InActor                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UDCAbilitySystemBlueprintLibrary::STATIC_ClearAllAbilities(class AActor* InActor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.ClearAllAbilities");
		
		UDCAbilitySystemBlueprintLibrary_ClearAllAbilities_Params params {};
		params.InActor = InActor;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0175B870
	 * 		Name   -> Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.CancelAllAbilities
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class AActor*                                      InActor                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UDCAbilitySystemBlueprintLibrary::STATIC_CancelAllAbilities(class AActor* InActor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.CancelAllAbilities");
		
		UDCAbilitySystemBlueprintLibrary_CancelAllAbilities_Params params {};
		params.InActor = InActor;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0175B5B0
	 * 		Name   -> Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.ApplyPremadeSpecArray
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		class AActor*                                      InActor                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FGameplayTag                                ContainerTag                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FGameplayEventData                          EventData                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	TArray<struct FActiveGameplayEffectHandle> UDCAbilitySystemBlueprintLibrary::STATIC_ApplyPremadeSpecArray(class AActor* InActor, const struct FGameplayTag& ContainerTag, const struct FGameplayEventData& EventData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.ApplyPremadeSpecArray");
		
		UDCAbilitySystemBlueprintLibrary_ApplyPremadeSpecArray_Params params {};
		params.InActor = InActor;
		params.ContainerTag = ContainerTag;
		params.EventData = EventData;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0175B400
	 * 		Name   -> Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.ApplyGameplayEffects
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		class AActor*                                      InActor                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		TArray<struct FDCGameplayEffectData>               InGameplayEffectDataArray                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      InSourceActor                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	TArray<struct FActiveGameplayEffectHandle> UDCAbilitySystemBlueprintLibrary::STATIC_ApplyGameplayEffects(class AActor* InActor, TArray<struct FDCGameplayEffectData> InGameplayEffectDataArray, class AActor* InSourceActor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.ApplyGameplayEffects");
		
		UDCAbilitySystemBlueprintLibrary_ApplyGameplayEffects_Params params {};
		params.InActor = InActor;
		params.InGameplayEffectDataArray = InGameplayEffectDataArray;
		params.InSourceActor = InSourceActor;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0175B290
	 * 		Name   -> Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.ApplyGameplayEffectByIds
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		class AActor*                                      InActor                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		TArray<struct FPrimaryAssetId>                     InGameplayEffectIdArray                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      InSourceActor                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	TArray<struct FActiveGameplayEffectHandle> UDCAbilitySystemBlueprintLibrary::STATIC_ApplyGameplayEffectByIds(class AActor* InActor, TArray<struct FPrimaryAssetId> InGameplayEffectIdArray, class AActor* InSourceActor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.ApplyGameplayEffectByIds");
		
		UDCAbilitySystemBlueprintLibrary_ApplyGameplayEffectByIds_Params params {};
		params.InActor = InActor;
		params.InGameplayEffectIdArray = InGameplayEffectIdArray;
		params.InSourceActor = InSourceActor;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0175B130
	 * 		Name   -> Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.ApplyGameplayEffect
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		class AActor*                                      InActor                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FDesignDataGameplayEffect                   InDesignDataGameplayEffect                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      InSourceActor                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FActiveGameplayEffectHandle UDCAbilitySystemBlueprintLibrary::STATIC_ApplyGameplayEffect(class AActor* InActor, const struct FDesignDataGameplayEffect& InDesignDataGameplayEffect, class AActor* InSourceActor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.ApplyGameplayEffect");
		
		UDCAbilitySystemBlueprintLibrary_ApplyGameplayEffect_Params params {};
		params.InActor = InActor;
		params.InDesignDataGameplayEffect = InDesignDataGameplayEffect;
		params.InSourceActor = InSourceActor;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0175AF40
	 * 		Name   -> Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.ApplyEffectContainerSpec
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		struct FDCGameplayEffectContainerSpec              ContainerSpec                                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	TArray<struct FActiveGameplayEffectHandle> UDCAbilitySystemBlueprintLibrary::STATIC_ApplyEffectContainerSpec(const struct FDCGameplayEffectContainerSpec& ContainerSpec)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.ApplyEffectContainerSpec");
		
		UDCAbilitySystemBlueprintLibrary_ApplyEffectContainerSpec_Params params {};
		params.ContainerSpec = ContainerSpec;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0175AD80
	 * 		Name   -> Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.AimSphereWithActorViewPoint
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		class AActor*                                      InActor                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Radius                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		TArray<struct FHitResult>                          OutHitResults                                              (Parm, OutParm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 * 		ECollisionChannel                                  TraceChannel                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              MaxRange                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UDCAbilitySystemBlueprintLibrary::STATIC_AimSphereWithActorViewPoint(class AActor* InActor, float Radius, TArray<struct FHitResult>* OutHitResults, ECollisionChannel TraceChannel, float MaxRange)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.AimSphereWithActorViewPoint");
		
		UDCAbilitySystemBlueprintLibrary_AimSphereWithActorViewPoint_Params params {};
		params.InActor = InActor;
		params.Radius = Radius;
		params.TraceChannel = TraceChannel;
		params.MaxRange = MaxRange;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutHitResults != nullptr)
			*OutHitResults = params.OutHitResults;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0175AC00
	 * 		Name   -> Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.AimLineWithActorViewPointToPoint
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		class AActor*                                      InActor                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     TraceEnd                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		TArray<struct FHitResult>                          OutHitResults                                              (Parm, OutParm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 * 		ECollisionChannel                                  TraceChannel                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UDCAbilitySystemBlueprintLibrary::STATIC_AimLineWithActorViewPointToPoint(class AActor* InActor, const struct FVector& TraceEnd, TArray<struct FHitResult>* OutHitResults, ECollisionChannel TraceChannel)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.AimLineWithActorViewPointToPoint");
		
		UDCAbilitySystemBlueprintLibrary_AimLineWithActorViewPointToPoint_Params params {};
		params.InActor = InActor;
		params.TraceEnd = TraceEnd;
		params.TraceChannel = TraceChannel;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutHitResults != nullptr)
			*OutHitResults = params.OutHitResults;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0175AA80
	 * 		Name   -> Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.AimLineWithActorViewPoint
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		class AActor*                                      InActor                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		TArray<struct FHitResult>                          OutHitResults                                              (Parm, OutParm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 * 		ECollisionChannel                                  TraceChannel                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              MaxRange                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UDCAbilitySystemBlueprintLibrary::STATIC_AimLineWithActorViewPoint(class AActor* InActor, TArray<struct FHitResult>* OutHitResults, ECollisionChannel TraceChannel, float MaxRange)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.AimLineWithActorViewPoint");
		
		UDCAbilitySystemBlueprintLibrary_AimLineWithActorViewPoint_Params params {};
		params.InActor = InActor;
		params.TraceChannel = TraceChannel;
		params.MaxRange = MaxRange;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutHitResults != nullptr)
			*OutHitResults = params.OutHitResults;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0175A9C0
	 * 		Name   -> Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.AddLooseGameplayTag
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class AActor*                                      InActor                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FGameplayTag                                GameplayTag                                                (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UDCAbilitySystemBlueprintLibrary::STATIC_AddLooseGameplayTag(class AActor* InActor, const struct FGameplayTag& GameplayTag)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.AddLooseGameplayTag");
		
		UDCAbilitySystemBlueprintLibrary_AddLooseGameplayTag_Params params {};
		params.InActor = InActor;
		params.GameplayTag = GameplayTag;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0175A8F0
	 * 		Name   -> Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.AddGameplayTag
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class AActor*                                      InActor                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FGameplayTag                                InGameplayTag                                              (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UDCAbilitySystemBlueprintLibrary::STATIC_AddGameplayTag(class AActor* InActor, const struct FGameplayTag& InGameplayTag)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.AddGameplayTag");
		
		UDCAbilitySystemBlueprintLibrary_AddGameplayTag_Params params {};
		params.InActor = InActor;
		params.InGameplayTag = InGameplayTag;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0175A520
	 * 		Name   -> Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.AddGameplayCueLocal
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		class AActor*                                      InActor                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FGameplayTag                                GameplayCueTag                                             (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FGameplayCueParameters                      GameplayCueParameters                                      (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	void UDCAbilitySystemBlueprintLibrary::STATIC_AddGameplayCueLocal(class AActor* InActor, const struct FGameplayTag& GameplayCueTag, const struct FGameplayCueParameters& GameplayCueParameters)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.AddGameplayCueLocal");
		
		UDCAbilitySystemBlueprintLibrary_AddGameplayCueLocal_Params params {};
		params.InActor = InActor;
		params.GameplayCueTag = GameplayCueTag;
		params.GameplayCueParameters = GameplayCueParameters;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0175A320
	 * 		Name   -> Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.AddGameplayCue
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		class AActor*                                      InActor                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FGameplayTag                                GameplayCueTag                                             (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FGameplayCueParameters                      GameplayCueParameters                                      (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	void UDCAbilitySystemBlueprintLibrary::STATIC_AddGameplayCue(class AActor* InActor, const struct FGameplayTag& GameplayCueTag, const struct FGameplayCueParameters& GameplayCueParameters)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAbilitySystemBlueprintLibrary.AddGameplayCue");
		
		UDCAbilitySystemBlueprintLibrary_AddGameplayCue_Params params {};
		params.InActor = InActor;
		params.GameplayCueTag = GameplayCueTag;
		params.GameplayCueParameters = GameplayCueParameters;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDCAbilitySystemBlueprintLibrary.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDCAbilitySystemBlueprintLibrary::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCAbilitySystemBlueprintLibrary");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0175FB50
	 * 		Name   -> Function DungeonCrawler.DCAbilitySystemComponent.UnbindMsgAll
	 * 		Flags  -> (Native, Public)
	 * Parameters:
	 * 		class UObject*                                     InObject                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UDCAbilitySystemComponent::UnbindMsgAll(class UObject* InObject)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAbilitySystemComponent.UnbindMsgAll");
		
		UDCAbilitySystemComponent_UnbindMsgAll_Params params {};
		params.InObject = InObject;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0175FA80
	 * 		Name   -> Function DungeonCrawler.DCAbilitySystemComponent.UnbindMsg
	 * 		Flags  -> (Native, Public)
	 * Parameters:
	 * 		class UScriptStruct*                               InMsgType                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UObject*                                     InObject                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UDCAbilitySystemComponent::UnbindMsg(class UScriptStruct* InMsgType, class UObject* InObject)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAbilitySystemComponent.UnbindMsg");
		
		UDCAbilitySystemComponent_UnbindMsg_Params params {};
		params.InMsgType = InMsgType;
		params.InObject = InObject;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0175FA50
	 * 		Name   -> Function DungeonCrawler.DCAbilitySystemComponent.TerminateBase
	 * 		Flags  -> (Native, Public)
	 */
	void UDCAbilitySystemComponent::TerminateBase()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAbilitySystemComponent.TerminateBase");
		
		UDCAbilitySystemComponent_TerminateBase_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0175F460
	 * 		Name   -> Function DungeonCrawler.DCAbilitySystemComponent.RemoveGameplayCueLocal
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		struct FGameplayTag                                GameplayCueTag                                             (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UDCAbilitySystemComponent::RemoveGameplayCueLocal(const struct FGameplayTag& GameplayCueTag)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAbilitySystemComponent.RemoveGameplayCueLocal");
		
		UDCAbilitySystemComponent_RemoveGameplayCueLocal_Params params {};
		params.GameplayCueTag = GameplayCueTag;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0175F0E0
	 * 		Name   -> Function DungeonCrawler.DCAbilitySystemComponent.PlayMontageOnSourceObject
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UGameplayAbility*                            InAnimatingAbility                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FGameplayAbilityActivationInfo              ActivationInfo                                             (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 * 		class UAnimMontage*                                NewAnimMontage                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              InPlayRate                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FName                                        StartSectionName                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              StartTimeSeconds                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UDCAbilitySystemComponent::PlayMontageOnSourceObject(class UGameplayAbility* InAnimatingAbility, const struct FGameplayAbilityActivationInfo& ActivationInfo, class UAnimMontage* NewAnimMontage, float InPlayRate, const class FName& StartSectionName, float StartTimeSeconds)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAbilitySystemComponent.PlayMontageOnSourceObject");
		
		UDCAbilitySystemComponent_PlayMontageOnSourceObject_Params params {};
		params.InAnimatingAbility = InAnimatingAbility;
		params.ActivationInfo = ActivationInfo;
		params.NewAnimMontage = NewAnimMontage;
		params.InPlayRate = InPlayRate;
		params.StartSectionName = StartSectionName;
		params.StartTimeSeconds = StartTimeSeconds;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0175EF30
	 * 		Name   -> Function DungeonCrawler.DCAbilitySystemComponent.OnRep_ImpactEnduranceExhaustedData
	 * 		Flags  -> (Final, Native, Private, HasOutParms)
	 * Parameters:
	 * 		struct FImpactEnduranceExhaustedData               InOldImpactEnduranceExhaustedData                          (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	void UDCAbilitySystemComponent::OnRep_ImpactEnduranceExhaustedData(const struct FImpactEnduranceExhaustedData& InOldImpactEnduranceExhaustedData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAbilitySystemComponent.OnRep_ImpactEnduranceExhaustedData");
		
		UDCAbilitySystemComponent_OnRep_ImpactEnduranceExhaustedData_Params params {};
		params.InOldImpactEnduranceExhaustedData = InOldImpactEnduranceExhaustedData;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0175EE80
	 * 		Name   -> Function DungeonCrawler.DCAbilitySystemComponent.OnRep_ActorDieData
	 * 		Flags  -> (Final, Native, Private, HasOutParms)
	 * Parameters:
	 * 		struct FActorDieData                               InOldActorDieData                                          (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	void UDCAbilitySystemComponent::OnRep_ActorDieData(const struct FActorDieData& InOldActorDieData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAbilitySystemComponent.OnRep_ActorDieData");
		
		UDCAbilitySystemComponent_OnRep_ActorDieData_Params params {};
		params.InOldActorDieData = InOldActorDieData;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0175EDB0
	 * 		Name   -> Function DungeonCrawler.DCAbilitySystemComponent.OnRep_AbilityHandleDataArray
	 * 		Flags  -> (Final, Native, Private, HasOutParms)
	 * Parameters:
	 * 		TArray<struct FDCGameplayAbilityHandleData>        InOldAbilityHandleDataArray                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UDCAbilitySystemComponent::OnRep_AbilityHandleDataArray(TArray<struct FDCGameplayAbilityHandleData> InOldAbilityHandleDataArray)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAbilitySystemComponent.OnRep_AbilityHandleDataArray");
		
		UDCAbilitySystemComponent_OnRep_AbilityHandleDataArray_Params params {};
		params.InOldAbilityHandleDataArray = InOldAbilityHandleDataArray;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0175ED00
	 * 		Name   -> Function DungeonCrawler.DCAbilitySystemComponent.OnImpactEnduranceExhaustedData
	 * 		Flags  -> (Final, Net, NetReliable, Native, Event, NetMulticast, Private)
	 * Parameters:
	 * 		struct FImpactEnduranceExhaustedData               InImpactEnduranceExhaustedData                             (ConstParm, Parm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	void UDCAbilitySystemComponent::OnImpactEnduranceExhaustedData(const struct FImpactEnduranceExhaustedData& InImpactEnduranceExhaustedData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAbilitySystemComponent.OnImpactEnduranceExhaustedData");
		
		UDCAbilitySystemComponent_OnImpactEnduranceExhaustedData_Params params {};
		params.InImpactEnduranceExhaustedData = InImpactEnduranceExhaustedData;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0175EC50
	 * 		Name   -> Function DungeonCrawler.DCAbilitySystemComponent.OnActorDieData
	 * 		Flags  -> (Final, Net, NetReliable, Native, Event, NetMulticast, Private)
	 * Parameters:
	 * 		struct FActorDieData                               InActorDieData                                             (ConstParm, Parm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	void UDCAbilitySystemComponent::OnActorDieData(const struct FActorDieData& InActorDieData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAbilitySystemComponent.OnActorDieData");
		
		UDCAbilitySystemComponent_OnActorDieData_Params params {};
		params.InActorDieData = InActorDieData;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0175D830
	 * 		Name   -> Function DungeonCrawler.DCAbilitySystemComponent.GetContainerSpecArray
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	TArray<struct FDCGameplayEffectContainerSpec> UDCAbilitySystemComponent::GetContainerSpecArray()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAbilitySystemComponent.GetContainerSpecArray");
		
		UDCAbilitySystemComponent_GetContainerSpecArray_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0175D1C0
	 * 		Name   -> Function DungeonCrawler.DCAbilitySystemComponent.ExecuteGameplayCueLocal
	 * 		Flags  -> (Final, Native, Public, HasOutParms)
	 * Parameters:
	 * 		struct FGameplayTag                                GameplayCueTag                                             (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FGameplayCueParameters                      GameplayCueParameters                                      (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	void UDCAbilitySystemComponent::ExecuteGameplayCueLocal(const struct FGameplayTag& GameplayCueTag, const struct FGameplayCueParameters& GameplayCueParameters)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAbilitySystemComponent.ExecuteGameplayCueLocal");
		
		UDCAbilitySystemComponent_ExecuteGameplayCueLocal_Params params {};
		params.GameplayCueTag = GameplayCueTag;
		params.GameplayCueParameters = GameplayCueParameters;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D3C640
	 * 		Name   -> Function DungeonCrawler.DCAbilitySystemComponent.BroadcastMsgBlueprint
	 * 		Flags  -> (Native, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		int32_t                                            InMsg                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UDCAbilitySystemComponent::BroadcastMsgBlueprint(int32_t InMsg)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAbilitySystemComponent.BroadcastMsgBlueprint");
		
		UDCAbilitySystemComponent_BroadcastMsgBlueprint_Params params {};
		params.InMsg = InMsg;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0175A720
	 * 		Name   -> Function DungeonCrawler.DCAbilitySystemComponent.AddGameplayCueLocal
	 * 		Flags  -> (Final, Native, Public, HasOutParms)
	 * Parameters:
	 * 		struct FGameplayTag                                GameplayCueTag                                             (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FGameplayCueParameters                      GameplayCueParameters                                      (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	void UDCAbilitySystemComponent::AddGameplayCueLocal(const struct FGameplayTag& GameplayCueTag, const struct FGameplayCueParameters& GameplayCueParameters)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAbilitySystemComponent.AddGameplayCueLocal");
		
		UDCAbilitySystemComponent_AddGameplayCueLocal_Params params {};
		params.GameplayCueTag = GameplayCueTag;
		params.GameplayCueParameters = GameplayCueParameters;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDCAbilitySystemComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDCAbilitySystemComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCAbilitySystemComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDCAbilitySystemGlobals.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDCAbilitySystemGlobals::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCAbilitySystemGlobals");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDCActorReferenceCounterInterface.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDCActorReferenceCounterInterface::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCActorReferenceCounterInterface");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01764730
	 * 		Name   -> Function DungeonCrawler.DCActorStatusComponent.UnbindMsgAll
	 * 		Flags  -> (Native, Public)
	 * Parameters:
	 * 		class UObject*                                     InObject                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UDCActorStatusComponent::UnbindMsgAll(class UObject* InObject)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCActorStatusComponent.UnbindMsgAll");
		
		UDCActorStatusComponent_UnbindMsgAll_Params params {};
		params.InObject = InObject;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01764280
	 * 		Name   -> Function DungeonCrawler.DCActorStatusComponent.UnbindMsg
	 * 		Flags  -> (Native, Public)
	 * Parameters:
	 * 		class UScriptStruct*                               InMsgType                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UObject*                                     InObject                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UDCActorStatusComponent::UnbindMsg(class UScriptStruct* InMsgType, class UObject* InObject)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCActorStatusComponent.UnbindMsg");
		
		UDCActorStatusComponent_UnbindMsg_Params params {};
		params.InMsgType = InMsgType;
		params.InObject = InObject;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01763EB0
	 * 		Name   -> Function DungeonCrawler.DCActorStatusComponent.TerminateBase
	 * 		Flags  -> (Native, Public)
	 */
	void UDCActorStatusComponent::TerminateBase()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCActorStatusComponent.TerminateBase");
		
		UDCActorStatusComponent_TerminateBase_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01763AE0
	 * 		Name   -> Function DungeonCrawler.DCActorStatusComponent.OnRep_ActorStatusDatas
	 * 		Flags  -> (Final, Native, Private, HasOutParms)
	 * Parameters:
	 * 		TArray<struct FActorStatusData>                    OldActorStatusDatas                                        (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UDCActorStatusComponent::OnRep_ActorStatusDatas(TArray<struct FActorStatusData> OldActorStatusDatas)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCActorStatusComponent.OnRep_ActorStatusDatas");
		
		UDCActorStatusComponent_OnRep_ActorStatusDatas_Params params {};
		params.OldActorStatusDatas = OldActorStatusDatas;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01763580
	 * 		Name   -> Function DungeonCrawler.DCActorStatusComponent.GameplayEffectStackChanged
	 * 		Flags  -> (Final, Native, Private)
	 * Parameters:
	 * 		struct FGameplayTag                                EffectGameplayTag                                          (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FActiveGameplayEffectHandle                 EffectHandle                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            NewStackCount                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            PreviousStackCount                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UDCActorStatusComponent::GameplayEffectStackChanged(const struct FGameplayTag& EffectGameplayTag, const struct FActiveGameplayEffectHandle& EffectHandle, int32_t NewStackCount, int32_t PreviousStackCount)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCActorStatusComponent.GameplayEffectStackChanged");
		
		UDCActorStatusComponent_GameplayEffectStackChanged_Params params {};
		params.EffectGameplayTag = EffectGameplayTag;
		params.EffectHandle = EffectHandle;
		params.NewStackCount = NewStackCount;
		params.PreviousStackCount = PreviousStackCount;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01763460
	 * 		Name   -> Function DungeonCrawler.DCActorStatusComponent.GameplayEffectInhibitChanged
	 * 		Flags  -> (Final, Native, Private)
	 * Parameters:
	 * 		struct FGameplayTag                                EffectGameplayTag                                          (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FActiveGameplayEffectHandle                 EffectHandle                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bIsInhibited                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UDCActorStatusComponent::GameplayEffectInhibitChanged(const struct FGameplayTag& EffectGameplayTag, const struct FActiveGameplayEffectHandle& EffectHandle, bool bIsInhibited)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCActorStatusComponent.GameplayEffectInhibitChanged");
		
		UDCActorStatusComponent_GameplayEffectInhibitChanged_Params params {};
		params.EffectGameplayTag = EffectGameplayTag;
		params.EffectHandle = EffectHandle;
		params.bIsInhibited = bIsInhibited;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D3C640
	 * 		Name   -> Function DungeonCrawler.DCActorStatusComponent.BroadcastMsgBlueprint
	 * 		Flags  -> (Native, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		int32_t                                            InMsg                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UDCActorStatusComponent::BroadcastMsgBlueprint(int32_t InMsg)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCActorStatusComponent.BroadcastMsgBlueprint");
		
		UDCActorStatusComponent_BroadcastMsgBlueprint_Params params {};
		params.InMsg = InMsg;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDCActorStatusComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDCActorStatusComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCActorStatusComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDCAIPerceptionComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDCAIPerceptionComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCAIPerceptionComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ADCAkAcousticPortal.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ADCAkAcousticPortal::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCAkAcousticPortal");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017647C0
	 * 		Name   -> Function DungeonCrawler.DCAkComponent.UnbindMsgAll
	 * 		Flags  -> (Native, Public)
	 * Parameters:
	 * 		class UObject*                                     InObject                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UDCAkComponent::UnbindMsgAll(class UObject* InObject)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAkComponent.UnbindMsgAll");
		
		UDCAkComponent_UnbindMsgAll_Params params {};
		params.InObject = InObject;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01764350
	 * 		Name   -> Function DungeonCrawler.DCAkComponent.UnbindMsg
	 * 		Flags  -> (Native, Public)
	 * Parameters:
	 * 		class UScriptStruct*                               InMsgType                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UObject*                                     InObject                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UDCAkComponent::UnbindMsg(class UScriptStruct* InMsgType, class UObject* InObject)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAkComponent.UnbindMsg");
		
		UDCAkComponent_UnbindMsg_Params params {};
		params.InMsgType = InMsgType;
		params.InObject = InObject;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01763EE0
	 * 		Name   -> Function DungeonCrawler.DCAkComponent.TerminateBase
	 * 		Flags  -> (Native, Public)
	 */
	void UDCAkComponent::TerminateBase()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAkComponent.TerminateBase");
		
		UDCAkComponent_TerminateBase_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01763C60
	 * 		Name   -> Function DungeonCrawler.DCAkComponent.SetSoundSwitch
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		struct FGameplayTag                                Tag                                                        (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EPhysicalSurface                                   SurfaceType                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FString                                      SwitchGroup                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FString                                      SwitchState                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UDCAkComponent::SetSoundSwitch(const struct FGameplayTag& Tag, EPhysicalSurface SurfaceType, const class FString& SwitchGroup, const class FString& SwitchState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAkComponent.SetSoundSwitch");
		
		UDCAkComponent_SetSoundSwitch_Params params {};
		params.Tag = Tag;
		params.SurfaceType = SurfaceType;
		params.SwitchGroup = SwitchGroup;
		params.SwitchState = SwitchState;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01763BD0
	 * 		Name   -> Function DungeonCrawler.DCAkComponent.PostSoundEvent
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		struct FGameplayTag                                Tag                                                        (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UDCAkComponent::PostSoundEvent(const struct FGameplayTag& Tag)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAkComponent.PostSoundEvent");
		
		UDCAkComponent_PostSoundEvent_Params params {};
		params.Tag = Tag;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D3C640
	 * 		Name   -> Function DungeonCrawler.DCAkComponent.BroadcastMsgBlueprint
	 * 		Flags  -> (Native, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		int32_t                                            InMsg                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UDCAkComponent::BroadcastMsgBlueprint(int32_t InMsg)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAkComponent.BroadcastMsgBlueprint");
		
		UDCAkComponent_BroadcastMsgBlueprint_Params params {};
		params.InMsg = InMsg;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDCAkComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDCAkComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCAkComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01764580
	 * 		Name   -> Function DungeonCrawler.DCAkSpatialAudioVolume.UnbindMsgAll
	 * 		Flags  -> (Native, Public)
	 * Parameters:
	 * 		class UObject*                                     InObject                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ADCAkSpatialAudioVolume::UnbindMsgAll(class UObject* InObject)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAkSpatialAudioVolume.UnbindMsgAll");
		
		ADCAkSpatialAudioVolume_UnbindMsgAll_Params params {};
		params.InObject = InObject;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01764010
	 * 		Name   -> Function DungeonCrawler.DCAkSpatialAudioVolume.UnbindMsg
	 * 		Flags  -> (Native, Public)
	 * Parameters:
	 * 		class UScriptStruct*                               InMsgType                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UObject*                                     InObject                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ADCAkSpatialAudioVolume::UnbindMsg(class UScriptStruct* InMsgType, class UObject* InObject)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAkSpatialAudioVolume.UnbindMsg");
		
		ADCAkSpatialAudioVolume_UnbindMsg_Params params {};
		params.InMsgType = InMsgType;
		params.InObject = InObject;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01763E20
	 * 		Name   -> Function DungeonCrawler.DCAkSpatialAudioVolume.TerminateBase
	 * 		Flags  -> (Native, Public)
	 */
	void ADCAkSpatialAudioVolume::TerminateBase()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAkSpatialAudioVolume.TerminateBase");
		
		ADCAkSpatialAudioVolume_TerminateBase_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01763BB0
	 * 		Name   -> Function DungeonCrawler.DCAkSpatialAudioVolume.OnTargetPlayerPawnExitVolume
	 * 		Flags  -> (Final, Native, Private)
	 */
	void ADCAkSpatialAudioVolume::OnTargetPlayerPawnExitVolume()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAkSpatialAudioVolume.OnTargetPlayerPawnExitVolume");
		
		ADCAkSpatialAudioVolume_OnTargetPlayerPawnExitVolume_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01763B90
	 * 		Name   -> Function DungeonCrawler.DCAkSpatialAudioVolume.OnTargetPlayerPawnEnterVolume
	 * 		Flags  -> (Final, Native, Private)
	 */
	void ADCAkSpatialAudioVolume::OnTargetPlayerPawnEnterVolume()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAkSpatialAudioVolume.OnTargetPlayerPawnEnterVolume");
		
		ADCAkSpatialAudioVolume_OnTargetPlayerPawnEnterVolume_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01763980
	 * 		Name   -> Function DungeonCrawler.DCAkSpatialAudioVolume.OnOverlapEnd
	 * 		Flags  -> (Final, Native, Private)
	 * Parameters:
	 * 		class UPrimitiveComponent*                         OverlappedComp                                             (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      OtherActor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UPrimitiveComponent*                         OtherComp                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            OtherBodyIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ADCAkSpatialAudioVolume::OnOverlapEnd(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32_t OtherBodyIndex)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAkSpatialAudioVolume.OnOverlapEnd");
		
		ADCAkSpatialAudioVolume_OnOverlapEnd_Params params {};
		params.OverlappedComp = OverlappedComp;
		params.OtherActor = OtherActor;
		params.OtherComp = OtherComp;
		params.OtherBodyIndex = OtherBodyIndex;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01763710
	 * 		Name   -> Function DungeonCrawler.DCAkSpatialAudioVolume.OnOverlapBegin
	 * 		Flags  -> (Final, Native, Private, HasOutParms)
	 * Parameters:
	 * 		class UPrimitiveComponent*                         OverlappedComp                                             (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      OtherActor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UPrimitiveComponent*                         OtherComp                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            OtherBodyIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bFromSweep                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FHitResult                                  SweepResult                                                (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	void ADCAkSpatialAudioVolume::OnOverlapBegin(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32_t OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAkSpatialAudioVolume.OnOverlapBegin");
		
		ADCAkSpatialAudioVolume_OnOverlapBegin_Params params {};
		params.OverlappedComp = OverlappedComp;
		params.OtherActor = OtherActor;
		params.OtherComp = OtherComp;
		params.OtherBodyIndex = OtherBodyIndex;
		params.bFromSweep = bFromSweep;
		params.SweepResult = SweepResult;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D3C640
	 * 		Name   -> Function DungeonCrawler.DCAkSpatialAudioVolume.BroadcastMsgBlueprint
	 * 		Flags  -> (Native, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		int32_t                                            InMsg                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ADCAkSpatialAudioVolume::BroadcastMsgBlueprint(int32_t InMsg)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAkSpatialAudioVolume.BroadcastMsgBlueprint");
		
		ADCAkSpatialAudioVolume_BroadcastMsgBlueprint_Params params {};
		params.InMsg = InMsg;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ADCAkSpatialAudioVolume.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ADCAkSpatialAudioVolume::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCAkSpatialAudioVolume");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01764850
	 * 		Name   -> Function DungeonCrawler.DCAnimInstanceBase.UnbindMsgAll
	 * 		Flags  -> (Native, Public)
	 * Parameters:
	 * 		class UObject*                                     InObject                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UDCAnimInstanceBase::UnbindMsgAll(class UObject* InObject)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAnimInstanceBase.UnbindMsgAll");
		
		UDCAnimInstanceBase_UnbindMsgAll_Params params {};
		params.InObject = InObject;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01764420
	 * 		Name   -> Function DungeonCrawler.DCAnimInstanceBase.UnbindMsg
	 * 		Flags  -> (Native, Public)
	 * Parameters:
	 * 		class UScriptStruct*                               InMsgType                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UObject*                                     InObject                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UDCAnimInstanceBase::UnbindMsg(class UScriptStruct* InMsgType, class UObject* InObject)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAnimInstanceBase.UnbindMsg");
		
		UDCAnimInstanceBase_UnbindMsg_Params params {};
		params.InMsgType = InMsgType;
		params.InObject = InObject;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01763F10
	 * 		Name   -> Function DungeonCrawler.DCAnimInstanceBase.TerminateBase
	 * 		Flags  -> (Native, Public)
	 */
	void UDCAnimInstanceBase::TerminateBase()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAnimInstanceBase.TerminateBase");
		
		UDCAnimInstanceBase_TerminateBase_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017636E0
	 * 		Name   -> Function DungeonCrawler.DCAnimInstanceBase.GetOriginActor
	 * 		Flags  -> (Native, Public, BlueprintCallable)
	 */
	class AActor* UDCAnimInstanceBase::GetOriginActor()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAnimInstanceBase.GetOriginActor");
		
		UDCAnimInstanceBase_GetOriginActor_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017633D0
	 * 		Name   -> Function DungeonCrawler.DCAnimInstanceBase.EventMontageStarted
	 * 		Flags  -> (Final, Native, Private)
	 * Parameters:
	 * 		class UAnimMontage*                                InMontage                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UDCAnimInstanceBase::EventMontageStarted(class UAnimMontage* InMontage)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAnimInstanceBase.EventMontageStarted");
		
		UDCAnimInstanceBase_EventMontageStarted_Params params {};
		params.InMontage = InMontage;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017633B0
	 * 		Name   -> Function DungeonCrawler.DCAnimInstanceBase.EventAllMontageInstancesEnded
	 * 		Flags  -> (Final, Native, Private)
	 */
	void UDCAnimInstanceBase::EventAllMontageInstancesEnded()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAnimInstanceBase.EventAllMontageInstancesEnded");
		
		UDCAnimInstanceBase_EventAllMontageInstancesEnded_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D3C640
	 * 		Name   -> Function DungeonCrawler.DCAnimInstanceBase.BroadcastMsgBlueprint
	 * 		Flags  -> (Native, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		int32_t                                            InMsg                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UDCAnimInstanceBase::BroadcastMsgBlueprint(int32_t InMsg)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAnimInstanceBase.BroadcastMsgBlueprint");
		
		UDCAnimInstanceBase_BroadcastMsgBlueprint_Params params {};
		params.InMsg = InMsg;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDCAnimInstanceBase.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDCAnimInstanceBase::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCAnimInstanceBase");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDCAnimNotify_SendGameplayEventTagToSelf.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDCAnimNotify_SendGameplayEventTagToSelf::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCAnimNotify_SendGameplayEventTagToSelf");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDCAnimNotify_MontageJumpToSectionOnSourceObject.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDCAnimNotify_MontageJumpToSectionOnSourceObject::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCAnimNotify_MontageJumpToSectionOnSourceObject");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDCAnimNotify_PreReduceAmmoCountOnSourceObject.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDCAnimNotify_PreReduceAmmoCountOnSourceObject::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCAnimNotify_PreReduceAmmoCountOnSourceObject");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDCAnimNotify_SoundEvent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDCAnimNotify_SoundEvent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCAnimNotify_SoundEvent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDCAnimNotify_UnHideEquippedWeapons.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDCAnimNotify_UnHideEquippedWeapons::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCAnimNotify_UnHideEquippedWeapons");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDCAnimNotify_SendGameplayEventTagsToSelf.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDCAnimNotify_SendGameplayEventTagsToSelf::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCAnimNotify_SendGameplayEventTagsToSelf");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01764610
	 * 		Name   -> Function DungeonCrawler.DCAoeAIControllerBase.UnbindMsgAll
	 * 		Flags  -> (Native, Public)
	 * Parameters:
	 * 		class UObject*                                     InObject                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ADCAoeAIControllerBase::UnbindMsgAll(class UObject* InObject)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAoeAIControllerBase.UnbindMsgAll");
		
		ADCAoeAIControllerBase_UnbindMsgAll_Params params {};
		params.InObject = InObject;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017640E0
	 * 		Name   -> Function DungeonCrawler.DCAoeAIControllerBase.UnbindMsg
	 * 		Flags  -> (Native, Public)
	 * Parameters:
	 * 		class UScriptStruct*                               InMsgType                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UObject*                                     InObject                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ADCAoeAIControllerBase::UnbindMsg(class UScriptStruct* InMsgType, class UObject* InObject)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAoeAIControllerBase.UnbindMsg");
		
		ADCAoeAIControllerBase_UnbindMsg_Params params {};
		params.InMsgType = InMsgType;
		params.InObject = InObject;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01763E50
	 * 		Name   -> Function DungeonCrawler.DCAoeAIControllerBase.TerminateBase
	 * 		Flags  -> (Native, Public)
	 */
	void ADCAoeAIControllerBase::TerminateBase()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAoeAIControllerBase.TerminateBase");
		
		ADCAoeAIControllerBase_TerminateBase_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D3C640
	 * 		Name   -> Function DungeonCrawler.DCAoeAIControllerBase.BroadcastMsgBlueprint
	 * 		Flags  -> (Native, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		int32_t                                            InMsg                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ADCAoeAIControllerBase::BroadcastMsgBlueprint(int32_t InMsg)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAoeAIControllerBase.BroadcastMsgBlueprint");
		
		ADCAoeAIControllerBase_BroadcastMsgBlueprint_Params params {};
		params.InMsg = InMsg;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ADCAoeAIControllerBase.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ADCAoeAIControllerBase::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCAoeAIControllerBase");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017646A0
	 * 		Name   -> Function DungeonCrawler.DCAoeBase.UnbindMsgAll
	 * 		Flags  -> (Native, Public)
	 * Parameters:
	 * 		class UObject*                                     InObject                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ADCAoeBase::UnbindMsgAll(class UObject* InObject)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAoeBase.UnbindMsgAll");
		
		ADCAoeBase_UnbindMsgAll_Params params {};
		params.InObject = InObject;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017641B0
	 * 		Name   -> Function DungeonCrawler.DCAoeBase.UnbindMsg
	 * 		Flags  -> (Native, Public)
	 * Parameters:
	 * 		class UScriptStruct*                               InMsgType                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UObject*                                     InObject                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ADCAoeBase::UnbindMsg(class UScriptStruct* InMsgType, class UObject* InObject)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAoeBase.UnbindMsg");
		
		ADCAoeBase_UnbindMsg_Params params {};
		params.InMsgType = InMsgType;
		params.InObject = InObject;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01763E80
	 * 		Name   -> Function DungeonCrawler.DCAoeBase.TerminateBase
	 * 		Flags  -> (Native, Public)
	 */
	void ADCAoeBase::TerminateBase()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAoeBase.TerminateBase");
		
		ADCAoeBase_TerminateBase_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.DCAoeBase.RemoveEndOverlapActor
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 * Parameters:
	 * 		class ADCCharacterBase*                            CharacterBase                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ADCAoeBase::RemoveEndOverlapActor(class ADCCharacterBase* CharacterBase)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAoeBase.RemoveEndOverlapActor");
		
		ADCAoeBase_RemoveEndOverlapActor_Params params {};
		params.CharacterBase = CharacterBase;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.DCAoeBase.OnSetAI
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 */
	void ADCAoeBase::OnSetAI()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAoeBase.OnSetAI");
		
		ADCAoeBase_OnSetAI_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D3C640
	 * 		Name   -> Function DungeonCrawler.DCAoeBase.BroadcastMsgBlueprint
	 * 		Flags  -> (Native, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		int32_t                                            InMsg                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ADCAoeBase::BroadcastMsgBlueprint(int32_t InMsg)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAoeBase.BroadcastMsgBlueprint");
		
		ADCAoeBase_BroadcastMsgBlueprint_Params params {};
		params.InMsg = InMsg;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.DCAoeBase.AddBeginOverlapActor
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 * Parameters:
	 * 		class ADCCharacterBase*                            CharacterBase                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ADCAoeBase::AddBeginOverlapActor(class ADCCharacterBase* CharacterBase)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAoeBase.AddBeginOverlapActor");
		
		ADCAoeBase_AddBeginOverlapActor_Params params {};
		params.CharacterBase = CharacterBase;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ADCAoeBase.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ADCAoeBase::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCAoeBase");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0176EB50
	 * 		Name   -> Function DungeonCrawler.DCAoeSystemBlueprintLibrary.SpawnAoe
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		class ADCCharacterBase*                            DCCharacterBase                                            (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UClass*                                      AoeClass                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     Location                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UDCGameplayAbilityBase*                      DCGameplayAbilityBase                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FGameplayEventData                          EventData                                                  (Parm, NativeAccessSpecifierPublic)
	 * 		bool                                               bSuccessfully                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class ADCAoeBase* UDCAoeSystemBlueprintLibrary::STATIC_SpawnAoe(class ADCCharacterBase** DCCharacterBase, class UClass* AoeClass, const struct FVector& Location, class UDCGameplayAbilityBase* DCGameplayAbilityBase, const struct FGameplayEventData& EventData, bool* bSuccessfully)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAoeSystemBlueprintLibrary.SpawnAoe");
		
		UDCAoeSystemBlueprintLibrary_SpawnAoe_Params params {};
		params.AoeClass = AoeClass;
		params.Location = Location;
		params.DCGameplayAbilityBase = DCGameplayAbilityBase;
		params.EventData = EventData;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (DCCharacterBase != nullptr)
			*DCCharacterBase = params.DCCharacterBase;
		if (bSuccessfully != nullptr)
			*bSuccessfully = params.bSuccessfully;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0176E9D0
	 * 		Name   -> Function DungeonCrawler.DCAoeSystemBlueprintLibrary.SortTargetsByDistanceAndPickTarget
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		class ADCAoeBase*                                  DCAoeBase                                                  (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		TArray<class ADCCharacterBase*>                    TargetArray                                                (Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		EAoeFilterSortingType                              AoeFilterSortingType                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            Index                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class ADCCharacterBase* UDCAoeSystemBlueprintLibrary::STATIC_SortTargetsByDistanceAndPickTarget(class ADCAoeBase** DCAoeBase, TArray<class ADCCharacterBase*>* TargetArray, EAoeFilterSortingType AoeFilterSortingType, int32_t Index)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAoeSystemBlueprintLibrary.SortTargetsByDistanceAndPickTarget");
		
		UDCAoeSystemBlueprintLibrary_SortTargetsByDistanceAndPickTarget_Params params {};
		params.AoeFilterSortingType = AoeFilterSortingType;
		params.Index = Index;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (DCAoeBase != nullptr)
			*DCAoeBase = params.DCAoeBase;
		if (TargetArray != nullptr)
			*TargetArray = params.TargetArray;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0176E880
	 * 		Name   -> Function DungeonCrawler.DCAoeSystemBlueprintLibrary.SortTargetsByDistance
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		class ADCAoeBase*                                  DCAoeBase                                                  (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		TArray<class ADCCharacterBase*>                    TargetArray                                                (Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		EAoeFilterSortingType                              AoeFilterSortingType                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UDCAoeSystemBlueprintLibrary::STATIC_SortTargetsByDistance(class ADCAoeBase** DCAoeBase, TArray<class ADCCharacterBase*>* TargetArray, EAoeFilterSortingType AoeFilterSortingType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAoeSystemBlueprintLibrary.SortTargetsByDistance");
		
		UDCAoeSystemBlueprintLibrary_SortTargetsByDistance_Params params {};
		params.AoeFilterSortingType = AoeFilterSortingType;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (DCAoeBase != nullptr)
			*DCAoeBase = params.DCAoeBase;
		if (TargetArray != nullptr)
			*TargetArray = params.TargetArray;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0176E780
	 * 		Name   -> Function DungeonCrawler.DCAoeSystemBlueprintLibrary.PickTarget
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		TArray<class ADCCharacterBase*>                    TargetArray                                                (Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		int32_t                                            Index                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class ADCCharacterBase* UDCAoeSystemBlueprintLibrary::STATIC_PickTarget(TArray<class ADCCharacterBase*>* TargetArray, int32_t Index)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAoeSystemBlueprintLibrary.PickTarget");
		
		UDCAoeSystemBlueprintLibrary_PickTarget_Params params {};
		params.Index = Index;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (TargetArray != nullptr)
			*TargetArray = params.TargetArray;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0176E6D0
	 * 		Name   -> Function DungeonCrawler.DCAoeSystemBlueprintLibrary.PickRandomTarget
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		TArray<class ADCCharacterBase*>                    TargetArray                                                (Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	class ADCCharacterBase* UDCAoeSystemBlueprintLibrary::STATIC_PickRandomTarget(TArray<class ADCCharacterBase*>* TargetArray)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAoeSystemBlueprintLibrary.PickRandomTarget");
		
		UDCAoeSystemBlueprintLibrary_PickRandomTarget_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (TargetArray != nullptr)
			*TargetArray = params.TargetArray;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0176A270
	 * 		Name   -> Function DungeonCrawler.DCAoeSystemBlueprintLibrary.GetTargetArray
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		class ADCAoeBase*                                  DCAoeBase                                                  (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		TArray<class ADCCharacterBase*>                    TargetArray                                                (Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	bool UDCAoeSystemBlueprintLibrary::STATIC_GetTargetArray(class ADCAoeBase** DCAoeBase, TArray<class ADCCharacterBase*>* TargetArray)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAoeSystemBlueprintLibrary.GetTargetArray");
		
		UDCAoeSystemBlueprintLibrary_GetTargetArray_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (DCAoeBase != nullptr)
			*DCAoeBase = params.DCAoeBase;
		if (TargetArray != nullptr)
			*TargetArray = params.TargetArray;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0176A170
	 * 		Name   -> Function DungeonCrawler.DCAoeSystemBlueprintLibrary.FilterUnTagedTargets
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		TArray<class ADCCharacterBase*>                    TargetArray                                                (Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		struct FGameplayTag                                GameplayTag                                                (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UDCAoeSystemBlueprintLibrary::STATIC_FilterUnTagedTargets(TArray<class ADCCharacterBase*>* TargetArray, const struct FGameplayTag& GameplayTag)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAoeSystemBlueprintLibrary.FilterUnTagedTargets");
		
		UDCAoeSystemBlueprintLibrary_FilterUnTagedTargets_Params params {};
		params.GameplayTag = GameplayTag;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (TargetArray != nullptr)
			*TargetArray = params.TargetArray;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0176A020
	 * 		Name   -> Function DungeonCrawler.DCAoeSystemBlueprintLibrary.FilterTargetsWithinDistance
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		class ADCAoeBase*                                  DCAoeBase                                                  (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		TArray<class ADCCharacterBase*>                    TargetArray                                                (Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		float                                              Distance                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UDCAoeSystemBlueprintLibrary::STATIC_FilterTargetsWithinDistance(class ADCAoeBase** DCAoeBase, TArray<class ADCCharacterBase*>* TargetArray, float Distance)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAoeSystemBlueprintLibrary.FilterTargetsWithinDistance");
		
		UDCAoeSystemBlueprintLibrary_FilterTargetsWithinDistance_Params params {};
		params.Distance = Distance;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (DCAoeBase != nullptr)
			*DCAoeBase = params.DCAoeBase;
		if (TargetArray != nullptr)
			*TargetArray = params.TargetArray;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01769ED0
	 * 		Name   -> Function DungeonCrawler.DCAoeSystemBlueprintLibrary.FilterTargetsOverDistance
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		class ADCAoeBase*                                  DCAoeBase                                                  (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		TArray<class ADCCharacterBase*>                    TargetArray                                                (Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		float                                              Distance                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UDCAoeSystemBlueprintLibrary::STATIC_FilterTargetsOverDistance(class ADCAoeBase** DCAoeBase, TArray<class ADCCharacterBase*>* TargetArray, float Distance)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAoeSystemBlueprintLibrary.FilterTargetsOverDistance");
		
		UDCAoeSystemBlueprintLibrary_FilterTargetsOverDistance_Params params {};
		params.Distance = Distance;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (DCAoeBase != nullptr)
			*DCAoeBase = params.DCAoeBase;
		if (TargetArray != nullptr)
			*TargetArray = params.TargetArray;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01769DD0
	 * 		Name   -> Function DungeonCrawler.DCAoeSystemBlueprintLibrary.FilterTagedTargets
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		TArray<class ADCCharacterBase*>                    TargetArray                                                (Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		struct FGameplayTag                                GameplayTag                                                (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UDCAoeSystemBlueprintLibrary::STATIC_FilterTagedTargets(TArray<class ADCCharacterBase*>* TargetArray, const struct FGameplayTag& GameplayTag)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAoeSystemBlueprintLibrary.FilterTagedTargets");
		
		UDCAoeSystemBlueprintLibrary_FilterTagedTargets_Params params {};
		params.GameplayTag = GameplayTag;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (TargetArray != nullptr)
			*TargetArray = params.TargetArray;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01769D30
	 * 		Name   -> Function DungeonCrawler.DCAoeSystemBlueprintLibrary.FilterPlayerCharacterTargets
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		TArray<class ADCCharacterBase*>                    TargetArray                                                (Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UDCAoeSystemBlueprintLibrary::STATIC_FilterPlayerCharacterTargets(TArray<class ADCCharacterBase*>* TargetArray)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAoeSystemBlueprintLibrary.FilterPlayerCharacterTargets");
		
		UDCAoeSystemBlueprintLibrary_FilterPlayerCharacterTargets_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (TargetArray != nullptr)
			*TargetArray = params.TargetArray;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01769C90
	 * 		Name   -> Function DungeonCrawler.DCAoeSystemBlueprintLibrary.FilterMonsterTargets
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		TArray<class ADCCharacterBase*>                    TargetArray                                                (Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UDCAoeSystemBlueprintLibrary::STATIC_FilterMonsterTargets(TArray<class ADCCharacterBase*>* TargetArray)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAoeSystemBlueprintLibrary.FilterMonsterTargets");
		
		UDCAoeSystemBlueprintLibrary_FilterMonsterTargets_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (TargetArray != nullptr)
			*TargetArray = params.TargetArray;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01769B50
	 * 		Name   -> Function DungeonCrawler.DCAoeSystemBlueprintLibrary.DespawnAoeWithinDistance
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		class ADCCharacterBase*                            DCCharacterBase                                            (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     Location                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Distance                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UDCAoeSystemBlueprintLibrary::STATIC_DespawnAoeWithinDistance(class ADCCharacterBase** DCCharacterBase, const struct FVector& Location, float Distance)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAoeSystemBlueprintLibrary.DespawnAoeWithinDistance");
		
		UDCAoeSystemBlueprintLibrary_DespawnAoeWithinDistance_Params params {};
		params.Location = Location;
		params.Distance = Distance;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (DCCharacterBase != nullptr)
			*DCCharacterBase = params.DCCharacterBase;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017699E0
	 * 		Name   -> Function DungeonCrawler.DCAoeSystemBlueprintLibrary.DespawnAoeByPrimaryAssetIdWithinDistance
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		class ADCCharacterBase*                            DCCharacterBase                                            (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FPrimaryAssetId                             PrimaryAssetId                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     Location                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Distance                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UDCAoeSystemBlueprintLibrary::STATIC_DespawnAoeByPrimaryAssetIdWithinDistance(class ADCCharacterBase** DCCharacterBase, const struct FPrimaryAssetId& PrimaryAssetId, const struct FVector& Location, float Distance)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAoeSystemBlueprintLibrary.DespawnAoeByPrimaryAssetIdWithinDistance");
		
		UDCAoeSystemBlueprintLibrary_DespawnAoeByPrimaryAssetIdWithinDistance_Params params {};
		params.PrimaryAssetId = PrimaryAssetId;
		params.Location = Location;
		params.Distance = Distance;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (DCCharacterBase != nullptr)
			*DCCharacterBase = params.DCCharacterBase;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01769900
	 * 		Name   -> Function DungeonCrawler.DCAoeSystemBlueprintLibrary.DespawnAoeByPrimaryAssetId
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		class ADCCharacterBase*                            DCCharacterBase                                            (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FPrimaryAssetId                             PrimaryAssetId                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UDCAoeSystemBlueprintLibrary::STATIC_DespawnAoeByPrimaryAssetId(class ADCCharacterBase** DCCharacterBase, const struct FPrimaryAssetId& PrimaryAssetId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAoeSystemBlueprintLibrary.DespawnAoeByPrimaryAssetId");
		
		UDCAoeSystemBlueprintLibrary_DespawnAoeByPrimaryAssetId_Params params {};
		params.PrimaryAssetId = PrimaryAssetId;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (DCCharacterBase != nullptr)
			*DCCharacterBase = params.DCCharacterBase;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01769880
	 * 		Name   -> Function DungeonCrawler.DCAoeSystemBlueprintLibrary.DespawnAoeAll
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class ADCCharacterBase*                            DCCharacterBase                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UDCAoeSystemBlueprintLibrary::STATIC_DespawnAoeAll(class ADCCharacterBase* DCCharacterBase)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAoeSystemBlueprintLibrary.DespawnAoeAll");
		
		UDCAoeSystemBlueprintLibrary_DespawnAoeAll_Params params {};
		params.DCCharacterBase = DCCharacterBase;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDCAoeSystemBlueprintLibrary.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDCAoeSystemBlueprintLibrary::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCAoeSystemBlueprintLibrary");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDCAssetManager.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDCAssetManager::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCAssetManager");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDCAttributeModMagnitudeCalculationStrength.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDCAttributeModMagnitudeCalculationStrength::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCAttributeModMagnitudeCalculationStrength");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDCAttributeModMagnitudeCalculationAgility.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDCAttributeModMagnitudeCalculationAgility::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCAttributeModMagnitudeCalculationAgility");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDCAttributeModMagnitudeCalculationWill.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDCAttributeModMagnitudeCalculationWill::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCAttributeModMagnitudeCalculationWill");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDCAttributeModMagnitudeCalculationKnowledge.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDCAttributeModMagnitudeCalculationKnowledge::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCAttributeModMagnitudeCalculationKnowledge");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDCAttributeModMagnitudeCalculationResourcefulness.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDCAttributeModMagnitudeCalculationResourcefulness::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCAttributeModMagnitudeCalculationResourcefulness");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDCAttributeModMagnitudeCalculationMaxHealth.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDCAttributeModMagnitudeCalculationMaxHealth::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCAttributeModMagnitudeCalculationMaxHealth");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDCAttributeModMagnitudeCalculationItemArmorRating.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDCAttributeModMagnitudeCalculationItemArmorRating::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCAttributeModMagnitudeCalculationItemArmorRating");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDCAttributeModMagnitudeCalculationSpellCapacity.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDCAttributeModMagnitudeCalculationSpellCapacity::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCAttributeModMagnitudeCalculationSpellCapacity");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDCAttributeModMagnitudeCalculationMoveSpeed.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDCAttributeModMagnitudeCalculationMoveSpeed::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCAttributeModMagnitudeCalculationMoveSpeed");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDCAttributeModMagnitudeCalculationRegularInteractionSpeedBase.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDCAttributeModMagnitudeCalculationRegularInteractionSpeedBase::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCAttributeModMagnitudeCalculationRegularInteractionSpeedBase");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDCAttributeModMagnitudeCalculationUtilityEffectiveness.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDCAttributeModMagnitudeCalculationUtilityEffectiveness::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCAttributeModMagnitudeCalculationUtilityEffectiveness");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDCAttributeModMagnitudeCalculationWeightLimit.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDCAttributeModMagnitudeCalculationWeightLimit::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCAttributeModMagnitudeCalculationWeightLimit");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDCAttributeModMagnitudeCalculationPerkBerSerker.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDCAttributeModMagnitudeCalculationPerkBerSerker::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCAttributeModMagnitudeCalculationPerkBerSerker");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDCAttributeModMagnitudeCalculationSkillVictoryStrike.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDCAttributeModMagnitudeCalculationSkillVictoryStrike::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCAttributeModMagnitudeCalculationSkillVictoryStrike");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0176E620
	 * 		Name   -> Function DungeonCrawler.DCAttributeSet.OnRep_WillMod
	 * 		Flags  -> (Native, Protected, HasOutParms)
	 * Parameters:
	 * 		struct FGameplayAttributeData                      OldValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UDCAttributeSet::OnRep_WillMod(const struct FGameplayAttributeData& OldValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAttributeSet.OnRep_WillMod");
		
		UDCAttributeSet_OnRep_WillMod_Params params {};
		params.OldValue = OldValue;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0176E570
	 * 		Name   -> Function DungeonCrawler.DCAttributeSet.OnRep_WillBase
	 * 		Flags  -> (Native, Protected, HasOutParms)
	 * Parameters:
	 * 		struct FGameplayAttributeData                      OldValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UDCAttributeSet::OnRep_WillBase(const struct FGameplayAttributeData& OldValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAttributeSet.OnRep_WillBase");
		
		UDCAttributeSet_OnRep_WillBase_Params params {};
		params.OldValue = OldValue;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0176E4C0
	 * 		Name   -> Function DungeonCrawler.DCAttributeSet.OnRep_Will
	 * 		Flags  -> (Native, Protected, HasOutParms)
	 * Parameters:
	 * 		struct FGameplayAttributeData                      OldValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UDCAttributeSet::OnRep_Will(const struct FGameplayAttributeData& OldValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAttributeSet.OnRep_Will");
		
		UDCAttributeSet_OnRep_Will_Params params {};
		params.OldValue = OldValue;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0176E410
	 * 		Name   -> Function DungeonCrawler.DCAttributeSet.OnRep_WeightLimitMod
	 * 		Flags  -> (Native, Protected, HasOutParms)
	 * Parameters:
	 * 		struct FGameplayAttributeData                      OldValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UDCAttributeSet::OnRep_WeightLimitMod(const struct FGameplayAttributeData& OldValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAttributeSet.OnRep_WeightLimitMod");
		
		UDCAttributeSet_OnRep_WeightLimitMod_Params params {};
		params.OldValue = OldValue;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0176E360
	 * 		Name   -> Function DungeonCrawler.DCAttributeSet.OnRep_WeightLimitBase
	 * 		Flags  -> (Native, Protected, HasOutParms)
	 * Parameters:
	 * 		struct FGameplayAttributeData                      OldValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UDCAttributeSet::OnRep_WeightLimitBase(const struct FGameplayAttributeData& OldValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAttributeSet.OnRep_WeightLimitBase");
		
		UDCAttributeSet_OnRep_WeightLimitBase_Params params {};
		params.OldValue = OldValue;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0176E2B0
	 * 		Name   -> Function DungeonCrawler.DCAttributeSet.OnRep_WeightLimitAdd
	 * 		Flags  -> (Native, Protected, HasOutParms)
	 * Parameters:
	 * 		struct FGameplayAttributeData                      OldValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UDCAttributeSet::OnRep_WeightLimitAdd(const struct FGameplayAttributeData& OldValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAttributeSet.OnRep_WeightLimitAdd");
		
		UDCAttributeSet_OnRep_WeightLimitAdd_Params params {};
		params.OldValue = OldValue;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0176E200
	 * 		Name   -> Function DungeonCrawler.DCAttributeSet.OnRep_WeightLimit
	 * 		Flags  -> (Native, Protected, HasOutParms)
	 * Parameters:
	 * 		struct FGameplayAttributeData                      OldValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UDCAttributeSet::OnRep_WeightLimit(const struct FGameplayAttributeData& OldValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAttributeSet.OnRep_WeightLimit");
		
		UDCAttributeSet_OnRep_WeightLimit_Params params {};
		params.OldValue = OldValue;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0176E150
	 * 		Name   -> Function DungeonCrawler.DCAttributeSet.OnRep_Weight
	 * 		Flags  -> (Native, Protected, HasOutParms)
	 * Parameters:
	 * 		struct FGameplayAttributeData                      OldValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UDCAttributeSet::OnRep_Weight(const struct FGameplayAttributeData& OldValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAttributeSet.OnRep_Weight");
		
		UDCAttributeSet_OnRep_Weight_Params params {};
		params.OldValue = OldValue;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0176E0A0
	 * 		Name   -> Function DungeonCrawler.DCAttributeSet.OnRep_UtilityEffectivenessMod
	 * 		Flags  -> (Native, Protected, HasOutParms)
	 * Parameters:
	 * 		struct FGameplayAttributeData                      OldValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UDCAttributeSet::OnRep_UtilityEffectivenessMod(const struct FGameplayAttributeData& OldValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAttributeSet.OnRep_UtilityEffectivenessMod");
		
		UDCAttributeSet_OnRep_UtilityEffectivenessMod_Params params {};
		params.OldValue = OldValue;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0176DFF0
	 * 		Name   -> Function DungeonCrawler.DCAttributeSet.OnRep_UtilityEffectivenessBase
	 * 		Flags  -> (Native, Protected, HasOutParms)
	 * Parameters:
	 * 		struct FGameplayAttributeData                      OldValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UDCAttributeSet::OnRep_UtilityEffectivenessBase(const struct FGameplayAttributeData& OldValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAttributeSet.OnRep_UtilityEffectivenessBase");
		
		UDCAttributeSet_OnRep_UtilityEffectivenessBase_Params params {};
		params.OldValue = OldValue;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0176DF40
	 * 		Name   -> Function DungeonCrawler.DCAttributeSet.OnRep_UtilityEffectivenessAdd
	 * 		Flags  -> (Native, Protected, HasOutParms)
	 * Parameters:
	 * 		struct FGameplayAttributeData                      OldValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UDCAttributeSet::OnRep_UtilityEffectivenessAdd(const struct FGameplayAttributeData& OldValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAttributeSet.OnRep_UtilityEffectivenessAdd");
		
		UDCAttributeSet_OnRep_UtilityEffectivenessAdd_Params params {};
		params.OldValue = OldValue;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0176DE90
	 * 		Name   -> Function DungeonCrawler.DCAttributeSet.OnRep_UtilityEffectiveness
	 * 		Flags  -> (Native, Protected, HasOutParms)
	 * Parameters:
	 * 		struct FGameplayAttributeData                      OldValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UDCAttributeSet::OnRep_UtilityEffectiveness(const struct FGameplayAttributeData& OldValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAttributeSet.OnRep_UtilityEffectiveness");
		
		UDCAttributeSet_OnRep_UtilityEffectiveness_Params params {};
		params.OldValue = OldValue;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0176DDE0
	 * 		Name   -> Function DungeonCrawler.DCAttributeSet.OnRep_TotalShield
	 * 		Flags  -> (Native, Protected, HasOutParms)
	 * Parameters:
	 * 		struct FGameplayAttributeData                      OldValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UDCAttributeSet::OnRep_TotalShield(const struct FGameplayAttributeData& OldValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAttributeSet.OnRep_TotalShield");
		
		UDCAttributeSet_OnRep_TotalShield_Params params {};
		params.OldValue = OldValue;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0176DD30
	 * 		Name   -> Function DungeonCrawler.DCAttributeSet.OnRep_StrengthMod
	 * 		Flags  -> (Native, Protected, HasOutParms)
	 * Parameters:
	 * 		struct FGameplayAttributeData                      OldValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UDCAttributeSet::OnRep_StrengthMod(const struct FGameplayAttributeData& OldValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAttributeSet.OnRep_StrengthMod");
		
		UDCAttributeSet_OnRep_StrengthMod_Params params {};
		params.OldValue = OldValue;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0176DC80
	 * 		Name   -> Function DungeonCrawler.DCAttributeSet.OnRep_StrengthBase
	 * 		Flags  -> (Native, Protected, HasOutParms)
	 * Parameters:
	 * 		struct FGameplayAttributeData                      OldValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UDCAttributeSet::OnRep_StrengthBase(const struct FGameplayAttributeData& OldValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAttributeSet.OnRep_StrengthBase");
		
		UDCAttributeSet_OnRep_StrengthBase_Params params {};
		params.OldValue = OldValue;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0176DBD0
	 * 		Name   -> Function DungeonCrawler.DCAttributeSet.OnRep_Strength
	 * 		Flags  -> (Native, Protected, HasOutParms)
	 * Parameters:
	 * 		struct FGameplayAttributeData                      OldValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UDCAttributeSet::OnRep_Strength(const struct FGameplayAttributeData& OldValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAttributeSet.OnRep_Strength");
		
		UDCAttributeSet_OnRep_Strength_Params params {};
		params.OldValue = OldValue;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0176DB20
	 * 		Name   -> Function DungeonCrawler.DCAttributeSet.OnRep_SpellPayload
	 * 		Flags  -> (Native, Protected, HasOutParms)
	 * Parameters:
	 * 		struct FGameplayAttributeData                      OldValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UDCAttributeSet::OnRep_SpellPayload(const struct FGameplayAttributeData& OldValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAttributeSet.OnRep_SpellPayload");
		
		UDCAttributeSet_OnRep_SpellPayload_Params params {};
		params.OldValue = OldValue;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0176DA70
	 * 		Name   -> Function DungeonCrawler.DCAttributeSet.OnRep_SpellCastingSpeed
	 * 		Flags  -> (Native, Protected, HasOutParms)
	 * Parameters:
	 * 		struct FGameplayAttributeData                      OldValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UDCAttributeSet::OnRep_SpellCastingSpeed(const struct FGameplayAttributeData& OldValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAttributeSet.OnRep_SpellCastingSpeed");
		
		UDCAttributeSet_OnRep_SpellCastingSpeed_Params params {};
		params.OldValue = OldValue;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0176D9C0
	 * 		Name   -> Function DungeonCrawler.DCAttributeSet.OnRep_SpellCapacityMod
	 * 		Flags  -> (Native, Protected, HasOutParms)
	 * Parameters:
	 * 		struct FGameplayAttributeData                      OldValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UDCAttributeSet::OnRep_SpellCapacityMod(const struct FGameplayAttributeData& OldValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAttributeSet.OnRep_SpellCapacityMod");
		
		UDCAttributeSet_OnRep_SpellCapacityMod_Params params {};
		params.OldValue = OldValue;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0176D910
	 * 		Name   -> Function DungeonCrawler.DCAttributeSet.OnRep_SpellCapacityBase
	 * 		Flags  -> (Native, Protected, HasOutParms)
	 * Parameters:
	 * 		struct FGameplayAttributeData                      OldValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UDCAttributeSet::OnRep_SpellCapacityBase(const struct FGameplayAttributeData& OldValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAttributeSet.OnRep_SpellCapacityBase");
		
		UDCAttributeSet_OnRep_SpellCapacityBase_Params params {};
		params.OldValue = OldValue;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0176D860
	 * 		Name   -> Function DungeonCrawler.DCAttributeSet.OnRep_SpellCapacityAdd
	 * 		Flags  -> (Native, Protected, HasOutParms)
	 * Parameters:
	 * 		struct FGameplayAttributeData                      OldValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UDCAttributeSet::OnRep_SpellCapacityAdd(const struct FGameplayAttributeData& OldValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAttributeSet.OnRep_SpellCapacityAdd");
		
		UDCAttributeSet_OnRep_SpellCapacityAdd_Params params {};
		params.OldValue = OldValue;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0176D7B0
	 * 		Name   -> Function DungeonCrawler.DCAttributeSet.OnRep_SpellCapacity
	 * 		Flags  -> (Native, Protected, HasOutParms)
	 * Parameters:
	 * 		struct FGameplayAttributeData                      OldValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UDCAttributeSet::OnRep_SpellCapacity(const struct FGameplayAttributeData& OldValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAttributeSet.OnRep_SpellCapacity");
		
		UDCAttributeSet_OnRep_SpellCapacity_Params params {};
		params.OldValue = OldValue;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0176D700
	 * 		Name   -> Function DungeonCrawler.DCAttributeSet.OnRep_ResourcefulnessMod
	 * 		Flags  -> (Native, Protected, HasOutParms)
	 * Parameters:
	 * 		struct FGameplayAttributeData                      OldValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UDCAttributeSet::OnRep_ResourcefulnessMod(const struct FGameplayAttributeData& OldValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAttributeSet.OnRep_ResourcefulnessMod");
		
		UDCAttributeSet_OnRep_ResourcefulnessMod_Params params {};
		params.OldValue = OldValue;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0176D650
	 * 		Name   -> Function DungeonCrawler.DCAttributeSet.OnRep_ResourcefulnessBase
	 * 		Flags  -> (Native, Protected, HasOutParms)
	 * Parameters:
	 * 		struct FGameplayAttributeData                      OldValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UDCAttributeSet::OnRep_ResourcefulnessBase(const struct FGameplayAttributeData& OldValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAttributeSet.OnRep_ResourcefulnessBase");
		
		UDCAttributeSet_OnRep_ResourcefulnessBase_Params params {};
		params.OldValue = OldValue;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0176D5A0
	 * 		Name   -> Function DungeonCrawler.DCAttributeSet.OnRep_Resourcefulness
	 * 		Flags  -> (Native, Protected, HasOutParms)
	 * Parameters:
	 * 		struct FGameplayAttributeData                      OldValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UDCAttributeSet::OnRep_Resourcefulness(const struct FGameplayAttributeData& OldValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAttributeSet.OnRep_Resourcefulness");
		
		UDCAttributeSet_OnRep_Resourcefulness_Params params {};
		params.OldValue = OldValue;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0176D4F0
	 * 		Name   -> Function DungeonCrawler.DCAttributeSet.OnRep_RegularInteractionSpeedBase
	 * 		Flags  -> (Native, Protected, HasOutParms)
	 * Parameters:
	 * 		struct FGameplayAttributeData                      OldValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UDCAttributeSet::OnRep_RegularInteractionSpeedBase(const struct FGameplayAttributeData& OldValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAttributeSet.OnRep_RegularInteractionSpeedBase");
		
		UDCAttributeSet_OnRep_RegularInteractionSpeedBase_Params params {};
		params.OldValue = OldValue;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0176D440
	 * 		Name   -> Function DungeonCrawler.DCAttributeSet.OnRep_RegularInteractionSpeed
	 * 		Flags  -> (Native, Protected, HasOutParms)
	 * Parameters:
	 * 		struct FGameplayAttributeData                      OldValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UDCAttributeSet::OnRep_RegularInteractionSpeed(const struct FGameplayAttributeData& OldValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAttributeSet.OnRep_RegularInteractionSpeed");
		
		UDCAttributeSet_OnRep_RegularInteractionSpeed_Params params {};
		params.OldValue = OldValue;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0176D390
	 * 		Name   -> Function DungeonCrawler.DCAttributeSet.OnRep_ProjectileReductionMod
	 * 		Flags  -> (Native, Protected, HasOutParms)
	 * Parameters:
	 * 		struct FGameplayAttributeData                      OldValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UDCAttributeSet::OnRep_ProjectileReductionMod(const struct FGameplayAttributeData& OldValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAttributeSet.OnRep_ProjectileReductionMod");
		
		UDCAttributeSet_OnRep_ProjectileReductionMod_Params params {};
		params.OldValue = OldValue;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0176D2E0
	 * 		Name   -> Function DungeonCrawler.DCAttributeSet.OnRep_PrestigeItemDrop
	 * 		Flags  -> (Native, Protected, HasOutParms)
	 * Parameters:
	 * 		struct FGameplayAttributeData                      OldValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UDCAttributeSet::OnRep_PrestigeItemDrop(const struct FGameplayAttributeData& OldValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAttributeSet.OnRep_PrestigeItemDrop");
		
		UDCAttributeSet_OnRep_PrestigeItemDrop_Params params {};
		params.OldValue = OldValue;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0176D230
	 * 		Name   -> Function DungeonCrawler.DCAttributeSet.OnRep_PhysicalShield
	 * 		Flags  -> (Native, Protected, HasOutParms)
	 * Parameters:
	 * 		struct FGameplayAttributeData                      OldValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UDCAttributeSet::OnRep_PhysicalShield(const struct FGameplayAttributeData& OldValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAttributeSet.OnRep_PhysicalShield");
		
		UDCAttributeSet_OnRep_PhysicalShield_Params params {};
		params.OldValue = OldValue;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0176D180
	 * 		Name   -> Function DungeonCrawler.DCAttributeSet.OnRep_PhysicalReductionMod
	 * 		Flags  -> (Native, Protected, HasOutParms)
	 * Parameters:
	 * 		struct FGameplayAttributeData                      OldValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UDCAttributeSet::OnRep_PhysicalReductionMod(const struct FGameplayAttributeData& OldValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAttributeSet.OnRep_PhysicalReductionMod");
		
		UDCAttributeSet_OnRep_PhysicalReductionMod_Params params {};
		params.OldValue = OldValue;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0176D0D0
	 * 		Name   -> Function DungeonCrawler.DCAttributeSet.OnRep_PhysicalReduction
	 * 		Flags  -> (Native, Protected, HasOutParms)
	 * Parameters:
	 * 		struct FGameplayAttributeData                      OldValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UDCAttributeSet::OnRep_PhysicalReduction(const struct FGameplayAttributeData& OldValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAttributeSet.OnRep_PhysicalReduction");
		
		UDCAttributeSet_OnRep_PhysicalReduction_Params params {};
		params.OldValue = OldValue;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0176D020
	 * 		Name   -> Function DungeonCrawler.DCAttributeSet.OnRep_PhysicalRangedHeadshotPower
	 * 		Flags  -> (Native, Protected, HasOutParms)
	 * Parameters:
	 * 		struct FGameplayAttributeData                      OldValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UDCAttributeSet::OnRep_PhysicalRangedHeadshotPower(const struct FGameplayAttributeData& OldValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAttributeSet.OnRep_PhysicalRangedHeadshotPower");
		
		UDCAttributeSet_OnRep_PhysicalRangedHeadshotPower_Params params {};
		params.OldValue = OldValue;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0176CF70
	 * 		Name   -> Function DungeonCrawler.DCAttributeSet.OnRep_PhysicalPower
	 * 		Flags  -> (Native, Protected, HasOutParms)
	 * Parameters:
	 * 		struct FGameplayAttributeData                      OldValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UDCAttributeSet::OnRep_PhysicalPower(const struct FGameplayAttributeData& OldValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAttributeSet.OnRep_PhysicalPower");
		
		UDCAttributeSet_OnRep_PhysicalPower_Params params {};
		params.OldValue = OldValue;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0176CEC0
	 * 		Name   -> Function DungeonCrawler.DCAttributeSet.OnRep_PhysicalHealBase
	 * 		Flags  -> (Native, Protected, HasOutParms)
	 * Parameters:
	 * 		struct FGameplayAttributeData                      OldValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UDCAttributeSet::OnRep_PhysicalHealBase(const struct FGameplayAttributeData& OldValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAttributeSet.OnRep_PhysicalHealBase");
		
		UDCAttributeSet_OnRep_PhysicalHealBase_Params params {};
		params.OldValue = OldValue;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0176CE10
	 * 		Name   -> Function DungeonCrawler.DCAttributeSet.OnRep_PhysicalDamageWeaponSecondary
	 * 		Flags  -> (Native, Protected, HasOutParms)
	 * Parameters:
	 * 		struct FGameplayAttributeData                      OldValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UDCAttributeSet::OnRep_PhysicalDamageWeaponSecondary(const struct FGameplayAttributeData& OldValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAttributeSet.OnRep_PhysicalDamageWeaponSecondary");
		
		UDCAttributeSet_OnRep_PhysicalDamageWeaponSecondary_Params params {};
		params.OldValue = OldValue;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0176CD60
	 * 		Name   -> Function DungeonCrawler.DCAttributeSet.OnRep_PhysicalDamageWeaponPrimary
	 * 		Flags  -> (Native, Protected, HasOutParms)
	 * Parameters:
	 * 		struct FGameplayAttributeData                      OldValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UDCAttributeSet::OnRep_PhysicalDamageWeaponPrimary(const struct FGameplayAttributeData& OldValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAttributeSet.OnRep_PhysicalDamageWeaponPrimary");
		
		UDCAttributeSet_OnRep_PhysicalDamageWeaponPrimary_Params params {};
		params.OldValue = OldValue;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0176CCB0
	 * 		Name   -> Function DungeonCrawler.DCAttributeSet.OnRep_PhysicalDamageTrue
	 * 		Flags  -> (Native, Protected, HasOutParms)
	 * Parameters:
	 * 		struct FGameplayAttributeData                      OldValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UDCAttributeSet::OnRep_PhysicalDamageTrue(const struct FGameplayAttributeData& OldValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAttributeSet.OnRep_PhysicalDamageTrue");
		
		UDCAttributeSet_OnRep_PhysicalDamageTrue_Params params {};
		params.OldValue = OldValue;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0176CC00
	 * 		Name   -> Function DungeonCrawler.DCAttributeSet.OnRep_PhysicalDamageMod
	 * 		Flags  -> (Native, Protected, HasOutParms)
	 * Parameters:
	 * 		struct FGameplayAttributeData                      OldValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UDCAttributeSet::OnRep_PhysicalDamageMod(const struct FGameplayAttributeData& OldValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAttributeSet.OnRep_PhysicalDamageMod");
		
		UDCAttributeSet_OnRep_PhysicalDamageMod_Params params {};
		params.OldValue = OldValue;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0176CB50
	 * 		Name   -> Function DungeonCrawler.DCAttributeSet.OnRep_PhysicalDamageBase
	 * 		Flags  -> (Native, Protected, HasOutParms)
	 * Parameters:
	 * 		struct FGameplayAttributeData                      OldValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UDCAttributeSet::OnRep_PhysicalDamageBase(const struct FGameplayAttributeData& OldValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAttributeSet.OnRep_PhysicalDamageBase");
		
		UDCAttributeSet_OnRep_PhysicalDamageBase_Params params {};
		params.OldValue = OldValue;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0176CAA0
	 * 		Name   -> Function DungeonCrawler.DCAttributeSet.OnRep_PhysicalDamageAdd
	 * 		Flags  -> (Native, Protected, HasOutParms)
	 * Parameters:
	 * 		struct FGameplayAttributeData                      OldValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UDCAttributeSet::OnRep_PhysicalDamageAdd(const struct FGameplayAttributeData& OldValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAttributeSet.OnRep_PhysicalDamageAdd");
		
		UDCAttributeSet_OnRep_PhysicalDamageAdd_Params params {};
		params.OldValue = OldValue;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0176C9F0
	 * 		Name   -> Function DungeonCrawler.DCAttributeSet.OnRep_PhysicalBackstabPower
	 * 		Flags  -> (Native, Protected, HasOutParms)
	 * Parameters:
	 * 		struct FGameplayAttributeData                      OldValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UDCAttributeSet::OnRep_PhysicalBackstabPower(const struct FGameplayAttributeData& OldValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAttributeSet.OnRep_PhysicalBackstabPower");
		
		UDCAttributeSet_OnRep_PhysicalBackstabPower_Params params {};
		params.OldValue = OldValue;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0176C940
	 * 		Name   -> Function DungeonCrawler.DCAttributeSet.OnRep_PhysicalAbsoluteReduction
	 * 		Flags  -> (Native, Protected, HasOutParms)
	 * Parameters:
	 * 		struct FGameplayAttributeData                      OldValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UDCAttributeSet::OnRep_PhysicalAbsoluteReduction(const struct FGameplayAttributeData& OldValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAttributeSet.OnRep_PhysicalAbsoluteReduction");
		
		UDCAttributeSet_OnRep_PhysicalAbsoluteReduction_Params params {};
		params.OldValue = OldValue;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0176C890
	 * 		Name   -> Function DungeonCrawler.DCAttributeSet.OnRep_MoveSpeedWithModifier
	 * 		Flags  -> (Native, Protected, HasOutParms)
	 * Parameters:
	 * 		struct FGameplayAttributeData                      OldValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UDCAttributeSet::OnRep_MoveSpeedWithModifier(const struct FGameplayAttributeData& OldValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAttributeSet.OnRep_MoveSpeedWithModifier");
		
		UDCAttributeSet_OnRep_MoveSpeedWithModifier_Params params {};
		params.OldValue = OldValue;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0176C7E0
	 * 		Name   -> Function DungeonCrawler.DCAttributeSet.OnRep_MoveSpeedMod
	 * 		Flags  -> (Native, Protected, HasOutParms)
	 * Parameters:
	 * 		struct FGameplayAttributeData                      OldValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UDCAttributeSet::OnRep_MoveSpeedMod(const struct FGameplayAttributeData& OldValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAttributeSet.OnRep_MoveSpeedMod");
		
		UDCAttributeSet_OnRep_MoveSpeedMod_Params params {};
		params.OldValue = OldValue;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0176C730
	 * 		Name   -> Function DungeonCrawler.DCAttributeSet.OnRep_MoveSpeedBase
	 * 		Flags  -> (Native, Protected, HasOutParms)
	 * Parameters:
	 * 		struct FGameplayAttributeData                      OldValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UDCAttributeSet::OnRep_MoveSpeedBase(const struct FGameplayAttributeData& OldValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAttributeSet.OnRep_MoveSpeedBase");
		
		UDCAttributeSet_OnRep_MoveSpeedBase_Params params {};
		params.OldValue = OldValue;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0176C680
	 * 		Name   -> Function DungeonCrawler.DCAttributeSet.OnRep_MoveSpeedArmorPenaltyMod
	 * 		Flags  -> (Native, Protected, HasOutParms)
	 * Parameters:
	 * 		struct FGameplayAttributeData                      OldValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UDCAttributeSet::OnRep_MoveSpeedArmorPenaltyMod(const struct FGameplayAttributeData& OldValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAttributeSet.OnRep_MoveSpeedArmorPenaltyMod");
		
		UDCAttributeSet_OnRep_MoveSpeedArmorPenaltyMod_Params params {};
		params.OldValue = OldValue;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0176C5D0
	 * 		Name   -> Function DungeonCrawler.DCAttributeSet.OnRep_MoveSpeedArmorPenalty
	 * 		Flags  -> (Native, Protected, HasOutParms)
	 * Parameters:
	 * 		struct FGameplayAttributeData                      OldValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UDCAttributeSet::OnRep_MoveSpeedArmorPenalty(const struct FGameplayAttributeData& OldValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAttributeSet.OnRep_MoveSpeedArmorPenalty");
		
		UDCAttributeSet_OnRep_MoveSpeedArmorPenalty_Params params {};
		params.OldValue = OldValue;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0176C520
	 * 		Name   -> Function DungeonCrawler.DCAttributeSet.OnRep_MoveSpeedAdd
	 * 		Flags  -> (Native, Protected, HasOutParms)
	 * Parameters:
	 * 		struct FGameplayAttributeData                      OldValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UDCAttributeSet::OnRep_MoveSpeedAdd(const struct FGameplayAttributeData& OldValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAttributeSet.OnRep_MoveSpeedAdd");
		
		UDCAttributeSet_OnRep_MoveSpeedAdd_Params params {};
		params.OldValue = OldValue;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0176C470
	 * 		Name   -> Function DungeonCrawler.DCAttributeSet.OnRep_MoveSpeed
	 * 		Flags  -> (Native, Protected, HasOutParms)
	 * Parameters:
	 * 		struct FGameplayAttributeData                      OldValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UDCAttributeSet::OnRep_MoveSpeed(const struct FGameplayAttributeData& OldValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAttributeSet.OnRep_MoveSpeed");
		
		UDCAttributeSet_OnRep_MoveSpeed_Params params {};
		params.OldValue = OldValue;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0176C3C0
	 * 		Name   -> Function DungeonCrawler.DCAttributeSet.OnRep_MaxTotalShield
	 * 		Flags  -> (Native, Protected, HasOutParms)
	 * Parameters:
	 * 		struct FGameplayAttributeData                      OldValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UDCAttributeSet::OnRep_MaxTotalShield(const struct FGameplayAttributeData& OldValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAttributeSet.OnRep_MaxTotalShield");
		
		UDCAttributeSet_OnRep_MaxTotalShield_Params params {};
		params.OldValue = OldValue;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0176C310
	 * 		Name   -> Function DungeonCrawler.DCAttributeSet.OnRep_MaxPhysicalShield
	 * 		Flags  -> (Native, Protected, HasOutParms)
	 * Parameters:
	 * 		struct FGameplayAttributeData                      OldValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UDCAttributeSet::OnRep_MaxPhysicalShield(const struct FGameplayAttributeData& OldValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAttributeSet.OnRep_MaxPhysicalShield");
		
		UDCAttributeSet_OnRep_MaxPhysicalShield_Params params {};
		params.OldValue = OldValue;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0176C260
	 * 		Name   -> Function DungeonCrawler.DCAttributeSet.OnRep_MaxMagicalShield
	 * 		Flags  -> (Native, Protected, HasOutParms)
	 * Parameters:
	 * 		struct FGameplayAttributeData                      OldValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UDCAttributeSet::OnRep_MaxMagicalShield(const struct FGameplayAttributeData& OldValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAttributeSet.OnRep_MaxMagicalShield");
		
		UDCAttributeSet_OnRep_MaxMagicalShield_Params params {};
		params.OldValue = OldValue;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0176C1B0
	 * 		Name   -> Function DungeonCrawler.DCAttributeSet.OnRep_MaxImpactEndurance
	 * 		Flags  -> (Native, Protected, HasOutParms)
	 * Parameters:
	 * 		struct FGameplayAttributeData                      OldValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UDCAttributeSet::OnRep_MaxImpactEndurance(const struct FGameplayAttributeData& OldValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAttributeSet.OnRep_MaxImpactEndurance");
		
		UDCAttributeSet_OnRep_MaxImpactEndurance_Params params {};
		params.OldValue = OldValue;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0176C100
	 * 		Name   -> Function DungeonCrawler.DCAttributeSet.OnRep_MaxHealthMod
	 * 		Flags  -> (Native, Protected, HasOutParms)
	 * Parameters:
	 * 		struct FGameplayAttributeData                      OldValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UDCAttributeSet::OnRep_MaxHealthMod(const struct FGameplayAttributeData& OldValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAttributeSet.OnRep_MaxHealthMod");
		
		UDCAttributeSet_OnRep_MaxHealthMod_Params params {};
		params.OldValue = OldValue;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0176C050
	 * 		Name   -> Function DungeonCrawler.DCAttributeSet.OnRep_MaxHealthBase
	 * 		Flags  -> (Native, Protected, HasOutParms)
	 * Parameters:
	 * 		struct FGameplayAttributeData                      OldValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UDCAttributeSet::OnRep_MaxHealthBase(const struct FGameplayAttributeData& OldValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAttributeSet.OnRep_MaxHealthBase");
		
		UDCAttributeSet_OnRep_MaxHealthBase_Params params {};
		params.OldValue = OldValue;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0176BFA0
	 * 		Name   -> Function DungeonCrawler.DCAttributeSet.OnRep_MaxHealthAdd
	 * 		Flags  -> (Native, Protected, HasOutParms)
	 * Parameters:
	 * 		struct FGameplayAttributeData                      OldValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UDCAttributeSet::OnRep_MaxHealthAdd(const struct FGameplayAttributeData& OldValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAttributeSet.OnRep_MaxHealthAdd");
		
		UDCAttributeSet_OnRep_MaxHealthAdd_Params params {};
		params.OldValue = OldValue;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0176BEF0
	 * 		Name   -> Function DungeonCrawler.DCAttributeSet.OnRep_MaxHealth
	 * 		Flags  -> (Native, Protected, HasOutParms)
	 * Parameters:
	 * 		struct FGameplayAttributeData                      OldValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UDCAttributeSet::OnRep_MaxHealth(const struct FGameplayAttributeData& OldValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAttributeSet.OnRep_MaxHealth");
		
		UDCAttributeSet_OnRep_MaxHealth_Params params {};
		params.OldValue = OldValue;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0176B130
	 * 		Name   -> Function DungeonCrawler.DCAttributeSet.OnRep_MagicResistance
	 * 		Flags  -> (Native, Protected, HasOutParms)
	 * Parameters:
	 * 		struct FGameplayAttributeData                      OldValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UDCAttributeSet::OnRep_MagicResistance(const struct FGameplayAttributeData& OldValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAttributeSet.OnRep_MagicResistance");
		
		UDCAttributeSet_OnRep_MagicResistance_Params params {};
		params.OldValue = OldValue;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0176B080
	 * 		Name   -> Function DungeonCrawler.DCAttributeSet.OnRep_MagicPenetration
	 * 		Flags  -> (Native, Protected, HasOutParms)
	 * Parameters:
	 * 		struct FGameplayAttributeData                      OldValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UDCAttributeSet::OnRep_MagicPenetration(const struct FGameplayAttributeData& OldValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAttributeSet.OnRep_MagicPenetration");
		
		UDCAttributeSet_OnRep_MagicPenetration_Params params {};
		params.OldValue = OldValue;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0176BE40
	 * 		Name   -> Function DungeonCrawler.DCAttributeSet.OnRep_MagicalShield
	 * 		Flags  -> (Native, Protected, HasOutParms)
	 * Parameters:
	 * 		struct FGameplayAttributeData                      OldValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UDCAttributeSet::OnRep_MagicalShield(const struct FGameplayAttributeData& OldValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAttributeSet.OnRep_MagicalShield");
		
		UDCAttributeSet_OnRep_MagicalShield_Params params {};
		params.OldValue = OldValue;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0176BD90
	 * 		Name   -> Function DungeonCrawler.DCAttributeSet.OnRep_MagicalReductionMod
	 * 		Flags  -> (Native, Protected, HasOutParms)
	 * Parameters:
	 * 		struct FGameplayAttributeData                      OldValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UDCAttributeSet::OnRep_MagicalReductionMod(const struct FGameplayAttributeData& OldValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAttributeSet.OnRep_MagicalReductionMod");
		
		UDCAttributeSet_OnRep_MagicalReductionMod_Params params {};
		params.OldValue = OldValue;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0176BCE0
	 * 		Name   -> Function DungeonCrawler.DCAttributeSet.OnRep_MagicalReduction
	 * 		Flags  -> (Native, Protected, HasOutParms)
	 * Parameters:
	 * 		struct FGameplayAttributeData                      OldValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UDCAttributeSet::OnRep_MagicalReduction(const struct FGameplayAttributeData& OldValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAttributeSet.OnRep_MagicalReduction");
		
		UDCAttributeSet_OnRep_MagicalReduction_Params params {};
		params.OldValue = OldValue;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0176BC30
	 * 		Name   -> Function DungeonCrawler.DCAttributeSet.OnRep_MagicalPower
	 * 		Flags  -> (Native, Protected, HasOutParms)
	 * Parameters:
	 * 		struct FGameplayAttributeData                      OldValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UDCAttributeSet::OnRep_MagicalPower(const struct FGameplayAttributeData& OldValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAttributeSet.OnRep_MagicalPower");
		
		UDCAttributeSet_OnRep_MagicalPower_Params params {};
		params.OldValue = OldValue;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0176BB80
	 * 		Name   -> Function DungeonCrawler.DCAttributeSet.OnRep_MagicalInteractionSpeed
	 * 		Flags  -> (Native, Protected, HasOutParms)
	 * Parameters:
	 * 		struct FGameplayAttributeData                      OldValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UDCAttributeSet::OnRep_MagicalInteractionSpeed(const struct FGameplayAttributeData& OldValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAttributeSet.OnRep_MagicalInteractionSpeed");
		
		UDCAttributeSet_OnRep_MagicalInteractionSpeed_Params params {};
		params.OldValue = OldValue;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0176BAD0
	 * 		Name   -> Function DungeonCrawler.DCAttributeSet.OnRep_MagicalHealBase
	 * 		Flags  -> (Native, Protected, HasOutParms)
	 * Parameters:
	 * 		struct FGameplayAttributeData                      OldValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UDCAttributeSet::OnRep_MagicalHealBase(const struct FGameplayAttributeData& OldValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAttributeSet.OnRep_MagicalHealBase");
		
		UDCAttributeSet_OnRep_MagicalHealBase_Params params {};
		params.OldValue = OldValue;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0176BA20
	 * 		Name   -> Function DungeonCrawler.DCAttributeSet.OnRep_MagicalFireDamageMod
	 * 		Flags  -> (Native, Protected, HasOutParms)
	 * Parameters:
	 * 		struct FGameplayAttributeData                      OldValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UDCAttributeSet::OnRep_MagicalFireDamageMod(const struct FGameplayAttributeData& OldValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAttributeSet.OnRep_MagicalFireDamageMod");
		
		UDCAttributeSet_OnRep_MagicalFireDamageMod_Params params {};
		params.OldValue = OldValue;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0176B970
	 * 		Name   -> Function DungeonCrawler.DCAttributeSet.OnRep_MagicalFireDamageBase
	 * 		Flags  -> (Native, Protected, HasOutParms)
	 * Parameters:
	 * 		struct FGameplayAttributeData                      OldValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UDCAttributeSet::OnRep_MagicalFireDamageBase(const struct FGameplayAttributeData& OldValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAttributeSet.OnRep_MagicalFireDamageBase");
		
		UDCAttributeSet_OnRep_MagicalFireDamageBase_Params params {};
		params.OldValue = OldValue;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0176B8C0
	 * 		Name   -> Function DungeonCrawler.DCAttributeSet.OnRep_MagicalFireDamageAdd
	 * 		Flags  -> (Native, Protected, HasOutParms)
	 * Parameters:
	 * 		struct FGameplayAttributeData                      OldValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UDCAttributeSet::OnRep_MagicalFireDamageAdd(const struct FGameplayAttributeData& OldValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAttributeSet.OnRep_MagicalFireDamageAdd");
		
		UDCAttributeSet_OnRep_MagicalFireDamageAdd_Params params {};
		params.OldValue = OldValue;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0176B810
	 * 		Name   -> Function DungeonCrawler.DCAttributeSet.OnRep_MagicalDamageWeaponSecondary
	 * 		Flags  -> (Native, Protected, HasOutParms)
	 * Parameters:
	 * 		struct FGameplayAttributeData                      OldValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UDCAttributeSet::OnRep_MagicalDamageWeaponSecondary(const struct FGameplayAttributeData& OldValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAttributeSet.OnRep_MagicalDamageWeaponSecondary");
		
		UDCAttributeSet_OnRep_MagicalDamageWeaponSecondary_Params params {};
		params.OldValue = OldValue;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0176B760
	 * 		Name   -> Function DungeonCrawler.DCAttributeSet.OnRep_MagicalDamageWeaponPrimary
	 * 		Flags  -> (Native, Protected, HasOutParms)
	 * Parameters:
	 * 		struct FGameplayAttributeData                      OldValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UDCAttributeSet::OnRep_MagicalDamageWeaponPrimary(const struct FGameplayAttributeData& OldValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAttributeSet.OnRep_MagicalDamageWeaponPrimary");
		
		UDCAttributeSet_OnRep_MagicalDamageWeaponPrimary_Params params {};
		params.OldValue = OldValue;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0176B6B0
	 * 		Name   -> Function DungeonCrawler.DCAttributeSet.OnRep_MagicalDamageTrue
	 * 		Flags  -> (Native, Protected, HasOutParms)
	 * Parameters:
	 * 		struct FGameplayAttributeData                      OldValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UDCAttributeSet::OnRep_MagicalDamageTrue(const struct FGameplayAttributeData& OldValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAttributeSet.OnRep_MagicalDamageTrue");
		
		UDCAttributeSet_OnRep_MagicalDamageTrue_Params params {};
		params.OldValue = OldValue;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0176B600
	 * 		Name   -> Function DungeonCrawler.DCAttributeSet.OnRep_MagicalDamageMod
	 * 		Flags  -> (Native, Protected, HasOutParms)
	 * Parameters:
	 * 		struct FGameplayAttributeData                      OldValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UDCAttributeSet::OnRep_MagicalDamageMod(const struct FGameplayAttributeData& OldValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAttributeSet.OnRep_MagicalDamageMod");
		
		UDCAttributeSet_OnRep_MagicalDamageMod_Params params {};
		params.OldValue = OldValue;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0176B550
	 * 		Name   -> Function DungeonCrawler.DCAttributeSet.OnRep_MagicalDamageBase
	 * 		Flags  -> (Native, Protected, HasOutParms)
	 * Parameters:
	 * 		struct FGameplayAttributeData                      OldValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UDCAttributeSet::OnRep_MagicalDamageBase(const struct FGameplayAttributeData& OldValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAttributeSet.OnRep_MagicalDamageBase");
		
		UDCAttributeSet_OnRep_MagicalDamageBase_Params params {};
		params.OldValue = OldValue;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0176B4A0
	 * 		Name   -> Function DungeonCrawler.DCAttributeSet.OnRep_MagicalDamageAdd
	 * 		Flags  -> (Native, Protected, HasOutParms)
	 * Parameters:
	 * 		struct FGameplayAttributeData                      OldValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UDCAttributeSet::OnRep_MagicalDamageAdd(const struct FGameplayAttributeData& OldValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAttributeSet.OnRep_MagicalDamageAdd");
		
		UDCAttributeSet_OnRep_MagicalDamageAdd_Params params {};
		params.OldValue = OldValue;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0176B3F0
	 * 		Name   -> Function DungeonCrawler.DCAttributeSet.OnRep_MagicalArcaneDamageMod
	 * 		Flags  -> (Native, Protected, HasOutParms)
	 * Parameters:
	 * 		struct FGameplayAttributeData                      OldValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UDCAttributeSet::OnRep_MagicalArcaneDamageMod(const struct FGameplayAttributeData& OldValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAttributeSet.OnRep_MagicalArcaneDamageMod");
		
		UDCAttributeSet_OnRep_MagicalArcaneDamageMod_Params params {};
		params.OldValue = OldValue;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0176B340
	 * 		Name   -> Function DungeonCrawler.DCAttributeSet.OnRep_MagicalArcaneDamageBase
	 * 		Flags  -> (Native, Protected, HasOutParms)
	 * Parameters:
	 * 		struct FGameplayAttributeData                      OldValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UDCAttributeSet::OnRep_MagicalArcaneDamageBase(const struct FGameplayAttributeData& OldValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAttributeSet.OnRep_MagicalArcaneDamageBase");
		
		UDCAttributeSet_OnRep_MagicalArcaneDamageBase_Params params {};
		params.OldValue = OldValue;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0176B290
	 * 		Name   -> Function DungeonCrawler.DCAttributeSet.OnRep_MagicalArcaneDamageAdd
	 * 		Flags  -> (Native, Protected, HasOutParms)
	 * Parameters:
	 * 		struct FGameplayAttributeData                      OldValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UDCAttributeSet::OnRep_MagicalArcaneDamageAdd(const struct FGameplayAttributeData& OldValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAttributeSet.OnRep_MagicalArcaneDamageAdd");
		
		UDCAttributeSet_OnRep_MagicalArcaneDamageAdd_Params params {};
		params.OldValue = OldValue;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0176B1E0
	 * 		Name   -> Function DungeonCrawler.DCAttributeSet.OnRep_MagicalAbsoluteReduction
	 * 		Flags  -> (Native, Protected, HasOutParms)
	 * Parameters:
	 * 		struct FGameplayAttributeData                      OldValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UDCAttributeSet::OnRep_MagicalAbsoluteReduction(const struct FGameplayAttributeData& OldValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAttributeSet.OnRep_MagicalAbsoluteReduction");
		
		UDCAttributeSet_OnRep_MagicalAbsoluteReduction_Params params {};
		params.OldValue = OldValue;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0176AFD0
	 * 		Name   -> Function DungeonCrawler.DCAttributeSet.OnRep_KnowledgeMod
	 * 		Flags  -> (Native, Protected, HasOutParms)
	 * Parameters:
	 * 		struct FGameplayAttributeData                      OldValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UDCAttributeSet::OnRep_KnowledgeMod(const struct FGameplayAttributeData& OldValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAttributeSet.OnRep_KnowledgeMod");
		
		UDCAttributeSet_OnRep_KnowledgeMod_Params params {};
		params.OldValue = OldValue;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0176AF20
	 * 		Name   -> Function DungeonCrawler.DCAttributeSet.OnRep_KnowledgeBase
	 * 		Flags  -> (Native, Protected, HasOutParms)
	 * Parameters:
	 * 		struct FGameplayAttributeData                      OldValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UDCAttributeSet::OnRep_KnowledgeBase(const struct FGameplayAttributeData& OldValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAttributeSet.OnRep_KnowledgeBase");
		
		UDCAttributeSet_OnRep_KnowledgeBase_Params params {};
		params.OldValue = OldValue;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0176AE70
	 * 		Name   -> Function DungeonCrawler.DCAttributeSet.OnRep_Knowledge
	 * 		Flags  -> (Native, Protected, HasOutParms)
	 * Parameters:
	 * 		struct FGameplayAttributeData                      OldValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UDCAttributeSet::OnRep_Knowledge(const struct FGameplayAttributeData& OldValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAttributeSet.OnRep_Knowledge");
		
		UDCAttributeSet_OnRep_Knowledge_Params params {};
		params.OldValue = OldValue;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0176ADC0
	 * 		Name   -> Function DungeonCrawler.DCAttributeSet.OnRep_ItemEquipSpeed
	 * 		Flags  -> (Native, Protected, HasOutParms)
	 * Parameters:
	 * 		struct FGameplayAttributeData                      OldValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UDCAttributeSet::OnRep_ItemEquipSpeed(const struct FGameplayAttributeData& OldValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAttributeSet.OnRep_ItemEquipSpeed");
		
		UDCAttributeSet_OnRep_ItemEquipSpeed_Params params {};
		params.OldValue = OldValue;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0176AD10
	 * 		Name   -> Function DungeonCrawler.DCAttributeSet.OnRep_ItemArmorRatingMod
	 * 		Flags  -> (Native, Protected, HasOutParms)
	 * Parameters:
	 * 		struct FGameplayAttributeData                      OldValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UDCAttributeSet::OnRep_ItemArmorRatingMod(const struct FGameplayAttributeData& OldValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAttributeSet.OnRep_ItemArmorRatingMod");
		
		UDCAttributeSet_OnRep_ItemArmorRatingMod_Params params {};
		params.OldValue = OldValue;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0176AC60
	 * 		Name   -> Function DungeonCrawler.DCAttributeSet.OnRep_ItemArmorRating
	 * 		Flags  -> (Native, Protected, HasOutParms)
	 * Parameters:
	 * 		struct FGameplayAttributeData                      OldValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UDCAttributeSet::OnRep_ItemArmorRating(const struct FGameplayAttributeData& OldValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAttributeSet.OnRep_ItemArmorRating");
		
		UDCAttributeSet_OnRep_ItemArmorRating_Params params {};
		params.OldValue = OldValue;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0176ABB0
	 * 		Name   -> Function DungeonCrawler.DCAttributeSet.OnRep_ImpactResistance
	 * 		Flags  -> (Native, Protected, HasOutParms)
	 * Parameters:
	 * 		struct FGameplayAttributeData                      OldValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UDCAttributeSet::OnRep_ImpactResistance(const struct FGameplayAttributeData& OldValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAttributeSet.OnRep_ImpactResistance");
		
		UDCAttributeSet_OnRep_ImpactResistance_Params params {};
		params.OldValue = OldValue;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0176AB00
	 * 		Name   -> Function DungeonCrawler.DCAttributeSet.OnRep_ImpactPower
	 * 		Flags  -> (Native, Protected, HasOutParms)
	 * Parameters:
	 * 		struct FGameplayAttributeData                      OldValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UDCAttributeSet::OnRep_ImpactPower(const struct FGameplayAttributeData& OldValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAttributeSet.OnRep_ImpactPower");
		
		UDCAttributeSet_OnRep_ImpactPower_Params params {};
		params.OldValue = OldValue;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0176AA50
	 * 		Name   -> Function DungeonCrawler.DCAttributeSet.OnRep_ImpactEndurance
	 * 		Flags  -> (Native, Protected, HasOutParms)
	 * Parameters:
	 * 		struct FGameplayAttributeData                      OldValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UDCAttributeSet::OnRep_ImpactEndurance(const struct FGameplayAttributeData& OldValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAttributeSet.OnRep_ImpactEndurance");
		
		UDCAttributeSet_OnRep_ImpactEndurance_Params params {};
		params.OldValue = OldValue;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0176A9A0
	 * 		Name   -> Function DungeonCrawler.DCAttributeSet.OnRep_Health
	 * 		Flags  -> (Native, Protected, HasOutParms)
	 * Parameters:
	 * 		struct FGameplayAttributeData                      OldValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UDCAttributeSet::OnRep_Health(const struct FGameplayAttributeData& OldValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAttributeSet.OnRep_Health");
		
		UDCAttributeSet_OnRep_Health_Params params {};
		params.OldValue = OldValue;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0176A8F0
	 * 		Name   -> Function DungeonCrawler.DCAttributeSet.OnRep_HeadshotReductionMod
	 * 		Flags  -> (Native, Protected, HasOutParms)
	 * Parameters:
	 * 		struct FGameplayAttributeData                      OldValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UDCAttributeSet::OnRep_HeadshotReductionMod(const struct FGameplayAttributeData& OldValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAttributeSet.OnRep_HeadshotReductionMod");
		
		UDCAttributeSet_OnRep_HeadshotReductionMod_Params params {};
		params.OldValue = OldValue;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0176A840
	 * 		Name   -> Function DungeonCrawler.DCAttributeSet.OnRep_DebuffDurationMod
	 * 		Flags  -> (Native, Protected, HasOutParms)
	 * Parameters:
	 * 		struct FGameplayAttributeData                      OldValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UDCAttributeSet::OnRep_DebuffDurationMod(const struct FGameplayAttributeData& OldValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAttributeSet.OnRep_DebuffDurationMod");
		
		UDCAttributeSet_OnRep_DebuffDurationMod_Params params {};
		params.OldValue = OldValue;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0176A790
	 * 		Name   -> Function DungeonCrawler.DCAttributeSet.OnRep_BuffDurationMod
	 * 		Flags  -> (Native, Protected, HasOutParms)
	 * Parameters:
	 * 		struct FGameplayAttributeData                      OldValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UDCAttributeSet::OnRep_BuffDurationMod(const struct FGameplayAttributeData& OldValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAttributeSet.OnRep_BuffDurationMod");
		
		UDCAttributeSet_OnRep_BuffDurationMod_Params params {};
		params.OldValue = OldValue;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0176A6E0
	 * 		Name   -> Function DungeonCrawler.DCAttributeSet.OnRep_ArmorRating
	 * 		Flags  -> (Native, Protected, HasOutParms)
	 * Parameters:
	 * 		struct FGameplayAttributeData                      OldValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UDCAttributeSet::OnRep_ArmorRating(const struct FGameplayAttributeData& OldValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAttributeSet.OnRep_ArmorRating");
		
		UDCAttributeSet_OnRep_ArmorRating_Params params {};
		params.OldValue = OldValue;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0176A630
	 * 		Name   -> Function DungeonCrawler.DCAttributeSet.OnRep_ArmorPenetration
	 * 		Flags  -> (Native, Protected, HasOutParms)
	 * Parameters:
	 * 		struct FGameplayAttributeData                      OldValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UDCAttributeSet::OnRep_ArmorPenetration(const struct FGameplayAttributeData& OldValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAttributeSet.OnRep_ArmorPenetration");
		
		UDCAttributeSet_OnRep_ArmorPenetration_Params params {};
		params.OldValue = OldValue;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0176A580
	 * 		Name   -> Function DungeonCrawler.DCAttributeSet.OnRep_AgilityMod
	 * 		Flags  -> (Native, Protected, HasOutParms)
	 * Parameters:
	 * 		struct FGameplayAttributeData                      OldValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UDCAttributeSet::OnRep_AgilityMod(const struct FGameplayAttributeData& OldValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAttributeSet.OnRep_AgilityMod");
		
		UDCAttributeSet_OnRep_AgilityMod_Params params {};
		params.OldValue = OldValue;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0176A4D0
	 * 		Name   -> Function DungeonCrawler.DCAttributeSet.OnRep_AgilityBase
	 * 		Flags  -> (Native, Protected, HasOutParms)
	 * Parameters:
	 * 		struct FGameplayAttributeData                      OldValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UDCAttributeSet::OnRep_AgilityBase(const struct FGameplayAttributeData& OldValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAttributeSet.OnRep_AgilityBase");
		
		UDCAttributeSet_OnRep_AgilityBase_Params params {};
		params.OldValue = OldValue;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0176A420
	 * 		Name   -> Function DungeonCrawler.DCAttributeSet.OnRep_Agility
	 * 		Flags  -> (Native, Protected, HasOutParms)
	 * Parameters:
	 * 		struct FGameplayAttributeData                      OldValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UDCAttributeSet::OnRep_Agility(const struct FGameplayAttributeData& OldValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAttributeSet.OnRep_Agility");
		
		UDCAttributeSet_OnRep_Agility_Params params {};
		params.OldValue = OldValue;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0176A370
	 * 		Name   -> Function DungeonCrawler.DCAttributeSet.OnRep_ActionSpeed
	 * 		Flags  -> (Native, Protected, HasOutParms)
	 * Parameters:
	 * 		struct FGameplayAttributeData                      OldValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UDCAttributeSet::OnRep_ActionSpeed(const struct FGameplayAttributeData& OldValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAttributeSet.OnRep_ActionSpeed");
		
		UDCAttributeSet_OnRep_ActionSpeed_Params params {};
		params.OldValue = OldValue;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDCAttributeSet.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDCAttributeSet::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCAttributeSet");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017711A0
	 * 		Name   -> Function DungeonCrawler.DCAT_DashToLocation.DashToLocation
	 * 		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		class UGameplayAbility*                            OwningAbility                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     DestLocation                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              AllowedDistance                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Speed                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               Teleport                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UDCAT_DashToLocation* UDCAT_DashToLocation::STATIC_DashToLocation(class UGameplayAbility* OwningAbility, const struct FVector& DestLocation, float AllowedDistance, float Speed, bool Teleport)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAT_DashToLocation.DashToLocation");
		
		UDCAT_DashToLocation_DashToLocation_Params params {};
		params.OwningAbility = OwningAbility;
		params.DestLocation = DestLocation;
		params.AllowedDistance = AllowedDistance;
		params.Speed = Speed;
		params.Teleport = Teleport;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDCAT_DashToLocation.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDCAT_DashToLocation::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCAT_DashToLocation");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01771440
	 * 		Name   -> Function DungeonCrawler.DCAT_InteractionSkillCheck.InteractionSkillCheck
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UGameplayAbility*                            OwningAbility                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FName                                        TaskInstanceName                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Duration                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              SucceedSectionStartTime                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              SucceedSectionEndTime                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              PerfectSucceedSectionStartTime                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              PerfectSucceedSectionEndTime                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UDCAT_InteractionSkillCheck* UDCAT_InteractionSkillCheck::STATIC_InteractionSkillCheck(class UGameplayAbility* OwningAbility, const class FName& TaskInstanceName, float Duration, float SucceedSectionStartTime, float SucceedSectionEndTime, float PerfectSucceedSectionStartTime, float PerfectSucceedSectionEndTime)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAT_InteractionSkillCheck.InteractionSkillCheck");
		
		UDCAT_InteractionSkillCheck_InteractionSkillCheck_Params params {};
		params.OwningAbility = OwningAbility;
		params.TaskInstanceName = TaskInstanceName;
		params.Duration = Duration;
		params.SucceedSectionStartTime = SucceedSectionStartTime;
		params.SucceedSectionEndTime = SucceedSectionEndTime;
		params.PerfectSucceedSectionStartTime = PerfectSucceedSectionStartTime;
		params.PerfectSucceedSectionEndTime = PerfectSucceedSectionEndTime;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDCAT_InteractionSkillCheck.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDCAT_InteractionSkillCheck::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCAT_InteractionSkillCheck");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01771660
	 * 		Name   -> Function DungeonCrawler.DCAT_MoveWithInputVectorCurve.MoveWithInputVectorCurve
	 * 		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		class UGameplayAbility*                            OwningAbility                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     DestLocation                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UCurveVector*                                InVelocityVector                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              DistanceTolerance                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bShouldTeleportWhenFinished                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UDCAT_MoveWithInputVectorCurve* UDCAT_MoveWithInputVectorCurve::STATIC_MoveWithInputVectorCurve(class UGameplayAbility* OwningAbility, const struct FVector& DestLocation, class UCurveVector* InVelocityVector, float DistanceTolerance, bool bShouldTeleportWhenFinished)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAT_MoveWithInputVectorCurve.MoveWithInputVectorCurve");
		
		UDCAT_MoveWithInputVectorCurve_MoveWithInputVectorCurve_Params params {};
		params.OwningAbility = OwningAbility;
		params.DestLocation = DestLocation;
		params.InVelocityVector = InVelocityVector;
		params.DistanceTolerance = DistanceTolerance;
		params.bShouldTeleportWhenFinished = bShouldTeleportWhenFinished;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017713B0
	 * 		Name   -> Function DungeonCrawler.DCAT_MoveWithInputVectorCurve.HandleTimelineUpdate
	 * 		Flags  -> (Final, Native, Protected, HasDefaults)
	 * Parameters:
	 * 		struct FVector                                     InVector                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UDCAT_MoveWithInputVectorCurve::HandleTimelineUpdate(const struct FVector& InVector)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAT_MoveWithInputVectorCurve.HandleTimelineUpdate");
		
		UDCAT_MoveWithInputVectorCurve_HandleTimelineUpdate_Params params {};
		params.InVector = InVector;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01771390
	 * 		Name   -> Function DungeonCrawler.DCAT_MoveWithInputVectorCurve.HandleTimelineFinished
	 * 		Flags  -> (Final, Native, Protected)
	 */
	void UDCAT_MoveWithInputVectorCurve::HandleTimelineFinished()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAT_MoveWithInputVectorCurve.HandleTimelineFinished");
		
		UDCAT_MoveWithInputVectorCurve_HandleTimelineFinished_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDCAT_MoveWithInputVectorCurve.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDCAT_MoveWithInputVectorCurve::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCAT_MoveWithInputVectorCurve");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01771D80
	 * 		Name   -> Function DungeonCrawler.DCAT_OverlapActorsInRadius.OverlapActorsInRadius
	 * 		Flags  -> (Final, Native, Static, Private, BlueprintCallable)
	 * Parameters:
	 * 		class UGameplayAbility*                            OwningAbility                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Radius                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FName                                        CollisionProfileName                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UClass*                                      OverlapTargetClass                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UDCAT_OverlapActorsInRadius* UDCAT_OverlapActorsInRadius::STATIC_OverlapActorsInRadius(class UGameplayAbility* OwningAbility, float Radius, const class FName& CollisionProfileName, class UClass* OverlapTargetClass)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAT_OverlapActorsInRadius.OverlapActorsInRadius");
		
		UDCAT_OverlapActorsInRadius_OverlapActorsInRadius_Params params {};
		params.OwningAbility = OwningAbility;
		params.Radius = Radius;
		params.CollisionProfileName = CollisionProfileName;
		params.OverlapTargetClass = OverlapTargetClass;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01771AA0
	 * 		Name   -> Function DungeonCrawler.DCAT_OverlapActorsInRadius.OnOverlapEnd
	 * 		Flags  -> (Final, Native, Protected)
	 * Parameters:
	 * 		class UPrimitiveComponent*                         OverlappedComponent                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      OtherActor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UPrimitiveComponent*                         OtherComp                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            OtherBodyIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UDCAT_OverlapActorsInRadius::OnOverlapEnd(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32_t OtherBodyIndex)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAT_OverlapActorsInRadius.OnOverlapEnd");
		
		UDCAT_OverlapActorsInRadius_OnOverlapEnd_Params params {};
		params.OverlappedComponent = OverlappedComponent;
		params.OtherActor = OtherActor;
		params.OtherComp = OtherComp;
		params.OtherBodyIndex = OtherBodyIndex;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01771830
	 * 		Name   -> Function DungeonCrawler.DCAT_OverlapActorsInRadius.OnOverlapBegin
	 * 		Flags  -> (Final, Native, Protected, HasOutParms)
	 * Parameters:
	 * 		class UPrimitiveComponent*                         OverlappedComponent                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      OtherActor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UPrimitiveComponent*                         OtherComp                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            OtherBodyIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bFromSweep                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FHitResult                                  SweepResult                                                (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	void UDCAT_OverlapActorsInRadius::OnOverlapBegin(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32_t OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAT_OverlapActorsInRadius.OnOverlapBegin");
		
		UDCAT_OverlapActorsInRadius_OnOverlapBegin_Params params {};
		params.OverlappedComponent = OverlappedComponent;
		params.OtherActor = OtherActor;
		params.OtherComp = OtherComp;
		params.OtherBodyIndex = OtherBodyIndex;
		params.bFromSweep = bFromSweep;
		params.SweepResult = SweepResult;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDCAT_OverlapActorsInRadius.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDCAT_OverlapActorsInRadius::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCAT_OverlapActorsInRadius");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01771EF0
	 * 		Name   -> Function DungeonCrawler.DCAT_PlayMontageAndWaitForEvent.PlayMontageAndWaitForEvent
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UGameplayAbility*                            OwningAbility                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FName                                        TaskInstanceName                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UAnimMontage*                                MontageToPlay                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FGameplayTagContainer                       EventTags                                                  (Parm, NativeAccessSpecifierPublic)
	 * 		float                                              Rate                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FName                                        StartSection                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bStopWhenAbilityEnds                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              AnimRootMotionTranslationScale                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              StartTimeSeconds                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UDCAT_PlayMontageAndWaitForEvent* UDCAT_PlayMontageAndWaitForEvent::STATIC_PlayMontageAndWaitForEvent(class UGameplayAbility* OwningAbility, const class FName& TaskInstanceName, class UAnimMontage* MontageToPlay, const struct FGameplayTagContainer& EventTags, float Rate, const class FName& StartSection, bool bStopWhenAbilityEnds, float AnimRootMotionTranslationScale, float StartTimeSeconds)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAT_PlayMontageAndWaitForEvent.PlayMontageAndWaitForEvent");
		
		UDCAT_PlayMontageAndWaitForEvent_PlayMontageAndWaitForEvent_Params params {};
		params.OwningAbility = OwningAbility;
		params.TaskInstanceName = TaskInstanceName;
		params.MontageToPlay = MontageToPlay;
		params.EventTags = EventTags;
		params.Rate = Rate;
		params.StartSection = StartSection;
		params.bStopWhenAbilityEnds = bStopWhenAbilityEnds;
		params.AnimRootMotionTranslationScale = AnimRootMotionTranslationScale;
		params.StartTimeSeconds = StartTimeSeconds;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDCAT_PlayMontageAndWaitForEvent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDCAT_PlayMontageAndWaitForEvent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCAT_PlayMontageAndWaitForEvent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01772250
	 * 		Name   -> Function DungeonCrawler.DCAT_RotateToActor.RotateToActor
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UGameplayAbility*                            OwningAbility                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      Actor                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EHitBoxType                                        HitBox                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Speed                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               WithoutPitch                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UDCAT_RotateToActor* UDCAT_RotateToActor::STATIC_RotateToActor(class UGameplayAbility* OwningAbility, class AActor* Actor, EHitBoxType HitBox, float Speed, bool WithoutPitch)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAT_RotateToActor.RotateToActor");
		
		UDCAT_RotateToActor_RotateToActor_Params params {};
		params.OwningAbility = OwningAbility;
		params.Actor = Actor;
		params.HitBox = HitBox;
		params.Speed = Speed;
		params.WithoutPitch = WithoutPitch;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDCAT_RotateToActor.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDCAT_RotateToActor::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCAT_RotateToActor");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017723F0
	 * 		Name   -> Function DungeonCrawler.DCAT_ServerWaitClientTargetData.ServerWaitForClientTargetData
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UGameplayAbility*                            OwningAbility                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FName                                        TaskInstanceName                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               TriggerOnce                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UDCAT_ServerWaitClientTargetData* UDCAT_ServerWaitClientTargetData::STATIC_ServerWaitForClientTargetData(class UGameplayAbility* OwningAbility, const class FName& TaskInstanceName, bool TriggerOnce)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAT_ServerWaitClientTargetData.ServerWaitForClientTargetData");
		
		UDCAT_ServerWaitClientTargetData_ServerWaitForClientTargetData_Params params {};
		params.OwningAbility = OwningAbility;
		params.TaskInstanceName = TaskInstanceName;
		params.TriggerOnce = TriggerOnce;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01771C00
	 * 		Name   -> Function DungeonCrawler.DCAT_ServerWaitClientTargetData.OnTargetDataReplicatedCallback
	 * 		Flags  -> (Final, Native, Public, HasOutParms)
	 * Parameters:
	 * 		struct FGameplayAbilityTargetDataHandle            Data                                                       (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		struct FGameplayTag                                ActivationTag                                              (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UDCAT_ServerWaitClientTargetData::OnTargetDataReplicatedCallback(const struct FGameplayAbilityTargetDataHandle& Data, const struct FGameplayTag& ActivationTag)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAT_ServerWaitClientTargetData.OnTargetDataReplicatedCallback");
		
		UDCAT_ServerWaitClientTargetData_OnTargetDataReplicatedCallback_Params params {};
		params.Data = Data;
		params.ActivationTag = ActivationTag;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDCAT_ServerWaitClientTargetData.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDCAT_ServerWaitClientTargetData::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCAT_ServerWaitClientTargetData");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017724F0
	 * 		Name   -> Function DungeonCrawler.DCAT_SpawnProjectile.SpawnProjectile
	 * 		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		class UGameplayAbility*                            OwningAbility                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UClass*                                      SpawnClass                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FTransform                                  SpawnTransform                                             (Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		float                                              FirePower                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UDCAT_SpawnProjectile* UDCAT_SpawnProjectile::STATIC_SpawnProjectile(class UGameplayAbility* OwningAbility, class UClass* SpawnClass, const struct FTransform& SpawnTransform, float FirePower)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAT_SpawnProjectile.SpawnProjectile");
		
		UDCAT_SpawnProjectile_SpawnProjectile_Params params {};
		params.OwningAbility = OwningAbility;
		params.SpawnClass = SpawnClass;
		params.SpawnTransform = SpawnTransform;
		params.FirePower = FirePower;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDCAT_SpawnProjectile.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDCAT_SpawnProjectile::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCAT_SpawnProjectile");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017726E0
	 * 		Name   -> Function DungeonCrawler.DCAT_TargetActorRadius.TargetActorRadius
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UGameplayAbility*                            OwningAbility                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Radius                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		ECollisionChannel                                  CollisionChannel                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UClass*                                      TargetingClass                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UDCAT_TargetActorRadius* UDCAT_TargetActorRadius::STATIC_TargetActorRadius(class UGameplayAbility* OwningAbility, float Radius, ECollisionChannel CollisionChannel, class UClass* TargetingClass)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAT_TargetActorRadius.TargetActorRadius");
		
		UDCAT_TargetActorRadius_TargetActorRadius_Params params {};
		params.OwningAbility = OwningAbility;
		params.Radius = Radius;
		params.CollisionChannel = CollisionChannel;
		params.TargetingClass = TargetingClass;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDCAT_TargetActorRadius.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDCAT_TargetActorRadius::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCAT_TargetActorRadius");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017728C0
	 * 		Name   -> Function DungeonCrawler.DCAT_WaitAimDirChangedFromLoc.WaitAimDirectionChangedFromLocation
	 * 		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		class UGameplayAbility*                            OwningAbility                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     InitialAimTargetLocation                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UDCAT_WaitAimDirChangedFromLoc* UDCAT_WaitAimDirChangedFromLoc::STATIC_WaitAimDirectionChangedFromLocation(class UGameplayAbility* OwningAbility, const struct FVector& InitialAimTargetLocation)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAT_WaitAimDirChangedFromLoc.WaitAimDirectionChangedFromLocation");
		
		UDCAT_WaitAimDirChangedFromLoc_WaitAimDirectionChangedFromLocation_Params params {};
		params.OwningAbility = OwningAbility;
		params.InitialAimTargetLocation = InitialAimTargetLocation;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDCAT_WaitAimDirChangedFromLoc.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDCAT_WaitAimDirChangedFromLoc::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCAT_WaitAimDirChangedFromLoc");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01772830
	 * 		Name   -> Function DungeonCrawler.DCAT_WaitAimDirectionChanged.WaitAimDirectionChanged
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UGameplayAbility*                            OwningAbility                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UDCAT_WaitAimDirectionChanged* UDCAT_WaitAimDirectionChanged::STATIC_WaitAimDirectionChanged(class UGameplayAbility* OwningAbility)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAT_WaitAimDirectionChanged.WaitAimDirectionChanged");
		
		UDCAT_WaitAimDirectionChanged_WaitAimDirectionChanged_Params params {};
		params.OwningAbility = OwningAbility;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDCAT_WaitAimDirectionChanged.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDCAT_WaitAimDirectionChanged::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCAT_WaitAimDirectionChanged");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01773250
	 * 		Name   -> Function DungeonCrawler.DCAT_WaitAttributeChangeByExecution.WaitForAttributesChange
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UGameplayAbility*                            OwningAbility                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		TArray<struct FGameplayAttribute>                  Attributes                                                 (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
	 * 		bool                                               TriggerOnce                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      OptionalExternalOwner                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UDCAT_WaitAttributeChangeByExecution* UDCAT_WaitAttributeChangeByExecution::STATIC_WaitForAttributesChange(class UGameplayAbility* OwningAbility, TArray<struct FGameplayAttribute> Attributes, bool TriggerOnce, class AActor* OptionalExternalOwner)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAT_WaitAttributeChangeByExecution.WaitForAttributesChange");
		
		UDCAT_WaitAttributeChangeByExecution_WaitForAttributesChange_Params params {};
		params.OwningAbility = OwningAbility;
		params.Attributes = Attributes;
		params.TriggerOnce = TriggerOnce;
		params.OptionalExternalOwner = OptionalExternalOwner;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01772FB0
	 * 		Name   -> Function DungeonCrawler.DCAT_WaitAttributeChangeByExecution.WaitForAttributeChange
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UGameplayAbility*                            OwningAbility                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FGameplayAttribute                          Attribute                                                  (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               TriggerOnce                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      OptionalExternalOwner                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UDCAT_WaitAttributeChangeByExecution* UDCAT_WaitAttributeChangeByExecution::STATIC_WaitForAttributeChange(class UGameplayAbility* OwningAbility, const struct FGameplayAttribute& Attribute, bool TriggerOnce, class AActor* OptionalExternalOwner)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAT_WaitAttributeChangeByExecution.WaitForAttributeChange");
		
		UDCAT_WaitAttributeChangeByExecution_WaitForAttributeChange_Params params {};
		params.OwningAbility = OwningAbility;
		params.Attribute = Attribute;
		params.TriggerOnce = TriggerOnce;
		params.OptionalExternalOwner = OptionalExternalOwner;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDCAT_WaitAttributeChangeByExecution.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDCAT_WaitAttributeChangeByExecution::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCAT_WaitAttributeChangeByExecution");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017729A0
	 * 		Name   -> Function DungeonCrawler.DCAT_WaitDelayPausable.WaitDelay
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UGameplayAbility*                            OwningAbility                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Duration                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UDCAT_WaitDelayPausable* UDCAT_WaitDelayPausable::STATIC_WaitDelay(class UGameplayAbility* OwningAbility, float Duration)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAT_WaitDelayPausable.WaitDelay");
		
		UDCAT_WaitDelayPausable_WaitDelay_Params params {};
		params.OwningAbility = OwningAbility;
		params.Duration = Duration;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01772230
	 * 		Name   -> Function DungeonCrawler.DCAT_WaitDelayPausable.ResumeTimer
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void UDCAT_WaitDelayPausable::ResumeTimer()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAT_WaitDelayPausable.ResumeTimer");
		
		UDCAT_WaitDelayPausable_ResumeTimer_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01771ED0
	 * 		Name   -> Function DungeonCrawler.DCAT_WaitDelayPausable.PauseTimer
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void UDCAT_WaitDelayPausable::PauseTimer()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAT_WaitDelayPausable.PauseTimer");
		
		UDCAT_WaitDelayPausable_PauseTimer_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01771360
	 * 		Name   -> Function DungeonCrawler.DCAT_WaitDelayPausable.GetElapsedTime
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	float UDCAT_WaitDelayPausable::GetElapsedTime()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAT_WaitDelayPausable.GetElapsedTime");
		
		UDCAT_WaitDelayPausable_GetElapsedTime_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01771120
	 * 		Name   -> Function DungeonCrawler.DCAT_WaitDelayPausable.AddTimerElapsedTimeRatio
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		float                                              AdditionalRatio                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UDCAT_WaitDelayPausable::AddTimerElapsedTimeRatio(float AdditionalRatio)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAT_WaitDelayPausable.AddTimerElapsedTimeRatio");
		
		UDCAT_WaitDelayPausable_AddTimerElapsedTimeRatio_Params params {};
		params.AdditionalRatio = AdditionalRatio;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDCAT_WaitDelayPausable.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDCAT_WaitDelayPausable::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCAT_WaitDelayPausable");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01772A70
	 * 		Name   -> Function DungeonCrawler.DCAT_WaitDelayRestartable.WaitDelay
	 * 		Flags  -> (Final, Native, Static, Private, BlueprintCallable)
	 * Parameters:
	 * 		class UGameplayAbility*                            OwningAbility                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Time                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UDCAT_WaitDelayRestartable* UDCAT_WaitDelayRestartable::STATIC_WaitDelay(class UGameplayAbility* OwningAbility, float Time)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAT_WaitDelayRestartable.WaitDelay");
		
		UDCAT_WaitDelayRestartable_WaitDelay_Params params {};
		params.OwningAbility = OwningAbility;
		params.Time = Time;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01772210
	 * 		Name   -> Function DungeonCrawler.DCAT_WaitDelayRestartable.RestartTimer
	 * 		Flags  -> (Final, Native, Private, BlueprintCallable)
	 */
	void UDCAT_WaitDelayRestartable::RestartTimer()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAT_WaitDelayRestartable.RestartTimer");
		
		UDCAT_WaitDelayRestartable_RestartTimer_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDCAT_WaitDelayRestartable.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDCAT_WaitDelayRestartable::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCAT_WaitDelayRestartable");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01772B40
	 * 		Name   -> Function DungeonCrawler.DCAT_WaitDistChangeFromActor.WaitDistanceChange
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UGameplayAbility*                            OwningAbility                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      TargetActor                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              MaximumDistance                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		ECollisionChannel                                  CollisionChannel                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UDCAT_WaitDistChangeFromActor* UDCAT_WaitDistChangeFromActor::STATIC_WaitDistanceChange(class UGameplayAbility* OwningAbility, class AActor* TargetActor, float MaximumDistance, ECollisionChannel CollisionChannel)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAT_WaitDistChangeFromActor.WaitDistanceChange");
		
		UDCAT_WaitDistChangeFromActor_WaitDistanceChange_Params params {};
		params.OwningAbility = OwningAbility;
		params.TargetActor = TargetActor;
		params.MaximumDistance = MaximumDistance;
		params.CollisionChannel = CollisionChannel;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDCAT_WaitDistChangeFromActor.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDCAT_WaitDistChangeFromActor::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCAT_WaitDistChangeFromActor");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01772C90
	 * 		Name   -> Function DungeonCrawler.DCAT_WaitDistChangeFromLocation.WaitDistanceChange
	 * 		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		class UGameplayAbility*                            OwningAbility                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     TargetLocation                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              MaximumDistance                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UDCAT_WaitDistChangeFromLocation* UDCAT_WaitDistChangeFromLocation::STATIC_WaitDistanceChange(class UGameplayAbility* OwningAbility, const struct FVector& TargetLocation, float MaximumDistance)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAT_WaitDistChangeFromLocation.WaitDistanceChange");
		
		UDCAT_WaitDistChangeFromLocation_WaitDistanceChange_Params params {};
		params.OwningAbility = OwningAbility;
		params.TargetLocation = TargetLocation;
		params.MaximumDistance = MaximumDistance;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDCAT_WaitDistChangeFromLocation.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDCAT_WaitDistChangeFromLocation::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCAT_WaitDistChangeFromLocation");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01772DD0
	 * 		Name   -> Function DungeonCrawler.DCAT_WaitDistChangeFromView.WaitDistanceChange
	 * 		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		class UGameplayAbility*                            OwningAbility                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      TargetActor                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     TargetLocation                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              MaximumDistance                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              CollisionRadius                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		ECollisionChannel                                  CollisionChannel                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UDCAT_WaitDistChangeFromView* UDCAT_WaitDistChangeFromView::STATIC_WaitDistanceChange(class UGameplayAbility* OwningAbility, class AActor* TargetActor, const struct FVector& TargetLocation, float MaximumDistance, float CollisionRadius, ECollisionChannel CollisionChannel)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAT_WaitDistChangeFromView.WaitDistanceChange");
		
		UDCAT_WaitDistChangeFromView_WaitDistanceChange_Params params {};
		params.OwningAbility = OwningAbility;
		params.TargetActor = TargetActor;
		params.TargetLocation = TargetLocation;
		params.MaximumDistance = MaximumDistance;
		params.CollisionRadius = CollisionRadius;
		params.CollisionChannel = CollisionChannel;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDCAT_WaitDistChangeFromView.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDCAT_WaitDistChangeFromView::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCAT_WaitDistChangeFromView");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01773400
	 * 		Name   -> Function DungeonCrawler.DCAT_WaitForCharacterUnCrouch.WaitForCharacterUnCrouch
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UGameplayAbility*                            OwningAbility                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UDCAT_WaitForCharacterUnCrouch* UDCAT_WaitForCharacterUnCrouch::STATIC_WaitForCharacterUnCrouch(class UGameplayAbility* OwningAbility)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAT_WaitForCharacterUnCrouch.WaitForCharacterUnCrouch");
		
		UDCAT_WaitForCharacterUnCrouch_WaitForCharacterUnCrouch_Params params {};
		params.OwningAbility = OwningAbility;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDCAT_WaitForCharacterUnCrouch.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDCAT_WaitForCharacterUnCrouch::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCAT_WaitForCharacterUnCrouch");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017785A0
	 * 		Name   -> Function DungeonCrawler.DCAT_WaitForGameplayEvents.WaitForGameplayEvents
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UGameplayAbility*                            OwningAbility                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FGameplayTagContainer                       InEventTags                                                (Parm, NativeAccessSpecifierPublic)
	 */
	class UDCAT_WaitForGameplayEvents* UDCAT_WaitForGameplayEvents::STATIC_WaitForGameplayEvents(class UGameplayAbility* OwningAbility, const struct FGameplayTagContainer& InEventTags)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAT_WaitForGameplayEvents.WaitForGameplayEvents");
		
		UDCAT_WaitForGameplayEvents_WaitForGameplayEvents_Params params {};
		params.OwningAbility = OwningAbility;
		params.InEventTags = InEventTags;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDCAT_WaitForGameplayEvents.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDCAT_WaitForGameplayEvents::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCAT_WaitForGameplayEvents");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017786C0
	 * 		Name   -> Function DungeonCrawler.DCAT_WaitForInputAction.WaitForInputAction
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UGameplayAbility*                            OwningAbility                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UInputAction*                                InInputAction                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               OnlyTriggerOnce                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UDCAT_WaitForInputAction* UDCAT_WaitForInputAction::STATIC_WaitForInputAction(class UGameplayAbility* OwningAbility, class UInputAction* InInputAction, bool OnlyTriggerOnce)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAT_WaitForInputAction.WaitForInputAction");
		
		UDCAT_WaitForInputAction_WaitForInputAction_Params params {};
		params.OwningAbility = OwningAbility;
		params.InInputAction = InInputAction;
		params.OnlyTriggerOnce = OnlyTriggerOnce;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDCAT_WaitForInputAction.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDCAT_WaitForInputAction::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCAT_WaitForInputAction");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017781E0
	 * 		Name   -> Function DungeonCrawler.DCAT_WaitGameplayAbilityActivateOrEnd.WaitForAbilityActivateOrEndWithTagRequirements
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UGameplayAbility*                            OwningAbility                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FGameplayTagRequirements                    TagRequirements                                            (Parm, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      InOptionalExternalTarget                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               TriggerOnce                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UDCAT_WaitGameplayAbilityActivateOrEnd* UDCAT_WaitGameplayAbilityActivateOrEnd::STATIC_WaitForAbilityActivateOrEndWithTagRequirements(class UGameplayAbility* OwningAbility, const struct FGameplayTagRequirements& TagRequirements, class AActor* InOptionalExternalTarget, bool TriggerOnce)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAT_WaitGameplayAbilityActivateOrEnd.WaitForAbilityActivateOrEndWithTagRequirements");
		
		UDCAT_WaitGameplayAbilityActivateOrEnd_WaitForAbilityActivateOrEndWithTagRequirements_Params params {};
		params.OwningAbility = OwningAbility;
		params.TagRequirements = TagRequirements;
		params.InOptionalExternalTarget = InOptionalExternalTarget;
		params.TriggerOnce = TriggerOnce;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017783C0
	 * 		Name   -> Function DungeonCrawler.DCAT_WaitGameplayAbilityActivateOrEnd.WaitForAbilityActivateOrEnd_Query
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UGameplayAbility*                            OwningAbility                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FGameplayTagQuery                           Query                                                      (Parm, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      InOptionalExternalTarget                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               TriggerOnce                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UDCAT_WaitGameplayAbilityActivateOrEnd* UDCAT_WaitGameplayAbilityActivateOrEnd::STATIC_WaitForAbilityActivateOrEnd_Query(class UGameplayAbility* OwningAbility, const struct FGameplayTagQuery& Query, class AActor* InOptionalExternalTarget, bool TriggerOnce)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAT_WaitGameplayAbilityActivateOrEnd.WaitForAbilityActivateOrEnd_Query");
		
		UDCAT_WaitGameplayAbilityActivateOrEnd_WaitForAbilityActivateOrEnd_Query_Params params {};
		params.OwningAbility = OwningAbility;
		params.Query = Query;
		params.InOptionalExternalTarget = InOptionalExternalTarget;
		params.TriggerOnce = TriggerOnce;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01778050
	 * 		Name   -> Function DungeonCrawler.DCAT_WaitGameplayAbilityActivateOrEnd.WaitForAbilityActivateOrEnd
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UGameplayAbility*                            OwningAbility                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FGameplayTag                                WithTag                                                    (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FGameplayTag                                WithoutTag                                                 (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      InOptionalExternalTarget                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               TriggerOnce                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UDCAT_WaitGameplayAbilityActivateOrEnd* UDCAT_WaitGameplayAbilityActivateOrEnd::STATIC_WaitForAbilityActivateOrEnd(class UGameplayAbility* OwningAbility, const struct FGameplayTag& WithTag, const struct FGameplayTag& WithoutTag, class AActor* InOptionalExternalTarget, bool TriggerOnce)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAT_WaitGameplayAbilityActivateOrEnd.WaitForAbilityActivateOrEnd");
		
		UDCAT_WaitGameplayAbilityActivateOrEnd_WaitForAbilityActivateOrEnd_Params params {};
		params.OwningAbility = OwningAbility;
		params.WithTag = WithTag;
		params.WithoutTag = WithoutTag;
		params.InOptionalExternalTarget = InOptionalExternalTarget;
		params.TriggerOnce = TriggerOnce;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017773A0
	 * 		Name   -> Function DungeonCrawler.DCAT_WaitGameplayAbilityActivateOrEnd.OnAbilityEnd
	 * 		Flags  -> (Final, Native, Protected, HasOutParms)
	 * Parameters:
	 * 		struct FAbilityEndedData                           AbilityEndedData                                           (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UDCAT_WaitGameplayAbilityActivateOrEnd::OnAbilityEnd(const struct FAbilityEndedData& AbilityEndedData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAT_WaitGameplayAbilityActivateOrEnd.OnAbilityEnd");
		
		UDCAT_WaitGameplayAbilityActivateOrEnd_OnAbilityEnd_Params params {};
		params.AbilityEndedData = AbilityEndedData;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01777310
	 * 		Name   -> Function DungeonCrawler.DCAT_WaitGameplayAbilityActivateOrEnd.OnAbilityActivate
	 * 		Flags  -> (Final, Native, Protected)
	 * Parameters:
	 * 		class UGameplayAbility*                            ActivatedAbility                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UDCAT_WaitGameplayAbilityActivateOrEnd::OnAbilityActivate(class UGameplayAbility* ActivatedAbility)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAT_WaitGameplayAbilityActivateOrEnd.OnAbilityActivate");
		
		UDCAT_WaitGameplayAbilityActivateOrEnd_OnAbilityActivate_Params params {};
		params.ActivatedAbility = ActivatedAbility;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDCAT_WaitGameplayAbilityActivateOrEnd.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDCAT_WaitGameplayAbilityActivateOrEnd::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCAT_WaitGameplayAbilityActivateOrEnd");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017787C0
	 * 		Name   -> Function DungeonCrawler.DCAT_WaitGameplayEffectAdd.WaitGameplayEffectAdded
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UGameplayAbility*                            OwningAbility                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               TriggerOnce                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UDCAT_WaitGameplayEffectAdd* UDCAT_WaitGameplayEffectAdd::STATIC_WaitGameplayEffectAdded(class UGameplayAbility* OwningAbility, bool TriggerOnce)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAT_WaitGameplayEffectAdd.WaitGameplayEffectAdded");
		
		UDCAT_WaitGameplayEffectAdd_WaitGameplayEffectAdded_Params params {};
		params.OwningAbility = OwningAbility;
		params.TriggerOnce = TriggerOnce;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01777440
	 * 		Name   -> Function DungeonCrawler.DCAT_WaitGameplayEffectAdd.OnApplyGameplayEffectCallback
	 * 		Flags  -> (Final, Native, Public, HasOutParms)
	 * Parameters:
	 * 		class UAbilitySystemComponent*                     Target                                                     (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FGameplayEffectSpec                         SpecApplied                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		struct FActiveGameplayEffectHandle                 ActiveHandle                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UDCAT_WaitGameplayEffectAdd::OnApplyGameplayEffectCallback(class UAbilitySystemComponent* Target, const struct FGameplayEffectSpec& SpecApplied, const struct FActiveGameplayEffectHandle& ActiveHandle)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAT_WaitGameplayEffectAdd.OnApplyGameplayEffectCallback");
		
		UDCAT_WaitGameplayEffectAdd_OnApplyGameplayEffectCallback_Params params {};
		params.Target = Target;
		params.SpecApplied = SpecApplied;
		params.ActiveHandle = ActiveHandle;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDCAT_WaitGameplayEffectAdd.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDCAT_WaitGameplayEffectAdd::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCAT_WaitGameplayEffectAdd");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01778890
	 * 		Name   -> Function DungeonCrawler.DCAT_WaitGenericGameplayTagEvent.WaitGenericGameplayTagEvent
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UGameplayAbility*                            OwningAbility                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      InOptionalExternalTarget                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UDCAT_WaitGenericGameplayTagEvent* UDCAT_WaitGenericGameplayTagEvent::STATIC_WaitGenericGameplayTagEvent(class UGameplayAbility* OwningAbility, class AActor* InOptionalExternalTarget)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAT_WaitGenericGameplayTagEvent.WaitGenericGameplayTagEvent");
		
		UDCAT_WaitGenericGameplayTagEvent_WaitGenericGameplayTagEvent_Params params {};
		params.OwningAbility = OwningAbility;
		params.InOptionalExternalTarget = InOptionalExternalTarget;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDCAT_WaitGenericGameplayTagEvent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDCAT_WaitGenericGameplayTagEvent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCAT_WaitGenericGameplayTagEvent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01778960
	 * 		Name   -> Function DungeonCrawler.DCAT_WaitInteractableTarget.WaitInteractableTarget
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UGameplayAbility*                            OwningAbility                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FName                                        TaskInstanceName                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class ADCGATA_LineTraceInteractable*               InTargetActor                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UDCAT_WaitInteractableTarget* UDCAT_WaitInteractableTarget::STATIC_WaitInteractableTarget(class UGameplayAbility* OwningAbility, const class FName& TaskInstanceName, class ADCGATA_LineTraceInteractable* InTargetActor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAT_WaitInteractableTarget.WaitInteractableTarget");
		
		UDCAT_WaitInteractableTarget_WaitInteractableTarget_Params params {};
		params.OwningAbility = OwningAbility;
		params.TaskInstanceName = TaskInstanceName;
		params.InTargetActor = InTargetActor;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01777E80
	 * 		Name   -> Function DungeonCrawler.DCAT_WaitInteractableTarget.StopTargeting
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void UDCAT_WaitInteractableTarget::StopTargeting()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAT_WaitInteractableTarget.StopTargeting");
		
		UDCAT_WaitInteractableTarget_StopTargeting_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01777E60
	 * 		Name   -> Function DungeonCrawler.DCAT_WaitInteractableTarget.StartTargeting
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void UDCAT_WaitInteractableTarget::StartTargeting()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAT_WaitInteractableTarget.StartTargeting");
		
		UDCAT_WaitInteractableTarget_StartTargeting_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01777C90
	 * 		Name   -> Function DungeonCrawler.DCAT_WaitInteractableTarget.ResetTargeting
	 * 		Flags  -> (Final, Native, Public)
	 */
	void UDCAT_WaitInteractableTarget::ResetTargeting()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAT_WaitInteractableTarget.ResetTargeting");
		
		UDCAT_WaitInteractableTarget_ResetTargeting_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01777A10
	 * 		Name   -> Function DungeonCrawler.DCAT_WaitInteractableTarget.OnLostInteractableTarget
	 * 		Flags  -> (Final, Native, Protected, HasOutParms)
	 * Parameters:
	 * 		struct FGameplayAbilityTargetDataHandle            Data                                                       (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UDCAT_WaitInteractableTarget::OnLostInteractableTarget(const struct FGameplayAbilityTargetDataHandle& Data)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAT_WaitInteractableTarget.OnLostInteractableTarget");
		
		UDCAT_WaitInteractableTarget_OnLostInteractableTarget_Params params {};
		params.Data = Data;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01777810
	 * 		Name   -> Function DungeonCrawler.DCAT_WaitInteractableTarget.OnFoundNewInteractableTarget
	 * 		Flags  -> (Final, Native, Protected, HasOutParms)
	 * Parameters:
	 * 		struct FGameplayAbilityTargetDataHandle            Data                                                       (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UDCAT_WaitInteractableTarget::OnFoundNewInteractableTarget(const struct FGameplayAbilityTargetDataHandle& Data)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAT_WaitInteractableTarget.OnFoundNewInteractableTarget");
		
		UDCAT_WaitInteractableTarget_OnFoundNewInteractableTarget_Params params {};
		params.Data = Data;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDCAT_WaitInteractableTarget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDCAT_WaitInteractableTarget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCAT_WaitInteractableTarget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01778A60
	 * 		Name   -> Function DungeonCrawler.DCAT_WaitSocketBlockedStateChange.WaitSocketBlockedStateChange
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UGameplayAbility*                            OwningAbility                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FName                                        TaskInstanceName                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class ADCGATA_AimTraceToSocket*                    InTargetActor                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UDCAT_WaitSocketBlockedStateChange* UDCAT_WaitSocketBlockedStateChange::STATIC_WaitSocketBlockedStateChange(class UGameplayAbility* OwningAbility, const class FName& TaskInstanceName, class ADCGATA_AimTraceToSocket* InTargetActor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAT_WaitSocketBlockedStateChange.WaitSocketBlockedStateChange");
		
		UDCAT_WaitSocketBlockedStateChange_WaitSocketBlockedStateChange_Params params {};
		params.OwningAbility = OwningAbility;
		params.TaskInstanceName = TaskInstanceName;
		params.InTargetActor = InTargetActor;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01777E80
	 * 		Name   -> Function DungeonCrawler.DCAT_WaitSocketBlockedStateChange.StopTargeting
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void UDCAT_WaitSocketBlockedStateChange::StopTargeting()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAT_WaitSocketBlockedStateChange.StopTargeting");
		
		UDCAT_WaitSocketBlockedStateChange_StopTargeting_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01777E60
	 * 		Name   -> Function DungeonCrawler.DCAT_WaitSocketBlockedStateChange.StartTargeting
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void UDCAT_WaitSocketBlockedStateChange::StartTargeting()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAT_WaitSocketBlockedStateChange.StartTargeting");
		
		UDCAT_WaitSocketBlockedStateChange_StartTargeting_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01777C90
	 * 		Name   -> Function DungeonCrawler.DCAT_WaitSocketBlockedStateChange.ResetTargeting
	 * 		Flags  -> (Final, Native, Public)
	 */
	void UDCAT_WaitSocketBlockedStateChange::ResetTargeting()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAT_WaitSocketBlockedStateChange.ResetTargeting");
		
		UDCAT_WaitSocketBlockedStateChange_ResetTargeting_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01777A10
	 * 		Name   -> Function DungeonCrawler.DCAT_WaitSocketBlockedStateChange.OnSocketSightUnblocked
	 * 		Flags  -> (Final, Native, Protected, HasOutParms)
	 * Parameters:
	 * 		struct FGameplayAbilityTargetDataHandle            Data                                                       (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UDCAT_WaitSocketBlockedStateChange::OnSocketSightUnblocked(const struct FGameplayAbilityTargetDataHandle& Data)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAT_WaitSocketBlockedStateChange.OnSocketSightUnblocked");
		
		UDCAT_WaitSocketBlockedStateChange_OnSocketSightUnblocked_Params params {};
		params.Data = Data;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01777810
	 * 		Name   -> Function DungeonCrawler.DCAT_WaitSocketBlockedStateChange.OnSocketSightBlocked
	 * 		Flags  -> (Final, Native, Protected, HasOutParms)
	 * Parameters:
	 * 		struct FGameplayAbilityTargetDataHandle            Data                                                       (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UDCAT_WaitSocketBlockedStateChange::OnSocketSightBlocked(const struct FGameplayAbilityTargetDataHandle& Data)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAT_WaitSocketBlockedStateChange.OnSocketSightBlocked");
		
		UDCAT_WaitSocketBlockedStateChange_OnSocketSightBlocked_Params params {};
		params.Data = Data;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDCAT_WaitSocketBlockedStateChange.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDCAT_WaitSocketBlockedStateChange::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCAT_WaitSocketBlockedStateChange");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01776970
	 * 		Name   -> Function DungeonCrawler.DCAT_WaitTargetData.DCWaitTargetData
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UGameplayAbility*                            OwningAbility                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FName                                        TaskInstanceName                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EGameplayTargetingConfirmation                     ConfirmationType                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AGameplayAbilityTargetActor*                 InTargetActor                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UDCAT_WaitTargetData* UDCAT_WaitTargetData::STATIC_DCWaitTargetData(class UGameplayAbility* OwningAbility, const class FName& TaskInstanceName, EGameplayTargetingConfirmation ConfirmationType, class AGameplayAbilityTargetActor* InTargetActor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAT_WaitTargetData.DCWaitTargetData");
		
		UDCAT_WaitTargetData_DCWaitTargetData_Params params {};
		params.OwningAbility = OwningAbility;
		params.TaskInstanceName = TaskInstanceName;
		params.ConfirmationType = ConfirmationType;
		params.InTargetActor = InTargetActor;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDCAT_WaitTargetData.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDCAT_WaitTargetData::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCAT_WaitTargetData");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01778B60
	 * 		Name   -> Function DungeonCrawler.DCAT_WaitTargetGameplayTagEvent.WaitTargetGameplayTagEvent
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UGameplayAbility*                            OwningAbility                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FGameplayTag                                InTargetTag                                                (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      InOptionalExternalTarget                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UDCAT_WaitTargetGameplayTagEvent* UDCAT_WaitTargetGameplayTagEvent::STATIC_WaitTargetGameplayTagEvent(class UGameplayAbility* OwningAbility, const struct FGameplayTag& InTargetTag, class AActor* InOptionalExternalTarget)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAT_WaitTargetGameplayTagEvent.WaitTargetGameplayTagEvent");
		
		UDCAT_WaitTargetGameplayTagEvent_WaitTargetGameplayTagEvent_Params params {};
		params.OwningAbility = OwningAbility;
		params.InTargetTag = InTargetTag;
		params.InOptionalExternalTarget = InOptionalExternalTarget;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDCAT_WaitTargetGameplayTagEvent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDCAT_WaitTargetGameplayTagEvent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCAT_WaitTargetGameplayTagEvent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01778C60
	 * 		Name   -> Function DungeonCrawler.DCAT_WaitVelocityChange.WaitVelocityChange
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UGameplayAbility*                            OwningAbility                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              MinimumMagnitude                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UDCAT_WaitVelocityChange* UDCAT_WaitVelocityChange::STATIC_WaitVelocityChange(class UGameplayAbility* OwningAbility, float MinimumMagnitude)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCAT_WaitVelocityChange.WaitVelocityChange");
		
		UDCAT_WaitVelocityChange_WaitVelocityChange_Params params {};
		params.OwningAbility = OwningAbility;
		params.MinimumMagnitude = MinimumMagnitude;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDCAT_WaitVelocityChange.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDCAT_WaitVelocityChange::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCAT_WaitVelocityChange");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDCBagSlotWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDCBagSlotWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCBagSlotWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDCControlWidgetBase.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDCControlWidgetBase::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCControlWidgetBase");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0179DD30
	 * 		Name   -> Function DungeonCrawler.DCItemWidgetBase.IsSet
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool UDCItemWidgetBase::IsSet()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCItemWidgetBase.IsSet");
		
		UDCItemWidgetBase_IsSet_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01799180
	 * 		Name   -> Function DungeonCrawler.DCItemWidgetBase.IsReadOnly
	 * 		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool UDCItemWidgetBase::IsReadOnly()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCItemWidgetBase.IsReadOnly");
		
		UDCItemWidgetBase_IsReadOnly_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDCItemWidgetBase.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDCItemWidgetBase::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCItemWidgetBase");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01799300
	 * 		Name   -> Function DungeonCrawler.DCItemCommonWidget.OnDragDropFinished
	 * 		Flags  -> (Final, Native, Private)
	 * Parameters:
	 * 		class UDragDropOperation*                          Operation                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UDCItemCommonWidget::OnDragDropFinished(class UDragDropOperation* Operation)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCItemCommonWidget.OnDragDropFinished");
		
		UDCItemCommonWidget_OnDragDropFinished_Params params {};
		params.Operation = Operation;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01798C70
	 * 		Name   -> Function DungeonCrawler.DCItemCommonWidget.GetTooltipWidget
	 * 		Flags  -> (Final, Native, Protected, BlueprintCallable, BlueprintPure)
	 */
	class UDCItemTooltipWidget* UDCItemCommonWidget::GetTooltipWidget()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCItemCommonWidget.GetTooltipWidget");
		
		UDCItemCommonWidget_GetTooltipWidget_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDCItemCommonWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDCItemCommonWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCItemCommonWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017771B0
	 * 		Name   -> Function DungeonCrawler.DCBagItemWidget.IsGold
	 * 		Flags  -> (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
	 */
	bool UDCBagItemWidget::IsGold()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCBagItemWidget.IsGold");
		
		UDCBagItemWidget_IsGold_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDCBagItemWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDCBagItemWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCBagItemWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017998B0
	 * 		Name   -> Function DungeonCrawler.DCInventoryWidgetBase.SetReadOnly
	 * 		Flags  -> (Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bState                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UDCInventoryWidgetBase::SetReadOnly(bool bState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCInventoryWidgetBase.SetReadOnly");
		
		UDCInventoryWidgetBase_SetReadOnly_Params params {};
		params.bState = bState;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017997A0
	 * 		Name   -> Function DungeonCrawler.DCInventoryWidgetBase.OnWidgetVisibilityChanged
	 * 		Flags  -> (Final, Native, Private)
	 * Parameters:
	 * 		ESlateVisibility                                   Invisibility                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UDCInventoryWidgetBase::OnWidgetVisibilityChanged(ESlateVisibility Invisibility)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCInventoryWidgetBase.OnWidgetVisibilityChanged");
		
		UDCInventoryWidgetBase_OnWidgetVisibilityChanged_Params params {};
		params.Invisibility = Invisibility;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01799550
	 * 		Name   -> Function DungeonCrawler.DCInventoryWidgetBase.OnItemDrop
	 * 		Flags  -> (Final, Native, Private, Const)
	 * Parameters:
	 * 		struct FDCItemId                                   ItemId                                                     (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            Count                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EDCInventoryId                                     Src                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EDCInventoryId                                     Dst                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            Index                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UDCInventoryWidgetBase::OnItemDrop(const struct FDCItemId& ItemId, int32_t Count, EDCInventoryId Src, EDCInventoryId Dst, int32_t Index)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCInventoryWidgetBase.OnItemDrop");
		
		UDCInventoryWidgetBase_OnItemDrop_Params params {};
		params.ItemId = ItemId;
		params.Count = Count;
		params.Src = Src;
		params.Dst = Dst;
		params.Index = Index;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01799390
	 * 		Name   -> Function DungeonCrawler.DCInventoryWidgetBase.OnItemClick
	 * 		Flags  -> (Final, Native, Private, HasOutParms, Const)
	 * Parameters:
	 * 		struct FDCItemId                                   ItemId                                                     (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EDCInventoryId                                     From                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FPointerEvent                               Event                                                      (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UDCInventoryWidgetBase::OnItemClick(const struct FDCItemId& ItemId, EDCInventoryId From, const struct FPointerEvent& Event)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCInventoryWidgetBase.OnItemClick");
		
		UDCInventoryWidgetBase_OnItemClick_Params params {};
		params.ItemId = ItemId;
		params.From = From;
		params.Event = Event;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01799180
	 * 		Name   -> Function DungeonCrawler.DCInventoryWidgetBase.IsReadOnly
	 * 		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool UDCInventoryWidgetBase::IsReadOnly()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCInventoryWidgetBase.IsReadOnly");
		
		UDCInventoryWidgetBase_IsReadOnly_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDCInventoryWidgetBase.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDCInventoryWidgetBase::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCInventoryWidgetBase");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017779F0
	 * 		Name   -> Function DungeonCrawler.DCBagWidget.OnItemsUpdated
	 * 		Flags  -> (Final, Native, Private)
	 */
	void UDCBagWidget::OnItemsUpdated()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCBagWidget.OnItemsUpdated");
		
		UDCBagWidget_OnItemsUpdated_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017775A0
	 * 		Name   -> Function DungeonCrawler.DCBagWidget.OnDropInternal
	 * 		Flags  -> (Final, Native, Private)
	 * Parameters:
	 * 		int32_t                                            Count                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FDCItemId                                   ItemId                                                     (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EDCInventoryId                                     From                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            Index                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UDCBagWidget::OnDropInternal(int32_t Count, const struct FDCItemId& ItemId, EDCInventoryId From, int32_t Index)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCBagWidget.OnDropInternal");
		
		UDCBagWidget_OnDropInternal_Params params {};
		params.Count = Count;
		params.ItemId = ItemId;
		params.From = From;
		params.Index = Index;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01776C40
	 * 		Name   -> Function DungeonCrawler.DCBagWidget.GetGoldAmount
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	int32_t UDCBagWidget::GetGoldAmount()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCBagWidget.GetGoldAmount");
		
		UDCBagWidget_GetGoldAmount_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDCBagWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDCBagWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCBagWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDCBoxInventory.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDCBoxInventory::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCBoxInventory");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDCCharacterAnimInstanceBase.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDCCharacterAnimInstanceBase::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCCharacterAnimInstanceBase");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01777FC0
	 * 		Name   -> Function DungeonCrawler.DCCharacterBase.UnbindMsgAll
	 * 		Flags  -> (Native, Public)
	 * Parameters:
	 * 		class UObject*                                     InObject                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ADCCharacterBase::UnbindMsgAll(class UObject* InObject)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCCharacterBase.UnbindMsgAll");
		
		ADCCharacterBase_UnbindMsgAll_Params params {};
		params.InObject = InObject;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01777EF0
	 * 		Name   -> Function DungeonCrawler.DCCharacterBase.UnbindMsg
	 * 		Flags  -> (Native, Public)
	 * Parameters:
	 * 		class UScriptStruct*                               InMsgType                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UObject*                                     InObject                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ADCCharacterBase::UnbindMsg(class UScriptStruct* InMsgType, class UObject* InObject)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCCharacterBase.UnbindMsg");
		
		ADCCharacterBase_UnbindMsg_Params params {};
		params.InMsgType = InMsgType;
		params.InObject = InObject;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01777ED0
	 * 		Name   -> Function DungeonCrawler.DCCharacterBase.TogglePerspective
	 * 		Flags  -> (Final, Native, Protected, BlueprintCallable)
	 */
	void ADCCharacterBase::TogglePerspective()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCCharacterBase.TogglePerspective");
		
		ADCCharacterBase_TogglePerspective_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01777EA0
	 * 		Name   -> Function DungeonCrawler.DCCharacterBase.TerminateBase
	 * 		Flags  -> (Native, Public)
	 */
	void ADCCharacterBase::TerminateBase()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCCharacterBase.TerminateBase");
		
		ADCCharacterBase_TerminateBase_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01777DD0
	 * 		Name   -> Function DungeonCrawler.DCCharacterBase.SetIsDead
	 * 		Flags  -> (Final, Native, Private, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               IsDead                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ADCCharacterBase::SetIsDead(bool IsDead)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCCharacterBase.SetIsDead");
		
		ADCCharacterBase_SetIsDead_Params params {};
		params.IsDead = IsDead;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01777D30
	 * 		Name   -> Function DungeonCrawler.DCCharacterBase.SetGenericTeamId
	 * 		Flags  -> (Native, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		struct FGenericTeamId                              TeamID                                                     (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ADCCharacterBase::SetGenericTeamId(const struct FGenericTeamId& TeamID)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCCharacterBase.SetGenericTeamId");
		
		ADCCharacterBase_SetGenericTeamId_Params params {};
		params.TeamID = TeamID;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01777CB0
	 * 		Name   -> Function DungeonCrawler.DCCharacterBase.ServerSetRemoteViewYaw
	 * 		Flags  -> (Final, Net, NetReliable, Native, Event, Private, NetServer)
	 * Parameters:
	 * 		unsigned char                                      InRemoteViewYaw                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ADCCharacterBase::ServerSetRemoteViewYaw(unsigned char InRemoteViewYaw)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCCharacterBase.ServerSetRemoteViewYaw");
		
		ADCCharacterBase_ServerSetRemoteViewYaw_Params params {};
		params.InRemoteViewYaw = InRemoteViewYaw;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01777C70
	 * 		Name   -> Function DungeonCrawler.DCCharacterBase.RemoveAllLocalStateTags
	 * 		Flags  -> (Final, Native, Private)
	 */
	void ADCCharacterBase::RemoveAllLocalStateTags()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCCharacterBase.RemoveAllLocalStateTags");
		
		ADCCharacterBase_RemoveAllLocalStateTags_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.DCCharacterBase.ReceivePreInitializeComponents
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 */
	void ADCCharacterBase::ReceivePreInitializeComponents()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCCharacterBase.ReceivePreInitializeComponents");
		
		ADCCharacterBase_ReceivePreInitializeComponents_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.DCCharacterBase.OnUpdateTeammateState
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 * Parameters:
	 * 		bool                                               bIsTeammateWithLocalPlayer                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ADCCharacterBase::OnUpdateTeammateState(bool bIsTeammateWithLocalPlayer)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCCharacterBase.OnUpdateTeammateState");
		
		ADCCharacterBase_OnUpdateTeammateState_Params params {};
		params.bIsTeammateWithLocalPlayer = bIsTeammateWithLocalPlayer;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.DCCharacterBase.OnSetPerspective
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 * Parameters:
	 * 		class APlayerController*                           InPlayerController                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bInIsFirstPersonPerspective                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ADCCharacterBase::OnSetPerspective(class APlayerController* InPlayerController, bool bInIsFirstPersonPerspective)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCCharacterBase.OnSetPerspective");
		
		ADCCharacterBase_OnSetPerspective_Params params {};
		params.InPlayerController = InPlayerController;
		params.bInIsFirstPersonPerspective = bInIsFirstPersonPerspective;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01777BD0
	 * 		Name   -> Function DungeonCrawler.DCCharacterBase.OnRep_AccountId
	 * 		Flags  -> (Final, Native, Protected)
	 * Parameters:
	 * 		class FString                                      InOldAccountId                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ADCCharacterBase::OnRep_AccountId(const class FString& InOldAccountId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCCharacterBase.OnRep_AccountId");
		
		ADCCharacterBase_OnRep_AccountId_Params params {};
		params.InOldAccountId = InOldAccountId;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01777B50
	 * 		Name   -> Function DungeonCrawler.DCCharacterBase.OnQuickSlotClicked
	 * 		Flags  -> (Final, Native, Private)
	 * Parameters:
	 * 		EEquipmentQuickSlotType                            SlotType                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ADCCharacterBase::OnQuickSlotClicked(EEquipmentQuickSlotType SlotType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCCharacterBase.OnQuickSlotClicked");
		
		ADCCharacterBase_OnQuickSlotClicked_Params params {};
		params.SlotType = SlotType;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01777950
	 * 		Name   -> Function DungeonCrawler.DCCharacterBase.OnGameState
	 * 		Flags  -> (Native, Event, Protected, HasOutParms, BlueprintEvent)
	 * Parameters:
	 * 		struct FGameStateData                              InGameStateData                                            (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void ADCCharacterBase::OnGameState(const struct FGameStateData& InGameStateData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCCharacterBase.OnGameState");
		
		ADCCharacterBase_OnGameState_Params params {};
		params.InGameStateData = InGameStateData;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01777700
	 * 		Name   -> Function DungeonCrawler.DCCharacterBase.OnFMsgGASActorDieNotifyBlueprint
	 * 		Flags  -> (Native, Event, Protected, HasOutParms, BlueprintEvent)
	 * Parameters:
	 * 		struct FMsgGASActorDieNotify                       InMsg                                                      (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	void ADCCharacterBase::OnFMsgGASActorDieNotifyBlueprint(const struct FMsgGASActorDieNotify& InMsg)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCCharacterBase.OnFMsgGASActorDieNotifyBlueprint");
		
		ADCCharacterBase_OnFMsgGASActorDieNotifyBlueprint_Params params {};
		params.InMsg = InMsg;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01777210
	 * 		Name   -> Function DungeonCrawler.DCCharacterBase.IsSameTeam
	 * 		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		class FString                                      PartyId                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool ADCCharacterBase::IsSameTeam(const class FString& PartyId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCCharacterBase.IsSameTeam");
		
		ADCCharacterBase_IsSameTeam_Params params {};
		params.PartyId = PartyId;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017771E0
	 * 		Name   -> Function DungeonCrawler.DCCharacterBase.IsInFirstPersonPerspective
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool ADCCharacterBase::IsInFirstPersonPerspective()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCCharacterBase.IsInFirstPersonPerspective");
		
		ADCCharacterBase_IsInFirstPersonPerspective_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01777180
	 * 		Name   -> Function DungeonCrawler.DCCharacterBase.IsDead
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool ADCCharacterBase::IsDead()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCCharacterBase.IsDead");
		
		ADCCharacterBase_IsDead_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01776E90
	 * 		Name   -> Function DungeonCrawler.DCCharacterBase.InteractSucceed
	 * 		Flags  -> (Native, Event, Protected, BlueprintEvent)
	 * Parameters:
	 * 		class AActor*                                      Interacter                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FGameplayTag                                StateTag                                                   (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FGameplayTag                                TriggerTag                                                 (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FHitResult                                  HitResult                                                  (Parm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	void ADCCharacterBase::InteractSucceed(class AActor* Interacter, const struct FGameplayTag& StateTag, const struct FGameplayTag& TriggerTag, const struct FHitResult& HitResult)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCCharacterBase.InteractSucceed");
		
		ADCCharacterBase_InteractSucceed_Params params {};
		params.Interacter = Interacter;
		params.StateTag = StateTag;
		params.TriggerTag = TriggerTag;
		params.HitResult = HitResult;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.DCCharacterBase.InteractLost
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 * Parameters:
	 * 		class AActor*                                      Interacter                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ADCCharacterBase::InteractLost(class AActor* Interacter)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCCharacterBase.InteractLost");
		
		ADCCharacterBase_InteractLost_Params params {};
		params.Interacter = Interacter;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.DCCharacterBase.InteractFound
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 * Parameters:
	 * 		class AActor*                                      Interacter                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UPrimitiveComponent*                         InteractPart                                               (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ADCCharacterBase::InteractFound(class AActor* Interacter, class UPrimitiveComponent* InteractPart)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCCharacterBase.InteractFound");
		
		ADCCharacterBase_InteractFound_Params params {};
		params.Interacter = Interacter;
		params.InteractPart = InteractPart;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01776E10
	 * 		Name   -> Function DungeonCrawler.DCCharacterBase.GetPartyId
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	class FString ADCCharacterBase::GetPartyId()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCCharacterBase.GetPartyId");
		
		ADCCharacterBase_GetPartyId_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01776D50
	 * 		Name   -> Function DungeonCrawler.DCCharacterBase.GetNickNameCached
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	struct FNickname ADCCharacterBase::GetNickNameCached()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCCharacterBase.GetNickNameCached");
		
		ADCCharacterBase_GetNickNameCached_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01776C70
	 * 		Name   -> Function DungeonCrawler.DCCharacterBase.GetHitBoxLocation
	 * 		Flags  -> (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		EHitBoxType                                        HitBoxType                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     Location                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool ADCCharacterBase::GetHitBoxLocation(EHitBoxType HitBoxType, struct FVector* Location)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCCharacterBase.GetHitBoxLocation");
		
		ADCCharacterBase_GetHitBoxLocation_Params params {};
		params.HitBoxType = HitBoxType;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (Location != nullptr)
			*Location = params.Location;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01776C00
	 * 		Name   -> Function DungeonCrawler.DCCharacterBase.GetGenericTeamId
	 * 		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	struct FGenericTeamId ADCCharacterBase::GetGenericTeamId()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCCharacterBase.GetGenericTeamId");
		
		ADCCharacterBase_GetGenericTeamId_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01776BC0
	 * 		Name   -> Function DungeonCrawler.DCCharacterBase.GetCapsuleTopLocation
	 * 		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable)
	 */
	struct FVector ADCCharacterBase::GetCapsuleTopLocation()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCCharacterBase.GetCapsuleTopLocation");
		
		ADCCharacterBase_GetCapsuleTopLocation_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01776B80
	 * 		Name   -> Function DungeonCrawler.DCCharacterBase.GetCapsuleBottomLocation
	 * 		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable)
	 */
	struct FVector ADCCharacterBase::GetCapsuleBottomLocation()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCCharacterBase.GetCapsuleBottomLocation");
		
		ADCCharacterBase_GetCapsuleBottomLocation_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.DCCharacterBase.GetCameraComponent
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 */
	class UCameraComponent* ADCCharacterBase::GetCameraComponent()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCCharacterBase.GetCameraComponent");
		
		ADCCharacterBase_GetCameraComponent_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01776AC0
	 * 		Name   -> Function DungeonCrawler.DCCharacterBase.GetAccountId
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	class FString ADCCharacterBase::GetAccountId()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCCharacterBase.GetAccountId");
		
		ADCCharacterBase_GetAccountId_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.DCCharacterBase.GameplayTagUpdated
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 * Parameters:
	 * 		struct FGameplayTag                                InGameplayTag                                              (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            InCount                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ADCCharacterBase::GameplayTagUpdated(const struct FGameplayTag& InGameplayTag, int32_t InCount)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCCharacterBase.GameplayTagUpdated");
		
		ADCCharacterBase_GameplayTagUpdated_Params params {};
		params.InGameplayTag = InGameplayTag;
		params.InCount = InCount;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D3C640
	 * 		Name   -> Function DungeonCrawler.DCCharacterBase.BroadcastMsgBlueprint
	 * 		Flags  -> (Native, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		int32_t                                            InMsg                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ADCCharacterBase::BroadcastMsgBlueprint(int32_t InMsg)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCCharacterBase.BroadcastMsgBlueprint");
		
		ADCCharacterBase_BroadcastMsgBlueprint_Params params {};
		params.InMsg = InMsg;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ADCCharacterBase.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ADCCharacterBase::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCCharacterBase");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01777FC0
	 * 		Name   -> Function DungeonCrawler.DCCharacterLobbyCapture.UnbindMsgAll
	 * 		Flags  -> (Native, Public)
	 * Parameters:
	 * 		class UObject*                                     InObject                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ADCCharacterLobbyCapture::UnbindMsgAll(class UObject* InObject)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCCharacterLobbyCapture.UnbindMsgAll");
		
		ADCCharacterLobbyCapture_UnbindMsgAll_Params params {};
		params.InObject = InObject;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01777EF0
	 * 		Name   -> Function DungeonCrawler.DCCharacterLobbyCapture.UnbindMsg
	 * 		Flags  -> (Native, Public)
	 * Parameters:
	 * 		class UScriptStruct*                               InMsgType                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UObject*                                     InObject                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ADCCharacterLobbyCapture::UnbindMsg(class UScriptStruct* InMsgType, class UObject* InObject)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCCharacterLobbyCapture.UnbindMsg");
		
		ADCCharacterLobbyCapture_UnbindMsg_Params params {};
		params.InMsgType = InMsgType;
		params.InObject = InObject;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01777EA0
	 * 		Name   -> Function DungeonCrawler.DCCharacterLobbyCapture.TerminateBase
	 * 		Flags  -> (Native, Public)
	 */
	void ADCCharacterLobbyCapture::TerminateBase()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCCharacterLobbyCapture.TerminateBase");
		
		ADCCharacterLobbyCapture_TerminateBase_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.DCCharacterLobbyCapture.OnVisibleCharacterRenderRight
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 * Parameters:
	 * 		bool                                               IsHidden                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ADCCharacterLobbyCapture::OnVisibleCharacterRenderRight(bool IsHidden)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCCharacterLobbyCapture.OnVisibleCharacterRenderRight");
		
		ADCCharacterLobbyCapture_OnVisibleCharacterRenderRight_Params params {};
		params.IsHidden = IsHidden;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.DCCharacterLobbyCapture.OnVisibleCharacterRenderLeft
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 * Parameters:
	 * 		bool                                               IsHidden                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ADCCharacterLobbyCapture::OnVisibleCharacterRenderLeft(bool IsHidden)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCCharacterLobbyCapture.OnVisibleCharacterRenderLeft");
		
		ADCCharacterLobbyCapture_OnVisibleCharacterRenderLeft_Params params {};
		params.IsHidden = IsHidden;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.DCCharacterLobbyCapture.OnItemEquipped
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 * Parameters:
	 * 		class UAnimationAsset*                             ItemStandIdle                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FGameplayTag                                ItemHandType                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FGameplayTag                                ItemSlotType                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ADCCharacterLobbyCapture::OnItemEquipped(class UAnimationAsset* ItemStandIdle, const struct FGameplayTag& ItemHandType, const struct FGameplayTag& ItemSlotType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCCharacterLobbyCapture.OnItemEquipped");
		
		ADCCharacterLobbyCapture_OnItemEquipped_Params params {};
		params.ItemStandIdle = ItemStandIdle;
		params.ItemHandType = ItemHandType;
		params.ItemSlotType = ItemSlotType;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D3C640
	 * 		Name   -> Function DungeonCrawler.DCCharacterLobbyCapture.BroadcastMsgBlueprint
	 * 		Flags  -> (Native, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		int32_t                                            InMsg                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ADCCharacterLobbyCapture::BroadcastMsgBlueprint(int32_t InMsg)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCCharacterLobbyCapture.BroadcastMsgBlueprint");
		
		ADCCharacterLobbyCapture_BroadcastMsgBlueprint_Params params {};
		params.InMsg = InMsg;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ADCCharacterLobbyCapture.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ADCCharacterLobbyCapture::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCCharacterLobbyCapture");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDCCharacterMovementComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDCCharacterMovementComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCCharacterMovementComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDCCharacterPartsArtData.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDCCharacterPartsArtData::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCCharacterPartsArtData");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0177DBC0
	 * 		Name   -> Function DungeonCrawler.DCCharacterProduction.OnRep_ItemDataList
	 * 		Flags  -> (Final, Native, Private, HasOutParms)
	 * Parameters:
	 * 		TArray<class FString>                              OldItemAssetIDList                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void ADCCharacterProduction::OnRep_ItemDataList(TArray<class FString> OldItemAssetIDList)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCCharacterProduction.OnRep_ItemDataList");
		
		ADCCharacterProduction_OnRep_ItemDataList_Params params {};
		params.OldItemAssetIDList = OldItemAssetIDList;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0177DB10
	 * 		Name   -> Function DungeonCrawler.DCCharacterProduction.OnRep_ChangeHeadMesh
	 * 		Flags  -> (Final, Native, Private)
	 */
	void ADCCharacterProduction::OnRep_ChangeHeadMesh()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCCharacterProduction.OnRep_ChangeHeadMesh");
		
		ADCCharacterProduction_OnRep_ChangeHeadMesh_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.DCCharacterProduction.OnItemEquip
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 */
	void ADCCharacterProduction::OnItemEquip()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCCharacterProduction.OnItemEquip");
		
		ADCCharacterProduction_OnItemEquip_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ADCCharacterProduction.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ADCCharacterProduction::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCCharacterProduction");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.DCCharacterSelectCapture.ActorActivity
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 * Parameters:
	 * 		bool                                               IsDisable                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ADCCharacterSelectCapture::ActorActivity(bool IsDisable)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCCharacterSelectCapture.ActorActivity");
		
		ADCCharacterSelectCapture_ActorActivity_Params params {};
		params.IsDisable = IsDisable;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ADCCharacterSelectCapture.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ADCCharacterSelectCapture::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCCharacterSelectCapture");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDCCharacterSkinArtData.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDCCharacterSkinArtData::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCCharacterSkinArtData");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0177DCE0
	 * 		Name   -> Function DungeonCrawler.DCCharacterSkinComponent.SetDataForDebug_Server
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetServer)
	 * Parameters:
	 * 		class UDCCharacterSkinDataAsset*                   InData                                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UDCCharacterSkinComponent::SetDataForDebug_Server(class UDCCharacterSkinDataAsset* InData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCCharacterSkinComponent.SetDataForDebug_Server");
		
		UDCCharacterSkinComponent_SetDataForDebug_Server_Params params {};
		params.InData = InData;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0177DB30
	 * 		Name   -> Function DungeonCrawler.DCCharacterSkinComponent.OnRep_Data
	 * 		Flags  -> (Final, Native, Protected)
	 * Parameters:
	 * 		class UDCCharacterSkinDataAsset*                   OldData                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UDCCharacterSkinComponent::OnRep_Data(class UDCCharacterSkinDataAsset* OldData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCCharacterSkinComponent.OnRep_Data");
		
		UDCCharacterSkinComponent_OnRep_Data_Params params {};
		params.OldData = OldData;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDCCharacterSkinComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDCCharacterSkinComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCCharacterSkinComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDCDataAsset.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDCDataAsset::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCDataAsset");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDCCharacterSkinDataAsset.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDCCharacterSkinDataAsset::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCCharacterSkinDataAsset");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDCCharacterSkinListEntryWidgetData.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDCCharacterSkinListEntryWidgetData::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCCharacterSkinListEntryWidgetData");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0177D8C0
	 * 		Name   -> Function DungeonCrawler.DCCharacterSkinWidget.GetTooltipWidget
	 * 		Flags  -> (Final, Native, Protected, BlueprintCallable, BlueprintPure)
	 */
	class UUserWidget* UDCCharacterSkinWidget::GetTooltipWidget()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCCharacterSkinWidget.GetTooltipWidget");
		
		UDCCharacterSkinWidget_GetTooltipWidget_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDCCharacterSkinWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDCCharacterSkinWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCCharacterSkinWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0177DC90
	 * 		Name   -> Function DungeonCrawler.DCCharacterSkinListEntryWidget.OnRightClicked
	 * 		Flags  -> (Native, Public)
	 */
	void UDCCharacterSkinListEntryWidget::OnRightClicked()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCCharacterSkinListEntryWidget.OnRightClicked");
		
		UDCCharacterSkinListEntryWidget_OnRightClicked_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDCCharacterSkinListEntryWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDCCharacterSkinListEntryWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCCharacterSkinListEntryWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDCUserInfoManagerBase.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDCUserInfoManagerBase::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCUserInfoManagerBase");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDCClientAccountManager.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDCClientAccountManager::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCClientAccountManager");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDCClientShopManager.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDCClientShopManager::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCClientShopManager");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDCCommunityBlockEntryWidgetData.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDCCommunityBlockEntryWidgetData::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCCommunityBlockEntryWidgetData");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0177D740
	 * 		Name   -> Function DungeonCrawler.DCCommunityBlockEntryWidget.ExecuteContextMenu
	 * 		Flags  -> (Final, Native, Private)
	 * Parameters:
	 * 		EContextOptionType                                 Option                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UDCCommunityBlockEntryWidget::ExecuteContextMenu(EContextOptionType Option)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCCommunityBlockEntryWidget.ExecuteContextMenu");
		
		UDCCommunityBlockEntryWidget_ExecuteContextMenu_Params params {};
		params.Option = Option;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0177D700
	 * 		Name   -> Function DungeonCrawler.DCCommunityBlockEntryWidget.CleanupContextMenuWidget
	 * 		Flags  -> (Final, Native, Private)
	 */
	void UDCCommunityBlockEntryWidget::CleanupContextMenuWidget()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCCommunityBlockEntryWidget.CleanupContextMenuWidget");
		
		UDCCommunityBlockEntryWidget_CleanupContextMenuWidget_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDCCommunityBlockEntryWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDCCommunityBlockEntryWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCCommunityBlockEntryWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ULobbyGroupWidgetBase.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ULobbyGroupWidgetBase::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.LobbyGroupWidgetBase");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0177DA40
	 * 		Name   -> Function DungeonCrawler.DCCommunityBlockWidget.OnEntryHovered
	 * 		Flags  -> (Final, Native, Private, Const)
	 * Parameters:
	 * 		class UObject*                                     WidgetData                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bIsHovered                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UDCCommunityBlockWidget::OnEntryHovered(class UObject* WidgetData, bool bIsHovered)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCCommunityBlockWidget.OnEntryHovered");
		
		UDCCommunityBlockWidget_OnEntryHovered_Params params {};
		params.WidgetData = WidgetData;
		params.bIsHovered = bIsHovered;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0177D980
	 * 		Name   -> Function DungeonCrawler.DCCommunityBlockWidget.OnButtonPageRight
	 * 		Flags  -> (Final, Native, Private)
	 */
	void UDCCommunityBlockWidget::OnButtonPageRight()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCCommunityBlockWidget.OnButtonPageRight");
		
		UDCCommunityBlockWidget_OnButtonPageRight_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0177D960
	 * 		Name   -> Function DungeonCrawler.DCCommunityBlockWidget.OnButtonPageLeft
	 * 		Flags  -> (Final, Native, Private)
	 */
	void UDCCommunityBlockWidget::OnButtonPageLeft()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCCommunityBlockWidget.OnButtonPageLeft");
		
		UDCCommunityBlockWidget_OnButtonPageLeft_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0177D940
	 * 		Name   -> Function DungeonCrawler.DCCommunityBlockWidget.OnButtonBack
	 * 		Flags  -> (Final, Native, Private)
	 */
	void UDCCommunityBlockWidget::OnButtonBack()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCCommunityBlockWidget.OnButtonBack");
		
		UDCCommunityBlockWidget_OnButtonBack_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0177D920
	 * 		Name   -> Function DungeonCrawler.DCCommunityBlockWidget.OnBlockUpdated
	 * 		Flags  -> (Final, Native, Private)
	 */
	void UDCCommunityBlockWidget::OnBlockUpdated()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCCommunityBlockWidget.OnBlockUpdated");
		
		UDCCommunityBlockWidget_OnBlockUpdated_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0177D8F0
	 * 		Name   -> Function DungeonCrawler.DCCommunityBlockWidget.NumItemsPerPage
	 * 		Flags  -> (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
	 */
	int32_t UDCCommunityBlockWidget::NumItemsPerPage()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCCommunityBlockWidget.NumItemsPerPage");
		
		UDCCommunityBlockWidget_NumItemsPerPage_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0177D890
	 * 		Name   -> Function DungeonCrawler.DCCommunityBlockWidget.GetMaxPage
	 * 		Flags  -> (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
	 */
	int32_t UDCCommunityBlockWidget::GetMaxPage()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCCommunityBlockWidget.GetMaxPage");
		
		UDCCommunityBlockWidget_GetMaxPage_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0177D7C0
	 * 		Name   -> Function DungeonCrawler.DCCommunityBlockWidget.FindId
	 * 		Flags  -> (Final, Native, Protected, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		class FText                                        FindText                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UDCCommunityBlockWidget::FindId(const class FText& FindText)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCCommunityBlockWidget.FindId");
		
		UDCCommunityBlockWidget_FindId_Params params {};
		params.FindText = FindText;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDCCommunityBlockWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDCCommunityBlockWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCCommunityBlockWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDCCommunityManager.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDCCommunityManager::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCCommunityManager");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDCConstantDataAsset.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDCConstantDataAsset::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCConstantDataAsset");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01764730
	 * 		Name   -> Function DungeonCrawler.DCContextComponent.UnbindMsgAll
	 * 		Flags  -> (Native, Public)
	 * Parameters:
	 * 		class UObject*                                     InObject                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UDCContextComponent::UnbindMsgAll(class UObject* InObject)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCContextComponent.UnbindMsgAll");
		
		UDCContextComponent_UnbindMsgAll_Params params {};
		params.InObject = InObject;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01764280
	 * 		Name   -> Function DungeonCrawler.DCContextComponent.UnbindMsg
	 * 		Flags  -> (Native, Public)
	 * Parameters:
	 * 		class UScriptStruct*                               InMsgType                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UObject*                                     InObject                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UDCContextComponent::UnbindMsg(class UScriptStruct* InMsgType, class UObject* InObject)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCContextComponent.UnbindMsg");
		
		UDCContextComponent_UnbindMsg_Params params {};
		params.InMsgType = InMsgType;
		params.InObject = InObject;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01763EB0
	 * 		Name   -> Function DungeonCrawler.DCContextComponent.TerminateBase
	 * 		Flags  -> (Native, Public)
	 */
	void UDCContextComponent::TerminateBase()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCContextComponent.TerminateBase");
		
		UDCContextComponent_TerminateBase_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0177D9C0
	 * 		Name   -> Function DungeonCrawler.DCContextComponent.OnContextMenuHolderVisibilityChaned
	 * 		Flags  -> (Final, Native, Private)
	 * Parameters:
	 * 		ESlateVisibility                                   Visibility                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UDCContextComponent::OnContextMenuHolderVisibilityChaned(ESlateVisibility Visibility)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCContextComponent.OnContextMenuHolderVisibilityChaned");
		
		UDCContextComponent_OnContextMenuHolderVisibilityChaned_Params params {};
		params.Visibility = Visibility;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D3C640
	 * 		Name   -> Function DungeonCrawler.DCContextComponent.BroadcastMsgBlueprint
	 * 		Flags  -> (Native, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		int32_t                                            InMsg                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UDCContextComponent::BroadcastMsgBlueprint(int32_t InMsg)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCContextComponent.BroadcastMsgBlueprint");
		
		UDCContextComponent_BroadcastMsgBlueprint_Params params {};
		params.InMsg = InMsg;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDCContextComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDCContextComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCContextComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDCContextMenuEntryWidgetData.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDCContextMenuEntryWidgetData::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCContextMenuEntryWidgetData");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0177D720
	 * 		Name   -> Function DungeonCrawler.DCContextMenuEntryWidget.Execute
	 * 		Flags  -> (Final, Native, Protected, BlueprintCallable)
	 */
	void UDCContextMenuEntryWidget::Execute()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCContextMenuEntryWidget.Execute");
		
		UDCContextMenuEntryWidget_Execute_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDCContextMenuEntryWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDCContextMenuEntryWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCContextMenuEntryWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDCContextMenuWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDCContextMenuWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCContextMenuWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017848E0
	 * 		Name   -> Function DungeonCrawler.DCCustomizeCharacterSkinListWidget.OnSetCharacterSkinInfoArray
	 * 		Flags  -> (Final, Native, Protected)
	 * Parameters:
	 * 		TArray<struct FDCCharacterSkinInfo>                CharacterSkinInfoArray                                     (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
	 */
	void UDCCustomizeCharacterSkinListWidget::OnSetCharacterSkinInfoArray(TArray<struct FDCCharacterSkinInfo> CharacterSkinInfoArray)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCCustomizeCharacterSkinListWidget.OnSetCharacterSkinInfoArray");
		
		UDCCustomizeCharacterSkinListWidget_OnSetCharacterSkinInfoArray_Params params {};
		params.CharacterSkinInfoArray = CharacterSkinInfoArray;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDCCustomizeCharacterSkinListWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDCCustomizeCharacterSkinListWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCCustomizeCharacterSkinListWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDCCustomizeComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDCCustomizeComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCCustomizeComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017849D0
	 * 		Name   -> Function DungeonCrawler.DCCustomizeEmoteListWidget.OnSetEmoteIdArray
	 * 		Flags  -> (Final, Native, Protected)
	 * Parameters:
	 * 		TArray<struct FDCEmoteInfo>                        EmoteIdArray                                               (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
	 */
	void UDCCustomizeEmoteListWidget::OnSetEmoteIdArray(TArray<struct FDCEmoteInfo> EmoteIdArray)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCCustomizeEmoteListWidget.OnSetEmoteIdArray");
		
		UDCCustomizeEmoteListWidget_OnSetEmoteIdArray_Params params {};
		params.EmoteIdArray = EmoteIdArray;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDCCustomizeEmoteListWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDCCustomizeEmoteListWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCCustomizeEmoteListWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.DCCustomizeEmoteRadialSlotWidget.SetEmoteIconImageAngle
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 * Parameters:
	 * 		float                                              NewAngle                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UDCCustomizeEmoteRadialSlotWidget::SetEmoteIconImageAngle(float NewAngle)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCCustomizeEmoteRadialSlotWidget.SetEmoteIconImageAngle");
		
		UDCCustomizeEmoteRadialSlotWidget_SetEmoteIconImageAngle_Params params {};
		params.NewAngle = NewAngle;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.DCCustomizeEmoteRadialSlotWidget.OnEmoteNameChanged
	 * 		Flags  -> (Event, Protected, HasOutParms, BlueprintEvent)
	 * Parameters:
	 * 		class FText                                        NewEmoteName                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UDCCustomizeEmoteRadialSlotWidget::OnEmoteNameChanged(const class FText& NewEmoteName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCCustomizeEmoteRadialSlotWidget.OnEmoteNameChanged");
		
		UDCCustomizeEmoteRadialSlotWidget_OnEmoteNameChanged_Params params {};
		params.NewEmoteName = NewEmoteName;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01784450
	 * 		Name   -> Function DungeonCrawler.DCCustomizeEmoteRadialSlotWidget.GetPreviewEmoteVisibility
	 * 		Flags  -> (Final, Native, Protected, BlueprintCallable, BlueprintPure)
	 */
	ESlateVisibility UDCCustomizeEmoteRadialSlotWidget::GetPreviewEmoteVisibility()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCCustomizeEmoteRadialSlotWidget.GetPreviewEmoteVisibility");
		
		UDCCustomizeEmoteRadialSlotWidget_GetPreviewEmoteVisibility_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017843B0
	 * 		Name   -> Function DungeonCrawler.DCCustomizeEmoteRadialSlotWidget.GetHighlightVisibility
	 * 		Flags  -> (Final, Native, Protected, BlueprintCallable, BlueprintPure)
	 */
	ESlateVisibility UDCCustomizeEmoteRadialSlotWidget::GetHighlightVisibility()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCCustomizeEmoteRadialSlotWidget.GetHighlightVisibility");
		
		UDCCustomizeEmoteRadialSlotWidget_GetHighlightVisibility_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01784350
	 * 		Name   -> Function DungeonCrawler.DCCustomizeEmoteRadialSlotWidget.GetEmoteIconVisibility
	 * 		Flags  -> (Final, Native, Protected, BlueprintCallable, BlueprintPure)
	 */
	ESlateVisibility UDCCustomizeEmoteRadialSlotWidget::GetEmoteIconVisibility()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCCustomizeEmoteRadialSlotWidget.GetEmoteIconVisibility");
		
		UDCCustomizeEmoteRadialSlotWidget_GetEmoteIconVisibility_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01780A70
	 * 		Name   -> Function DungeonCrawler.DCCustomizeEmoteRadialSlotWidget.GetArrowVisibility
	 * 		Flags  -> (Final, Native, Protected, BlueprintCallable, BlueprintPure)
	 */
	ESlateVisibility UDCCustomizeEmoteRadialSlotWidget::GetArrowVisibility()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCCustomizeEmoteRadialSlotWidget.GetArrowVisibility");
		
		UDCCustomizeEmoteRadialSlotWidget_GetArrowVisibility_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDCCustomizeEmoteRadialSlotWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDCCustomizeEmoteRadialSlotWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCCustomizeEmoteRadialSlotWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDCCustomizeEmoteRadialWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDCCustomizeEmoteRadialWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCCustomizeEmoteRadialWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01784AC0
	 * 		Name   -> Function DungeonCrawler.DCCustomizeItemSkinListWidget.OnSetItemSkinInfoArray
	 * 		Flags  -> (Final, Native, Protected)
	 * Parameters:
	 * 		TArray<struct FDCItemSkinInfo>                     ItemSkinInfoArray                                          (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
	 */
	void UDCCustomizeItemSkinListWidget::OnSetItemSkinInfoArray(TArray<struct FDCItemSkinInfo> ItemSkinInfoArray)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCCustomizeItemSkinListWidget.OnSetItemSkinInfoArray");
		
		UDCCustomizeItemSkinListWidget_OnSetItemSkinInfoArray_Params params {};
		params.ItemSkinInfoArray = ItemSkinInfoArray;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDCCustomizeItemSkinListWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDCCustomizeItemSkinListWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCCustomizeItemSkinListWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017848C0
	 * 		Name   -> Function DungeonCrawler.DCCustomizeWidgetBase.OnItemTabSelected
	 * 		Flags  -> (Final, Native, Private)
	 */
	void UDCCustomizeWidgetBase::OnItemTabSelected()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCCustomizeWidgetBase.OnItemTabSelected");
		
		UDCCustomizeWidgetBase_OnItemTabSelected_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017848A0
	 * 		Name   -> Function DungeonCrawler.DCCustomizeWidgetBase.OnEmoteTabSelected
	 * 		Flags  -> (Final, Native, Private)
	 */
	void UDCCustomizeWidgetBase::OnEmoteTabSelected()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCCustomizeWidgetBase.OnEmoteTabSelected");
		
		UDCCustomizeWidgetBase_OnEmoteTabSelected_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01784880
	 * 		Name   -> Function DungeonCrawler.DCCustomizeWidgetBase.OnCustomizeWidgetOpen
	 * 		Flags  -> (Final, Native, Protected, BlueprintCallable)
	 */
	void UDCCustomizeWidgetBase::OnCustomizeWidgetOpen()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCCustomizeWidgetBase.OnCustomizeWidgetOpen");
		
		UDCCustomizeWidgetBase_OnCustomizeWidgetOpen_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01784860
	 * 		Name   -> Function DungeonCrawler.DCCustomizeWidgetBase.OnCharacterTabSelected
	 * 		Flags  -> (Final, Native, Private)
	 */
	void UDCCustomizeWidgetBase::OnCharacterTabSelected()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCCustomizeWidgetBase.OnCharacterTabSelected");
		
		UDCCustomizeWidgetBase_OnCharacterTabSelected_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01784420
	 * 		Name   -> Function DungeonCrawler.DCCustomizeWidgetBase.GetItemSkinListVisibility
	 * 		Flags  -> (Final, Native, Protected, BlueprintCallable, BlueprintPure)
	 */
	ESlateVisibility UDCCustomizeWidgetBase::GetItemSkinListVisibility()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCCustomizeWidgetBase.GetItemSkinListVisibility");
		
		UDCCustomizeWidgetBase_GetItemSkinListVisibility_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01784380
	 * 		Name   -> Function DungeonCrawler.DCCustomizeWidgetBase.GetEmoteListVisibility
	 * 		Flags  -> (Final, Native, Protected, BlueprintCallable, BlueprintPure)
	 */
	ESlateVisibility UDCCustomizeWidgetBase::GetEmoteListVisibility()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCCustomizeWidgetBase.GetEmoteListVisibility");
		
		UDCCustomizeWidgetBase_GetEmoteListVisibility_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01780C40
	 * 		Name   -> Function DungeonCrawler.DCCustomizeWidgetBase.GetCharacterSkinListVisibility
	 * 		Flags  -> (Final, Native, Protected, BlueprintCallable, BlueprintPure)
	 */
	ESlateVisibility UDCCustomizeWidgetBase::GetCharacterSkinListVisibility()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCCustomizeWidgetBase.GetCharacterSkinListVisibility");
		
		UDCCustomizeWidgetBase_GetCharacterSkinListVisibility_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDCCustomizeWidgetBase.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDCCustomizeWidgetBase::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCCustomizeWidgetBase");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDCDamageExecCalculation.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDCDamageExecCalculation::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCDamageExecCalculation");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01764730
	 * 		Name   -> Function DungeonCrawler.DCDamageIndicatorComponent.UnbindMsgAll
	 * 		Flags  -> (Native, Public)
	 * Parameters:
	 * 		class UObject*                                     InObject                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UDCDamageIndicatorComponent::UnbindMsgAll(class UObject* InObject)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCDamageIndicatorComponent.UnbindMsgAll");
		
		UDCDamageIndicatorComponent_UnbindMsgAll_Params params {};
		params.InObject = InObject;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01764280
	 * 		Name   -> Function DungeonCrawler.DCDamageIndicatorComponent.UnbindMsg
	 * 		Flags  -> (Native, Public)
	 * Parameters:
	 * 		class UScriptStruct*                               InMsgType                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UObject*                                     InObject                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UDCDamageIndicatorComponent::UnbindMsg(class UScriptStruct* InMsgType, class UObject* InObject)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCDamageIndicatorComponent.UnbindMsg");
		
		UDCDamageIndicatorComponent_UnbindMsg_Params params {};
		params.InMsgType = InMsgType;
		params.InObject = InObject;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01763EB0
	 * 		Name   -> Function DungeonCrawler.DCDamageIndicatorComponent.TerminateBase
	 * 		Flags  -> (Native, Public)
	 */
	void UDCDamageIndicatorComponent::TerminateBase()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCDamageIndicatorComponent.TerminateBase");
		
		UDCDamageIndicatorComponent_TerminateBase_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D3C640
	 * 		Name   -> Function DungeonCrawler.DCDamageIndicatorComponent.BroadcastMsgBlueprint
	 * 		Flags  -> (Native, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		int32_t                                            InMsg                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UDCDamageIndicatorComponent::BroadcastMsgBlueprint(int32_t InMsg)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCDamageIndicatorComponent.BroadcastMsgBlueprint");
		
		UDCDamageIndicatorComponent_BroadcastMsgBlueprint_Params params {};
		params.InMsg = InMsg;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDCDamageIndicatorComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDCDamageIndicatorComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCDamageIndicatorComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01784830
	 * 		Name   -> Function DungeonCrawler.DCDataBlueprintLibrary.MakeUniqueId
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 */
	int64_t UDCDataBlueprintLibrary::STATIC_MakeUniqueId()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCDataBlueprintLibrary.MakeUniqueId");
		
		UDCDataBlueprintLibrary_MakeUniqueId_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01784750
	 * 		Name   -> Function DungeonCrawler.DCDataBlueprintLibrary.MakePrimaryAssetIdStr
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FPrimaryAssetId                             PrimaryAssetId                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class FString UDCDataBlueprintLibrary::STATIC_MakePrimaryAssetIdStr(const struct FPrimaryAssetId& PrimaryAssetId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCDataBlueprintLibrary.MakePrimaryAssetIdStr");
		
		UDCDataBlueprintLibrary_MakePrimaryAssetIdStr_Params params {};
		params.PrimaryAssetId = PrimaryAssetId;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017846A0
	 * 		Name   -> Function DungeonCrawler.DCDataBlueprintLibrary.MakePrimaryAssetId
	 * 		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		class FString                                      PrimaryAssetIdStr                                          (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FPrimaryAssetId UDCDataBlueprintLibrary::STATIC_MakePrimaryAssetId(const class FString& PrimaryAssetIdStr)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCDataBlueprintLibrary.MakePrimaryAssetId");
		
		UDCDataBlueprintLibrary_MakePrimaryAssetId_Params params {};
		params.PrimaryAssetIdStr = PrimaryAssetIdStr;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017845B0
	 * 		Name   -> Function DungeonCrawler.DCDataBlueprintLibrary.LoadPrimaryAsset
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FPrimaryAssetId                             InPrimaryAssetId                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FScriptDelegate                              InOnComplete                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UDCDataBlueprintLibrary::STATIC_LoadPrimaryAsset(const struct FPrimaryAssetId& InPrimaryAssetId, const class FScriptDelegate& InOnComplete)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCDataBlueprintLibrary.LoadPrimaryAsset");
		
		UDCDataBlueprintLibrary_LoadPrimaryAsset_Params params {};
		params.InPrimaryAssetId = InPrimaryAssetId;
		params.InOnComplete = InOnComplete;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01784580
	 * 		Name   -> Function DungeonCrawler.DCDataBlueprintLibrary.IsStreamingMode
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 */
	bool UDCDataBlueprintLibrary::STATIC_IsStreamingMode()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCDataBlueprintLibrary.IsStreamingMode");
		
		UDCDataBlueprintLibrary_IsStreamingMode_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01784480
	 * 		Name   -> Function DungeonCrawler.DCDataBlueprintLibrary.GetViewNickname
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		struct FNickname                                   Nickname                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	class FString UDCDataBlueprintLibrary::STATIC_GetViewNickname(const struct FNickname& Nickname)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCDataBlueprintLibrary.GetViewNickname");
		
		UDCDataBlueprintLibrary_GetViewNickname_Params params {};
		params.Nickname = Nickname;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017843E0
	 * 		Name   -> Function DungeonCrawler.DCDataBlueprintLibrary.GetItemPropertyTypeId_Unidentified
	 * 		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
	 */
	struct FPrimaryAssetId UDCDataBlueprintLibrary::STATIC_GetItemPropertyTypeId_Unidentified()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCDataBlueprintLibrary.GetItemPropertyTypeId_Unidentified");
		
		UDCDataBlueprintLibrary_GetItemPropertyTypeId_Unidentified_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01784180
	 * 		Name   -> Function DungeonCrawler.DCDataBlueprintLibrary.GetDesignDataStockSellBackItemByUniqueId
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FPrimaryAssetId                             InId                                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int64_t                                            StockSellBackUniqueId                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FDesignDataStockSellBackItem UDCDataBlueprintLibrary::STATIC_GetDesignDataStockSellBackItemByUniqueId(const struct FPrimaryAssetId& InId, int64_t StockSellBackUniqueId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCDataBlueprintLibrary.GetDesignDataStockSellBackItemByUniqueId");
		
		UDCDataBlueprintLibrary_GetDesignDataStockSellBackItemByUniqueId_Params params {};
		params.InId = InId;
		params.StockSellBackUniqueId = StockSellBackUniqueId;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01784030
	 * 		Name   -> Function DungeonCrawler.DCDataBlueprintLibrary.GetDesignDataStockSellBack
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FPrimaryAssetId                             InId                                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FDesignDataStockSellBack UDCDataBlueprintLibrary::STATIC_GetDesignDataStockSellBack(const struct FPrimaryAssetId& InId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCDataBlueprintLibrary.GetDesignDataStockSellBack");
		
		UDCDataBlueprintLibrary_GetDesignDataStockSellBack_Params params {};
		params.InId = InId;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01783DB0
	 * 		Name   -> Function DungeonCrawler.DCDataBlueprintLibrary.GetDesignDataStockCraftItemByUniqueId
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FPrimaryAssetId                             InId                                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int64_t                                            StockCraftUniqueId                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FDesignDataStockCraftItem UDCDataBlueprintLibrary::STATIC_GetDesignDataStockCraftItemByUniqueId(const struct FPrimaryAssetId& InId, int64_t StockCraftUniqueId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCDataBlueprintLibrary.GetDesignDataStockCraftItemByUniqueId");
		
		UDCDataBlueprintLibrary_GetDesignDataStockCraftItemByUniqueId_Params params {};
		params.InId = InId;
		params.StockCraftUniqueId = StockCraftUniqueId;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01783C20
	 * 		Name   -> Function DungeonCrawler.DCDataBlueprintLibrary.GetDesignDataStockCraft
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FPrimaryAssetId                             InId                                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FDesignDataStockCraft UDCDataBlueprintLibrary::STATIC_GetDesignDataStockCraft(const struct FPrimaryAssetId& InId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCDataBlueprintLibrary.GetDesignDataStockCraft");
		
		UDCDataBlueprintLibrary_GetDesignDataStockCraft_Params params {};
		params.InId = InId;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017839A0
	 * 		Name   -> Function DungeonCrawler.DCDataBlueprintLibrary.GetDesignDataStockBuyItemByUniqueId
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FPrimaryAssetId                             InId                                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int64_t                                            StockBuyUniqueId                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FDesignDataStockBuyItem UDCDataBlueprintLibrary::STATIC_GetDesignDataStockBuyItemByUniqueId(const struct FPrimaryAssetId& InId, int64_t StockBuyUniqueId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCDataBlueprintLibrary.GetDesignDataStockBuyItemByUniqueId");
		
		UDCDataBlueprintLibrary_GetDesignDataStockBuyItemByUniqueId_Params params {};
		params.InId = InId;
		params.StockBuyUniqueId = StockBuyUniqueId;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01783810
	 * 		Name   -> Function DungeonCrawler.DCDataBlueprintLibrary.GetDesignDataStockBuy
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FPrimaryAssetId                             InId                                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FDesignDataStockBuy UDCDataBlueprintLibrary::STATIC_GetDesignDataStockBuy(const struct FPrimaryAssetId& InId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCDataBlueprintLibrary.GetDesignDataStockBuy");
		
		UDCDataBlueprintLibrary_GetDesignDataStockBuy_Params params {};
		params.InId = InId;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01783720
	 * 		Name   -> Function DungeonCrawler.DCDataBlueprintLibrary.GetDesignDataSpellMap
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		TMap<struct FPrimaryAssetId, struct FDesignDataSpell> OutDesignDataSpellMap                                      (Parm, OutParm, NativeAccessSpecifierPublic)
	 */
	void UDCDataBlueprintLibrary::STATIC_GetDesignDataSpellMap(TMap<struct FPrimaryAssetId, struct FDesignDataSpell>* OutDesignDataSpellMap)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCDataBlueprintLibrary.GetDesignDataSpellMap");
		
		UDCDataBlueprintLibrary_GetDesignDataSpellMap_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutDesignDataSpellMap != nullptr)
			*OutDesignDataSpellMap = params.OutDesignDataSpellMap;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017834B0
	 * 		Name   -> Function DungeonCrawler.DCDataBlueprintLibrary.GetDesignDataSpell
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FPrimaryAssetId                             InId                                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FDesignDataSpell UDCDataBlueprintLibrary::STATIC_GetDesignDataSpell(const struct FPrimaryAssetId& InId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCDataBlueprintLibrary.GetDesignDataSpell");
		
		UDCDataBlueprintLibrary_GetDesignDataSpell_Params params {};
		params.InId = InId;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017833C0
	 * 		Name   -> Function DungeonCrawler.DCDataBlueprintLibrary.GetDesignDataSkillMap
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		TMap<struct FPrimaryAssetId, struct FDesignDataSkill> OutDesignDataSkillMap                                      (Parm, OutParm, NativeAccessSpecifierPublic)
	 */
	void UDCDataBlueprintLibrary::STATIC_GetDesignDataSkillMap(TMap<struct FPrimaryAssetId, struct FDesignDataSkill>* OutDesignDataSkillMap)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCDataBlueprintLibrary.GetDesignDataSkillMap");
		
		UDCDataBlueprintLibrary_GetDesignDataSkillMap_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutDesignDataSkillMap != nullptr)
			*OutDesignDataSkillMap = params.OutDesignDataSkillMap;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01783130
	 * 		Name   -> Function DungeonCrawler.DCDataBlueprintLibrary.GetDesignDataSkill
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FPrimaryAssetId                             InId                                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FDesignDataSkill UDCDataBlueprintLibrary::STATIC_GetDesignDataSkill(const struct FPrimaryAssetId& InId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCDataBlueprintLibrary.GetDesignDataSkill");
		
		UDCDataBlueprintLibrary_GetDesignDataSkill_Params params {};
		params.InId = InId;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01783080
	 * 		Name   -> Function DungeonCrawler.DCDataBlueprintLibrary.GetDesignDataPropsSkillCheck
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FPrimaryAssetId                             InId                                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FDesignDataPropsSkillCheck UDCDataBlueprintLibrary::STATIC_GetDesignDataPropsSkillCheck(const struct FPrimaryAssetId& InId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCDataBlueprintLibrary.GetDesignDataPropsSkillCheck");
		
		UDCDataBlueprintLibrary_GetDesignDataPropsSkillCheck_Params params {};
		params.InId = InId;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01782EE0
	 * 		Name   -> Function DungeonCrawler.DCDataBlueprintLibrary.GetDesignDataPropsInteract
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FPrimaryAssetId                             InId                                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FDesignDataPropsInteract UDCDataBlueprintLibrary::STATIC_GetDesignDataPropsInteract(const struct FPrimaryAssetId& InId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCDataBlueprintLibrary.GetDesignDataPropsInteract");
		
		UDCDataBlueprintLibrary_GetDesignDataPropsInteract_Params params {};
		params.InId = InId;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01782DB0
	 * 		Name   -> Function DungeonCrawler.DCDataBlueprintLibrary.GetDesignDataProps
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FPrimaryAssetId                             InId                                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FDesignDataProps UDCDataBlueprintLibrary::STATIC_GetDesignDataProps(const struct FPrimaryAssetId& InId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCDataBlueprintLibrary.GetDesignDataProps");
		
		UDCDataBlueprintLibrary_GetDesignDataProps_Params params {};
		params.InId = InId;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01782BF0
	 * 		Name   -> Function DungeonCrawler.DCDataBlueprintLibrary.GetDesignDataProjectile
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FPrimaryAssetId                             InId                                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FDesignDataProjectile UDCDataBlueprintLibrary::STATIC_GetDesignDataProjectile(const struct FPrimaryAssetId& InId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCDataBlueprintLibrary.GetDesignDataProjectile");
		
		UDCDataBlueprintLibrary_GetDesignDataProjectile_Params params {};
		params.InId = InId;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01782B00
	 * 		Name   -> Function DungeonCrawler.DCDataBlueprintLibrary.GetDesignDataPlayerCharacterMap
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		TMap<struct FPrimaryAssetId, struct FDesignDataPlayerCharacter> OutDesignDataPlayerCharacterMap                            (Parm, OutParm, NativeAccessSpecifierPublic)
	 */
	void UDCDataBlueprintLibrary::STATIC_GetDesignDataPlayerCharacterMap(TMap<struct FPrimaryAssetId, struct FDesignDataPlayerCharacter>* OutDesignDataPlayerCharacterMap)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCDataBlueprintLibrary.GetDesignDataPlayerCharacterMap");
		
		UDCDataBlueprintLibrary_GetDesignDataPlayerCharacterMap_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutDesignDataPlayerCharacterMap != nullptr)
			*OutDesignDataPlayerCharacterMap = params.OutDesignDataPlayerCharacterMap;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01782A40
	 * 		Name   -> Function DungeonCrawler.DCDataBlueprintLibrary.GetDesignDataPlayerCharacter
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FPrimaryAssetId                             InId                                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FDesignDataPlayerCharacter UDCDataBlueprintLibrary::STATIC_GetDesignDataPlayerCharacter(const struct FPrimaryAssetId& InId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCDataBlueprintLibrary.GetDesignDataPlayerCharacter");
		
		UDCDataBlueprintLibrary_GetDesignDataPlayerCharacter_Params params {};
		params.InId = InId;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01782950
	 * 		Name   -> Function DungeonCrawler.DCDataBlueprintLibrary.GetDesignDataPerkMap
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		TMap<struct FPrimaryAssetId, struct FDesignDataPerk> OutDesignDataPerkMap                                       (Parm, OutParm, NativeAccessSpecifierPublic)
	 */
	void UDCDataBlueprintLibrary::STATIC_GetDesignDataPerkMap(TMap<struct FPrimaryAssetId, struct FDesignDataPerk>* OutDesignDataPerkMap)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCDataBlueprintLibrary.GetDesignDataPerkMap");
		
		UDCDataBlueprintLibrary_GetDesignDataPerkMap_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutDesignDataPerkMap != nullptr)
			*OutDesignDataPerkMap = params.OutDesignDataPerkMap;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01782730
	 * 		Name   -> Function DungeonCrawler.DCDataBlueprintLibrary.GetDesignDataPerk
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FPrimaryAssetId                             InId                                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FDesignDataPerk UDCDataBlueprintLibrary::STATIC_GetDesignDataPerk(const struct FPrimaryAssetId& InId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCDataBlueprintLibrary.GetDesignDataPerk");
		
		UDCDataBlueprintLibrary_GetDesignDataPerk_Params params {};
		params.InId = InId;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01782690
	 * 		Name   -> Function DungeonCrawler.DCDataBlueprintLibrary.GetDesignDataMovementModifier
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FPrimaryAssetId                             InId                                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FDesignDataMovementModifier UDCDataBlueprintLibrary::STATIC_GetDesignDataMovementModifier(const struct FPrimaryAssetId& InId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCDataBlueprintLibrary.GetDesignDataMovementModifier");
		
		UDCDataBlueprintLibrary_GetDesignDataMovementModifier_Params params {};
		params.InId = InId;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017824C0
	 * 		Name   -> Function DungeonCrawler.DCDataBlueprintLibrary.GetDesignDataMonster
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FPrimaryAssetId                             InId                                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FDesignDataMonster UDCDataBlueprintLibrary::STATIC_GetDesignDataMonster(const struct FPrimaryAssetId& InId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCDataBlueprintLibrary.GetDesignDataMonster");
		
		UDCDataBlueprintLibrary_GetDesignDataMonster_Params params {};
		params.InId = InId;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01782350
	 * 		Name   -> Function DungeonCrawler.DCDataBlueprintLibrary.GetDesignDataMerchant
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FPrimaryAssetId                             InId                                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FDesignDataMerchant UDCDataBlueprintLibrary::STATIC_GetDesignDataMerchant(const struct FPrimaryAssetId& InId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCDataBlueprintLibrary.GetDesignDataMerchant");
		
		UDCDataBlueprintLibrary_GetDesignDataMerchant_Params params {};
		params.InId = InId;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01782280
	 * 		Name   -> Function DungeonCrawler.DCDataBlueprintLibrary.GetDesignDataMeleeAttack
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FPrimaryAssetId                             InId                                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FDesignDataMeleeAttack UDCDataBlueprintLibrary::STATIC_GetDesignDataMeleeAttack(const struct FPrimaryAssetId& InId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCDataBlueprintLibrary.GetDesignDataMeleeAttack");
		
		UDCDataBlueprintLibrary_GetDesignDataMeleeAttack_Params params {};
		params.InId = InId;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017821A0
	 * 		Name   -> Function DungeonCrawler.DCDataBlueprintLibrary.GetDesignDataLootDrop
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FPrimaryAssetId                             InId                                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FDesignDataLootDrop UDCDataBlueprintLibrary::STATIC_GetDesignDataLootDrop(const struct FPrimaryAssetId& InId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCDataBlueprintLibrary.GetDesignDataLootDrop");
		
		UDCDataBlueprintLibrary_GetDesignDataLootDrop_Params params {};
		params.InId = InId;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01782060
	 * 		Name   -> Function DungeonCrawler.DCDataBlueprintLibrary.GetDesignDataItemRequirement
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FPrimaryAssetId                             InId                                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FDesignDataItemRequirement UDCDataBlueprintLibrary::STATIC_GetDesignDataItemRequirement(const struct FPrimaryAssetId& InId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCDataBlueprintLibrary.GetDesignDataItemRequirement");
		
		UDCDataBlueprintLibrary_GetDesignDataItemRequirement_Params params {};
		params.InId = InId;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01781F70
	 * 		Name   -> Function DungeonCrawler.DCDataBlueprintLibrary.GetDesignDataItemPropertyType
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FPrimaryAssetId                             InId                                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FDesignDataItemPropertyType UDCDataBlueprintLibrary::STATIC_GetDesignDataItemPropertyType(const struct FPrimaryAssetId& InId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCDataBlueprintLibrary.GetDesignDataItemPropertyType");
		
		UDCDataBlueprintLibrary_GetDesignDataItemPropertyType_Params params {};
		params.InId = InId;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01781E90
	 * 		Name   -> Function DungeonCrawler.DCDataBlueprintLibrary.GetDesignDataItemProperty
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FPrimaryAssetId                             InId                                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FDesignDataItemProperty UDCDataBlueprintLibrary::STATIC_GetDesignDataItemProperty(const struct FPrimaryAssetId& InId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCDataBlueprintLibrary.GetDesignDataItemProperty");
		
		UDCDataBlueprintLibrary_GetDesignDataItemProperty_Params params {};
		params.InId = InId;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01781DB0
	 * 		Name   -> Function DungeonCrawler.DCDataBlueprintLibrary.GetDesignDataItemIdsByGameplayTag
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		struct FGameplayTag                                ItemGameplayTag                                            (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	TArray<struct FPrimaryAssetId> UDCDataBlueprintLibrary::STATIC_GetDesignDataItemIdsByGameplayTag(const struct FGameplayTag& ItemGameplayTag)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCDataBlueprintLibrary.GetDesignDataItemIdsByGameplayTag");
		
		UDCDataBlueprintLibrary_GetDesignDataItemIdsByGameplayTag_Params params {};
		params.ItemGameplayTag = ItemGameplayTag;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01781D00
	 * 		Name   -> Function DungeonCrawler.DCDataBlueprintLibrary.GetDesignDataItemContainer
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FPrimaryAssetId                             InId                                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FDesignDataItemContainer UDCDataBlueprintLibrary::STATIC_GetDesignDataItemContainer(const struct FPrimaryAssetId& InId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCDataBlueprintLibrary.GetDesignDataItemContainer");
		
		UDCDataBlueprintLibrary_GetDesignDataItemContainer_Params params {};
		params.InId = InId;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01781C00
	 * 		Name   -> Function DungeonCrawler.DCDataBlueprintLibrary.GetDesignDataItemConsume
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FPrimaryAssetId                             InId                                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FDesignDataItemConsume UDCDataBlueprintLibrary::STATIC_GetDesignDataItemConsume(const struct FPrimaryAssetId& InId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCDataBlueprintLibrary.GetDesignDataItemConsume");
		
		UDCDataBlueprintLibrary_GetDesignDataItemConsume_Params params {};
		params.InId = InId;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01781B40
	 * 		Name   -> Function DungeonCrawler.DCDataBlueprintLibrary.GetDesignDataItem
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FPrimaryAssetId                             InId                                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FDesignDataItem UDCDataBlueprintLibrary::STATIC_GetDesignDataItem(const struct FPrimaryAssetId& InId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCDataBlueprintLibrary.GetDesignDataItem");
		
		UDCDataBlueprintLibrary_GetDesignDataItem_Params params {};
		params.InId = InId;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01781A60
	 * 		Name   -> Function DungeonCrawler.DCDataBlueprintLibrary.GetDesignDataIdTagGroup
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FPrimaryAssetId                             InId                                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FDesignDataIdTagGroup UDCDataBlueprintLibrary::STATIC_GetDesignDataIdTagGroup(const struct FPrimaryAssetId& InId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCDataBlueprintLibrary.GetDesignDataIdTagGroup");
		
		UDCDataBlueprintLibrary_GetDesignDataIdTagGroup_Params params {};
		params.InId = InId;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017819A0
	 * 		Name   -> Function DungeonCrawler.DCDataBlueprintLibrary.GetDesignDataGameplayEffect
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FPrimaryAssetId                             InId                                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FDesignDataGameplayEffect UDCDataBlueprintLibrary::STATIC_GetDesignDataGameplayEffect(const struct FPrimaryAssetId& InId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCDataBlueprintLibrary.GetDesignDataGameplayEffect");
		
		UDCDataBlueprintLibrary_GetDesignDataGameplayEffect_Params params {};
		params.InId = InId;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017817E0
	 * 		Name   -> Function DungeonCrawler.DCDataBlueprintLibrary.GetDesignDataGameplayAbility
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FPrimaryAssetId                             InId                                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FDesignDataGameplayAbility UDCDataBlueprintLibrary::STATIC_GetDesignDataGameplayAbility(const struct FPrimaryAssetId& InId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCDataBlueprintLibrary.GetDesignDataGameplayAbility");
		
		UDCDataBlueprintLibrary_GetDesignDataGameplayAbility_Params params {};
		params.InId = InId;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017816B0
	 * 		Name   -> Function DungeonCrawler.DCDataBlueprintLibrary.GetDesignDataFloorRule
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FPrimaryAssetId                             InId                                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FDesignDataFloorRule UDCDataBlueprintLibrary::STATIC_GetDesignDataFloorRule(const struct FPrimaryAssetId& InId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCDataBlueprintLibrary.GetDesignDataFloorRule");
		
		UDCDataBlueprintLibrary_GetDesignDataFloorRule_Params params {};
		params.InId = InId;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01781600
	 * 		Name   -> Function DungeonCrawler.DCDataBlueprintLibrary.GetDesignDataFloorPortal
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FPrimaryAssetId                             InId                                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FDesignDataFloorPortal UDCDataBlueprintLibrary::STATIC_GetDesignDataFloorPortal(const struct FPrimaryAssetId& InId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCDataBlueprintLibrary.GetDesignDataFloorPortal");
		
		UDCDataBlueprintLibrary_GetDesignDataFloorPortal_Params params {};
		params.InId = InId;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01781510
	 * 		Name   -> Function DungeonCrawler.DCDataBlueprintLibrary.GetDesignDataEmoteMap
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		TMap<struct FPrimaryAssetId, struct FDesignDataEmote> OutDesignDataEmoteMap                                      (Parm, OutParm, NativeAccessSpecifierPublic)
	 */
	void UDCDataBlueprintLibrary::STATIC_GetDesignDataEmoteMap(TMap<struct FPrimaryAssetId, struct FDesignDataEmote>* OutDesignDataEmoteMap)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCDataBlueprintLibrary.GetDesignDataEmoteMap");
		
		UDCDataBlueprintLibrary_GetDesignDataEmoteMap_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutDesignDataEmoteMap != nullptr)
			*OutDesignDataEmoteMap = params.OutDesignDataEmoteMap;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01781350
	 * 		Name   -> Function DungeonCrawler.DCDataBlueprintLibrary.GetDesignDataEmote
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FPrimaryAssetId                             InId                                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FDesignDataEmote UDCDataBlueprintLibrary::STATIC_GetDesignDataEmote(const struct FPrimaryAssetId& InId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCDataBlueprintLibrary.GetDesignDataEmote");
		
		UDCDataBlueprintLibrary_GetDesignDataEmote_Params params {};
		params.InId = InId;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01781260
	 * 		Name   -> Function DungeonCrawler.DCDataBlueprintLibrary.GetDesignDataDungeonMap
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		TMap<struct FPrimaryAssetId, struct FDesignDataDungeon> OutDesignDataDungeonMap                                    (Parm, OutParm, NativeAccessSpecifierPublic)
	 */
	void UDCDataBlueprintLibrary::STATIC_GetDesignDataDungeonMap(TMap<struct FPrimaryAssetId, struct FDesignDataDungeon>* OutDesignDataDungeonMap)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCDataBlueprintLibrary.GetDesignDataDungeonMap");
		
		UDCDataBlueprintLibrary_GetDesignDataDungeonMap_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutDesignDataDungeonMap != nullptr)
			*OutDesignDataDungeonMap = params.OutDesignDataDungeonMap;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01781120
	 * 		Name   -> Function DungeonCrawler.DCDataBlueprintLibrary.GetDesignDataDungeon
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FPrimaryAssetId                             InId                                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FDesignDataDungeon UDCDataBlueprintLibrary::STATIC_GetDesignDataDungeon(const struct FPrimaryAssetId& InId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCDataBlueprintLibrary.GetDesignDataDungeon");
		
		UDCDataBlueprintLibrary_GetDesignDataDungeon_Params params {};
		params.InId = InId;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01781080
	 * 		Name   -> Function DungeonCrawler.DCDataBlueprintLibrary.GetDesignDataConstant
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FPrimaryAssetId                             InId                                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FDesignDataConstant UDCDataBlueprintLibrary::STATIC_GetDesignDataConstant(const struct FPrimaryAssetId& InId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCDataBlueprintLibrary.GetDesignDataConstant");
		
		UDCDataBlueprintLibrary_GetDesignDataConstant_Params params {};
		params.InId = InId;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01780F70
	 * 		Name   -> Function DungeonCrawler.DCDataBlueprintLibrary.GetDesignDataBaseItem
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FPrimaryAssetId                             InId                                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FDesignDataBaseItem UDCDataBlueprintLibrary::STATIC_GetDesignDataBaseItem(const struct FPrimaryAssetId& InId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCDataBlueprintLibrary.GetDesignDataBaseItem");
		
		UDCDataBlueprintLibrary_GetDesignDataBaseItem_Params params {};
		params.InId = InId;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01780ED0
	 * 		Name   -> Function DungeonCrawler.DCDataBlueprintLibrary.GetDesignDataAssetItemRequirement
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FPrimaryAssetId                             InId                                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UDesignDataAssetItemRequirement* UDCDataBlueprintLibrary::STATIC_GetDesignDataAssetItemRequirement(const struct FPrimaryAssetId& InId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCDataBlueprintLibrary.GetDesignDataAssetItemRequirement");
		
		UDCDataBlueprintLibrary_GetDesignDataAssetItemRequirement_Params params {};
		params.InId = InId;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01780D10
	 * 		Name   -> Function DungeonCrawler.DCDataBlueprintLibrary.GetDesignDataAoe
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FPrimaryAssetId                             InId                                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FDesignDataAoe UDCDataBlueprintLibrary::STATIC_GetDesignDataAoe(const struct FPrimaryAssetId& InId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCDataBlueprintLibrary.GetDesignDataAoe");
		
		UDCDataBlueprintLibrary_GetDesignDataAoe_Params params {};
		params.InId = InId;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01780C70
	 * 		Name   -> Function DungeonCrawler.DCDataBlueprintLibrary.GetDescData
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FPrimaryAssetId                             InId                                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UDescData* UDCDataBlueprintLibrary::STATIC_GetDescData(const struct FPrimaryAssetId& InId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCDataBlueprintLibrary.GetDescData");
		
		UDCDataBlueprintLibrary_GetDescData_Params params {};
		params.InId = InId;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01780AA0
	 * 		Name   -> Function DungeonCrawler.DCDataBlueprintLibrary.GetCharacterBaseItemMap
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FPrimaryAssetId                             InId                                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		TMap<struct FPrimaryAssetId, int32_t>              BaseItemMap                                                (Parm, OutParm, NativeAccessSpecifierPublic)
	 */
	void UDCDataBlueprintLibrary::STATIC_GetCharacterBaseItemMap(const struct FPrimaryAssetId& InId, TMap<struct FPrimaryAssetId, int32_t>* BaseItemMap)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCDataBlueprintLibrary.GetCharacterBaseItemMap");
		
		UDCDataBlueprintLibrary_GetCharacterBaseItemMap_Params params {};
		params.InId = InId;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (BaseItemMap != nullptr)
			*BaseItemMap = params.BaseItemMap;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDCDataBlueprintLibrary.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDCDataBlueprintLibrary::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCDataBlueprintLibrary");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDCEditableText.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDCEditableText::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCEditableText");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDCEmoteDataAsset.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDCEmoteDataAsset::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCEmoteDataAsset");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDCEmoteListEntryWidgetData.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDCEmoteListEntryWidgetData::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCEmoteListEntryWidgetData");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDCEmoteWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDCEmoteWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCEmoteWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01789450
	 * 		Name   -> Function DungeonCrawler.DCEmoteListEntryWidget.OnRightClicked
	 * 		Flags  -> (Native, Public)
	 */
	void UDCEmoteListEntryWidget::OnRightClicked()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCEmoteListEntryWidget.OnRightClicked");
		
		UDCEmoteListEntryWidget_OnRightClicked_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01788D80
	 * 		Name   -> Function DungeonCrawler.DCEmoteListEntryWidget.GetSelectedVisibility
	 * 		Flags  -> (Final, Native, Protected, BlueprintCallable, BlueprintPure)
	 */
	ESlateVisibility UDCEmoteListEntryWidget::GetSelectedVisibility()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCEmoteListEntryWidget.GetSelectedVisibility");
		
		UDCEmoteListEntryWidget_GetSelectedVisibility_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDCEmoteListEntryWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDCEmoteListEntryWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCEmoteListEntryWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01789560
	 * 		Name   -> Function DungeonCrawler.DCEnhancedInputLibrary.RemovePlayerMappableConfigByTagContainer
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FGameplayTagContainer                       InputConfigTags                                            (Parm, NativeAccessSpecifierPublic)
	 */
	void UDCEnhancedInputLibrary::STATIC_RemovePlayerMappableConfigByTagContainer(class UObject* WorldContextObject, const struct FGameplayTagContainer& InputConfigTags)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCEnhancedInputLibrary.RemovePlayerMappableConfigByTagContainer");
		
		UDCEnhancedInputLibrary_RemovePlayerMappableConfigByTagContainer_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.InputConfigTags = InputConfigTags;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01789030
	 * 		Name   -> Function DungeonCrawler.DCEnhancedInputLibrary.InjectInputVectorForAction
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UInputAction*                                Action                                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     Value                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		TArray<class UInputModifier*>                      Modifiers                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		TArray<class UInputTrigger*>                       Triggers                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UDCEnhancedInputLibrary::STATIC_InjectInputVectorForAction(class UObject* WorldContextObject, class UInputAction* Action, const struct FVector& Value, TArray<class UInputModifier*> Modifiers, TArray<class UInputTrigger*> Triggers)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCEnhancedInputLibrary.InjectInputVectorForAction");
		
		UDCEnhancedInputLibrary_InjectInputVectorForAction_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.Action = Action;
		params.Value = Value;
		params.Modifiers = Modifiers;
		params.Triggers = Triggers;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01788E40
	 * 		Name   -> Function DungeonCrawler.DCEnhancedInputLibrary.InjectInputForAction
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UInputAction*                                Action                                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FInputActionValue                           RawValue                                                   (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 * 		TArray<class UInputModifier*>                      Modifiers                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		TArray<class UInputTrigger*>                       Triggers                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UDCEnhancedInputLibrary::STATIC_InjectInputForAction(class UObject* WorldContextObject, class UInputAction* Action, const struct FInputActionValue& RawValue, TArray<class UInputModifier*> Modifiers, TArray<class UInputTrigger*> Triggers)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCEnhancedInputLibrary.InjectInputForAction");
		
		UDCEnhancedInputLibrary_InjectInputForAction_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.Action = Action;
		params.RawValue = RawValue;
		params.Modifiers = Modifiers;
		params.Triggers = Triggers;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01788B10
	 * 		Name   -> Function DungeonCrawler.DCEnhancedInputLibrary.GetKeysMappedToAction
	 * 		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UInputAction*                                Action                                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	TArray<struct FKey> UDCEnhancedInputLibrary::GetKeysMappedToAction(class UObject* WorldContextObject, class UInputAction* Action)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCEnhancedInputLibrary.GetKeysMappedToAction");
		
		UDCEnhancedInputLibrary_GetKeysMappedToAction_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.Action = Action;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01788A40
	 * 		Name   -> Function DungeonCrawler.DCEnhancedInputLibrary.GetInputConfigByTag
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FGameplayTag                                InputConfigTag                                             (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UDCInputConfig* UDCEnhancedInputLibrary::STATIC_GetInputConfigByTag(class UObject* WorldContextObject, const struct FGameplayTag& InputConfigTag)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCEnhancedInputLibrary.GetInputConfigByTag");
		
		UDCEnhancedInputLibrary_GetInputConfigByTag_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.InputConfigTag = InputConfigTag;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017888A0
	 * 		Name   -> Function DungeonCrawler.DCEnhancedInputLibrary.GetInputAction
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FGameplayTag                                InputConfigTag                                             (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FGameplayTag                                InputTag                                                   (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UInputAction* UDCEnhancedInputLibrary::STATIC_GetInputAction(class UObject* WorldContextObject, const struct FGameplayTag& InputConfigTag, const struct FGameplayTag& InputTag)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCEnhancedInputLibrary.GetInputAction");
		
		UDCEnhancedInputLibrary_GetInputAction_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.InputConfigTag = InputConfigTag;
		params.InputTag = InputTag;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01788810
	 * 		Name   -> Function DungeonCrawler.DCEnhancedInputLibrary.GetEnhancedPlayerInput
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UEnhancedPlayerInput* UDCEnhancedInputLibrary::STATIC_GetEnhancedPlayerInput(class UObject* WorldContextObject)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCEnhancedInputLibrary.GetEnhancedPlayerInput");
		
		UDCEnhancedInputLibrary_GetEnhancedPlayerInput_Params params {};
		params.WorldContextObject = WorldContextObject;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01788780
	 * 		Name   -> Function DungeonCrawler.DCEnhancedInputLibrary.GetDCEnhancedInputLocalPlayerSubSystem
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UDCEnhancedInputLocalPlayerSubsystem* UDCEnhancedInputLibrary::STATIC_GetDCEnhancedInputLocalPlayerSubSystem(class UObject* WorldContextObject)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCEnhancedInputLibrary.GetDCEnhancedInputLocalPlayerSubSystem");
		
		UDCEnhancedInputLibrary_GetDCEnhancedInputLocalPlayerSubSystem_Params params {};
		params.WorldContextObject = WorldContextObject;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017886A0
	 * 		Name   -> Function DungeonCrawler.DCEnhancedInputLibrary.GetActionValueWithController
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UInputAction*                                Action                                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FInputActionValue UDCEnhancedInputLibrary::STATIC_GetActionValueWithController(class UObject* WorldContextObject, class UInputAction* Action)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCEnhancedInputLibrary.GetActionValueWithController");
		
		UDCEnhancedInputLibrary_GetActionValueWithController_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.Action = Action;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01788590
	 * 		Name   -> Function DungeonCrawler.DCEnhancedInputLibrary.GetActionValueByTags
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FGameplayTag                                InputConfigTag                                             (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FGameplayTag                                InputTag                                                   (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FInputActionValue UDCEnhancedInputLibrary::STATIC_GetActionValueByTags(class UObject* WorldContextObject, const struct FGameplayTag& InputConfigTag, const struct FGameplayTag& InputTag)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCEnhancedInputLibrary.GetActionValueByTags");
		
		UDCEnhancedInputLibrary_GetActionValueByTags_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.InputConfigTag = InputConfigTag;
		params.InputTag = InputTag;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017884C0
	 * 		Name   -> Function DungeonCrawler.DCEnhancedInputLibrary.GetActionBoolWithController
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UInputAction*                                Action                                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UDCEnhancedInputLibrary::STATIC_GetActionBoolWithController(class UObject* WorldContextObject, class UInputAction* Action)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCEnhancedInputLibrary.GetActionBoolWithController");
		
		UDCEnhancedInputLibrary_GetActionBoolWithController_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.Action = Action;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017883C0
	 * 		Name   -> Function DungeonCrawler.DCEnhancedInputLibrary.GetActionBoolByTags
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FGameplayTag                                InputConfigTag                                             (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FGameplayTag                                InputTag                                                   (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UDCEnhancedInputLibrary::STATIC_GetActionBoolByTags(class UObject* WorldContextObject, const struct FGameplayTag& InputConfigTag, const struct FGameplayTag& InputTag)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCEnhancedInputLibrary.GetActionBoolByTags");
		
		UDCEnhancedInputLibrary_GetActionBoolByTags_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.InputConfigTag = InputConfigTag;
		params.InputTag = InputTag;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017882B0
	 * 		Name   -> Function DungeonCrawler.DCEnhancedInputLibrary.AddPlayerMappableConfigByTagContainer
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FGameplayTagContainer                       InputConfigTags                                            (Parm, NativeAccessSpecifierPublic)
	 */
	void UDCEnhancedInputLibrary::STATIC_AddPlayerMappableConfigByTagContainer(class UObject* WorldContextObject, const struct FGameplayTagContainer& InputConfigTags)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCEnhancedInputLibrary.AddPlayerMappableConfigByTagContainer");
		
		UDCEnhancedInputLibrary_AddPlayerMappableConfigByTagContainer_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.InputConfigTags = InputConfigTags;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDCEnhancedInputLibrary.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDCEnhancedInputLibrary::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCEnhancedInputLibrary");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01789480
	 * 		Name   -> Function DungeonCrawler.DCEnhancedInputLocalPlayerSubsystem.RemovePlayerMappableConfigByTag
	 * 		Flags  -> (BlueprintCosmetic, Native, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		struct FGameplayTag                                InputConfigTag                                             (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FModifyContextOptions                       Options                                                    (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UDCEnhancedInputLocalPlayerSubsystem::RemovePlayerMappableConfigByTag(const struct FGameplayTag& InputConfigTag, const struct FModifyContextOptions& Options)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCEnhancedInputLocalPlayerSubsystem.RemovePlayerMappableConfigByTag");
		
		UDCEnhancedInputLocalPlayerSubsystem_RemovePlayerMappableConfigByTag_Params params {};
		params.InputConfigTag = InputConfigTag;
		params.Options = Options;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01788CE0
	 * 		Name   -> Function DungeonCrawler.DCEnhancedInputLocalPlayerSubsystem.GetPlayerMappableInputConfig
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		struct FGameplayTag                                ConfigTag                                                  (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UPlayerMappableInputConfig* UDCEnhancedInputLocalPlayerSubsystem::GetPlayerMappableInputConfig(const struct FGameplayTag& ConfigTag)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCEnhancedInputLocalPlayerSubsystem.GetPlayerMappableInputConfig");
		
		UDCEnhancedInputLocalPlayerSubsystem_GetPlayerMappableInputConfig_Params params {};
		params.ConfigTag = ConfigTag;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017889A0
	 * 		Name   -> Function DungeonCrawler.DCEnhancedInputLocalPlayerSubsystem.GetInputConfig
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		struct FGameplayTag                                ConfigTag                                                  (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UDCInputConfig* UDCEnhancedInputLocalPlayerSubsystem::GetInputConfig(const struct FGameplayTag& ConfigTag)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCEnhancedInputLocalPlayerSubsystem.GetInputConfig");
		
		UDCEnhancedInputLocalPlayerSubsystem_GetInputConfig_Params params {};
		params.ConfigTag = ConfigTag;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017881D0
	 * 		Name   -> Function DungeonCrawler.DCEnhancedInputLocalPlayerSubsystem.AddPlayerMappableConfigByTag
	 * 		Flags  -> (BlueprintCosmetic, Native, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		struct FGameplayTag                                InputConfigTag                                             (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FModifyContextOptions                       Options                                                    (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UDCEnhancedInputLocalPlayerSubsystem::AddPlayerMappableConfigByTag(const struct FGameplayTag& InputConfigTag, const struct FModifyContextOptions& Options)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCEnhancedInputLocalPlayerSubsystem.AddPlayerMappableConfigByTag");
		
		UDCEnhancedInputLocalPlayerSubsystem_AddPlayerMappableConfigByTag_Params params {};
		params.InputConfigTag = InputConfigTag;
		params.Options = Options;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDCEnhancedInputLocalPlayerSubsystem.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDCEnhancedInputLocalPlayerSubsystem::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCEnhancedInputLocalPlayerSubsystem");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDCEquipInventory.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDCEquipInventory::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCEquipInventory");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01789270
	 * 		Name   -> Function DungeonCrawler.DCEquipmentSlotWidget.IsWeapon
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool UDCEquipmentSlotWidget::IsWeapon()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCEquipmentSlotWidget.IsWeapon");
		
		UDCEquipmentSlotWidget_IsWeapon_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01789240
	 * 		Name   -> Function DungeonCrawler.DCEquipmentSlotWidget.IsTwoHandedWeapon
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool UDCEquipmentSlotWidget::IsTwoHandedWeapon()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCEquipmentSlotWidget.IsTwoHandedWeapon");
		
		UDCEquipmentSlotWidget_IsTwoHandedWeapon_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01789210
	 * 		Name   -> Function DungeonCrawler.DCEquipmentSlotWidget.IsPairSlot
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool UDCEquipmentSlotWidget::IsPairSlot()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCEquipmentSlotWidget.IsPairSlot");
		
		UDCEquipmentSlotWidget_IsPairSlot_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDCEquipmentSlotWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDCEquipmentSlotWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCEquipmentSlotWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017892A0
	 * 		Name   -> Function DungeonCrawler.DCEquipmentWidget.OnItemsUpdated
	 * 		Flags  -> (Final, Native, Private)
	 */
	void UDCEquipmentWidget::OnItemsUpdated()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCEquipmentWidget.OnItemsUpdated");
		
		UDCEquipmentWidget_OnItemsUpdated_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01788DB0
	 * 		Name   -> Function DungeonCrawler.DCEquipmentWidget.GetSlotWidget
	 * 		Flags  -> (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		EDCEquipmentSlotIndex                              Index                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UDCEquipmentSlotWidget* UDCEquipmentWidget::GetSlotWidget(EDCEquipmentSlotIndex Index)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCEquipmentWidget.GetSlotWidget");
		
		UDCEquipmentWidget_GetSlotWidget_Params params {};
		params.Index = Index;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDCEquipmentWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDCEquipmentWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCEquipmentWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDCFloorPortalDataAsset.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDCFloorPortalDataAsset::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCFloorPortalDataAsset");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDCFloorRuleDataAsset.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDCFloorRuleDataAsset::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCFloorRuleDataAsset");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDCFriendInterface.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDCFriendInterface::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCFriendInterface");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01789770
	 * 		Name   -> Function DungeonCrawler.DCGameInstance.UnbindMsgAll
	 * 		Flags  -> (Native, Public)
	 * Parameters:
	 * 		class UObject*                                     InObject                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UDCGameInstance::UnbindMsgAll(class UObject* InObject)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCGameInstance.UnbindMsgAll");
		
		UDCGameInstance_UnbindMsgAll_Params params {};
		params.InObject = InObject;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017896A0
	 * 		Name   -> Function DungeonCrawler.DCGameInstance.UnbindMsg
	 * 		Flags  -> (Native, Public)
	 * Parameters:
	 * 		class UScriptStruct*                               InMsgType                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UObject*                                     InObject                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UDCGameInstance::UnbindMsg(class UScriptStruct* InMsgType, class UObject* InObject)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCGameInstance.UnbindMsg");
		
		UDCGameInstance_UnbindMsg_Params params {};
		params.InMsgType = InMsgType;
		params.InObject = InObject;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01789670
	 * 		Name   -> Function DungeonCrawler.DCGameInstance.TerminateBase
	 * 		Flags  -> (Native, Public)
	 */
	void UDCGameInstance::TerminateBase()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCGameInstance.TerminateBase");
		
		UDCGameInstance_TerminateBase_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017893B0
	 * 		Name   -> Function DungeonCrawler.DCGameInstance.OnPreLoadMap
	 * 		Flags  -> (Final, Native, Private)
	 * Parameters:
	 * 		class FString                                      MapName                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UDCGameInstance::OnPreLoadMap(const class FString& MapName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCGameInstance.OnPreLoadMap");
		
		UDCGameInstance_OnPreLoadMap_Params params {};
		params.MapName = MapName;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017892C0
	 * 		Name   -> Function DungeonCrawler.DCGameInstance.OnLoadingFinished
	 * 		Flags  -> (Final, Native, Private)
	 * Parameters:
	 * 		class FString                                      InMapName                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UDCGameInstance::OnLoadingFinished(const class FString& InMapName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCGameInstance.OnLoadingFinished");
		
		UDCGameInstance_OnLoadingFinished_Params params {};
		params.InMapName = InMapName;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D3C640
	 * 		Name   -> Function DungeonCrawler.DCGameInstance.BroadcastMsgBlueprint
	 * 		Flags  -> (Native, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		int32_t                                            InMsg                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UDCGameInstance::BroadcastMsgBlueprint(int32_t InMsg)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCGameInstance.BroadcastMsgBlueprint");
		
		UDCGameInstance_BroadcastMsgBlueprint_Params params {};
		params.InMsg = InMsg;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDCGameInstance.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDCGameInstance::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCGameInstance");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01764610
	 * 		Name   -> Function DungeonCrawler.DCGameModeAIControllerBase.UnbindMsgAll
	 * 		Flags  -> (Native, Public)
	 * Parameters:
	 * 		class UObject*                                     InObject                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ADCGameModeAIControllerBase::UnbindMsgAll(class UObject* InObject)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCGameModeAIControllerBase.UnbindMsgAll");
		
		ADCGameModeAIControllerBase_UnbindMsgAll_Params params {};
		params.InObject = InObject;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017640E0
	 * 		Name   -> Function DungeonCrawler.DCGameModeAIControllerBase.UnbindMsg
	 * 		Flags  -> (Native, Public)
	 * Parameters:
	 * 		class UScriptStruct*                               InMsgType                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UObject*                                     InObject                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ADCGameModeAIControllerBase::UnbindMsg(class UScriptStruct* InMsgType, class UObject* InObject)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCGameModeAIControllerBase.UnbindMsg");
		
		ADCGameModeAIControllerBase_UnbindMsg_Params params {};
		params.InMsgType = InMsgType;
		params.InObject = InObject;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01763E50
	 * 		Name   -> Function DungeonCrawler.DCGameModeAIControllerBase.TerminateBase
	 * 		Flags  -> (Native, Public)
	 */
	void ADCGameModeAIControllerBase::TerminateBase()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCGameModeAIControllerBase.TerminateBase");
		
		ADCGameModeAIControllerBase_TerminateBase_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.DCGameModeAIControllerBase.ReceivePreInitializeComponents
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 */
	void ADCGameModeAIControllerBase::ReceivePreInitializeComponents()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCGameModeAIControllerBase.ReceivePreInitializeComponents");
		
		ADCGameModeAIControllerBase_ReceivePreInitializeComponents_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D3C640
	 * 		Name   -> Function DungeonCrawler.DCGameModeAIControllerBase.BroadcastMsgBlueprint
	 * 		Flags  -> (Native, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		int32_t                                            InMsg                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ADCGameModeAIControllerBase::BroadcastMsgBlueprint(int32_t InMsg)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCGameModeAIControllerBase.BroadcastMsgBlueprint");
		
		ADCGameModeAIControllerBase_BroadcastMsgBlueprint_Params params {};
		params.InMsg = InMsg;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ADCGameModeAIControllerBase.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ADCGameModeAIControllerBase::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCGameModeAIControllerBase");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ADCGameModeAIControllerGameBase.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ADCGameModeAIControllerGameBase::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCGameModeAIControllerGameBase");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ADCGameModeAIControllerArenaBase.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ADCGameModeAIControllerArenaBase::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCGameModeAIControllerArenaBase");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ADCGameModeAIControllerDungeonBase.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ADCGameModeAIControllerDungeonBase::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCGameModeAIControllerDungeonBase");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ADCGameModeAIControllerDungeonBattleRoyalBase.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ADCGameModeAIControllerDungeonBattleRoyalBase::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCGameModeAIControllerDungeonBattleRoyalBase");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ADCGameModeAIControllerDungeonCrawlBase.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ADCGameModeAIControllerDungeonCrawlBase::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCGameModeAIControllerDungeonCrawlBase");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ADCGameModeAIControllerMetaBase.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ADCGameModeAIControllerMetaBase::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCGameModeAIControllerMetaBase");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ADCGameModeAIControllerMetaLobbyBase.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ADCGameModeAIControllerMetaLobbyBase::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCGameModeAIControllerMetaLobbyBase");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ADCGameModeAIControllerTavernBase.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ADCGameModeAIControllerTavernBase::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCGameModeAIControllerTavernBase");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ADCGameModeAIControllerTestBase.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ADCGameModeAIControllerTestBase::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCGameModeAIControllerTestBase");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0178EFD0
	 * 		Name   -> Function DungeonCrawler.DCGameModeBase.UnbindMsgAll
	 * 		Flags  -> (Native, Public)
	 * Parameters:
	 * 		class UObject*                                     InObject                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ADCGameModeBase::UnbindMsgAll(class UObject* InObject)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCGameModeBase.UnbindMsgAll");
		
		ADCGameModeBase_UnbindMsgAll_Params params {};
		params.InObject = InObject;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0178EF00
	 * 		Name   -> Function DungeonCrawler.DCGameModeBase.UnbindMsg
	 * 		Flags  -> (Native, Public)
	 * Parameters:
	 * 		class UScriptStruct*                               InMsgType                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UObject*                                     InObject                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ADCGameModeBase::UnbindMsg(class UScriptStruct* InMsgType, class UObject* InObject)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCGameModeBase.UnbindMsg");
		
		ADCGameModeBase_UnbindMsg_Params params {};
		params.InMsgType = InMsgType;
		params.InObject = InObject;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0178EED0
	 * 		Name   -> Function DungeonCrawler.DCGameModeBase.TerminateBase
	 * 		Flags  -> (Native, Public)
	 */
	void ADCGameModeBase::TerminateBase()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCGameModeBase.TerminateBase");
		
		ADCGameModeBase_TerminateBase_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D3C640
	 * 		Name   -> Function DungeonCrawler.DCGameModeBase.BroadcastMsgBlueprint
	 * 		Flags  -> (Native, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		int32_t                                            InMsg                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ADCGameModeBase::BroadcastMsgBlueprint(int32_t InMsg)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCGameModeBase.BroadcastMsgBlueprint");
		
		ADCGameModeBase_BroadcastMsgBlueprint_Params params {};
		params.InMsg = InMsg;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ADCGameModeBase.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ADCGameModeBase::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCGameModeBase");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UObjectLinkMetaDataBlueprint.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UObjectLinkMetaDataBlueprint::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.ObjectLinkMetaDataBlueprint");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0178EAC0
	 * 		Name   -> Function DungeonCrawler.DCGameObjectLinkComponent.RequestToLinkers
	 * 		Flags  -> (Final, Native, Protected, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		struct FObjectLinkRequestEvent                     ObjectLinkRequestEvent                                     (Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	TArray<struct FObjectLinkResponeEvent> UDCGameObjectLinkComponent::RequestToLinkers(struct FObjectLinkRequestEvent* ObjectLinkRequestEvent)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCGameObjectLinkComponent.RequestToLinkers");
		
		UDCGameObjectLinkComponent_RequestToLinkers_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (ObjectLinkRequestEvent != nullptr)
			*ObjectLinkRequestEvent = params.ObjectLinkRequestEvent;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDCGameObjectLinkComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDCGameObjectLinkComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCGameObjectLinkComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ADCGameObjectLinker.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ADCGameObjectLinker::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCGameObjectLinker");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0178EA00
	 * 		Name   -> Function DungeonCrawler.DCGameplayAbilityBase.RemoveMovementModifier
	 * 		Flags  -> (Native, Protected, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		struct FGameplayTagContainer                       ContainerTags                                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UDCGameplayAbilityBase::RemoveMovementModifier(const struct FGameplayTagContainer& ContainerTags)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCGameplayAbilityBase.RemoveMovementModifier");
		
		UDCGameplayAbilityBase_RemoveMovementModifier_Params params {};
		params.ContainerTags = ContainerTags;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0178E970
	 * 		Name   -> Function DungeonCrawler.DCGameplayAbilityBase.RemoveGameplayCueLocal
	 * 		Flags  -> (Final, Native, Protected, BlueprintCallable)
	 * Parameters:
	 * 		struct FGameplayTag                                GameplayCueTag                                             (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UDCGameplayAbilityBase::RemoveGameplayCueLocal(const struct FGameplayTag& GameplayCueTag)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCGameplayAbilityBase.RemoveGameplayCueLocal");
		
		UDCGameplayAbilityBase_RemoveGameplayCueLocal_Params params {};
		params.GameplayCueTag = GameplayCueTag;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0178E8E0
	 * 		Name   -> Function DungeonCrawler.DCGameplayAbilityBase.RemoveGameplayCue
	 * 		Flags  -> (Final, Native, Protected, BlueprintCallable)
	 * Parameters:
	 * 		struct FGameplayTag                                GameplayCueTag                                             (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UDCGameplayAbilityBase::RemoveGameplayCue(const struct FGameplayTag& GameplayCueTag)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCGameplayAbilityBase.RemoveGameplayCue");
		
		UDCGameplayAbilityBase_RemoveGameplayCue_Params params {};
		params.GameplayCueTag = GameplayCueTag;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0178E8C0
	 * 		Name   -> Function DungeonCrawler.DCGameplayAbilityBase.RemoveAllAppliedMovementModifiers
	 * 		Flags  -> (Native, Protected, BlueprintCallable)
	 */
	void UDCGameplayAbilityBase::RemoveAllAppliedMovementModifiers()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCGameplayAbilityBase.RemoveAllAppliedMovementModifiers");
		
		UDCGameplayAbilityBase_RemoveAllAppliedMovementModifiers_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0178E0B0
	 * 		Name   -> Function DungeonCrawler.DCGameplayAbilityBase.MakeEffectContainerSpecFromContainer
	 * 		Flags  -> (Native, Public, HasOutParms)
	 * Parameters:
	 * 		TArray<struct FDCGameplayEffectContainerSpec>      OutContainerSpecArray                                      (Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		struct FDCGameplayEffectContainer                  Container                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		struct FGameplayEventData                          EventData                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		int32_t                                            OverrideGameplayLevel                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UDCGameplayAbilityBase::MakeEffectContainerSpecFromContainer(TArray<struct FDCGameplayEffectContainerSpec>* OutContainerSpecArray, const struct FDCGameplayEffectContainer& Container, const struct FGameplayEventData& EventData, int32_t OverrideGameplayLevel)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCGameplayAbilityBase.MakeEffectContainerSpecFromContainer");
		
		UDCGameplayAbilityBase_MakeEffectContainerSpecFromContainer_Params params {};
		params.Container = Container;
		params.EventData = EventData;
		params.OverrideGameplayLevel = OverrideGameplayLevel;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutContainerSpecArray != nullptr)
			*OutContainerSpecArray = params.OutContainerSpecArray;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0178DD80
	 * 		Name   -> Function DungeonCrawler.DCGameplayAbilityBase.MakeEffectContainerSpec
	 * 		Flags  -> (Native, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		TArray<struct FDCGameplayEffectContainerSpec>      OutContainerSpecArray                                      (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	 * 		struct FGameplayTag                                ContainerTag                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FGameplayEventData                          EventData                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		int32_t                                            OverrideGameplayLevel                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UDCGameplayAbilityBase::MakeEffectContainerSpec(TArray<struct FDCGameplayEffectContainerSpec>* OutContainerSpecArray, const struct FGameplayTag& ContainerTag, const struct FGameplayEventData& EventData, int32_t OverrideGameplayLevel)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCGameplayAbilityBase.MakeEffectContainerSpec");
		
		UDCGameplayAbilityBase_MakeEffectContainerSpec_Params params {};
		params.ContainerTag = ContainerTag;
		params.EventData = EventData;
		params.OverrideGameplayLevel = OverrideGameplayLevel;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutContainerSpecArray != nullptr)
			*OutContainerSpecArray = params.OutContainerSpecArray;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0178DAB0
	 * 		Name   -> Function DungeonCrawler.DCGameplayAbilityBase.MakeEffectContainerPremadeSpec
	 * 		Flags  -> (Native, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		class AActor*                                      InActor                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FGameplayTag                                ContainerTag                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FGameplayEventData                          EventData                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		int32_t                                            OverrideGameplayLevel                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UDCGameplayAbilityBase::MakeEffectContainerPremadeSpec(class AActor* InActor, const struct FGameplayTag& ContainerTag, const struct FGameplayEventData& EventData, int32_t OverrideGameplayLevel)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCGameplayAbilityBase.MakeEffectContainerPremadeSpec");
		
		UDCGameplayAbilityBase_MakeEffectContainerPremadeSpec_Params params {};
		params.InActor = InActor;
		params.ContainerTag = ContainerTag;
		params.EventData = EventData;
		params.OverrideGameplayLevel = OverrideGameplayLevel;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0178D9E0
	 * 		Name   -> Function DungeonCrawler.DCGameplayAbilityBase.GetSetByCallerValueInEffectContainerArray
	 * 		Flags  -> (Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		struct FGameplayTag                                ContainerTag                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FGameplayTag                                SetByCallerDataTag                                         (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	int32_t UDCGameplayAbilityBase::GetSetByCallerValueInEffectContainerArray(const struct FGameplayTag& ContainerTag, const struct FGameplayTag& SetByCallerDataTag)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCGameplayAbilityBase.GetSetByCallerValueInEffectContainerArray");
		
		UDCGameplayAbilityBase_GetSetByCallerValueInEffectContainerArray_Params params {};
		params.ContainerTag = ContainerTag;
		params.SetByCallerDataTag = SetByCallerDataTag;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0178D950
	 * 		Name   -> Function DungeonCrawler.DCGameplayAbilityBase.GetGameplayTriggerTag
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		int32_t                                            Index                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FGameplayTag UDCGameplayAbilityBase::GetGameplayTriggerTag(int32_t Index)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCGameplayAbilityBase.GetGameplayTriggerTag");
		
		UDCGameplayAbilityBase_GetGameplayTriggerTag_Params params {};
		params.Index = Index;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0178D760
	 * 		Name   -> Function DungeonCrawler.DCGameplayAbilityBase.ExecuteGameplayCueWithParams
	 * 		Flags  -> (Final, Native, Protected, BlueprintCallable)
	 * Parameters:
	 * 		struct FGameplayTag                                GameplayCueTag                                             (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FGameplayCueParameters                      Params                                                     (Parm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	void UDCGameplayAbilityBase::ExecuteGameplayCueWithParams(const struct FGameplayTag& GameplayCueTag, const struct FGameplayCueParameters& Params)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCGameplayAbilityBase.ExecuteGameplayCueWithParams");
		
		UDCGameplayAbilityBase_ExecuteGameplayCueWithParams_Params params {};
		params.GameplayCueTag = GameplayCueTag;
		params.Params = Params;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0178D570
	 * 		Name   -> Function DungeonCrawler.DCGameplayAbilityBase.ExecuteGameplayCueLocalWithParams
	 * 		Flags  -> (Final, Native, Protected, BlueprintCallable)
	 * Parameters:
	 * 		struct FGameplayTag                                GameplayCueTag                                             (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FGameplayCueParameters                      Params                                                     (Parm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	void UDCGameplayAbilityBase::ExecuteGameplayCueLocalWithParams(const struct FGameplayTag& GameplayCueTag, const struct FGameplayCueParameters& Params)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCGameplayAbilityBase.ExecuteGameplayCueLocalWithParams");
		
		UDCGameplayAbilityBase_ExecuteGameplayCueLocalWithParams_Params params {};
		params.GameplayCueTag = GameplayCueTag;
		params.Params = Params;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0178D420
	 * 		Name   -> Function DungeonCrawler.DCGameplayAbilityBase.ExecuteGameplayCueLocal
	 * 		Flags  -> (Final, Native, Protected, BlueprintCallable)
	 * Parameters:
	 * 		struct FGameplayTag                                GameplayCueTag                                             (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FGameplayEffectContextHandle                EffectContext                                              (Parm, NativeAccessSpecifierPublic)
	 */
	void UDCGameplayAbilityBase::ExecuteGameplayCueLocal(const struct FGameplayTag& GameplayCueTag, const struct FGameplayEffectContextHandle& EffectContext)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCGameplayAbilityBase.ExecuteGameplayCueLocal");
		
		UDCGameplayAbilityBase_ExecuteGameplayCueLocal_Params params {};
		params.GameplayCueTag = GameplayCueTag;
		params.EffectContext = EffectContext;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0178D2D0
	 * 		Name   -> Function DungeonCrawler.DCGameplayAbilityBase.ExecuteGameplayCue
	 * 		Flags  -> (Final, Native, Protected, BlueprintCallable)
	 * Parameters:
	 * 		struct FGameplayTag                                GameplayCueTag                                             (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FGameplayEffectContextHandle                EffectContext                                              (Parm, NativeAccessSpecifierPublic)
	 */
	void UDCGameplayAbilityBase::ExecuteGameplayCue(const struct FGameplayTag& GameplayCueTag, const struct FGameplayEffectContextHandle& EffectContext)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCGameplayAbilityBase.ExecuteGameplayCue");
		
		UDCGameplayAbilityBase_ExecuteGameplayCue_Params params {};
		params.GameplayCueTag = GameplayCueTag;
		params.EffectContext = EffectContext;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0178D240
	 * 		Name   -> Function DungeonCrawler.DCGameplayAbilityBase.CopyPremadeSpecArray
	 * 		Flags  -> (Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class AActor*                                      InActor                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UDCGameplayAbilityBase::CopyPremadeSpecArray(class AActor* InActor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCGameplayAbilityBase.CopyPremadeSpecArray");
		
		UDCGameplayAbilityBase_CopyPremadeSpecArray_Params params {};
		params.InActor = InActor;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0178CF90
	 * 		Name   -> Function DungeonCrawler.DCGameplayAbilityBase.ApplyPremadeSpecArray
	 * 		Flags  -> (Native, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		struct FGameplayTag                                ContainerTag                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FGameplayEventData                          EventData                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	TArray<struct FActiveGameplayEffectHandle> UDCGameplayAbilityBase::ApplyPremadeSpecArray(const struct FGameplayTag& ContainerTag, const struct FGameplayEventData& EventData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCGameplayAbilityBase.ApplyPremadeSpecArray");
		
		UDCGameplayAbilityBase_ApplyPremadeSpecArray_Params params {};
		params.ContainerTag = ContainerTag;
		params.EventData = EventData;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0178CED0
	 * 		Name   -> Function DungeonCrawler.DCGameplayAbilityBase.ApplyMovementModifier
	 * 		Flags  -> (Native, Protected, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		struct FGameplayTagContainer                       ContainerTags                                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UDCGameplayAbilityBase::ApplyMovementModifier(const struct FGameplayTagContainer& ContainerTags)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCGameplayAbilityBase.ApplyMovementModifier");
		
		UDCGameplayAbilityBase_ApplyMovementModifier_Params params {};
		params.ContainerTags = ContainerTags;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0178CBB0
	 * 		Name   -> Function DungeonCrawler.DCGameplayAbilityBase.ApplyEffectContainerSpecArray
	 * 		Flags  -> (Native, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		TArray<struct FDCGameplayEffectContainerSpec>      OutContainerSpecArray                                      (Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		struct FGameplayTag                                ContainerTag                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FGameplayEventData                          EventData                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	TArray<struct FActiveGameplayEffectHandle> UDCGameplayAbilityBase::ApplyEffectContainerSpecArray(TArray<struct FDCGameplayEffectContainerSpec>* OutContainerSpecArray, const struct FGameplayTag& ContainerTag, const struct FGameplayEventData& EventData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCGameplayAbilityBase.ApplyEffectContainerSpecArray");
		
		UDCGameplayAbilityBase_ApplyEffectContainerSpecArray_Params params {};
		params.ContainerTag = ContainerTag;
		params.EventData = EventData;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutContainerSpecArray != nullptr)
			*OutContainerSpecArray = params.OutContainerSpecArray;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0178C9B0
	 * 		Name   -> Function DungeonCrawler.DCGameplayAbilityBase.ApplyEffectContainerSpec
	 * 		Flags  -> (Native, Public, HasOutParms)
	 * Parameters:
	 * 		struct FDCGameplayEffectContainerSpec              ContainerSpec                                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	TArray<struct FActiveGameplayEffectHandle> UDCGameplayAbilityBase::ApplyEffectContainerSpec(const struct FDCGameplayEffectContainerSpec& ContainerSpec)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCGameplayAbilityBase.ApplyEffectContainerSpec");
		
		UDCGameplayAbilityBase_ApplyEffectContainerSpec_Params params {};
		params.ContainerSpec = ContainerSpec;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0178C6D0
	 * 		Name   -> Function DungeonCrawler.DCGameplayAbilityBase.ApplyEffectContainer
	 * 		Flags  -> (Native, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		struct FGameplayTag                                ContainerTag                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FGameplayEventData                          EventData                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		int32_t                                            OverrideGameplayLevel                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	TArray<struct FActiveGameplayEffectHandle> UDCGameplayAbilityBase::ApplyEffectContainer(const struct FGameplayTag& ContainerTag, const struct FGameplayEventData& EventData, int32_t OverrideGameplayLevel)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCGameplayAbilityBase.ApplyEffectContainer");
		
		UDCGameplayAbilityBase_ApplyEffectContainer_Params params {};
		params.ContainerTag = ContainerTag;
		params.EventData = EventData;
		params.OverrideGameplayLevel = OverrideGameplayLevel;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0178C4E0
	 * 		Name   -> Function DungeonCrawler.DCGameplayAbilityBase.AddGameplayCueWithParams
	 * 		Flags  -> (Final, Native, Protected, BlueprintCallable)
	 * Parameters:
	 * 		struct FGameplayTag                                GameplayCueTag                                             (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FGameplayCueParameters                      Params                                                     (Parm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	void UDCGameplayAbilityBase::AddGameplayCueWithParams(const struct FGameplayTag& GameplayCueTag, const struct FGameplayCueParameters& Params)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCGameplayAbilityBase.AddGameplayCueWithParams");
		
		UDCGameplayAbilityBase_AddGameplayCueWithParams_Params params {};
		params.GameplayCueTag = GameplayCueTag;
		params.Params = Params;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0178C2F0
	 * 		Name   -> Function DungeonCrawler.DCGameplayAbilityBase.AddGameplayCueLocalWithParams
	 * 		Flags  -> (Final, Native, Protected, BlueprintCallable)
	 * Parameters:
	 * 		struct FGameplayTag                                GameplayCueTag                                             (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FGameplayCueParameters                      Params                                                     (Parm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	void UDCGameplayAbilityBase::AddGameplayCueLocalWithParams(const struct FGameplayTag& GameplayCueTag, const struct FGameplayCueParameters& Params)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCGameplayAbilityBase.AddGameplayCueLocalWithParams");
		
		UDCGameplayAbilityBase_AddGameplayCueLocalWithParams_Params params {};
		params.GameplayCueTag = GameplayCueTag;
		params.Params = Params;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0178C1A0
	 * 		Name   -> Function DungeonCrawler.DCGameplayAbilityBase.AddGameplayCueLocal
	 * 		Flags  -> (Final, Native, Protected, BlueprintCallable)
	 * Parameters:
	 * 		struct FGameplayTag                                GameplayCueTag                                             (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FGameplayEffectContextHandle                EffectContext                                              (Parm, NativeAccessSpecifierPublic)
	 */
	void UDCGameplayAbilityBase::AddGameplayCueLocal(const struct FGameplayTag& GameplayCueTag, const struct FGameplayEffectContextHandle& EffectContext)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCGameplayAbilityBase.AddGameplayCueLocal");
		
		UDCGameplayAbilityBase_AddGameplayCueLocal_Params params {};
		params.GameplayCueTag = GameplayCueTag;
		params.EffectContext = EffectContext;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0178C050
	 * 		Name   -> Function DungeonCrawler.DCGameplayAbilityBase.AddGameplayCue
	 * 		Flags  -> (Final, Native, Protected, BlueprintCallable)
	 * Parameters:
	 * 		struct FGameplayTag                                GameplayCueTag                                             (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FGameplayEffectContextHandle                EffectContext                                              (Parm, NativeAccessSpecifierPublic)
	 */
	void UDCGameplayAbilityBase::AddGameplayCue(const struct FGameplayTag& GameplayCueTag, const struct FGameplayEffectContextHandle& EffectContext)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCGameplayAbilityBase.AddGameplayCue");
		
		UDCGameplayAbilityBase_AddGameplayCue_Params params {};
		params.GameplayCueTag = GameplayCueTag;
		params.EffectContext = EffectContext;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDCGameplayAbilityBase.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDCGameplayAbilityBase::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCGameplayAbilityBase");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDCGameplayEffectDataAsset.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDCGameplayEffectDataAsset::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCGameplayEffectDataAsset");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDCMovementModifierDataAsset.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDCMovementModifierDataAsset::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCMovementModifierDataAsset");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDCGameplayAbilityDataAsset.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDCGameplayAbilityDataAsset::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCGameplayAbilityDataAsset");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDCGameplayCueManager.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDCGameplayCueManager::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCGameplayCueManager");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0178ED20
	 * 		Name   -> Function DungeonCrawler.DCGameplayCueNotify_Actor.SetAkComponentRTPCValue
	 * 		Flags  -> (Final, Native, Protected, BlueprintCallable)
	 * Parameters:
	 * 		class UAkComponent*                                AkComponent                                                (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UAkRtpc*                                     RtpcValue                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              InTickValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              InTotalValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              InMaxRTPCValue                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ADCGameplayCueNotify_Actor::SetAkComponentRTPCValue(class UAkComponent* AkComponent, class UAkRtpc* RtpcValue, float InTickValue, float InTotalValue, float InMaxRTPCValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCGameplayCueNotify_Actor.SetAkComponentRTPCValue");
		
		ADCGameplayCueNotify_Actor_SetAkComponentRTPCValue_Params params {};
		params.AkComponent = AkComponent;
		params.RtpcValue = RtpcValue;
		params.InTickValue = InTickValue;
		params.InTotalValue = InTotalValue;
		params.InMaxRTPCValue = InMaxRTPCValue;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0178D220
	 * 		Name   -> Function DungeonCrawler.DCGameplayCueNotify_Actor.ClearAkComponentRTPCValue
	 * 		Flags  -> (Final, Native, Protected, BlueprintCallable)
	 */
	void ADCGameplayCueNotify_Actor::ClearAkComponentRTPCValue()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCGameplayCueNotify_Actor.ClearAkComponentRTPCValue");
		
		ADCGameplayCueNotify_Actor_ClearAkComponentRTPCValue_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ADCGameplayCueNotify_Actor.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ADCGameplayCueNotify_Actor::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCGameplayCueNotify_Actor");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDCGameplayEffectUIData.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDCGameplayEffectUIData::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCGameplayEffectUIData");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0178E820
	 * 		Name   -> Function DungeonCrawler.DCGameplayTagCollider.OnRep_TargetAccountId
	 * 		Flags  -> (Final, Native, Private)
	 * Parameters:
	 * 		class FString                                      InOldTargetAccountId                                       (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ADCGameplayTagCollider::OnRep_TargetAccountId(const class FString& InOldTargetAccountId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCGameplayTagCollider.OnRep_TargetAccountId");
		
		ADCGameplayTagCollider_OnRep_TargetAccountId_Params params {};
		params.InOldTargetAccountId = InOldTargetAccountId;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0178E800
	 * 		Name   -> Function DungeonCrawler.DCGameplayTagCollider.OnOverlapping
	 * 		Flags  -> (Final, Native, Private)
	 */
	void ADCGameplayTagCollider::OnOverlapping()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCGameplayTagCollider.OnOverlapping");
		
		ADCGameplayTagCollider_OnOverlapping_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0178E6A0
	 * 		Name   -> Function DungeonCrawler.DCGameplayTagCollider.OnOverlapEnd
	 * 		Flags  -> (Final, Native, Protected)
	 * Parameters:
	 * 		class UPrimitiveComponent*                         OverlappedComponent                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      OtherActor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UPrimitiveComponent*                         OtherComp                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            OtherBodyIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ADCGameplayTagCollider::OnOverlapEnd(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32_t OtherBodyIndex)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCGameplayTagCollider.OnOverlapEnd");
		
		ADCGameplayTagCollider_OnOverlapEnd_Params params {};
		params.OverlappedComponent = OverlappedComponent;
		params.OtherActor = OtherActor;
		params.OtherComp = OtherComp;
		params.OtherBodyIndex = OtherBodyIndex;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0178E430
	 * 		Name   -> Function DungeonCrawler.DCGameplayTagCollider.OnOverlapBegin
	 * 		Flags  -> (Final, Native, Protected, HasOutParms)
	 * Parameters:
	 * 		class UPrimitiveComponent*                         OverlappedComponent                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      OtherActor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UPrimitiveComponent*                         OtherComp                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            OtherBodyIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bFromSweep                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FHitResult                                  SweepResult                                                (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	void ADCGameplayTagCollider::OnOverlapBegin(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32_t OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCGameplayTagCollider.OnOverlapBegin");
		
		ADCGameplayTagCollider_OnOverlapBegin_Params params {};
		params.OverlappedComponent = OverlappedComponent;
		params.OtherActor = OtherActor;
		params.OtherComp = OtherComp;
		params.OtherBodyIndex = OtherBodyIndex;
		params.bFromSweep = bFromSweep;
		params.SweepResult = SweepResult;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ADCGameplayTagCollider.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ADCGameplayTagCollider::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCGameplayTagCollider");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01793B60
	 * 		Name   -> Function DungeonCrawler.DCGameSession.UnbindMsgAll
	 * 		Flags  -> (Native, Public)
	 * Parameters:
	 * 		class UObject*                                     InObject                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ADCGameSession::UnbindMsgAll(class UObject* InObject)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCGameSession.UnbindMsgAll");
		
		ADCGameSession_UnbindMsgAll_Params params {};
		params.InObject = InObject;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01793A90
	 * 		Name   -> Function DungeonCrawler.DCGameSession.UnbindMsg
	 * 		Flags  -> (Native, Public)
	 * Parameters:
	 * 		class UScriptStruct*                               InMsgType                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UObject*                                     InObject                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ADCGameSession::UnbindMsg(class UScriptStruct* InMsgType, class UObject* InObject)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCGameSession.UnbindMsg");
		
		ADCGameSession_UnbindMsg_Params params {};
		params.InMsgType = InMsgType;
		params.InObject = InObject;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01793A60
	 * 		Name   -> Function DungeonCrawler.DCGameSession.TerminateBase
	 * 		Flags  -> (Native, Public)
	 */
	void ADCGameSession::TerminateBase()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCGameSession.TerminateBase");
		
		ADCGameSession_TerminateBase_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017925D0
	 * 		Name   -> Function DungeonCrawler.DCGameSession.CharacterResurrection
	 * 		Flags  -> (Final, Native, Private)
	 * Parameters:
	 * 		class FString                                      AccountId                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UClass*                                      DCCharacterClass                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		TArray<struct FDCGameplayEffectSetByCallerData>    InInitGameplayEffectSetByCallerDataArray                   (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
	 * 		bool                                               bIsRemoveAllItem                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class ADCCharacterProduction*                      CharacterProduction                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ADCGameSession::CharacterResurrection(const class FString& AccountId, class UClass* DCCharacterClass, TArray<struct FDCGameplayEffectSetByCallerData> InInitGameplayEffectSetByCallerDataArray, bool bIsRemoveAllItem, class ADCCharacterProduction* CharacterProduction)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCGameSession.CharacterResurrection");
		
		ADCGameSession_CharacterResurrection_Params params {};
		params.AccountId = AccountId;
		params.DCCharacterClass = DCCharacterClass;
		params.InInitGameplayEffectSetByCallerDataArray = InInitGameplayEffectSetByCallerDataArray;
		params.bIsRemoveAllItem = bIsRemoveAllItem;
		params.CharacterProduction = CharacterProduction;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D3C640
	 * 		Name   -> Function DungeonCrawler.DCGameSession.BroadcastMsgBlueprint
	 * 		Flags  -> (Native, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		int32_t                                            InMsg                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ADCGameSession::BroadcastMsgBlueprint(int32_t InMsg)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCGameSession.BroadcastMsgBlueprint");
		
		ADCGameSession_BroadcastMsgBlueprint_Params params {};
		params.InMsg = InMsg;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ADCGameSession.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ADCGameSession::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCGameSession");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDCGameSettings.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDCGameSettings::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCGameSettings");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.DCGameSpawner.UpdateGameState
	 * 		Flags  -> (Event, Protected, HasOutParms, BlueprintEvent)
	 * Parameters:
	 * 		struct FGameStateData                              InGameStateData                                            (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void ADCGameSpawner::UpdateGameState(const struct FGameStateData& InGameStateData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCGameSpawner.UpdateGameState");
		
		ADCGameSpawner_UpdateGameState_Params params {};
		params.InGameStateData = InGameStateData;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017939B0
	 * 		Name   -> Function DungeonCrawler.DCGameSpawner.SpawnProps
	 * 		Flags  -> (Final, Native, Protected, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FPrimaryAssetId                             InPropsId                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class APropsActorBase* ADCGameSpawner::SpawnProps(const struct FPrimaryAssetId& InPropsId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCGameSpawner.SpawnProps");
		
		ADCGameSpawner_SpawnProps_Params params {};
		params.InPropsId = InPropsId;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017938C0
	 * 		Name   -> Function DungeonCrawler.DCGameSpawner.SpawnMonster
	 * 		Flags  -> (Final, Native, Protected, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FPrimaryAssetId                             InMonsterId                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bPreview                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class ADCMonsterBase* ADCGameSpawner::SpawnMonster(const struct FPrimaryAssetId& InMonsterId, bool bPreview)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCGameSpawner.SpawnMonster");
		
		ADCGameSpawner_SpawnMonster_Params params {};
		params.InMonsterId = InMonsterId;
		params.bPreview = bPreview;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01793810
	 * 		Name   -> Function DungeonCrawler.DCGameSpawner.SpawnItemHolder
	 * 		Flags  -> (Final, Native, Protected, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FPrimaryAssetId                             InLootDropId                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class AItemHolderActorBase* ADCGameSpawner::SpawnItemHolder(const struct FPrimaryAssetId& InLootDropId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCGameSpawner.SpawnItemHolder");
		
		ADCGameSpawner_SpawnItemHolder_Params params {};
		params.InLootDropId = InLootDropId;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017937F0
	 * 		Name   -> Function DungeonCrawler.DCGameSpawner.SetNextPreview
	 * 		Flags  -> (Final, Native, Protected)
	 */
	void ADCGameSpawner::SetNextPreview()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCGameSpawner.SetNextPreview");
		
		ADCGameSpawner_SetNextPreview_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017925B0
	 * 		Name   -> Function DungeonCrawler.DCGameSpawner.BindFMsgGameStateNotify
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void ADCGameSpawner::BindFMsgGameStateNotify()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCGameSpawner.BindFMsgGameStateNotify");
		
		ADCGameSpawner_BindFMsgGameStateNotify_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ADCGameSpawner.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ADCGameSpawner::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCGameSpawner");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ADCGameSpawnerGroup.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ADCGameSpawnerGroup::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCGameSpawnerGroup");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01764580
	 * 		Name   -> Function DungeonCrawler.DCGameStateBase.UnbindMsgAll
	 * 		Flags  -> (Native, Public)
	 * Parameters:
	 * 		class UObject*                                     InObject                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ADCGameStateBase::UnbindMsgAll(class UObject* InObject)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCGameStateBase.UnbindMsgAll");
		
		ADCGameStateBase_UnbindMsgAll_Params params {};
		params.InObject = InObject;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01764010
	 * 		Name   -> Function DungeonCrawler.DCGameStateBase.UnbindMsg
	 * 		Flags  -> (Native, Public)
	 * Parameters:
	 * 		class UScriptStruct*                               InMsgType                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UObject*                                     InObject                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ADCGameStateBase::UnbindMsg(class UScriptStruct* InMsgType, class UObject* InObject)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCGameStateBase.UnbindMsg");
		
		ADCGameStateBase_UnbindMsg_Params params {};
		params.InMsgType = InMsgType;
		params.InObject = InObject;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01763E20
	 * 		Name   -> Function DungeonCrawler.DCGameStateBase.TerminateBase
	 * 		Flags  -> (Native, Public)
	 */
	void ADCGameStateBase::TerminateBase()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCGameStateBase.TerminateBase");
		
		ADCGameStateBase_TerminateBase_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01793630
	 * 		Name   -> Function DungeonCrawler.DCGameStateBase.SetGameInfo
	 * 		Flags  -> (Final, Native, Public, HasOutParms)
	 * Parameters:
	 * 		struct FDCGameInfo                                 InGameInfo                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void ADCGameStateBase::SetGameInfo(const struct FDCGameInfo& InGameInfo)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCGameStateBase.SetGameInfo");
		
		ADCGameStateBase_SetGameInfo_Params params {};
		params.InGameInfo = InGameInfo;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017935A0
	 * 		Name   -> Function DungeonCrawler.DCGameStateBase.SetDungeonInfo_HideDeathSwarmTimer
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               HideDeathSwarmTimer                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ADCGameStateBase::SetDungeonInfo_HideDeathSwarmTimer(bool HideDeathSwarmTimer)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCGameStateBase.SetDungeonInfo_HideDeathSwarmTimer");
		
		ADCGameStateBase_SetDungeonInfo_HideDeathSwarmTimer_Params params {};
		params.HideDeathSwarmTimer = HideDeathSwarmTimer;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01793510
	 * 		Name   -> Function DungeonCrawler.DCGameStateBase.SetDungeonInfo_GameTimeSec
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		int32_t                                            GameTimeSec                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ADCGameStateBase::SetDungeonInfo_GameTimeSec(int32_t GameTimeSec)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCGameStateBase.SetDungeonInfo_GameTimeSec");
		
		ADCGameStateBase_SetDungeonInfo_GameTimeSec_Params params {};
		params.GameTimeSec = GameTimeSec;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01793270
	 * 		Name   -> Function DungeonCrawler.DCGameStateBase.OnSetGameInfo
	 * 		Flags  -> (Final, Native, Private, HasOutParms, Const)
	 * Parameters:
	 * 		struct FDCGameInfo                                 OldGameInfo                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void ADCGameStateBase::OnSetGameInfo(const struct FDCGameInfo& OldGameInfo)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCGameStateBase.OnSetGameInfo");
		
		ADCGameStateBase_OnSetGameInfo_Params params {};
		params.OldGameInfo = OldGameInfo;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017933F0
	 * 		Name   -> Function DungeonCrawler.DCGameStateBase.OnRep_PartyDataArray
	 * 		Flags  -> (Final, Native, Private, HasOutParms)
	 * Parameters:
	 * 		TArray<struct FPartyData>                          OldPartyDataArray                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void ADCGameStateBase::OnRep_PartyDataArray(TArray<struct FPartyData> OldPartyDataArray)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCGameStateBase.OnRep_PartyDataArray");
		
		ADCGameStateBase_OnRep_PartyDataArray_Params params {};
		params.OldPartyDataArray = OldPartyDataArray;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01793340
	 * 		Name   -> Function DungeonCrawler.DCGameStateBase.OnRep_GameStateDataArray
	 * 		Flags  -> (Final, Native, Private, HasOutParms)
	 * Parameters:
	 * 		TArray<struct FGameStateData>                      OldGameStateDataArray                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void ADCGameStateBase::OnRep_GameStateDataArray(TArray<struct FGameStateData> OldGameStateDataArray)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCGameStateBase.OnRep_GameStateDataArray");
		
		ADCGameStateBase_OnRep_GameStateDataArray_Params params {};
		params.OldGameStateDataArray = OldGameStateDataArray;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01793270
	 * 		Name   -> Function DungeonCrawler.DCGameStateBase.OnRep_GameInfo
	 * 		Flags  -> (Final, Native, Private, HasOutParms, Const)
	 * Parameters:
	 * 		struct FDCGameInfo                                 OldGameInfo                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void ADCGameStateBase::OnRep_GameInfo(const struct FDCGameInfo& OldGameInfo)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCGameStateBase.OnRep_GameInfo");
		
		ADCGameStateBase_OnRep_GameInfo_Params params {};
		params.OldGameInfo = OldGameInfo;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01793190
	 * 		Name   -> Function DungeonCrawler.DCGameStateBase.OnRep_GameFloorRuleData
	 * 		Flags  -> (Final, Native, Private, HasOutParms)
	 * Parameters:
	 * 		struct FGameFloorRuleData                          InOldGameFloorRuleData                                     (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void ADCGameStateBase::OnRep_GameFloorRuleData(const struct FGameFloorRuleData& InOldGameFloorRuleData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCGameStateBase.OnRep_GameFloorRuleData");
		
		ADCGameStateBase_OnRep_GameFloorRuleData_Params params {};
		params.InOldGameFloorRuleData = InOldGameFloorRuleData;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017930F0
	 * 		Name   -> Function DungeonCrawler.DCGameStateBase.OnRep_DungeonInfo
	 * 		Flags  -> (Final, Native, Private, HasOutParms)
	 * Parameters:
	 * 		struct FDCDungeonInfo                              OldDungeonInfo                                             (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void ADCGameStateBase::OnRep_DungeonInfo(const struct FDCDungeonInfo& OldDungeonInfo)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCGameStateBase.OnRep_DungeonInfo");
		
		ADCGameStateBase_OnRep_DungeonInfo_Params params {};
		params.OldDungeonInfo = OldDungeonInfo;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01792FE0
	 * 		Name   -> Function DungeonCrawler.DCGameStateBase.OnRep_AccountDataReplicationArray
	 * 		Flags  -> (Final, Native, Private, HasOutParms)
	 * Parameters:
	 * 		TArray<struct FAccountDataReplication>             OldAccountDataReplicationArray                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void ADCGameStateBase::OnRep_AccountDataReplicationArray(TArray<struct FAccountDataReplication> OldAccountDataReplicationArray)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCGameStateBase.OnRep_AccountDataReplicationArray");
		
		ADCGameStateBase_OnRep_AccountDataReplicationArray_Params params {};
		params.OldAccountDataReplicationArray = OldAccountDataReplicationArray;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01792F00
	 * 		Name   -> Function DungeonCrawler.DCGameStateBase.OnGameFloorRuleData
	 * 		Flags  -> (Final, Net, NetReliable, Native, Event, NetMulticast, Private)
	 * Parameters:
	 * 		struct FGameFloorRuleData                          InGameFloorRuleData                                        (ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void ADCGameStateBase::OnGameFloorRuleData(const struct FGameFloorRuleData& InGameFloorRuleData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCGameStateBase.OnGameFloorRuleData");
		
		ADCGameStateBase_OnGameFloorRuleData_Params params {};
		params.InGameFloorRuleData = InGameFloorRuleData;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01792E60
	 * 		Name   -> Function DungeonCrawler.DCGameStateBase.OnDungeonInfo
	 * 		Flags  -> (Final, Net, NetReliable, Native, Event, NetMulticast, Private)
	 * Parameters:
	 * 		struct FDCDungeonInfo                              InDungeonInfo                                              (ConstParm, Parm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void ADCGameStateBase::OnDungeonInfo(const struct FDCDungeonInfo& InDungeonInfo)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCGameStateBase.OnDungeonInfo");
		
		ADCGameStateBase_OnDungeonInfo_Params params {};
		params.InDungeonInfo = InDungeonInfo;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017929D0
	 * 		Name   -> Function DungeonCrawler.DCGameStateBase.GetGameInfo
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	struct FDCGameInfo ADCGameStateBase::GetGameInfo()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCGameStateBase.GetGameInfo");
		
		ADCGameStateBase_GetGameInfo_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01792990
	 * 		Name   -> Function DungeonCrawler.DCGameStateBase.GetDungeonInfo
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	struct FDCDungeonInfo ADCGameStateBase::GetDungeonInfo()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCGameStateBase.GetDungeonInfo");
		
		ADCGameStateBase_GetDungeonInfo_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D3C640
	 * 		Name   -> Function DungeonCrawler.DCGameStateBase.BroadcastMsgBlueprint
	 * 		Flags  -> (Native, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		int32_t                                            InMsg                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ADCGameStateBase::BroadcastMsgBlueprint(int32_t InMsg)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCGameStateBase.BroadcastMsgBlueprint");
		
		ADCGameStateBase_BroadcastMsgBlueprint_Params params {};
		params.InMsg = InMsg;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ADCGameStateBase.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ADCGameStateBase::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCGameStateBase");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01792D20
	 * 		Name   -> Function DungeonCrawler.DCGameUserSettings.GetInputConfigByName
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		class FName                                        ConfigName                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UPlayerMappableInputConfig* UDCGameUserSettings::GetInputConfigByName(const class FName& ConfigName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCGameUserSettings.GetInputConfigByName");
		
		UDCGameUserSettings_GetInputConfigByName_Params params {};
		params.ConfigName = ConfigName;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDCGameUserSettings.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDCGameUserSettings::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCGameUserSettings");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ADCGATA_AimTrace.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ADCGATA_AimTrace::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCGATA_AimTrace");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ADCGATA_AimTraceOnServer.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ADCGATA_AimTraceOnServer::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCGATA_AimTraceOnServer");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ADCGATA_AimTraceToSocket.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ADCGATA_AimTraceToSocket::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCGATA_AimTraceToSocket");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ADCGATA_AimTraceWithSphere.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ADCGATA_AimTraceWithSphere::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCGATA_AimTraceWithSphere");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ADCGATA_GroundTraceWithMaxHeight.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ADCGATA_GroundTraceWithMaxHeight::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCGATA_GroundTraceWithMaxHeight");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ADCGATA_LineCollision.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ADCGATA_LineCollision::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCGATA_LineCollision");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ADCGATA_LineTraceInteractable.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ADCGATA_LineTraceInteractable::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCGATA_LineTraceInteractable");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDCGeometryCollectionComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDCGeometryCollectionComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCGeometryCollectionComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01793700
	 * 		Name   -> Function DungeonCrawler.DCGhostTrailActor.SetGhostMaterial
	 * 		Flags  -> (Final, Native, Protected)
	 * Parameters:
	 * 		TArray<class UMeshComponent*>                      Components                                                 (Parm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	void ADCGhostTrailActor::SetGhostMaterial(TArray<class UMeshComponent*> Components)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCGhostTrailActor.SetGhostMaterial");
		
		ADCGhostTrailActor_SetGhostMaterial_Params params {};
		params.Components = Components;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01792DE0
	 * 		Name   -> Function DungeonCrawler.DCGhostTrailActor.HandleTimelineUpdate
	 * 		Flags  -> (Final, Native, Protected)
	 * Parameters:
	 * 		float                                              Value                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ADCGhostTrailActor::HandleTimelineUpdate(float Value)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCGhostTrailActor.HandleTimelineUpdate");
		
		ADCGhostTrailActor_HandleTimelineUpdate_Params params {};
		params.Value = Value;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01792DC0
	 * 		Name   -> Function DungeonCrawler.DCGhostTrailActor.HandleTimelineFinished
	 * 		Flags  -> (Final, Native, Protected)
	 */
	void ADCGhostTrailActor::HandleTimelineFinished()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCGhostTrailActor.HandleTimelineFinished");
		
		ADCGhostTrailActor_HandleTimelineFinished_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01792590
	 * 		Name   -> Function DungeonCrawler.DCGhostTrailActor.BeginGhostTrailEffect
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void ADCGhostTrailActor::BeginGhostTrailEffect()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCGhostTrailActor.BeginGhostTrailEffect");
		
		ADCGhostTrailActor_BeginGhostTrailEffect_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ADCGhostTrailActor.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ADCGhostTrailActor::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCGhostTrailActor");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01792B30
	 * 		Name   -> Function DungeonCrawler.DCHitBoxComponent.GetHitResultFromClosestLocationTraceOnMesh
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		struct FHitResult                                  InHitResult                                                (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      Instigator                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FHitResult UDCHitBoxComponent::GetHitResultFromClosestLocationTraceOnMesh(const struct FHitResult& InHitResult, class AActor* Instigator)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCHitBoxComponent.GetHitResultFromClosestLocationTraceOnMesh");
		
		UDCHitBoxComponent_GetHitResultFromClosestLocationTraceOnMesh_Params params {};
		params.InHitResult = InHitResult;
		params.Instigator = Instigator;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01792A90
	 * 		Name   -> Function DungeonCrawler.DCHitBoxComponent.GetHitDirection
	 * 		Flags  -> (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		struct FVector                                     AttackerLocation                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	EHitDirection UDCHitBoxComponent::GetHitDirection(const struct FVector& AttackerLocation)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCHitBoxComponent.GetHitDirection");
		
		UDCHitBoxComponent_GetHitDirection_Params params {};
		params.AttackerLocation = AttackerLocation;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01792820
	 * 		Name   -> Function DungeonCrawler.DCHitBoxComponent.GetClosestLocationOnMesh
	 * 		Flags  -> (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		struct FHitResult                                  InHitResult                                                (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      Instigator                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FVector UDCHitBoxComponent::GetClosestLocationOnMesh(const struct FHitResult& InHitResult, class AActor* Instigator)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCHitBoxComponent.GetClosestLocationOnMesh");
		
		UDCHitBoxComponent_GetClosestLocationOnMesh_Params params {};
		params.InHitResult = InHitResult;
		params.Instigator = Instigator;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDCHitBoxComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDCHitBoxComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCHitBoxComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDCHudWidgetBase.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDCHudWidgetBase::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCHudWidgetBase");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDCIdTagGroupItemDataAsset.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDCIdTagGroupItemDataAsset::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCIdTagGroupItemDataAsset");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ADCIngameGameMode.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ADCIngameGameMode::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCIngameGameMode");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ADCIngameGameSession.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ADCIngameGameSession::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCIngameGameSession");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDCInputComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDCInputComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCInputComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDCInputConfig.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDCInputConfig::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCInputConfig");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDCInputConfigData.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDCInputConfigData::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCInputConfigData");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017992E0
	 * 		Name   -> Function DungeonCrawler.DCInputNumberWidget.OnCancelled
	 * 		Flags  -> (Final, Native, Private)
	 */
	void UDCInputNumberWidget::OnCancelled()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCInputNumberWidget.OnCancelled");
		
		UDCInputNumberWidget_OnCancelled_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017992C0
	 * 		Name   -> Function DungeonCrawler.DCInputNumberWidget.OnAccepted
	 * 		Flags  -> (Final, Native, Private)
	 */
	void UDCInputNumberWidget::OnAccepted()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCInputNumberWidget.OnAccepted");
		
		UDCInputNumberWidget_OnAccepted_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017992A0
	 * 		Name   -> Function DungeonCrawler.DCInputNumberWidget.ManualClick
	 * 		Flags  -> (Final, Native, Protected, BlueprintCallable)
	 */
	void UDCInputNumberWidget::ManualClick()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCInputNumberWidget.ManualClick");
		
		UDCInputNumberWidget_ManualClick_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017991B0
	 * 		Name   -> Function DungeonCrawler.DCInputNumberWidget.IsValidText
	 * 		Flags  -> (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		class FText                                        Text                                                       (Parm, NativeAccessSpecifierPublic)
	 */
	bool UDCInputNumberWidget::IsValidText(const class FText& Text)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCInputNumberWidget.IsValidText");
		
		UDCInputNumberWidget_IsValidText_Params params {};
		params.Text = Text;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDCInputNumberWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDCInputNumberWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCInputNumberWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01799090
	 * 		Name   -> Function DungeonCrawler.DCInteractTargetInterface.InteractTargetInfoRarity
	 * 		Flags  -> (Native, Event, Public, HasOutParms, BlueprintCallable, BlueprintEvent)
	 * Parameters:
	 * 		struct FGameplayTag                                RarityTag                                                  (Parm, OutParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UDCInteractTargetInterface::InteractTargetInfoRarity(struct FGameplayTag* RarityTag)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCInteractTargetInterface.InteractTargetInfoRarity");
		
		UDCInteractTargetInterface_InteractTargetInfoRarity_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (RarityTag != nullptr)
			*RarityTag = params.RarityTag;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01798FC0
	 * 		Name   -> Function DungeonCrawler.DCInteractTargetInterface.InteractTargetInfoName
	 * 		Flags  -> (Native, Event, Public, HasOutParms, BlueprintCallable, BlueprintEvent)
	 * Parameters:
	 * 		class FText                                        Name                                                       (Parm, OutParm, NativeAccessSpecifierPublic)
	 */
	void UDCInteractTargetInterface::InteractTargetInfoName(class FText* Name)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCInteractTargetInterface.InteractTargetInfoName");
		
		UDCInteractTargetInterface_InteractTargetInfoName_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (Name != nullptr)
			*Name = params.Name;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDCInteractTargetInterface.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDCInteractTargetInterface::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCInteractTargetInterface");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDCInventoryComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDCInventoryComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCInventoryComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDCInventoryBase.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDCInventoryBase::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCInventoryBase");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDCItemActorAttributeSet.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDCItemActorAttributeSet::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCItemActorAttributeSet");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDCItemContainerDataAsset.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDCItemContainerDataAsset::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCItemContainerDataAsset");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDCItemBundleInfoDataAsset.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDCItemBundleInfoDataAsset::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCItemBundleInfoDataAsset");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDCItemRequirementDataAsset.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDCItemRequirementDataAsset::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCItemRequirementDataAsset");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDCItemPropertyTypeDataAsset.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDCItemPropertyTypeDataAsset::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCItemPropertyTypeDataAsset");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDCItemPropertyDataAsset.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDCItemPropertyDataAsset::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCItemPropertyDataAsset");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDCItemConsumeDataAsset.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDCItemConsumeDataAsset::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCItemConsumeDataAsset");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDCItemDataAsset.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDCItemDataAsset::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCItemDataAsset");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDCItemDragDropOperation.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDCItemDragDropOperation::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCItemDragDropOperation");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDCItemDragVisualWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDCItemDragVisualWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCItemDragVisualWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDCItemSkinArtData.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDCItemSkinArtData::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCItemSkinArtData");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01799820
	 * 		Name   -> Function DungeonCrawler.DCItemSkinComponent.RemoveDataForDebug_Server
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetServer, HasDefaults)
	 * Parameters:
	 * 		struct FPrimaryAssetId                             ID                                                         (ConstParm, Parm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UDCItemSkinComponent::RemoveDataForDebug_Server(const struct FPrimaryAssetId& ID)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCItemSkinComponent.RemoveDataForDebug_Server");
		
		UDCItemSkinComponent_RemoveDataForDebug_Server_Params params {};
		params.ID = ID;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017996F0
	 * 		Name   -> Function DungeonCrawler.DCItemSkinComponent.OnRep_Datas
	 * 		Flags  -> (Final, Native, Private, HasOutParms)
	 * Parameters:
	 * 		TArray<class UDCItemSkinDataAsset*>                OldDatas                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UDCItemSkinComponent::OnRep_Datas(TArray<class UDCItemSkinDataAsset*> OldDatas)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCItemSkinComponent.OnRep_Datas");
		
		UDCItemSkinComponent_OnRep_Datas_Params params {};
		params.OldDatas = OldDatas;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01798BE0
	 * 		Name   -> Function DungeonCrawler.DCItemSkinComponent.AddDataForDebug_Server
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetServer)
	 * Parameters:
	 * 		class UDCItemSkinDataAsset*                        InData                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UDCItemSkinComponent::AddDataForDebug_Server(class UDCItemSkinDataAsset* InData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCItemSkinComponent.AddDataForDebug_Server");
		
		UDCItemSkinComponent_AddDataForDebug_Server_Params params {};
		params.InData = InData;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDCItemSkinComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDCItemSkinComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCItemSkinComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDCItemSkinDataAsset.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDCItemSkinDataAsset::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCItemSkinDataAsset");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDCItemSkinListEntryWidgetData.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDCItemSkinListEntryWidgetData::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCItemSkinListEntryWidgetData");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01798CA0
	 * 		Name   -> Function DungeonCrawler.DCItemSkinWidget.GetTooltipWidget
	 * 		Flags  -> (Final, Native, Protected, BlueprintCallable, BlueprintPure)
	 */
	class UUserWidget* UDCItemSkinWidget::GetTooltipWidget()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCItemSkinWidget.GetTooltipWidget");
		
		UDCItemSkinWidget_GetTooltipWidget_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDCItemSkinWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDCItemSkinWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCItemSkinWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0177DC90
	 * 		Name   -> Function DungeonCrawler.DCItemSkinListEntryWidget.OnRightClicked
	 * 		Flags  -> (Native, Public)
	 */
	void UDCItemSkinListEntryWidget::OnRightClicked()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCItemSkinListEntryWidget.OnRightClicked");
		
		UDCItemSkinListEntryWidget_OnRightClicked_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDCItemSkinListEntryWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDCItemSkinListEntryWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCItemSkinListEntryWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDCItemTooltipNameWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDCItemTooltipNameWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCItemTooltipNameWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDCItemTooltipStatElementWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDCItemTooltipStatElementWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCItemTooltipStatElementWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01799120
	 * 		Name   -> Function DungeonCrawler.DCItemTooltipStatWidget.IsEmpty
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool UDCItemTooltipStatWidget::IsEmpty()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCItemTooltipStatWidget.IsEmpty");
		
		UDCItemTooltipStatWidget_IsEmpty_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDCItemTooltipStatWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDCItemTooltipStatWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCItemTooltipStatWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDCItemTooltipAbilityElementWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDCItemTooltipAbilityElementWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCItemTooltipAbilityElementWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01799120
	 * 		Name   -> Function DungeonCrawler.DCItemTooltipAbilityWidget.IsEmpty
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool UDCItemTooltipAbilityWidget::IsEmpty()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCItemTooltipAbilityWidget.IsEmpty");
		
		UDCItemTooltipAbilityWidget_IsEmpty_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDCItemTooltipAbilityWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDCItemTooltipAbilityWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCItemTooltipAbilityWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01799150
	 * 		Name   -> Function DungeonCrawler.DCItemTooltipRequirementWidget.IsEmpty
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool UDCItemTooltipRequirementWidget::IsEmpty()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCItemTooltipRequirementWidget.IsEmpty");
		
		UDCItemTooltipRequirementWidget_IsEmpty_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDCItemTooltipRequirementWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDCItemTooltipRequirementWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCItemTooltipRequirementWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDCItemTooltipInfoWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDCItemTooltipInfoWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCItemTooltipInfoWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDCItemTooltipWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDCItemTooltipWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCItemTooltipWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0179F660
	 * 		Name   -> Function DungeonCrawler.DCItemViewerActor.SetStartRotateLocation
	 * 		Flags  -> (Final, Native, Protected, BlueprintCallable)
	 * Parameters:
	 * 		float                                              InStartPosition                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ADCItemViewerActor::SetStartRotateLocation(float InStartPosition)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCItemViewerActor.SetStartRotateLocation");
		
		ADCItemViewerActor_SetStartRotateLocation_Params params {};
		params.InStartPosition = InStartPosition;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0179F5E0
	 * 		Name   -> Function DungeonCrawler.DCItemViewerActor.SetItemActorRotation
	 * 		Flags  -> (Final, Native, Protected, BlueprintCallable)
	 * Parameters:
	 * 		float                                              InYaw                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ADCItemViewerActor::SetItemActorRotation(float InYaw)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCItemViewerActor.SetItemActorRotation");
		
		ADCItemViewerActor_SetItemActorRotation_Params params {};
		params.InYaw = InYaw;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0179DC10
	 * 		Name   -> Function DungeonCrawler.DCItemViewerActor.InitItemActorRotation
	 * 		Flags  -> (Final, Native, Protected, BlueprintCallable)
	 */
	void ADCItemViewerActor::InitItemActorRotation()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCItemViewerActor.InitItemActorRotation");
		
		ADCItemViewerActor_InitItemActorRotation_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ADCItemViewerActor.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ADCItemViewerActor::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCItemViewerActor");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0179DBF0
	 * 		Name   -> Function DungeonCrawler.DCLoadoutWidget.Init
	 * 		Flags  -> (Final, Native, Private)
	 */
	void UDCLoadoutWidget::Init()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCLoadoutWidget.Init");
		
		UDCLoadoutWidget_Init_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDCLoadoutWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDCLoadoutWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCLoadoutWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ADCLoginGameMode.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ADCLoginGameMode::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCLoginGameMode");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0179DA00
	 * 		Name   -> Function DungeonCrawler.DCMerchantBlueprintLibrary.GetStockSellBackReceivedDataArray
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		struct FDesignDataStockSellBackItem                InDesignDataStockSellBackItem                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	TArray<struct FStockSellBackReceivedData> UDCMerchantBlueprintLibrary::STATIC_GetStockSellBackReceivedDataArray(const struct FDesignDataStockSellBackItem& InDesignDataStockSellBackItem)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCMerchantBlueprintLibrary.GetStockSellBackReceivedDataArray");
		
		UDCMerchantBlueprintLibrary_GetStockSellBackReceivedDataArray_Params params {};
		params.InDesignDataStockSellBackItem = InDesignDataStockSellBackItem;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0179D860
	 * 		Name   -> Function DungeonCrawler.DCMerchantBlueprintLibrary.GetStockCraftRequiredDataArray
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		struct FDesignDataStockCraftItem                   InDesignDataStockCraftItem                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	TArray<struct FStockCraftRequiredData> UDCMerchantBlueprintLibrary::STATIC_GetStockCraftRequiredDataArray(const struct FDesignDataStockCraftItem& InDesignDataStockCraftItem)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCMerchantBlueprintLibrary.GetStockCraftRequiredDataArray");
		
		UDCMerchantBlueprintLibrary_GetStockCraftRequiredDataArray_Params params {};
		params.InDesignDataStockCraftItem = InDesignDataStockCraftItem;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0179D860
	 * 		Name   -> Function DungeonCrawler.DCMerchantBlueprintLibrary.GetStockBuyRequiredDataArray
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		struct FDesignDataStockBuyItem                     InDesignDataStockBuyItem                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	TArray<struct FStockBuyRequiredData> UDCMerchantBlueprintLibrary::STATIC_GetStockBuyRequiredDataArray(const struct FDesignDataStockBuyItem& InDesignDataStockBuyItem)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCMerchantBlueprintLibrary.GetStockBuyRequiredDataArray");
		
		UDCMerchantBlueprintLibrary_GetStockBuyRequiredDataArray_Params params {};
		params.InDesignDataStockBuyItem = InDesignDataStockBuyItem;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDCMerchantBlueprintLibrary.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDCMerchantBlueprintLibrary::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCMerchantBlueprintLibrary");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDCMetaCustomizeComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDCMetaCustomizeComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCMetaCustomizeComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ADCMetaGameMode.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ADCMetaGameMode::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCMetaGameMode");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ADCMetaGameSession.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ADCMetaGameSession::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCMetaGameSession");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017A02D0
	 * 		Name   -> Function DungeonCrawler.DCMetaInventoryComponent.UnbindMsgAll
	 * 		Flags  -> (Native, Public)
	 * Parameters:
	 * 		class UObject*                                     InObject                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UDCMetaInventoryComponent::UnbindMsgAll(class UObject* InObject)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCMetaInventoryComponent.UnbindMsgAll");
		
		UDCMetaInventoryComponent_UnbindMsgAll_Params params {};
		params.InObject = InObject;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017A0170
	 * 		Name   -> Function DungeonCrawler.DCMetaInventoryComponent.UnbindMsg
	 * 		Flags  -> (Native, Public)
	 * Parameters:
	 * 		class UScriptStruct*                               InMsgType                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UObject*                                     InObject                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UDCMetaInventoryComponent::UnbindMsg(class UScriptStruct* InMsgType, class UObject* InObject)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCMetaInventoryComponent.UnbindMsg");
		
		UDCMetaInventoryComponent_UnbindMsg_Params params {};
		params.InMsgType = InMsgType;
		params.InObject = InObject;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017A0070
	 * 		Name   -> Function DungeonCrawler.DCMetaInventoryComponent.TerminateBase
	 * 		Flags  -> (Native, Public)
	 */
	void UDCMetaInventoryComponent::TerminateBase()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCMetaInventoryComponent.TerminateBase");
		
		UDCMetaInventoryComponent_TerminateBase_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0179EAD0
	 * 		Name   -> Function DungeonCrawler.DCMetaInventoryComponent.OnResetInventory
	 * 		Flags  -> (Final, Native, Private)
	 */
	void UDCMetaInventoryComponent::OnResetInventory()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCMetaInventoryComponent.OnResetInventory");
		
		UDCMetaInventoryComponent_OnResetInventory_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0179E6E0
	 * 		Name   -> Function DungeonCrawler.DCMetaInventoryComponent.OnItemDrop
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		struct FDCItemId                                   ItemId                                                     (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            Count                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EDCInventoryId                                     Src                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EDCInventoryId                                     Dst                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            Index                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UDCMetaInventoryComponent::OnItemDrop(const struct FDCItemId& ItemId, int32_t Count, EDCInventoryId Src, EDCInventoryId Dst, int32_t Index)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCMetaInventoryComponent.OnItemDrop");
		
		UDCMetaInventoryComponent_OnItemDrop_Params params {};
		params.ItemId = ItemId;
		params.Count = Count;
		params.Src = Src;
		params.Dst = Dst;
		params.Index = Index;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0179E360
	 * 		Name   -> Function DungeonCrawler.DCMetaInventoryComponent.OnItemClick
	 * 		Flags  -> (Final, Native, Public, HasOutParms)
	 * Parameters:
	 * 		struct FDCItemId                                   ItemId                                                     (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EDCInventoryId                                     From                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FPointerEvent                               Event                                                      (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UDCMetaInventoryComponent::OnItemClick(const struct FDCItemId& ItemId, EDCInventoryId From, const struct FPointerEvent& Event)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCMetaInventoryComponent.OnItemClick");
		
		UDCMetaInventoryComponent_OnItemClick_Params params {};
		params.ItemId = ItemId;
		params.From = From;
		params.Event = Event;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D3C640
	 * 		Name   -> Function DungeonCrawler.DCMetaInventoryComponent.BroadcastMsgBlueprint
	 * 		Flags  -> (Native, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		int32_t                                            InMsg                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UDCMetaInventoryComponent::BroadcastMsgBlueprint(int32_t InMsg)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCMetaInventoryComponent.BroadcastMsgBlueprint");
		
		UDCMetaInventoryComponent_BroadcastMsgBlueprint_Params params {};
		params.InMsg = InMsg;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDCMetaInventoryComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDCMetaInventoryComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCMetaInventoryComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017A0360
	 * 		Name   -> Function DungeonCrawler.DCMetaPlayerController.UpdateGameState
	 * 		Flags  -> (Native, Event, Protected, HasOutParms, BlueprintEvent)
	 * Parameters:
	 * 		struct FGameStateData                              InGameStateData                                            (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void ADCMetaPlayerController::UpdateGameState(const struct FGameStateData& InGameStateData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCMetaPlayerController.UpdateGameState");
		
		ADCMetaPlayerController_UpdateGameState_Params params {};
		params.InGameStateData = InGameStateData;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017A0240
	 * 		Name   -> Function DungeonCrawler.DCMetaPlayerController.UnbindMsgAll
	 * 		Flags  -> (Native, Public)
	 * Parameters:
	 * 		class UObject*                                     InObject                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ADCMetaPlayerController::UnbindMsgAll(class UObject* InObject)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCMetaPlayerController.UnbindMsgAll");
		
		ADCMetaPlayerController_UnbindMsgAll_Params params {};
		params.InObject = InObject;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017A00A0
	 * 		Name   -> Function DungeonCrawler.DCMetaPlayerController.UnbindMsg
	 * 		Flags  -> (Native, Public)
	 * Parameters:
	 * 		class UScriptStruct*                               InMsgType                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UObject*                                     InObject                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ADCMetaPlayerController::UnbindMsg(class UScriptStruct* InMsgType, class UObject* InObject)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCMetaPlayerController.UnbindMsg");
		
		ADCMetaPlayerController_UnbindMsg_Params params {};
		params.InMsgType = InMsgType;
		params.InObject = InObject;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017A0040
	 * 		Name   -> Function DungeonCrawler.DCMetaPlayerController.TerminateBase
	 * 		Flags  -> (Native, Public)
	 */
	void ADCMetaPlayerController::TerminateBase()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCMetaPlayerController.TerminateBase");
		
		ADCMetaPlayerController_TerminateBase_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0179DB50
	 * 		Name   -> Function DungeonCrawler.DCMetaPlayerController.Gm
	 * 		Flags  -> (Final, Exec, Native, Protected)
	 * Parameters:
	 * 		class FString                                      InCmd                                                      (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ADCMetaPlayerController::Gm(const class FString& InCmd)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCMetaPlayerController.Gm");
		
		ADCMetaPlayerController_Gm_Params params {};
		params.InCmd = InCmd;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0179CC40
	 * 		Name   -> Function DungeonCrawler.DCMetaPlayerController.GetAccountSessionData
	 * 		Flags  -> (Final, Native, Protected, BlueprintCallable)
	 */
	struct FAccountSessionData ADCMetaPlayerController::GetAccountSessionData()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCMetaPlayerController.GetAccountSessionData");
		
		ADCMetaPlayerController_GetAccountSessionData_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0179C050
	 * 		Name   -> Function DungeonCrawler.DCMetaPlayerController.ExitClient
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void ADCMetaPlayerController::ExitClient()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCMetaPlayerController.ExitClient");
		
		ADCMetaPlayerController_ExitClient_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D3C640
	 * 		Name   -> Function DungeonCrawler.DCMetaPlayerController.BroadcastMsgBlueprint
	 * 		Flags  -> (Native, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		int32_t                                            InMsg                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ADCMetaPlayerController::BroadcastMsgBlueprint(int32_t InMsg)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCMetaPlayerController.BroadcastMsgBlueprint");
		
		ADCMetaPlayerController_BroadcastMsgBlueprint_Params params {};
		params.InMsg = InMsg;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ADCMetaPlayerController.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ADCMetaPlayerController::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCMetaPlayerController");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01764730
	 * 		Name   -> Function DungeonCrawler.MetaComponentBase.UnbindMsgAll
	 * 		Flags  -> (Native, Public)
	 * Parameters:
	 * 		class UObject*                                     InObject                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UMetaComponentBase::UnbindMsgAll(class UObject* InObject)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.MetaComponentBase.UnbindMsgAll");
		
		UMetaComponentBase_UnbindMsgAll_Params params {};
		params.InObject = InObject;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01764280
	 * 		Name   -> Function DungeonCrawler.MetaComponentBase.UnbindMsg
	 * 		Flags  -> (Native, Public)
	 * Parameters:
	 * 		class UScriptStruct*                               InMsgType                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UObject*                                     InObject                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UMetaComponentBase::UnbindMsg(class UScriptStruct* InMsgType, class UObject* InObject)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.MetaComponentBase.UnbindMsg");
		
		UMetaComponentBase_UnbindMsg_Params params {};
		params.InMsgType = InMsgType;
		params.InObject = InObject;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01763EB0
	 * 		Name   -> Function DungeonCrawler.MetaComponentBase.TerminateBase
	 * 		Flags  -> (Native, Public)
	 */
	void UMetaComponentBase::TerminateBase()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.MetaComponentBase.TerminateBase");
		
		UMetaComponentBase_TerminateBase_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D3C640
	 * 		Name   -> Function DungeonCrawler.MetaComponentBase.BroadcastMsgBlueprint
	 * 		Flags  -> (Native, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		int32_t                                            InMsg                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UMetaComponentBase::BroadcastMsgBlueprint(int32_t InMsg)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.MetaComponentBase.BroadcastMsgBlueprint");
		
		UMetaComponentBase_BroadcastMsgBlueprint_Params params {};
		params.InMsg = InMsg;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMetaComponentBase.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMetaComponentBase::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.MetaComponentBase");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017A0400
	 * 		Name   -> Function DungeonCrawler.DCMetaTradeComponent.UpdateResetTimer
	 * 		Flags  -> (Final, Native, Private)
	 */
	void UDCMetaTradeComponent::UpdateResetTimer()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCMetaTradeComponent.UpdateResetTimer");
		
		UDCMetaTradeComponent_UpdateResetTimer_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0179EF90
	 * 		Name   -> Function DungeonCrawler.DCMetaTradeComponent.OnTradingBoxItemUpdate
	 * 		Flags  -> (Final, Native, Private, HasOutParms)
	 * Parameters:
	 * 		struct FDCItemInfo                                 ItemInfo                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		int32_t                                            Index                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EDCInventoryId                                     InventoryId                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UDCMetaTradeComponent::OnTradingBoxItemUpdate(const struct FDCItemInfo& ItemInfo, int32_t Index, EDCInventoryId InventoryId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCMetaTradeComponent.OnTradingBoxItemUpdate");
		
		UDCMetaTradeComponent_OnTradingBoxItemUpdate_Params params {};
		params.ItemInfo = ItemInfo;
		params.Index = Index;
		params.InventoryId = InventoryId;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0179EEC0
	 * 		Name   -> Function DungeonCrawler.DCMetaTradeComponent.OnTradingBoxItemRemove
	 * 		Flags  -> (Final, Native, Private)
	 * Parameters:
	 * 		struct FDCItemId                                   ItemId                                                     (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EDCInventoryId                                     InventoryId                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UDCMetaTradeComponent::OnTradingBoxItemRemove(const struct FDCItemId& ItemId, EDCInventoryId InventoryId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCMetaTradeComponent.OnTradingBoxItemRemove");
		
		UDCMetaTradeComponent_OnTradingBoxItemRemove_Params params {};
		params.ItemId = ItemId;
		params.InventoryId = InventoryId;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0179ED30
	 * 		Name   -> Function DungeonCrawler.DCMetaTradeComponent.OnTradingBoxItemAdd
	 * 		Flags  -> (Final, Native, Private, HasOutParms)
	 * Parameters:
	 * 		struct FDCItemInfo                                 ItemInfo                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		int32_t                                            Index                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EDCInventoryId                                     InventoryId                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UDCMetaTradeComponent::OnTradingBoxItemAdd(const struct FDCItemInfo& ItemInfo, int32_t Index, EDCInventoryId InventoryId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCMetaTradeComponent.OnTradingBoxItemAdd");
		
		UDCMetaTradeComponent_OnTradingBoxItemAdd_Params params {};
		params.ItemInfo = ItemInfo;
		params.Index = Index;
		params.InventoryId = InventoryId;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0179E880
	 * 		Name   -> Function DungeonCrawler.DCMetaTradeComponent.OnItemDrop
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		struct FDCItemId                                   ItemId                                                     (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            _                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EDCInventoryId                                     From                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EDCInventoryId                                     To                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            Index                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UDCMetaTradeComponent::OnItemDrop(const struct FDCItemId& ItemId, int32_t _, EDCInventoryId From, EDCInventoryId To, int32_t Index)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCMetaTradeComponent.OnItemDrop");
		
		UDCMetaTradeComponent_OnItemDrop_Params params {};
		params.ItemId = ItemId;
		params._ = _;
		params.From = From;
		params.To = To;
		params.Index = Index;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0179E520
	 * 		Name   -> Function DungeonCrawler.DCMetaTradeComponent.OnItemClick
	 * 		Flags  -> (Final, Native, Public, HasOutParms)
	 * Parameters:
	 * 		struct FDCItemId                                   ItemId                                                     (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EDCInventoryId                                     From                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FPointerEvent                               Event                                                      (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UDCMetaTradeComponent::OnItemClick(const struct FDCItemId& ItemId, EDCInventoryId From, const struct FPointerEvent& Event)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCMetaTradeComponent.OnItemClick");
		
		UDCMetaTradeComponent_OnItemClick_Params params {};
		params.ItemId = ItemId;
		params.From = From;
		params.Event = Event;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0179E1A0
	 * 		Name   -> Function DungeonCrawler.DCMetaTradeComponent.OnInventoryItemClick
	 * 		Flags  -> (Final, Native, Public, HasOutParms)
	 * Parameters:
	 * 		struct FDCItemId                                   ItemId                                                     (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EDCInventoryId                                     From                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FPointerEvent                               Event                                                      (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UDCMetaTradeComponent::OnInventoryItemClick(const struct FDCItemId& ItemId, EDCInventoryId From, const struct FPointerEvent& Event)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCMetaTradeComponent.OnInventoryItemClick");
		
		UDCMetaTradeComponent_OnInventoryItemClick_Params params {};
		params.ItemId = ItemId;
		params.From = From;
		params.Event = Event;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDCMetaTradeComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDCMetaTradeComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCMetaTradeComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01764610
	 * 		Name   -> Function DungeonCrawler.DCMonsterAIController.UnbindMsgAll
	 * 		Flags  -> (Native, Public)
	 * Parameters:
	 * 		class UObject*                                     InObject                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ADCMonsterAIController::UnbindMsgAll(class UObject* InObject)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCMonsterAIController.UnbindMsgAll");
		
		ADCMonsterAIController_UnbindMsgAll_Params params {};
		params.InObject = InObject;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017640E0
	 * 		Name   -> Function DungeonCrawler.DCMonsterAIController.UnbindMsg
	 * 		Flags  -> (Native, Public)
	 * Parameters:
	 * 		class UScriptStruct*                               InMsgType                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UObject*                                     InObject                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ADCMonsterAIController::UnbindMsg(class UScriptStruct* InMsgType, class UObject* InObject)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCMonsterAIController.UnbindMsg");
		
		ADCMonsterAIController_UnbindMsg_Params params {};
		params.InMsgType = InMsgType;
		params.InObject = InObject;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01763E50
	 * 		Name   -> Function DungeonCrawler.DCMonsterAIController.TerminateBase
	 * 		Flags  -> (Native, Public)
	 */
	void ADCMonsterAIController::TerminateBase()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCMonsterAIController.TerminateBase");
		
		ADCMonsterAIController_TerminateBase_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0179EBA0
	 * 		Name   -> Function DungeonCrawler.DCMonsterAIController.OnTargetPerceptionUpdated
	 * 		Flags  -> (Native, Event, Protected, BlueprintCallable, BlueprintEvent)
	 * Parameters:
	 * 		class AActor*                                      Actor                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FAIStimulus                                 Stimulus                                                   (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void ADCMonsterAIController::OnTargetPerceptionUpdated(class AActor* Actor, const struct FAIStimulus& Stimulus)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCMonsterAIController.OnTargetPerceptionUpdated");
		
		ADCMonsterAIController_OnTargetPerceptionUpdated_Params params {};
		params.Actor = Actor;
		params.Stimulus = Stimulus;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0179EAF0
	 * 		Name   -> Function DungeonCrawler.DCMonsterAIController.OnTargetPerceptionInfoUpdated
	 * 		Flags  -> (Native, Event, Protected, HasOutParms, BlueprintCallable, BlueprintEvent)
	 * Parameters:
	 * 		struct FActorPerceptionUpdateInfo                  UpdateInfo                                                 (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void ADCMonsterAIController::OnTargetPerceptionInfoUpdated(const struct FActorPerceptionUpdateInfo& UpdateInfo)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCMonsterAIController.OnTargetPerceptionInfoUpdated");
		
		ADCMonsterAIController_OnTargetPerceptionInfoUpdated_Params params {};
		params.UpdateInfo = UpdateInfo;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0179EA20
	 * 		Name   -> Function DungeonCrawler.DCMonsterAIController.OnPerceptionUpdated
	 * 		Flags  -> (Native, Event, Protected, HasOutParms, BlueprintCallable, BlueprintEvent)
	 * Parameters:
	 * 		TArray<class AActor*>                              UpdatedActors                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void ADCMonsterAIController::OnPerceptionUpdated(TArray<class AActor*> UpdatedActors)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCMonsterAIController.OnPerceptionUpdated");
		
		ADCMonsterAIController_OnPerceptionUpdated_Params params {};
		params.UpdatedActors = UpdatedActors;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D3C640
	 * 		Name   -> Function DungeonCrawler.DCMonsterAIController.BroadcastMsgBlueprint
	 * 		Flags  -> (Native, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		int32_t                                            InMsg                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ADCMonsterAIController::BroadcastMsgBlueprint(int32_t InMsg)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCMonsterAIController.BroadcastMsgBlueprint");
		
		ADCMonsterAIController_BroadcastMsgBlueprint_Params params {};
		params.InMsg = InMsg;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ADCMonsterAIController.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ADCMonsterAIController::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCMonsterAIController");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0179FF10
	 * 		Name   -> Function DungeonCrawler.DCMonsterAISystemBlueprintLibrary.SubAggro
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		class ADCMonsterBase*                              DCMonsterBase                                              (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class ADCCharacterBase*                            Target                                                     (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Point                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UDCMonsterAISystemBlueprintLibrary::STATIC_SubAggro(class ADCMonsterBase** DCMonsterBase, class ADCCharacterBase** Target, float Point)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCMonsterAISystemBlueprintLibrary.SubAggro");
		
		UDCMonsterAISystemBlueprintLibrary_SubAggro_Params params {};
		params.Point = Point;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (DCMonsterBase != nullptr)
			*DCMonsterBase = params.DCMonsterBase;
		if (Target != nullptr)
			*Target = params.Target;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0179FDA0
	 * 		Name   -> Function DungeonCrawler.DCMonsterAISystemBlueprintLibrary.SpawnSlave
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		class ADCMonsterBase*                              DCMonsterBase                                              (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UClass*                                      SlaveClass                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              XYRange                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bSuccessfully                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class ADCCharacterBase* UDCMonsterAISystemBlueprintLibrary::STATIC_SpawnSlave(class ADCMonsterBase** DCMonsterBase, class UClass* SlaveClass, float XYRange, bool* bSuccessfully)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCMonsterAISystemBlueprintLibrary.SpawnSlave");
		
		UDCMonsterAISystemBlueprintLibrary_SpawnSlave_Params params {};
		params.SlaveClass = SlaveClass;
		params.XYRange = XYRange;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (DCMonsterBase != nullptr)
			*DCMonsterBase = params.DCMonsterBase;
		if (bSuccessfully != nullptr)
			*bSuccessfully = params.bSuccessfully;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0179FC50
	 * 		Name   -> Function DungeonCrawler.DCMonsterAISystemBlueprintLibrary.SortTargetsByZRange
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		class ADCMonsterBase*                              DCMonsterBase                                              (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		TArray<class ADCCharacterBase*>                    TargetArray                                                (Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		EMonsterFilterSortingType                          MonsterFilterSortingType                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UDCMonsterAISystemBlueprintLibrary::STATIC_SortTargetsByZRange(class ADCMonsterBase** DCMonsterBase, TArray<class ADCCharacterBase*>* TargetArray, EMonsterFilterSortingType MonsterFilterSortingType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCMonsterAISystemBlueprintLibrary.SortTargetsByZRange");
		
		UDCMonsterAISystemBlueprintLibrary_SortTargetsByZRange_Params params {};
		params.MonsterFilterSortingType = MonsterFilterSortingType;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (DCMonsterBase != nullptr)
			*DCMonsterBase = params.DCMonsterBase;
		if (TargetArray != nullptr)
			*TargetArray = params.TargetArray;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0179FB00
	 * 		Name   -> Function DungeonCrawler.DCMonsterAISystemBlueprintLibrary.SortTargetsByXYRange
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		class ADCMonsterBase*                              DCMonsterBase                                              (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		TArray<class ADCCharacterBase*>                    TargetArray                                                (Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		EMonsterFilterSortingType                          MonsterFilterSortingType                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UDCMonsterAISystemBlueprintLibrary::STATIC_SortTargetsByXYRange(class ADCMonsterBase** DCMonsterBase, TArray<class ADCCharacterBase*>* TargetArray, EMonsterFilterSortingType MonsterFilterSortingType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCMonsterAISystemBlueprintLibrary.SortTargetsByXYRange");
		
		UDCMonsterAISystemBlueprintLibrary_SortTargetsByXYRange_Params params {};
		params.MonsterFilterSortingType = MonsterFilterSortingType;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (DCMonsterBase != nullptr)
			*DCMonsterBase = params.DCMonsterBase;
		if (TargetArray != nullptr)
			*TargetArray = params.TargetArray;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0179F980
	 * 		Name   -> Function DungeonCrawler.DCMonsterAISystemBlueprintLibrary.SortTargetsByDistanceAndPickTarget
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		class ADCMonsterBase*                              DCMonsterBase                                              (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		TArray<class ADCCharacterBase*>                    TargetArray                                                (Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		EMonsterFilterSortingType                          MonsterFilterSortingType                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            Index                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class ADCCharacterBase* UDCMonsterAISystemBlueprintLibrary::STATIC_SortTargetsByDistanceAndPickTarget(class ADCMonsterBase** DCMonsterBase, TArray<class ADCCharacterBase*>* TargetArray, EMonsterFilterSortingType MonsterFilterSortingType, int32_t Index)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCMonsterAISystemBlueprintLibrary.SortTargetsByDistanceAndPickTarget");
		
		UDCMonsterAISystemBlueprintLibrary_SortTargetsByDistanceAndPickTarget_Params params {};
		params.MonsterFilterSortingType = MonsterFilterSortingType;
		params.Index = Index;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (DCMonsterBase != nullptr)
			*DCMonsterBase = params.DCMonsterBase;
		if (TargetArray != nullptr)
			*TargetArray = params.TargetArray;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0179F830
	 * 		Name   -> Function DungeonCrawler.DCMonsterAISystemBlueprintLibrary.SortTargetsByDistance
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		class ADCMonsterBase*                              DCMonsterBase                                              (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		TArray<class ADCCharacterBase*>                    TargetArray                                                (Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		EMonsterFilterSortingType                          MonsterFilterSortingType                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UDCMonsterAISystemBlueprintLibrary::STATIC_SortTargetsByDistance(class ADCMonsterBase** DCMonsterBase, TArray<class ADCCharacterBase*>* TargetArray, EMonsterFilterSortingType MonsterFilterSortingType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCMonsterAISystemBlueprintLibrary.SortTargetsByDistance");
		
		UDCMonsterAISystemBlueprintLibrary_SortTargetsByDistance_Params params {};
		params.MonsterFilterSortingType = MonsterFilterSortingType;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (DCMonsterBase != nullptr)
			*DCMonsterBase = params.DCMonsterBase;
		if (TargetArray != nullptr)
			*TargetArray = params.TargetArray;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0179F6E0
	 * 		Name   -> Function DungeonCrawler.DCMonsterAISystemBlueprintLibrary.SortTargetsByAggro
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		class ADCMonsterBase*                              DCMonsterBase                                              (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		TArray<class ADCCharacterBase*>                    TargetArray                                                (Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		EMonsterFilterSortingType                          MonsterFilterSortingType                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UDCMonsterAISystemBlueprintLibrary::STATIC_SortTargetsByAggro(class ADCMonsterBase** DCMonsterBase, TArray<class ADCCharacterBase*>* TargetArray, EMonsterFilterSortingType MonsterFilterSortingType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCMonsterAISystemBlueprintLibrary.SortTargetsByAggro");
		
		UDCMonsterAISystemBlueprintLibrary_SortTargetsByAggro_Params params {};
		params.MonsterFilterSortingType = MonsterFilterSortingType;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (DCMonsterBase != nullptr)
			*DCMonsterBase = params.DCMonsterBase;
		if (TargetArray != nullptr)
			*TargetArray = params.TargetArray;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0179F4C0
	 * 		Name   -> Function DungeonCrawler.DCMonsterAISystemBlueprintLibrary.SetAggroRate
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		class ADCCharacterBase*                            DCCharacterBase                                            (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Time                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Rate                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UDCMonsterAISystemBlueprintLibrary::STATIC_SetAggroRate(class ADCCharacterBase** DCCharacterBase, float Time, float Rate)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCMonsterAISystemBlueprintLibrary.SetAggroRate");
		
		UDCMonsterAISystemBlueprintLibrary_SetAggroRate_Params params {};
		params.Time = Time;
		params.Rate = Rate;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (DCCharacterBase != nullptr)
			*DCCharacterBase = params.DCCharacterBase;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0179F390
	 * 		Name   -> Function DungeonCrawler.DCMonsterAISystemBlueprintLibrary.SetAggro
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		class ADCMonsterBase*                              DCMonsterBase                                              (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class ADCCharacterBase*                            Target                                                     (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Point                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UDCMonsterAISystemBlueprintLibrary::STATIC_SetAggro(class ADCMonsterBase** DCMonsterBase, class ADCCharacterBase** Target, float Point)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCMonsterAISystemBlueprintLibrary.SetAggro");
		
		UDCMonsterAISystemBlueprintLibrary_SetAggro_Params params {};
		params.Point = Point;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (DCMonsterBase != nullptr)
			*DCMonsterBase = params.DCMonsterBase;
		if (Target != nullptr)
			*Target = params.Target;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0179F300
	 * 		Name   -> Function DungeonCrawler.DCMonsterAISystemBlueprintLibrary.RemoveAggroAll
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class ADCCharacterBase*                            DCCharacterBase                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UDCMonsterAISystemBlueprintLibrary::STATIC_RemoveAggroAll(class ADCCharacterBase* DCCharacterBase)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCMonsterAISystemBlueprintLibrary.RemoveAggroAll");
		
		UDCMonsterAISystemBlueprintLibrary_RemoveAggroAll_Params params {};
		params.DCCharacterBase = DCCharacterBase;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0179F220
	 * 		Name   -> Function DungeonCrawler.DCMonsterAISystemBlueprintLibrary.RemoveAggro
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		class ADCMonsterBase*                              DCMonsterBase                                              (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class ADCCharacterBase*                            Target                                                     (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UDCMonsterAISystemBlueprintLibrary::STATIC_RemoveAggro(class ADCMonsterBase** DCMonsterBase, class ADCCharacterBase** Target)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCMonsterAISystemBlueprintLibrary.RemoveAggro");
		
		UDCMonsterAISystemBlueprintLibrary_RemoveAggro_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (DCMonsterBase != nullptr)
			*DCMonsterBase = params.DCMonsterBase;
		if (Target != nullptr)
			*Target = params.Target;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0179F120
	 * 		Name   -> Function DungeonCrawler.DCMonsterAISystemBlueprintLibrary.PickTopAggroTarget
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		class ADCMonsterBase*                              DCMonsterBase                                              (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		TArray<class ADCCharacterBase*>                    TargetArray                                                (Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	class ADCCharacterBase* UDCMonsterAISystemBlueprintLibrary::STATIC_PickTopAggroTarget(class ADCMonsterBase** DCMonsterBase, TArray<class ADCCharacterBase*>* TargetArray)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCMonsterAISystemBlueprintLibrary.PickTopAggroTarget");
		
		UDCMonsterAISystemBlueprintLibrary_PickTopAggroTarget_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (DCMonsterBase != nullptr)
			*DCMonsterBase = params.DCMonsterBase;
		if (TargetArray != nullptr)
			*TargetArray = params.TargetArray;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0176E780
	 * 		Name   -> Function DungeonCrawler.DCMonsterAISystemBlueprintLibrary.PickTarget
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		TArray<class ADCCharacterBase*>                    TargetArray                                                (Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		int32_t                                            Index                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class ADCCharacterBase* UDCMonsterAISystemBlueprintLibrary::STATIC_PickTarget(TArray<class ADCCharacterBase*>* TargetArray, int32_t Index)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCMonsterAISystemBlueprintLibrary.PickTarget");
		
		UDCMonsterAISystemBlueprintLibrary_PickTarget_Params params {};
		params.Index = Index;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (TargetArray != nullptr)
			*TargetArray = params.TargetArray;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0176E6D0
	 * 		Name   -> Function DungeonCrawler.DCMonsterAISystemBlueprintLibrary.PickRandomTarget
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		TArray<class ADCCharacterBase*>                    TargetArray                                                (Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	class ADCCharacterBase* UDCMonsterAISystemBlueprintLibrary::STATIC_PickRandomTarget(TArray<class ADCCharacterBase*>* TargetArray)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCMonsterAISystemBlueprintLibrary.PickRandomTarget");
		
		UDCMonsterAISystemBlueprintLibrary_PickRandomTarget_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (TargetArray != nullptr)
			*TargetArray = params.TargetArray;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0179E070
	 * 		Name   -> Function DungeonCrawler.DCMonsterAISystemBlueprintLibrary.MulAggro
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		class ADCMonsterBase*                              DCMonsterBase                                              (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class ADCCharacterBase*                            Target                                                     (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Point                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UDCMonsterAISystemBlueprintLibrary::STATIC_MulAggro(class ADCMonsterBase** DCMonsterBase, class ADCCharacterBase** Target, float Point)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCMonsterAISystemBlueprintLibrary.MulAggro");
		
		UDCMonsterAISystemBlueprintLibrary_MulAggro_Params params {};
		params.Point = Point;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (DCMonsterBase != nullptr)
			*DCMonsterBase = params.DCMonsterBase;
		if (Target != nullptr)
			*Target = params.Target;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0179DED0
	 * 		Name   -> Function DungeonCrawler.DCMonsterAISystemBlueprintLibrary.JumpToLocation
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		class ADCCharacterBase*                            DCCharacterBase                                            (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     DstLocation                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Power                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bFavorHighArc                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UDCMonsterAISystemBlueprintLibrary::STATIC_JumpToLocation(class ADCCharacterBase** DCCharacterBase, const struct FVector& DstLocation, float Power, bool bFavorHighArc)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCMonsterAISystemBlueprintLibrary.JumpToLocation");
		
		UDCMonsterAISystemBlueprintLibrary_JumpToLocation_Params params {};
		params.DstLocation = DstLocation;
		params.Power = Power;
		params.bFavorHighArc = bFavorHighArc;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (DCCharacterBase != nullptr)
			*DCCharacterBase = params.DCCharacterBase;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0179DD60
	 * 		Name   -> Function DungeonCrawler.DCMonsterAISystemBlueprintLibrary.JumpToActor
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		class ADCCharacterBase*                            DCCharacterBase                                            (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      DstActor                                                   (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Power                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bFavorHighArc                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UDCMonsterAISystemBlueprintLibrary::STATIC_JumpToActor(class ADCCharacterBase** DCCharacterBase, class AActor** DstActor, float Power, bool bFavorHighArc)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCMonsterAISystemBlueprintLibrary.JumpToActor");
		
		UDCMonsterAISystemBlueprintLibrary_JumpToActor_Params params {};
		params.Power = Power;
		params.bFavorHighArc = bFavorHighArc;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (DCCharacterBase != nullptr)
			*DCCharacterBase = params.DCCharacterBase;
		if (DstActor != nullptr)
			*DstActor = params.DstActor;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0179DC30
	 * 		Name   -> Function DungeonCrawler.DCMonsterAISystemBlueprintLibrary.IsAvailablePath
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		class ADCMonsterBase*                              DCMonsterBase                                              (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     DstLocation                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UDCMonsterAISystemBlueprintLibrary::STATIC_IsAvailablePath(class ADCMonsterBase** DCMonsterBase, const struct FVector& DstLocation)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCMonsterAISystemBlueprintLibrary.IsAvailablePath");
		
		UDCMonsterAISystemBlueprintLibrary_IsAvailablePath_Params params {};
		params.DstLocation = DstLocation;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (DCMonsterBase != nullptr)
			*DCMonsterBase = params.DCMonsterBase;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0179D7C0
	 * 		Name   -> Function DungeonCrawler.DCMonsterAISystemBlueprintLibrary.GetSlaveCount
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		class ADCMonsterBase*                              DCMonsterBase                                              (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	int32_t UDCMonsterAISystemBlueprintLibrary::STATIC_GetSlaveCount(class ADCMonsterBase** DCMonsterBase)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCMonsterAISystemBlueprintLibrary.GetSlaveCount");
		
		UDCMonsterAISystemBlueprintLibrary_GetSlaveCount_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (DCMonsterBase != nullptr)
			*DCMonsterBase = params.DCMonsterBase;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0179D6C0
	 * 		Name   -> Function DungeonCrawler.DCMonsterAISystemBlueprintLibrary.GetSightTargetArray
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		class ADCMonsterBase*                              DCMonsterBase                                              (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		TArray<class ADCCharacterBase*>                    TargetArray                                                (Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	bool UDCMonsterAISystemBlueprintLibrary::STATIC_GetSightTargetArray(class ADCMonsterBase** DCMonsterBase, TArray<class ADCCharacterBase*>* TargetArray)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCMonsterAISystemBlueprintLibrary.GetSightTargetArray");
		
		UDCMonsterAISystemBlueprintLibrary_GetSightTargetArray_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (DCMonsterBase != nullptr)
			*DCMonsterBase = params.DCMonsterBase;
		if (TargetArray != nullptr)
			*TargetArray = params.TargetArray;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0179D5C0
	 * 		Name   -> Function DungeonCrawler.DCMonsterAISystemBlueprintLibrary.GetHearingTargetArray
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		class ADCMonsterBase*                              DCMonsterBase                                              (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		TArray<class ADCCharacterBase*>                    TargetArray                                                (Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	bool UDCMonsterAISystemBlueprintLibrary::STATIC_GetHearingTargetArray(class ADCMonsterBase** DCMonsterBase, TArray<class ADCCharacterBase*>* TargetArray)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCMonsterAISystemBlueprintLibrary.GetHearingTargetArray");
		
		UDCMonsterAISystemBlueprintLibrary_GetHearingTargetArray_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (DCMonsterBase != nullptr)
			*DCMonsterBase = params.DCMonsterBase;
		if (TargetArray != nullptr)
			*TargetArray = params.TargetArray;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0179D4C0
	 * 		Name   -> Function DungeonCrawler.DCMonsterAISystemBlueprintLibrary.GetDamageTargetArray
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		class ADCMonsterBase*                              DCMonsterBase                                              (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		TArray<class ADCCharacterBase*>                    TargetArray                                                (Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	bool UDCMonsterAISystemBlueprintLibrary::STATIC_GetDamageTargetArray(class ADCMonsterBase** DCMonsterBase, TArray<class ADCCharacterBase*>* TargetArray)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCMonsterAISystemBlueprintLibrary.GetDamageTargetArray");
		
		UDCMonsterAISystemBlueprintLibrary_GetDamageTargetArray_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (DCMonsterBase != nullptr)
			*DCMonsterBase = params.DCMonsterBase;
		if (TargetArray != nullptr)
			*TargetArray = params.TargetArray;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0179D240
	 * 		Name   -> Function DungeonCrawler.DCMonsterAISystemBlueprintLibrary.GetCurrentAttributeValue
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		class ADCCharacterBase*                            DCCharacterBase                                            (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FGameplayAttribute                          GameplayAttribute                                          (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bSuccessfully                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	float UDCMonsterAISystemBlueprintLibrary::STATIC_GetCurrentAttributeValue(class ADCCharacterBase** DCCharacterBase, const struct FGameplayAttribute& GameplayAttribute, bool* bSuccessfully)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCMonsterAISystemBlueprintLibrary.GetCurrentAttributeValue");
		
		UDCMonsterAISystemBlueprintLibrary_GetCurrentAttributeValue_Params params {};
		params.GameplayAttribute = GameplayAttribute;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (DCCharacterBase != nullptr)
			*DCCharacterBase = params.DCCharacterBase;
		if (bSuccessfully != nullptr)
			*bSuccessfully = params.bSuccessfully;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0179CFC0
	 * 		Name   -> Function DungeonCrawler.DCMonsterAISystemBlueprintLibrary.GetBaseAttributeValue
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		class ADCCharacterBase*                            DCCharacterBase                                            (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FGameplayAttribute                          GameplayAttribute                                          (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bSuccessfully                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	float UDCMonsterAISystemBlueprintLibrary::STATIC_GetBaseAttributeValue(class ADCCharacterBase** DCCharacterBase, const struct FGameplayAttribute& GameplayAttribute, bool* bSuccessfully)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCMonsterAISystemBlueprintLibrary.GetBaseAttributeValue");
		
		UDCMonsterAISystemBlueprintLibrary_GetBaseAttributeValue_Params params {};
		params.GameplayAttribute = GameplayAttribute;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (DCCharacterBase != nullptr)
			*DCCharacterBase = params.DCCharacterBase;
		if (bSuccessfully != nullptr)
			*bSuccessfully = params.bSuccessfully;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0179CEC0
	 * 		Name   -> Function DungeonCrawler.DCMonsterAISystemBlueprintLibrary.GetAllTargetArray
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		class ADCMonsterBase*                              DCMonsterBase                                              (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		TArray<class ADCCharacterBase*>                    TargetArray                                                (Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	bool UDCMonsterAISystemBlueprintLibrary::STATIC_GetAllTargetArray(class ADCMonsterBase** DCMonsterBase, TArray<class ADCCharacterBase*>* TargetArray)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCMonsterAISystemBlueprintLibrary.GetAllTargetArray");
		
		UDCMonsterAISystemBlueprintLibrary_GetAllTargetArray_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (DCMonsterBase != nullptr)
			*DCMonsterBase = params.DCMonsterBase;
		if (TargetArray != nullptr)
			*TargetArray = params.TargetArray;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0179CD90
	 * 		Name   -> Function DungeonCrawler.DCMonsterAISystemBlueprintLibrary.GetAggroPoint
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		class ADCMonsterBase*                              DCMonsterBase                                              (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class ADCCharacterBase*                            Target                                                     (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bSuccessfully                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	float UDCMonsterAISystemBlueprintLibrary::STATIC_GetAggroPoint(class ADCMonsterBase** DCMonsterBase, class ADCCharacterBase** Target, bool* bSuccessfully)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCMonsterAISystemBlueprintLibrary.GetAggroPoint");
		
		UDCMonsterAISystemBlueprintLibrary_GetAggroPoint_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (DCMonsterBase != nullptr)
			*DCMonsterBase = params.DCMonsterBase;
		if (Target != nullptr)
			*Target = params.Target;
		if (bSuccessfully != nullptr)
			*bSuccessfully = params.bSuccessfully;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0179CCA0
	 * 		Name   -> Function DungeonCrawler.DCMonsterAISystemBlueprintLibrary.GetAggroMonster
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		class ADCCharacterBase*                            DCCharacterBase                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		TArray<class ADCMonsterBase*>                      TargetArray                                                (Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	bool UDCMonsterAISystemBlueprintLibrary::STATIC_GetAggroMonster(class ADCCharacterBase* DCCharacterBase, TArray<class ADCMonsterBase*>* TargetArray)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCMonsterAISystemBlueprintLibrary.GetAggroMonster");
		
		UDCMonsterAISystemBlueprintLibrary_GetAggroMonster_Params params {};
		params.DCCharacterBase = DCCharacterBase;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (TargetArray != nullptr)
			*TargetArray = params.TargetArray;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0176A170
	 * 		Name   -> Function DungeonCrawler.DCMonsterAISystemBlueprintLibrary.FilterUnTagedTargets
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		TArray<class ADCCharacterBase*>                    TargetArray                                                (Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		struct FGameplayTag                                GameplayTag                                                (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UDCMonsterAISystemBlueprintLibrary::STATIC_FilterUnTagedTargets(TArray<class ADCCharacterBase*>* TargetArray, const struct FGameplayTag& GameplayTag)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCMonsterAISystemBlueprintLibrary.FilterUnTagedTargets");
		
		UDCMonsterAISystemBlueprintLibrary_FilterUnTagedTargets_Params params {};
		params.GameplayTag = GameplayTag;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (TargetArray != nullptr)
			*TargetArray = params.TargetArray;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0179CAF0
	 * 		Name   -> Function DungeonCrawler.DCMonsterAISystemBlueprintLibrary.FilterTargetsWithinZRange
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		class ADCMonsterBase*                              DCMonsterBase                                              (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		TArray<class ADCCharacterBase*>                    TargetArray                                                (Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		float                                              ZRange                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UDCMonsterAISystemBlueprintLibrary::STATIC_FilterTargetsWithinZRange(class ADCMonsterBase** DCMonsterBase, TArray<class ADCCharacterBase*>* TargetArray, float ZRange)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCMonsterAISystemBlueprintLibrary.FilterTargetsWithinZRange");
		
		UDCMonsterAISystemBlueprintLibrary_FilterTargetsWithinZRange_Params params {};
		params.ZRange = ZRange;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (DCMonsterBase != nullptr)
			*DCMonsterBase = params.DCMonsterBase;
		if (TargetArray != nullptr)
			*TargetArray = params.TargetArray;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0179C8E0
	 * 		Name   -> Function DungeonCrawler.DCMonsterAISystemBlueprintLibrary.FilterTargetsWithinXYRangeAndZRangeAndDirectionalAngleAndAllowedAngle
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		class ADCMonsterBase*                              DCMonsterBase                                              (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		TArray<class ADCCharacterBase*>                    TargetArray                                                (Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		float                                              XYRange                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              ZRange                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              DirectionalAngle                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              AllowedAngle                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UDCMonsterAISystemBlueprintLibrary::STATIC_FilterTargetsWithinXYRangeAndZRangeAndDirectionalAngleAndAllowedAngle(class ADCMonsterBase** DCMonsterBase, TArray<class ADCCharacterBase*>* TargetArray, float XYRange, float ZRange, float DirectionalAngle, float AllowedAngle)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCMonsterAISystemBlueprintLibrary.FilterTargetsWithinXYRangeAndZRangeAndDirectionalAngleAndAllowedAngle");
		
		UDCMonsterAISystemBlueprintLibrary_FilterTargetsWithinXYRangeAndZRangeAndDirectionalAngleAndAllowedAngle_Params params {};
		params.XYRange = XYRange;
		params.ZRange = ZRange;
		params.DirectionalAngle = DirectionalAngle;
		params.AllowedAngle = AllowedAngle;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (DCMonsterBase != nullptr)
			*DCMonsterBase = params.DCMonsterBase;
		if (TargetArray != nullptr)
			*TargetArray = params.TargetArray;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0179C790
	 * 		Name   -> Function DungeonCrawler.DCMonsterAISystemBlueprintLibrary.FilterTargetsWithinXYRange
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		class ADCMonsterBase*                              DCMonsterBase                                              (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		TArray<class ADCCharacterBase*>                    TargetArray                                                (Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		float                                              XYRange                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UDCMonsterAISystemBlueprintLibrary::STATIC_FilterTargetsWithinXYRange(class ADCMonsterBase** DCMonsterBase, TArray<class ADCCharacterBase*>* TargetArray, float XYRange)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCMonsterAISystemBlueprintLibrary.FilterTargetsWithinXYRange");
		
		UDCMonsterAISystemBlueprintLibrary_FilterTargetsWithinXYRange_Params params {};
		params.XYRange = XYRange;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (DCMonsterBase != nullptr)
			*DCMonsterBase = params.DCMonsterBase;
		if (TargetArray != nullptr)
			*TargetArray = params.TargetArray;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0179C5A0
	 * 		Name   -> Function DungeonCrawler.DCMonsterAISystemBlueprintLibrary.FilterTargetsWithinDistanceAndDirectionalAngleAndAllowedAngle
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		class ADCMonsterBase*                              DCMonsterBase                                              (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		TArray<class ADCCharacterBase*>                    TargetArray                                                (Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		float                                              Distance                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              DirectionalAngle                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              AllowedAngle                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UDCMonsterAISystemBlueprintLibrary::STATIC_FilterTargetsWithinDistanceAndDirectionalAngleAndAllowedAngle(class ADCMonsterBase** DCMonsterBase, TArray<class ADCCharacterBase*>* TargetArray, float Distance, float DirectionalAngle, float AllowedAngle)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCMonsterAISystemBlueprintLibrary.FilterTargetsWithinDistanceAndDirectionalAngleAndAllowedAngle");
		
		UDCMonsterAISystemBlueprintLibrary_FilterTargetsWithinDistanceAndDirectionalAngleAndAllowedAngle_Params params {};
		params.Distance = Distance;
		params.DirectionalAngle = DirectionalAngle;
		params.AllowedAngle = AllowedAngle;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (DCMonsterBase != nullptr)
			*DCMonsterBase = params.DCMonsterBase;
		if (TargetArray != nullptr)
			*TargetArray = params.TargetArray;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0176A020
	 * 		Name   -> Function DungeonCrawler.DCMonsterAISystemBlueprintLibrary.FilterTargetsWithinDistance
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		class ADCMonsterBase*                              DCMonsterBase                                              (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		TArray<class ADCCharacterBase*>                    TargetArray                                                (Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		float                                              Distance                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UDCMonsterAISystemBlueprintLibrary::STATIC_FilterTargetsWithinDistance(class ADCMonsterBase** DCMonsterBase, TArray<class ADCCharacterBase*>* TargetArray, float Distance)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCMonsterAISystemBlueprintLibrary.FilterTargetsWithinDistance");
		
		UDCMonsterAISystemBlueprintLibrary_FilterTargetsWithinDistance_Params params {};
		params.Distance = Distance;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (DCMonsterBase != nullptr)
			*DCMonsterBase = params.DCMonsterBase;
		if (TargetArray != nullptr)
			*TargetArray = params.TargetArray;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0179C420
	 * 		Name   -> Function DungeonCrawler.DCMonsterAISystemBlueprintLibrary.FilterTargetsWithinDirectionAngleAndAllowedAngle
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		class ADCMonsterBase*                              DCMonsterBase                                              (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		TArray<class ADCCharacterBase*>                    TargetArray                                                (Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		float                                              DirectionalAngle                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              AllowedAngle                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UDCMonsterAISystemBlueprintLibrary::STATIC_FilterTargetsWithinDirectionAngleAndAllowedAngle(class ADCMonsterBase** DCMonsterBase, TArray<class ADCCharacterBase*>* TargetArray, float DirectionalAngle, float AllowedAngle)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCMonsterAISystemBlueprintLibrary.FilterTargetsWithinDirectionAngleAndAllowedAngle");
		
		UDCMonsterAISystemBlueprintLibrary_FilterTargetsWithinDirectionAngleAndAllowedAngle_Params params {};
		params.DirectionalAngle = DirectionalAngle;
		params.AllowedAngle = AllowedAngle;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (DCMonsterBase != nullptr)
			*DCMonsterBase = params.DCMonsterBase;
		if (TargetArray != nullptr)
			*TargetArray = params.TargetArray;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0179C2D0
	 * 		Name   -> Function DungeonCrawler.DCMonsterAISystemBlueprintLibrary.FilterTargetsOverZRange
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		class ADCMonsterBase*                              DCMonsterBase                                              (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		TArray<class ADCCharacterBase*>                    TargetArray                                                (Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		float                                              ZRange                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UDCMonsterAISystemBlueprintLibrary::STATIC_FilterTargetsOverZRange(class ADCMonsterBase** DCMonsterBase, TArray<class ADCCharacterBase*>* TargetArray, float ZRange)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCMonsterAISystemBlueprintLibrary.FilterTargetsOverZRange");
		
		UDCMonsterAISystemBlueprintLibrary_FilterTargetsOverZRange_Params params {};
		params.ZRange = ZRange;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (DCMonsterBase != nullptr)
			*DCMonsterBase = params.DCMonsterBase;
		if (TargetArray != nullptr)
			*TargetArray = params.TargetArray;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0179C180
	 * 		Name   -> Function DungeonCrawler.DCMonsterAISystemBlueprintLibrary.FilterTargetsOverXYRange
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		class ADCMonsterBase*                              DCMonsterBase                                              (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		TArray<class ADCCharacterBase*>                    TargetArray                                                (Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		float                                              XYRange                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UDCMonsterAISystemBlueprintLibrary::STATIC_FilterTargetsOverXYRange(class ADCMonsterBase** DCMonsterBase, TArray<class ADCCharacterBase*>* TargetArray, float XYRange)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCMonsterAISystemBlueprintLibrary.FilterTargetsOverXYRange");
		
		UDCMonsterAISystemBlueprintLibrary_FilterTargetsOverXYRange_Params params {};
		params.XYRange = XYRange;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (DCMonsterBase != nullptr)
			*DCMonsterBase = params.DCMonsterBase;
		if (TargetArray != nullptr)
			*TargetArray = params.TargetArray;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01769ED0
	 * 		Name   -> Function DungeonCrawler.DCMonsterAISystemBlueprintLibrary.FilterTargetsOverDistance
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		class ADCMonsterBase*                              DCMonsterBase                                              (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		TArray<class ADCCharacterBase*>                    TargetArray                                                (Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		float                                              Distance                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UDCMonsterAISystemBlueprintLibrary::STATIC_FilterTargetsOverDistance(class ADCMonsterBase** DCMonsterBase, TArray<class ADCCharacterBase*>* TargetArray, float Distance)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCMonsterAISystemBlueprintLibrary.FilterTargetsOverDistance");
		
		UDCMonsterAISystemBlueprintLibrary_FilterTargetsOverDistance_Params params {};
		params.Distance = Distance;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (DCMonsterBase != nullptr)
			*DCMonsterBase = params.DCMonsterBase;
		if (TargetArray != nullptr)
			*TargetArray = params.TargetArray;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01769DD0
	 * 		Name   -> Function DungeonCrawler.DCMonsterAISystemBlueprintLibrary.FilterTagedTargets
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		TArray<class ADCCharacterBase*>                    TargetArray                                                (Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		struct FGameplayTag                                GameplayTag                                                (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UDCMonsterAISystemBlueprintLibrary::STATIC_FilterTagedTargets(TArray<class ADCCharacterBase*>* TargetArray, const struct FGameplayTag& GameplayTag)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCMonsterAISystemBlueprintLibrary.FilterTagedTargets");
		
		UDCMonsterAISystemBlueprintLibrary_FilterTagedTargets_Params params {};
		params.GameplayTag = GameplayTag;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (TargetArray != nullptr)
			*TargetArray = params.TargetArray;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01769D30
	 * 		Name   -> Function DungeonCrawler.DCMonsterAISystemBlueprintLibrary.FilterPlayerCharacterTargets
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		TArray<class ADCCharacterBase*>                    TargetArray                                                (Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UDCMonsterAISystemBlueprintLibrary::STATIC_FilterPlayerCharacterTargets(TArray<class ADCCharacterBase*>* TargetArray)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCMonsterAISystemBlueprintLibrary.FilterPlayerCharacterTargets");
		
		UDCMonsterAISystemBlueprintLibrary_FilterPlayerCharacterTargets_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (TargetArray != nullptr)
			*TargetArray = params.TargetArray;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0179C070
	 * 		Name   -> Function DungeonCrawler.DCMonsterAISystemBlueprintLibrary.FilterMonsterTargetsByID
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		TArray<class ADCCharacterBase*>                    TargetArray                                                (Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		struct FPrimaryAssetId                             ID                                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UDCMonsterAISystemBlueprintLibrary::STATIC_FilterMonsterTargetsByID(TArray<class ADCCharacterBase*>* TargetArray, const struct FPrimaryAssetId& ID)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCMonsterAISystemBlueprintLibrary.FilterMonsterTargetsByID");
		
		UDCMonsterAISystemBlueprintLibrary_FilterMonsterTargetsByID_Params params {};
		params.ID = ID;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (TargetArray != nullptr)
			*TargetArray = params.TargetArray;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01769C90
	 * 		Name   -> Function DungeonCrawler.DCMonsterAISystemBlueprintLibrary.FilterMonsterTargets
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		TArray<class ADCCharacterBase*>                    TargetArray                                                (Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UDCMonsterAISystemBlueprintLibrary::STATIC_FilterMonsterTargets(TArray<class ADCCharacterBase*>* TargetArray)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCMonsterAISystemBlueprintLibrary.FilterMonsterTargets");
		
		UDCMonsterAISystemBlueprintLibrary_FilterMonsterTargets_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (TargetArray != nullptr)
			*TargetArray = params.TargetArray;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0179BF20
	 * 		Name   -> Function DungeonCrawler.DCMonsterAISystemBlueprintLibrary.AddAggro
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		class ADCMonsterBase*                              DCMonsterBase                                              (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class ADCCharacterBase*                            Target                                                     (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Point                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UDCMonsterAISystemBlueprintLibrary::STATIC_AddAggro(class ADCMonsterBase** DCMonsterBase, class ADCCharacterBase** Target, float Point)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCMonsterAISystemBlueprintLibrary.AddAggro");
		
		UDCMonsterAISystemBlueprintLibrary_AddAggro_Params params {};
		params.Point = Point;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (DCMonsterBase != nullptr)
			*DCMonsterBase = params.DCMonsterBase;
		if (Target != nullptr)
			*Target = params.Target;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDCMonsterAISystemBlueprintLibrary.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDCMonsterAISystemBlueprintLibrary::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCMonsterAISystemBlueprintLibrary");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDCMonsterAnimInstanceBase.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDCMonsterAnimInstanceBase::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCMonsterAnimInstanceBase");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017A6590
	 * 		Name   -> Function DungeonCrawler.DCMonsterBase.SetMonsterId
	 * 		Flags  -> (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FPrimaryAssetId                             InMonsterId                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ADCMonsterBase::SetMonsterId(const struct FPrimaryAssetId& InMonsterId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCMonsterBase.SetMonsterId");
		
		ADCMonsterBase_SetMonsterId_Params params {};
		params.InMonsterId = InMonsterId;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.DCMonsterBase.OnStuckByShield
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		class ADCCharacterBase*                            InInstigator                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      InEffectCauser                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ADCMonsterBase::OnStuckByShield(class ADCCharacterBase* InInstigator, class AActor* InEffectCauser)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCMonsterBase.OnStuckByShield");
		
		ADCMonsterBase_OnStuckByShield_Params params {};
		params.InInstigator = InInstigator;
		params.InEffectCauser = InEffectCauser;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.DCMonsterBase.OnSetAI
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 */
	void ADCMonsterBase::OnSetAI()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCMonsterBase.OnSetAI");
		
		ADCMonsterBase_OnSetAI_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017A6240
	 * 		Name   -> Function DungeonCrawler.DCMonsterBase.OnRep_PauseAnims
	 * 		Flags  -> (Final, Native, Private, HasOutParms)
	 * Parameters:
	 * 		unsigned char                                      OldPauseAnims                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ADCMonsterBase::OnRep_PauseAnims(unsigned char OldPauseAnims)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCMonsterBase.OnRep_PauseAnims");
		
		ADCMonsterBase_OnRep_PauseAnims_Params params {};
		params.OldPauseAnims = OldPauseAnims;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017A6170
	 * 		Name   -> Function DungeonCrawler.DCMonsterBase.OnRep_OrientRotationToMovement
	 * 		Flags  -> (Final, Native, Private, HasOutParms)
	 * Parameters:
	 * 		unsigned char                                      OldOrientRotationToMovement                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ADCMonsterBase::OnRep_OrientRotationToMovement(unsigned char OldOrientRotationToMovement)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCMonsterBase.OnRep_OrientRotationToMovement");
		
		ADCMonsterBase_OnRep_OrientRotationToMovement_Params params {};
		params.OldOrientRotationToMovement = OldOrientRotationToMovement;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017A60D0
	 * 		Name   -> Function DungeonCrawler.DCMonsterBase.OnRep_MonsterId
	 * 		Flags  -> (Final, Native, Protected, HasOutParms, HasDefaults)
	 * Parameters:
	 * 		struct FPrimaryAssetId                             InOldMonsterId                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ADCMonsterBase::OnRep_MonsterId(const struct FPrimaryAssetId& InOldMonsterId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCMonsterBase.OnRep_MonsterId");
		
		ADCMonsterBase_OnRep_MonsterId_Params params {};
		params.InOldMonsterId = InOldMonsterId;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017A6040
	 * 		Name   -> Function DungeonCrawler.DCMonsterBase.OnRep_MonsterCollisionProfile
	 * 		Flags  -> (Final, Native, Private, HasOutParms)
	 * Parameters:
	 * 		unsigned char                                      OldMonsterCollisionProfile                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ADCMonsterBase::OnRep_MonsterCollisionProfile(unsigned char OldMonsterCollisionProfile)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCMonsterBase.OnRep_MonsterCollisionProfile");
		
		ADCMonsterBase_OnRep_MonsterCollisionProfile_Params params {};
		params.OldMonsterCollisionProfile = OldMonsterCollisionProfile;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017A5500
	 * 		Name   -> Function DungeonCrawler.DCMonsterBase.OnFMsgGASAttributeNotifyBlueprint
	 * 		Flags  -> (Native, Event, Protected, HasOutParms, BlueprintEvent)
	 * Parameters:
	 * 		struct FMsgGASAttributeNotify                      InMsg                                                      (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	void ADCMonsterBase::OnFMsgGASAttributeNotifyBlueprint(const struct FMsgGASAttributeNotify& InMsg)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCMonsterBase.OnFMsgGASAttributeNotifyBlueprint");
		
		ADCMonsterBase_OnFMsgGASAttributeNotifyBlueprint_Params params {};
		params.InMsg = InMsg;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.DCMonsterBase.OnDamaged
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 * Parameters:
	 * 		class ADCCharacterBase*                            DCCharacterBase                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ADCMonsterBase::OnDamaged(class ADCCharacterBase* DCCharacterBase)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCMonsterBase.OnDamaged");
		
		ADCMonsterBase_OnDamaged_Params params {};
		params.DCCharacterBase = DCCharacterBase;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017A54E0
	 * 		Name   -> Function DungeonCrawler.DCMonsterBase.OnBeforeDeath
	 * 		Flags  -> (Native, Event, Protected, BlueprintEvent)
	 */
	void ADCMonsterBase::OnBeforeDeath()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCMonsterBase.OnBeforeDeath");
		
		ADCMonsterBase_OnBeforeDeath_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.DCMonsterBase.OnAfterDeath
	 * 		Flags  -> (Event, Public, BlueprintCallable, BlueprintEvent)
	 */
	void ADCMonsterBase::OnAfterDeath()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCMonsterBase.OnAfterDeath");
		
		ADCMonsterBase_OnAfterDeath_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017A53A0
	 * 		Name   -> Function DungeonCrawler.DCMonsterBase.Normal
	 * 		Flags  -> (Final, Native, Protected, BlueprintCallable)
	 */
	bool ADCMonsterBase::Normal()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCMonsterBase.Normal");
		
		ADCMonsterBase_Normal_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017A5340
	 * 		Name   -> Function DungeonCrawler.DCMonsterBase.InteractableWithoutHit
	 * 		Flags  -> (Final, Native, Protected, BlueprintCallable)
	 */
	bool ADCMonsterBase::InteractableWithoutHit()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCMonsterBase.InteractableWithoutHit");
		
		ADCMonsterBase_InteractableWithoutHit_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017A5310
	 * 		Name   -> Function DungeonCrawler.DCMonsterBase.InteractableOnly
	 * 		Flags  -> (Final, Native, Protected, BlueprintCallable)
	 */
	bool ADCMonsterBase::InteractableOnly()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCMonsterBase.InteractableOnly");
		
		ADCMonsterBase_InteractableOnly_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017A52E0
	 * 		Name   -> Function DungeonCrawler.DCMonsterBase.Interactable
	 * 		Flags  -> (Final, Native, Protected, BlueprintCallable)
	 */
	bool ADCMonsterBase::Interactable()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCMonsterBase.Interactable");
		
		ADCMonsterBase_Interactable_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017A4FA0
	 * 		Name   -> Function DungeonCrawler.DCMonsterBase.GetMonsterId
	 * 		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable)
	 */
	struct FPrimaryAssetId ADCMonsterBase::GetMonsterId()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCMonsterBase.GetMonsterId");
		
		ADCMonsterBase_GetMonsterId_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017A4EE0
	 * 		Name   -> Function DungeonCrawler.DCMonsterBase.GetDesignDataMonster
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	struct FDesignDataMonster ADCMonsterBase::GetDesignDataMonster()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCMonsterBase.GetDesignDataMonster");
		
		ADCMonsterBase_GetDesignDataMonster_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017A4D90
	 * 		Name   -> Function DungeonCrawler.DCMonsterBase.Fly
	 * 		Flags  -> (Final, Native, Protected, BlueprintCallable)
	 */
	bool ADCMonsterBase::Fly()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCMonsterBase.Fly");
		
		ADCMonsterBase_Fly_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017A4AD0
	 * 		Name   -> Function DungeonCrawler.DCMonsterBase.Death
	 * 		Flags  -> (Final, Native, Protected, BlueprintCallable)
	 */
	bool ADCMonsterBase::Death()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCMonsterBase.Death");
		
		ADCMonsterBase_Death_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017A4970
	 * 		Name   -> Function DungeonCrawler.DCMonsterBase.ChangePauseAnims
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		unsigned char                                      Value                                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ADCMonsterBase::ChangePauseAnims(unsigned char Value)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCMonsterBase.ChangePauseAnims");
		
		ADCMonsterBase_ChangePauseAnims_Params params {};
		params.Value = Value;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017A4850
	 * 		Name   -> Function DungeonCrawler.DCMonsterBase.ChangeOrientRotationToMovement
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		unsigned char                                      Value                                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ADCMonsterBase::ChangeOrientRotationToMovement(unsigned char Value)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCMonsterBase.ChangeOrientRotationToMovement");
		
		ADCMonsterBase_ChangeOrientRotationToMovement_Params params {};
		params.Value = Value;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017A4820
	 * 		Name   -> Function DungeonCrawler.DCMonsterBase.Burrow
	 * 		Flags  -> (Final, Native, Protected, BlueprintCallable)
	 */
	bool ADCMonsterBase::Burrow()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCMonsterBase.Burrow");
		
		ADCMonsterBase_Burrow_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017A47F0
	 * 		Name   -> Function DungeonCrawler.DCMonsterBase.BeforeDeath
	 * 		Flags  -> (Final, Native, Protected, BlueprintCallable)
	 */
	bool ADCMonsterBase::BeforeDeath()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCMonsterBase.BeforeDeath");
		
		ADCMonsterBase_BeforeDeath_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ADCMonsterBase.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ADCMonsterBase::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCMonsterBase");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.DCMonsterGameplayAbilityBase.AbilityActivated
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 * Parameters:
	 * 		struct FGameplayEventData                          TriggerEventData                                           (ConstParm, Parm, NativeAccessSpecifierPublic)
	 */
	void UDCMonsterGameplayAbilityBase::AbilityActivated(const struct FGameplayEventData& TriggerEventData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCMonsterGameplayAbilityBase.AbilityActivated");
		
		UDCMonsterGameplayAbilityBase_AbilityActivated_Params params {};
		params.TriggerEventData = TriggerEventData;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDCMonsterGameplayAbilityBase.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDCMonsterGameplayAbilityBase::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCMonsterGameplayAbilityBase");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.DCMonsterSpawner.UpdateGameState
	 * 		Flags  -> (Event, Protected, HasOutParms, BlueprintEvent)
	 * Parameters:
	 * 		struct FGameStateData                              InGameStateData                                            (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void ADCMonsterSpawner::UpdateGameState(const struct FGameStateData& InGameStateData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCMonsterSpawner.UpdateGameState");
		
		ADCMonsterSpawner_UpdateGameState_Params params {};
		params.InGameStateData = InGameStateData;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017644F0
	 * 		Name   -> Function DungeonCrawler.DCMonsterSpawner.UnbindMsgAll
	 * 		Flags  -> (Native, Public)
	 * Parameters:
	 * 		class UObject*                                     InObject                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ADCMonsterSpawner::UnbindMsgAll(class UObject* InObject)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCMonsterSpawner.UnbindMsgAll");
		
		ADCMonsterSpawner_UnbindMsgAll_Params params {};
		params.InObject = InObject;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01763F40
	 * 		Name   -> Function DungeonCrawler.DCMonsterSpawner.UnbindMsg
	 * 		Flags  -> (Native, Public)
	 * Parameters:
	 * 		class UScriptStruct*                               InMsgType                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UObject*                                     InObject                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ADCMonsterSpawner::UnbindMsg(class UScriptStruct* InMsgType, class UObject* InObject)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCMonsterSpawner.UnbindMsg");
		
		ADCMonsterSpawner_UnbindMsg_Params params {};
		params.InMsgType = InMsgType;
		params.InObject = InObject;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01763DF0
	 * 		Name   -> Function DungeonCrawler.DCMonsterSpawner.TerminateBase
	 * 		Flags  -> (Native, Public)
	 */
	void ADCMonsterSpawner::TerminateBase()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCMonsterSpawner.TerminateBase");
		
		ADCMonsterSpawner_TerminateBase_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017A68A0
	 * 		Name   -> Function DungeonCrawler.DCMonsterSpawner.Spawns
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	TArray<class ADCMonsterBase*> ADCMonsterSpawner::Spawns()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCMonsterSpawner.Spawns");
		
		ADCMonsterSpawner_Spawns_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D3C640
	 * 		Name   -> Function DungeonCrawler.DCMonsterSpawner.BroadcastMsgBlueprint
	 * 		Flags  -> (Native, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		int32_t                                            InMsg                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ADCMonsterSpawner::BroadcastMsgBlueprint(int32_t InMsg)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCMonsterSpawner.BroadcastMsgBlueprint");
		
		ADCMonsterSpawner_BroadcastMsgBlueprint_Params params {};
		params.InMsg = InMsg;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ADCMonsterSpawner.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ADCMonsterSpawner::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCMonsterSpawner");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDCMovementModifierContainerData.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDCMovementModifierContainerData::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCMovementModifierContainerData");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017A51F0
	 * 		Name   -> Function DungeonCrawler.DCMultiLineEditableTextBox.InsertTextAtCursor
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, Const)
	 * Parameters:
	 * 		class FString                                      InText                                                     (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UDCMultiLineEditableTextBox::InsertTextAtCursor(const class FString& InText)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCMultiLineEditableTextBox.InsertTextAtCursor");
		
		UDCMultiLineEditableTextBox_InsertTextAtCursor_Params params {};
		params.InText = InText;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017A5120
	 * 		Name   -> Function DungeonCrawler.DCMultiLineEditableTextBox.Goto
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		int32_t                                            InLineIndex                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            InOffset                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UDCMultiLineEditableTextBox::Goto(int32_t InLineIndex, int32_t InOffset)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCMultiLineEditableTextBox.Goto");
		
		UDCMultiLineEditableTextBox_Goto_Params params {};
		params.InLineIndex = InLineIndex;
		params.InOffset = InOffset;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017A47C0
	 * 		Name   -> Function DungeonCrawler.DCMultiLineEditableTextBox.AnyTextSelected
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool UDCMultiLineEditableTextBox::AnyTextSelected()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCMultiLineEditableTextBox.AnyTextSelected");
		
		UDCMultiLineEditableTextBox_AnyTextSelected_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDCMultiLineEditableTextBox.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDCMultiLineEditableTextBox::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCMultiLineEditableTextBox");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDCNetReplicationGraphConnection.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDCNetReplicationGraphConnection::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCNetReplicationGraphConnection");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDCPartyChatInterface.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDCPartyChatInterface::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCPartyChatInterface");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDCPerkDataAsset.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDCPerkDataAsset::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCPerkDataAsset");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017A66F0
	 * 		Name   -> Function DungeonCrawler.DCPerkDataComponent.SetWeaponMasteryList
	 * 		Flags  -> (Final, Native, Protected, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		struct FGameplayTagContainer                       InWeaponMsteryList                                         (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UDCPerkDataComponent::SetWeaponMasteryList(const struct FGameplayTagContainer& InWeaponMsteryList)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCPerkDataComponent.SetWeaponMasteryList");
		
		UDCPerkDataComponent_SetWeaponMasteryList_Params params {};
		params.InWeaponMsteryList = InWeaponMsteryList;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017A6630
	 * 		Name   -> Function DungeonCrawler.DCPerkDataComponent.SetSpearProficiencyList
	 * 		Flags  -> (Final, Native, Protected, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		struct FGameplayTagContainer                       InWeaponList                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UDCPerkDataComponent::SetSpearProficiencyList(const struct FGameplayTagContainer& InWeaponList)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCPerkDataComponent.SetSpearProficiencyList");
		
		UDCPerkDataComponent_SetSpearProficiencyList_Params params {};
		params.InWeaponList = InWeaponList;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017A6390
	 * 		Name   -> Function DungeonCrawler.DCPerkDataComponent.ResetWeaponMasteryList
	 * 		Flags  -> (Final, Native, Protected, BlueprintCallable)
	 */
	void UDCPerkDataComponent::ResetWeaponMasteryList()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCPerkDataComponent.ResetWeaponMasteryList");
		
		UDCPerkDataComponent_ResetWeaponMasteryList_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017A6370
	 * 		Name   -> Function DungeonCrawler.DCPerkDataComponent.ResetSpearProficiencyList
	 * 		Flags  -> (Final, Native, Protected, BlueprintCallable)
	 */
	void UDCPerkDataComponent::ResetSpearProficiencyList()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCPerkDataComponent.ResetSpearProficiencyList");
		
		UDCPerkDataComponent_ResetSpearProficiencyList_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDCPerkDataComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDCPerkDataComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCPerkDataComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017A4E20
	 * 		Name   -> Function DungeonCrawler.DCPlayerBlueprintFunctionLibrary.GetCurrentPlayerPawn
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class APawn* UDCPlayerBlueprintFunctionLibrary::STATIC_GetCurrentPlayerPawn(class UObject* WorldContextObject)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCPlayerBlueprintFunctionLibrary.GetCurrentPlayerPawn");
		
		UDCPlayerBlueprintFunctionLibrary_GetCurrentPlayerPawn_Params params {};
		params.WorldContextObject = WorldContextObject;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDCPlayerBlueprintFunctionLibrary.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDCPlayerBlueprintFunctionLibrary::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCPlayerBlueprintFunctionLibrary");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDCPlayerCharacterAnimInstanceBase.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDCPlayerCharacterAnimInstanceBase::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCPlayerCharacterAnimInstanceBase");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017A6B80
	 * 		Name   -> Function DungeonCrawler.DCPlayerCharacterBase.UpdateMeshHalfTranslucent
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               IsTranslucent                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UMaterialInterface*                          Material                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ADCPlayerCharacterBase::UpdateMeshHalfTranslucent(bool IsTranslucent, class UMaterialInterface* Material)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCPlayerCharacterBase.UpdateMeshHalfTranslucent");
		
		ADCPlayerCharacterBase_UpdateMeshHalfTranslucent_Params params {};
		params.IsTranslucent = IsTranslucent;
		params.Material = Material;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017A67B0
	 * 		Name   -> Function DungeonCrawler.DCPlayerCharacterBase.ShowHitDirectionUIMessage
	 * 		Flags  -> (Final, Net, NetReliable, Native, Event, Private, HasDefaults, NetClient)
	 * Parameters:
	 * 		class AActor*                                      SourceActor                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     HitDirection                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ADCPlayerCharacterBase::ShowHitDirectionUIMessage(class AActor* SourceActor, const struct FVector& HitDirection)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCPlayerCharacterBase.ShowHitDirectionUIMessage");
		
		ADCPlayerCharacterBase_ShowHitDirectionUIMessage_Params params {};
		params.SourceActor = SourceActor;
		params.HitDirection = HitDirection;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017A6220
	 * 		Name   -> Function DungeonCrawler.DCPlayerCharacterBase.OnRep_OwnedSkillIdArray
	 * 		Flags  -> (Final, Native, Private)
	 */
	void ADCPlayerCharacterBase::OnRep_OwnedSkillIdArray()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCPlayerCharacterBase.OnRep_OwnedSkillIdArray");
		
		ADCPlayerCharacterBase_OnRep_OwnedSkillIdArray_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017A6200
	 * 		Name   -> Function DungeonCrawler.DCPlayerCharacterBase.OnRep_OwnedPerkIdArray
	 * 		Flags  -> (Final, Native, Private)
	 */
	void ADCPlayerCharacterBase::OnRep_OwnedPerkIdArray()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCPlayerCharacterBase.OnRep_OwnedPerkIdArray");
		
		ADCPlayerCharacterBase_OnRep_OwnedPerkIdArray_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017A4F70
	 * 		Name   -> Function DungeonCrawler.DCPlayerCharacterBase.GetGender
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	EDCGender ADCPlayerCharacterBase::GetGender()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCPlayerCharacterBase.GetGender");
		
		ADCPlayerCharacterBase_GetGender_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017A4A10
	 * 		Name   -> Function DungeonCrawler.DCPlayerCharacterBase.ClientShowSystemMessage
	 * 		Flags  -> (Final, Net, NetReliable, Native, Event, Private, NetClient)
	 * Parameters:
	 * 		class FText                                        MessageText                                                (ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void ADCPlayerCharacterBase::ClientShowSystemMessage(const class FText& MessageText)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCPlayerCharacterBase.ClientShowSystemMessage");
		
		ADCPlayerCharacterBase_ClientShowSystemMessage_Params params {};
		params.MessageText = MessageText;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ADCPlayerCharacterBase.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ADCPlayerCharacterBase::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCPlayerCharacterBase");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDCPlayerCharMovementComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDCPlayerCharMovementComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCPlayerCharMovementComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDCPlayerChatComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDCPlayerChatComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCPlayerChatComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017A0240
	 * 		Name   -> Function DungeonCrawler.DCPlayerController.UnbindMsgAll
	 * 		Flags  -> (Native, Public)
	 * Parameters:
	 * 		class UObject*                                     InObject                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ADCPlayerController::UnbindMsgAll(class UObject* InObject)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCPlayerController.UnbindMsgAll");
		
		ADCPlayerController_UnbindMsgAll_Params params {};
		params.InObject = InObject;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017A00A0
	 * 		Name   -> Function DungeonCrawler.DCPlayerController.UnbindMsg
	 * 		Flags  -> (Native, Public)
	 * Parameters:
	 * 		class UScriptStruct*                               InMsgType                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UObject*                                     InObject                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ADCPlayerController::UnbindMsg(class UScriptStruct* InMsgType, class UObject* InObject)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCPlayerController.UnbindMsg");
		
		ADCPlayerController_UnbindMsg_Params params {};
		params.InMsgType = InMsgType;
		params.InObject = InObject;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017A0040
	 * 		Name   -> Function DungeonCrawler.DCPlayerController.TerminateBase
	 * 		Flags  -> (Native, Public)
	 */
	void ADCPlayerController::TerminateBase()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCPlayerController.TerminateBase");
		
		ADCPlayerController_TerminateBase_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017A6B60
	 * 		Name   -> Function DungeonCrawler.DCPlayerController.StatServer
	 * 		Flags  -> (Final, Exec, Native, Public)
	 */
	void ADCPlayerController::StatServer()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCPlayerController.StatServer");
		
		ADCPlayerController_StatServer_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017A6920
	 * 		Name   -> Function DungeonCrawler.DCPlayerController.StartToWearItem_Client
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetClient)
	 * Parameters:
	 * 		struct FItemData                                   InWearingItemData                                          (ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      InWearingActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              InDuration                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FText                                        InDescription                                              (ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void ADCPlayerController::StartToWearItem_Client(const struct FItemData& InWearingItemData, class AActor* InWearingActor, float InDuration, const class FText& InDescription)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCPlayerController.StartToWearItem_Client");
		
		ADCPlayerController_StartToWearItem_Client_Params params {};
		params.InWearingItemData = InWearingItemData;
		params.InWearingActor = InWearingActor;
		params.InDuration = InDuration;
		params.InDescription = InDescription;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017A6570
	 * 		Name   -> Function DungeonCrawler.DCPlayerController.SetClientReady_Server
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetServer)
	 */
	void ADCPlayerController::SetClientReady_Server()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCPlayerController.SetClientReady_Server");
		
		ADCPlayerController_SetClientReady_Server_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017A6490
	 * 		Name   -> Function DungeonCrawler.DCPlayerController.ServerDebugSpawnItem
	 * 		Flags  -> (Final, Net, NetReliable, Native, Event, Private, NetServer, HasDefaults)
	 * Parameters:
	 * 		class AActor*                                      SpawnActor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FPrimaryAssetId                             SpawnItemAssetId                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ADCPlayerController::ServerDebugSpawnItem(class AActor* SpawnActor, const struct FPrimaryAssetId& SpawnItemAssetId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCPlayerController.ServerDebugSpawnItem");
		
		ADCPlayerController_ServerDebugSpawnItem_Params params {};
		params.SpawnActor = SpawnActor;
		params.SpawnItemAssetId = SpawnItemAssetId;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017A63B0
	 * 		Name   -> Function DungeonCrawler.DCPlayerController.ServerDebugGiveGameplayEffectToTarget
	 * 		Flags  -> (Final, Net, NetReliable, Native, Event, Private, NetServer, HasDefaults)
	 * Parameters:
	 * 		class AActor*                                      TargetActor                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FPrimaryAssetId                             GameplayEffectAssetId                                      (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ADCPlayerController::ServerDebugGiveGameplayEffectToTarget(class AActor* TargetActor, const struct FPrimaryAssetId& GameplayEffectAssetId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCPlayerController.ServerDebugGiveGameplayEffectToTarget");
		
		ADCPlayerController_ServerDebugGiveGameplayEffectToTarget_Params params {};
		params.TargetActor = TargetActor;
		params.GameplayEffectAssetId = GameplayEffectAssetId;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017A62D0
	 * 		Name   -> Function DungeonCrawler.DCPlayerController.RequestPlayerCharacterLocation_Server
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetServer)
	 * Parameters:
	 * 		struct FDCAccountId                                InAccountId                                                (ConstParm, Parm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ADCPlayerController::RequestPlayerCharacterLocation_Server(const struct FDCAccountId& InAccountId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCPlayerController.RequestPlayerCharacterLocation_Server");
		
		ADCPlayerController_RequestPlayerCharacterLocation_Server_Params params {};
		params.InAccountId = InAccountId;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017A5FA0
	 * 		Name   -> Function DungeonCrawler.DCPlayerController.OnRep_AccountId
	 * 		Flags  -> (Final, Native, Private)
	 * Parameters:
	 * 		class FString                                      OldId                                                      (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ADCPlayerController::OnRep_AccountId(const class FString& OldId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCPlayerController.OnRep_AccountId");
		
		ADCPlayerController_OnRep_AccountId_Params params {};
		params.OldId = OldId;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017A5CD0
	 * 		Name   -> Function DungeonCrawler.DCPlayerController.OnPlayerInfoUpdate
	 * 		Flags  -> (Final, Native, Private, HasOutParms)
	 * Parameters:
	 * 		struct FDCPlayerInfo                               InPlayerInfo                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		struct FDCPlayerInfo                               OldPlayerInfo                                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void ADCPlayerController::OnPlayerInfoUpdate(const struct FDCPlayerInfo& InPlayerInfo, const struct FDCPlayerInfo& OldPlayerInfo)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCPlayerController.OnPlayerInfoUpdate");
		
		ADCPlayerController_OnPlayerInfoUpdate_Params params {};
		params.InPlayerInfo = InPlayerInfo;
		params.OldPlayerInfo = OldPlayerInfo;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017A5B40
	 * 		Name   -> Function DungeonCrawler.DCPlayerController.OnPlayerInfoAdd
	 * 		Flags  -> (Final, Native, Private, HasOutParms)
	 * Parameters:
	 * 		struct FDCPlayerInfo                               InPlayerInfo                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void ADCPlayerController::OnPlayerInfoAdd(const struct FDCPlayerInfo& InPlayerInfo)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCPlayerController.OnPlayerInfoAdd");
		
		ADCPlayerController_OnPlayerInfoAdd_Params params {};
		params.InPlayerInfo = InPlayerInfo;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017A5AC0
	 * 		Name   -> Function DungeonCrawler.DCPlayerController.OnIronShieldScan
	 * 		Flags  -> (Final, Net, NetReliable, Native, Event, Private, NetServer)
	 * Parameters:
	 * 		struct FIronShieldScanResult                       InIronShieldScanResult                                     (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void ADCPlayerController::OnIronShieldScan(const struct FIronShieldScanResult& InIronShieldScanResult)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCPlayerController.OnIronShieldScan");
		
		ADCPlayerController_OnIronShieldScan_Params params {};
		params.InIronShieldScanResult = InIronShieldScanResult;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.DCPlayerController.OnGameStateNotify
	 * 		Flags  -> (Event, Protected, HasOutParms, BlueprintEvent)
	 * Parameters:
	 * 		struct FGameStateData                              InGameStateData                                            (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void ADCPlayerController::OnGameStateNotify(const struct FGameStateData& InGameStateData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCPlayerController.OnGameStateNotify");
		
		ADCPlayerController_OnGameStateNotify_Params params {};
		params.InGameStateData = InGameStateData;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017A58C0
	 * 		Name   -> Function DungeonCrawler.DCPlayerController.OnFMsgGameKillLogNotifyClient
	 * 		Flags  -> (Final, Net, NetReliable, Native, Event, Private, NetClient)
	 * Parameters:
	 * 		struct FGameKillLogData                            InGameKillLogData                                          (ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void ADCPlayerController::OnFMsgGameKillLogNotifyClient(const struct FGameKillLogData& InGameKillLogData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCPlayerController.OnFMsgGameKillLogNotifyClient");
		
		ADCPlayerController_OnFMsgGameKillLogNotifyClient_Params params {};
		params.InGameKillLogData = InGameKillLogData;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017A5780
	 * 		Name   -> Function DungeonCrawler.DCPlayerController.OnFMsgGameFloorLogNotifyClient
	 * 		Flags  -> (Final, Net, NetReliable, Native, Event, Private, NetClient)
	 * Parameters:
	 * 		struct FGameFloorLogData                           InGameFloorLogData                                         (ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void ADCPlayerController::OnFMsgGameFloorLogNotifyClient(const struct FGameFloorLogData& InGameFloorLogData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCPlayerController.OnFMsgGameFloorLogNotifyClient");
		
		ADCPlayerController_OnFMsgGameFloorLogNotifyClient_Params params {};
		params.InGameFloorLogData = InGameFloorLogData;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017A56B0
	 * 		Name   -> Function DungeonCrawler.DCPlayerController.OnFMsgGameAnnounceNotifyClient
	 * 		Flags  -> (Final, Net, NetReliable, Native, Event, Private, NetClient)
	 * Parameters:
	 * 		struct FGameAnnounceData                           InGameAnnounceData                                         (ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void ADCPlayerController::OnFMsgGameAnnounceNotifyClient(const struct FGameAnnounceData& InGameAnnounceData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCPlayerController.OnFMsgGameAnnounceNotifyClient");
		
		ADCPlayerController_OnFMsgGameAnnounceNotifyClient_Params params {};
		params.InGameAnnounceData = InGameAnnounceData;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017A53D0
	 * 		Name   -> Function DungeonCrawler.DCPlayerController.NotifySystemMessage_Client
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetClient)
	 * Parameters:
	 * 		class FText                                        SystemMessage                                              (ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		float                                              Duration                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ADCPlayerController::NotifySystemMessage_Client(const class FText& SystemMessage, float Duration)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCPlayerController.NotifySystemMessage_Client");
		
		ADCPlayerController_NotifySystemMessage_Client_Params params {};
		params.SystemMessage = SystemMessage;
		params.Duration = Duration;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.DCPlayerController.LobbyPopup
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 */
	void ADCPlayerController::LobbyPopup()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCPlayerController.LobbyPopup");
		
		ADCPlayerController_LobbyPopup_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017A5370
	 * 		Name   -> Function DungeonCrawler.DCPlayerController.IsTargetAccountSelf
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	bool ADCPlayerController::IsTargetAccountSelf()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCPlayerController.IsTargetAccountSelf");
		
		ADCPlayerController_IsTargetAccountSelf_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017A5080
	 * 		Name   -> Function DungeonCrawler.DCPlayerController.GmServer
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetServer)
	 * Parameters:
	 * 		class FString                                      InCmd                                                      (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ADCPlayerController::GmServer(const class FString& InCmd)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCPlayerController.GmServer");
		
		ADCPlayerController_GmServer_Params params {};
		params.InCmd = InCmd;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017A4FE0
	 * 		Name   -> Function DungeonCrawler.DCPlayerController.Gm
	 * 		Flags  -> (Final, Exec, Native, Public)
	 * Parameters:
	 * 		class FString                                      InCmd                                                      (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ADCPlayerController::Gm(const class FString& InCmd)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCPlayerController.Gm");
		
		ADCPlayerController_Gm_Params params {};
		params.InCmd = InCmd;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017A4EB0
	 * 		Name   -> Function DungeonCrawler.DCPlayerController.GetDebugFaceTargetActor
	 * 		Flags  -> (Final, Native, Private)
	 */
	class AActor* ADCPlayerController::GetDebugFaceTargetActor()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCPlayerController.GetDebugFaceTargetActor");
		
		ADCPlayerController_GetDebugFaceTargetActor_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017A4DC0
	 * 		Name   -> Function DungeonCrawler.DCPlayerController.GetAccountSessionData
	 * 		Flags  -> (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
	 */
	struct FAccountSessionData ADCPlayerController::GetAccountSessionData()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCPlayerController.GetAccountSessionData");
		
		ADCPlayerController_GetAccountSessionData_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017A4C90
	 * 		Name   -> Function DungeonCrawler.DCPlayerController.ExitClientServer
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetServer, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               InbLobby                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FString                                      InReason                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ADCPlayerController::ExitClientServer(bool InbLobby, const class FString& InReason)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCPlayerController.ExitClientServer");
		
		ADCPlayerController_ExitClientServer_Params params {};
		params.InbLobby = InbLobby;
		params.InReason = InReason;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017A4B90
	 * 		Name   -> Function DungeonCrawler.DCPlayerController.ExitClient
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetClient)
	 * Parameters:
	 * 		bool                                               bInLobby                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FString                                      InReason                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ADCPlayerController::ExitClient(bool bInLobby, const class FString& InReason)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCPlayerController.ExitClient");
		
		ADCPlayerController_ExitClient_Params params {};
		params.bInLobby = bInLobby;
		params.InReason = InReason;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.DCPlayerController.ExecuteExitClientReason
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 * Parameters:
	 * 		bool                                               bInLobby                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FString                                      InReason                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ADCPlayerController::ExecuteExitClientReason(bool bInLobby, const class FString& InReason)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCPlayerController.ExecuteExitClientReason");
		
		ADCPlayerController_ExecuteExitClientReason_Params params {};
		params.bInLobby = bInLobby;
		params.InReason = InReason;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017A4B00
	 * 		Name   -> Function DungeonCrawler.DCPlayerController.ExecuteExitClient
	 * 		Flags  -> (Final, Native, Private, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bInLobby                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ADCPlayerController::ExecuteExitClient(bool bInLobby)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCPlayerController.ExecuteExitClient");
		
		ADCPlayerController_ExecuteExitClient_Params params {};
		params.bInLobby = bInLobby;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017A49F0
	 * 		Name   -> Function DungeonCrawler.DCPlayerController.ClientLobbyPopup
	 * 		Flags  -> (Final, Net, NetReliable, Native, Event, Private, NetClient)
	 */
	void ADCPlayerController::ClientLobbyPopup()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCPlayerController.ClientLobbyPopup");
		
		ADCPlayerController_ClientLobbyPopup_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017A48D0
	 * 		Name   -> Function DungeonCrawler.DCPlayerController.ChangeParty_Server
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetServer)
	 * Parameters:
	 * 		struct FDCPartyId                                  InPartyId                                                  (ConstParm, Parm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ADCPlayerController::ChangeParty_Server(const struct FDCPartyId& InPartyId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCPlayerController.ChangeParty_Server");
		
		ADCPlayerController_ChangeParty_Server_Params params {};
		params.InPartyId = InPartyId;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D3C640
	 * 		Name   -> Function DungeonCrawler.DCPlayerController.BroadcastMsgBlueprint
	 * 		Flags  -> (Native, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		int32_t                                            InMsg                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ADCPlayerController::BroadcastMsgBlueprint(int32_t InMsg)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCPlayerController.BroadcastMsgBlueprint");
		
		ADCPlayerController_BroadcastMsgBlueprint_Params params {};
		params.InMsg = InMsg;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017A46A0
	 * 		Name   -> Function DungeonCrawler.DCPlayerController.AckPlayerCharacterLocation_Client
	 * 		Flags  -> (Final, Net, NetReliable, Native, Event, Private, HasDefaults, NetClient)
	 * Parameters:
	 * 		struct FDCAccountId                                InAccountId                                                (ConstParm, Parm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     InPlayerPawnLocation                                       (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FRotator                                    InPlayerPawnRotation                                       (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void ADCPlayerController::AckPlayerCharacterLocation_Client(const struct FDCAccountId& InAccountId, const struct FVector& InPlayerPawnLocation, const struct FRotator& InPlayerPawnRotation)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCPlayerController.AckPlayerCharacterLocation_Client");
		
		ADCPlayerController_AckPlayerCharacterLocation_Client_Params params {};
		params.InAccountId = InAccountId;
		params.InPlayerPawnLocation = InPlayerPawnLocation;
		params.InPlayerPawnRotation = InPlayerPawnRotation;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ADCPlayerController.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ADCPlayerController::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCPlayerController");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017AB9A0
	 * 		Name   -> Function DungeonCrawler.DCPlayerInfoHolder.OnRep_PlayerInfo
	 * 		Flags  -> (Final, Native, Private, HasOutParms, Const)
	 * Parameters:
	 * 		struct FDCPlayerInfo                               OldPlayerInfo                                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void ADCPlayerInfoHolder::OnRep_PlayerInfo(const struct FDCPlayerInfo& OldPlayerInfo)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCPlayerInfoHolder.OnRep_PlayerInfo");
		
		ADCPlayerInfoHolder_OnRep_PlayerInfo_Params params {};
		params.OldPlayerInfo = OldPlayerInfo;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017AB6B0
	 * 		Name   -> Function DungeonCrawler.DCPlayerInfoHolder.OnPlayerInfoUpdated
	 * 		Flags  -> (Final, Native, Private, HasOutParms)
	 * Parameters:
	 * 		struct FDCPlayerInfo                               InPlayerInfo                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		struct FDCPlayerInfo                               InOldPlayerInfo                                            (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void ADCPlayerInfoHolder::OnPlayerInfoUpdated(const struct FDCPlayerInfo& InPlayerInfo, const struct FDCPlayerInfo& InOldPlayerInfo)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCPlayerInfoHolder.OnPlayerInfoUpdated");
		
		ADCPlayerInfoHolder_OnPlayerInfoUpdated_Params params {};
		params.InPlayerInfo = InPlayerInfo;
		params.InOldPlayerInfo = InOldPlayerInfo;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ADCPlayerInfoHolder.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ADCPlayerInfoHolder::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCPlayerInfoHolder");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0102E960
	 * 		Name   -> Function DungeonCrawler.DCPlayerInventoryWidget.GetEquipWidget
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	class UDCEquipmentWidget* UDCPlayerInventoryWidget::GetEquipWidget()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCPlayerInventoryWidget.GetEquipWidget");
		
		UDCPlayerInventoryWidget_GetEquipWidget_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017AB500
	 * 		Name   -> Function DungeonCrawler.DCPlayerInventoryWidget.GetBagWidget
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		int32_t                                            Index                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UDCBagWidget* UDCPlayerInventoryWidget::GetBagWidget(int32_t Index)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCPlayerInventoryWidget.GetBagWidget");
		
		UDCPlayerInventoryWidget_GetBagWidget_Params params {};
		params.Index = Index;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDCPlayerInventoryWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDCPlayerInventoryWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCPlayerInventoryWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDCPlayerManager.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDCPlayerManager::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCPlayerManager");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ADCPlayerPoint.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ADCPlayerPoint::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCPlayerPoint");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ADCPlayerStart.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ADCPlayerStart::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCPlayerStart");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ADCPlayerDown.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ADCPlayerDown::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCPlayerDown");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ADCPlayerSpectator.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ADCPlayerSpectator::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCPlayerSpectator");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDCProjectileAttributeSet.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDCProjectileAttributeSet::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCProjectileAttributeSet");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDCProjectSettings.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDCProjectSettings::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCProjectSettings");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDCPropAttributeSet.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDCPropAttributeSet::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCPropAttributeSet");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDCReplicationGraph.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDCReplicationGraph::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCReplicationGraph");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDCResource.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDCResource::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCResource");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDCServerAccountManager.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDCServerAccountManager::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCServerAccountManager");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDCShopArtData.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDCShopArtData::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCShopArtData");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDCShopDataAsset.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDCShopDataAsset::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCShopDataAsset");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDCCharacterSkinShopDataAsset.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDCCharacterSkinShopDataAsset::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCCharacterSkinShopDataAsset");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDCItemSkinShopDataAsset.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDCItemSkinShopDataAsset::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCItemSkinShopDataAsset");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDCEmoteShopDataAsset.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDCEmoteShopDataAsset::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCEmoteShopDataAsset");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDCShopItemListWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDCShopItemListWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCShopItemListWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017AB640
	 * 		Name   -> Function DungeonCrawler.DCShopItemSlotWidget.GetTooltipWidget
	 * 		Flags  -> (Final, Native, Protected, BlueprintCallable, BlueprintPure)
	 */
	class UUserWidget* UDCShopItemSlotWidget::GetTooltipWidget()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCShopItemSlotWidget.GetTooltipWidget");
		
		UDCShopItemSlotWidget_GetTooltipWidget_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017AB5D0
	 * 		Name   -> Function DungeonCrawler.DCShopItemSlotWidget.GetSelectedImgVisibility
	 * 		Flags  -> (Final, Native, Protected, BlueprintCallable, BlueprintPure)
	 */
	ESlateVisibility UDCShopItemSlotWidget::GetSelectedImgVisibility()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCShopItemSlotWidget.GetSelectedImgVisibility");
		
		UDCShopItemSlotWidget_GetSelectedImgVisibility_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017AB5A0
	 * 		Name   -> Function DungeonCrawler.DCShopItemSlotWidget.GetPurchasedImgVisibility
	 * 		Flags  -> (Final, Native, Protected, BlueprintCallable, BlueprintPure)
	 */
	ESlateVisibility UDCShopItemSlotWidget::GetPurchasedImgVisibility()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCShopItemSlotWidget.GetPurchasedImgVisibility");
		
		UDCShopItemSlotWidget_GetPurchasedImgVisibility_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017843B0
	 * 		Name   -> Function DungeonCrawler.DCShopItemSlotWidget.GetHoverImgVisibility
	 * 		Flags  -> (Final, Native, Protected, BlueprintCallable, BlueprintPure)
	 */
	ESlateVisibility UDCShopItemSlotWidget::GetHoverImgVisibility()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCShopItemSlotWidget.GetHoverImgVisibility");
		
		UDCShopItemSlotWidget_GetHoverImgVisibility_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDCShopItemSlotWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDCShopItemSlotWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCShopItemSlotWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017ABB50
	 * 		Name   -> Function DungeonCrawler.DCShopWidgetBase.OnWidgetOpen
	 * 		Flags  -> (Final, Native, Protected, BlueprintCallable)
	 */
	void UDCShopWidgetBase::OnWidgetOpen()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCShopWidgetBase.OnWidgetOpen");
		
		UDCShopWidgetBase_OnWidgetOpen_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017ABB30
	 * 		Name   -> Function DungeonCrawler.DCShopWidgetBase.OnWidgetClose
	 * 		Flags  -> (Final, Native, Protected, BlueprintCallable)
	 */
	void UDCShopWidgetBase::OnWidgetClose()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCShopWidgetBase.OnWidgetClose");
		
		UDCShopWidgetBase_OnWidgetClose_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017AB980
	 * 		Name   -> Function DungeonCrawler.DCShopWidgetBase.OnPrevPage
	 * 		Flags  -> (Final, Native, Private)
	 */
	void UDCShopWidgetBase::OnPrevPage()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCShopWidgetBase.OnPrevPage");
		
		UDCShopWidgetBase_OnPrevPage_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017AB690
	 * 		Name   -> Function DungeonCrawler.DCShopWidgetBase.OnNextPage
	 * 		Flags  -> (Final, Native, Private)
	 */
	void UDCShopWidgetBase::OnNextPage()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCShopWidgetBase.OnNextPage");
		
		UDCShopWidgetBase_OnNextPage_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017AB670
	 * 		Name   -> Function DungeonCrawler.DCShopWidgetBase.OnButtonBuyClicked
	 * 		Flags  -> (Final, Native, Private)
	 */
	void UDCShopWidgetBase::OnButtonBuyClicked()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCShopWidgetBase.OnButtonBuyClicked");
		
		UDCShopWidgetBase_OnButtonBuyClicked_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDCShopWidgetBase.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDCShopWidgetBase::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCShopWidgetBase");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.DCShowingKeyWidgetBase.OnInputBindChanged
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 */
	void UDCShowingKeyWidgetBase::OnInputBindChanged()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCShowingKeyWidgetBase.OnInputBindChanged");
		
		UDCShowingKeyWidgetBase_OnInputBindChanged_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDCShowingKeyWidgetBase.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDCShowingKeyWidgetBase::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCShowingKeyWidgetBase");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017ABC00
	 * 		Name   -> Function DungeonCrawler.DCSimpleTooltipWidget.SetTooltipData
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		class FText                                        Text                                                       (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		struct FSlateColor                                 TextColor                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UDCSimpleTooltipWidget::SetTooltipData(const class FText& Text, const struct FSlateColor& TextColor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCSimpleTooltipWidget.SetTooltipData");
		
		UDCSimpleTooltipWidget_SetTooltipData_Params params {};
		params.Text = Text;
		params.TextColor = TextColor;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017AB600
	 * 		Name   -> Function DungeonCrawler.DCSimpleTooltipWidget.GetTooltipColor
	 * 		Flags  -> (Final, Native, Protected, BlueprintCallable, BlueprintPure)
	 */
	struct FSlateColor UDCSimpleTooltipWidget::GetTooltipColor()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCSimpleTooltipWidget.GetTooltipColor");
		
		UDCSimpleTooltipWidget_GetTooltipColor_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDCSimpleTooltipWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDCSimpleTooltipWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCSimpleTooltipWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017ABE40
	 * 		Name   -> Function DungeonCrawler.DCSkeletalMeshComponent.UnbindMsgAll
	 * 		Flags  -> (Native, Public)
	 * Parameters:
	 * 		class UObject*                                     InObject                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UDCSkeletalMeshComponent::UnbindMsgAll(class UObject* InObject)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCSkeletalMeshComponent.UnbindMsgAll");
		
		UDCSkeletalMeshComponent_UnbindMsgAll_Params params {};
		params.InObject = InObject;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017ABD70
	 * 		Name   -> Function DungeonCrawler.DCSkeletalMeshComponent.UnbindMsg
	 * 		Flags  -> (Native, Public)
	 * Parameters:
	 * 		class UScriptStruct*                               InMsgType                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UObject*                                     InObject                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UDCSkeletalMeshComponent::UnbindMsg(class UScriptStruct* InMsgType, class UObject* InObject)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCSkeletalMeshComponent.UnbindMsg");
		
		UDCSkeletalMeshComponent_UnbindMsg_Params params {};
		params.InMsgType = InMsgType;
		params.InObject = InObject;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017ABD40
	 * 		Name   -> Function DungeonCrawler.DCSkeletalMeshComponent.TerminateBase
	 * 		Flags  -> (Native, Public)
	 */
	void UDCSkeletalMeshComponent::TerminateBase()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCSkeletalMeshComponent.TerminateBase");
		
		UDCSkeletalMeshComponent_TerminateBase_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017ABB70
	 * 		Name   -> Function DungeonCrawler.DCSkeletalMeshComponent.SetAffectNavigation
	 * 		Flags  -> (Final, Native, Protected, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bRelevant                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UDCSkeletalMeshComponent::SetAffectNavigation(bool bRelevant)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCSkeletalMeshComponent.SetAffectNavigation");
		
		UDCSkeletalMeshComponent_SetAffectNavigation_Params params {};
		params.bRelevant = bRelevant;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D3C640
	 * 		Name   -> Function DungeonCrawler.DCSkeletalMeshComponent.BroadcastMsgBlueprint
	 * 		Flags  -> (Native, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		int32_t                                            InMsg                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UDCSkeletalMeshComponent::BroadcastMsgBlueprint(int32_t InMsg)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCSkeletalMeshComponent.BroadcastMsgBlueprint");
		
		UDCSkeletalMeshComponent_BroadcastMsgBlueprint_Params params {};
		params.InMsg = InMsg;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDCSkeletalMeshComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDCSkeletalMeshComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCSkeletalMeshComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDCSkinTooltipWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDCSkinTooltipWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCSkinTooltipWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDCTabMenuWidgetBase.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDCTabMenuWidgetBase::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCTabMenuWidgetBase");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDCTagCollisionDetectorComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDCTagCollisionDetectorComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCTagCollisionDetectorComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017C13D0
	 * 		Name   -> Function DungeonCrawler.DCTargetType.GetTargets
	 * 		Flags  -> (Native, Event, Public, HasOutParms, BlueprintEvent, Const)
	 * Parameters:
	 * 		class AActor*                                      TargetingOwnerActor                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      TargetingAvatarActor                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FGameplayEventData                          EventData                                                  (Parm, NativeAccessSpecifierPublic)
	 * 		TArray<struct FHitResult>                          OutHitResults                                              (Parm, OutParm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 * 		TArray<class AActor*>                              OutActors                                                  (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	 */
	void UDCTargetType::GetTargets(class AActor* TargetingOwnerActor, class AActor* TargetingAvatarActor, const struct FGameplayEventData& EventData, TArray<struct FHitResult>* OutHitResults, TArray<class AActor*>* OutActors)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCTargetType.GetTargets");
		
		UDCTargetType_GetTargets_Params params {};
		params.TargetingOwnerActor = TargetingOwnerActor;
		params.TargetingAvatarActor = TargetingAvatarActor;
		params.EventData = EventData;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutHitResults != nullptr)
			*OutHitResults = params.OutHitResults;
		if (OutActors != nullptr)
			*OutActors = params.OutActors;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDCTargetType.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDCTargetType::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCTargetType");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDCTargetType_UseOwner.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDCTargetType_UseOwner::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCTargetType_UseOwner");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDCTargetType_UseEventData.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDCTargetType_UseEventData::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCTargetType_UseEventData");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017C2880
	 * 		Name   -> Function DungeonCrawler.DCTradeBoxWidget.SetReady
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		bool                                               bState                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UDCTradeBoxWidget::SetReady(bool bState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCTradeBoxWidget.SetReady");
		
		UDCTradeBoxWidget_SetReady_Params params {};
		params.bState = bState;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDCTradeBoxWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDCTradeBoxWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCTradeBoxWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDCTradeChannelCategoryWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDCTradeChannelCategoryWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCTradeChannelCategoryWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017C25B0
	 * 		Name   -> Function DungeonCrawler.DCTradeInventoryWidget.OnTradeRemoved
	 * 		Flags  -> (Final, Native, Private)
	 * Parameters:
	 * 		struct FDCItemId                                   ItemId                                                     (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UDCTradeInventoryWidget::OnTradeRemoved(const struct FDCItemId& ItemId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCTradeInventoryWidget.OnTradeRemoved");
		
		UDCTradeInventoryWidget_OnTradeRemoved_Params params {};
		params.ItemId = ItemId;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017C24A0
	 * 		Name   -> Function DungeonCrawler.DCTradeInventoryWidget.OnTradeInserted
	 * 		Flags  -> (Final, Native, Private, HasOutParms)
	 * Parameters:
	 * 		struct FDCItemInfo                                 ItemInfo                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		int32_t                                            Index                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UDCTradeInventoryWidget::OnTradeInserted(const struct FDCItemInfo& ItemInfo, int32_t Index)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCTradeInventoryWidget.OnTradeInserted");
		
		UDCTradeInventoryWidget_OnTradeInserted_Params params {};
		params.ItemInfo = ItemInfo;
		params.Index = Index;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017C2480
	 * 		Name   -> Function DungeonCrawler.DCTradeInventoryWidget.OnTradeEnd
	 * 		Flags  -> (Final, Native, Private)
	 */
	void UDCTradeInventoryWidget::OnTradeEnd()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCTradeInventoryWidget.OnTradeEnd");
		
		UDCTradeInventoryWidget_OnTradeEnd_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017C2460
	 * 		Name   -> Function DungeonCrawler.DCTradeInventoryWidget.OnStorageTabClicked
	 * 		Flags  -> (Final, Native, Private)
	 */
	void UDCTradeInventoryWidget::OnStorageTabClicked()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCTradeInventoryWidget.OnStorageTabClicked");
		
		UDCTradeInventoryWidget_OnStorageTabClicked_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017C2290
	 * 		Name   -> Function DungeonCrawler.DCTradeInventoryWidget.OnInventoryTabClicked
	 * 		Flags  -> (Final, Native, Private)
	 */
	void UDCTradeInventoryWidget::OnInventoryTabClicked()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCTradeInventoryWidget.OnInventoryTabClicked");
		
		UDCTradeInventoryWidget_OnInventoryTabClicked_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017C1B10
	 * 		Name   -> Function DungeonCrawler.DCTradeInventoryWidget.Init
	 * 		Flags  -> (Final, Native, Private)
	 */
	void UDCTradeInventoryWidget::Init()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCTradeInventoryWidget.Init");
		
		UDCTradeInventoryWidget_Init_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDCTradeInventoryWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDCTradeInventoryWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCTradeInventoryWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDCTradeLocalBoxWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDCTradeLocalBoxWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCTradeLocalBoxWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017C23D0
	 * 		Name   -> Function DungeonCrawler.DCTradePhaseConfirmWidget.OnResponseLocalTraderConfirmRequestResult
	 * 		Flags  -> (Final, Native, Private)
	 * Parameters:
	 * 		bool                                               bRequestSucceed                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UDCTradePhaseConfirmWidget::OnResponseLocalTraderConfirmRequestResult(bool bRequestSucceed)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCTradePhaseConfirmWidget.OnResponseLocalTraderConfirmRequestResult");
		
		UDCTradePhaseConfirmWidget_OnResponseLocalTraderConfirmRequestResult_Params params {};
		params.bRequestSucceed = bRequestSucceed;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017C22B0
	 * 		Name   -> Function DungeonCrawler.DCTradePhaseConfirmWidget.OnLocalTraderCheckBoxStateChanged
	 * 		Flags  -> (Final, Native, Private, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bIsChecked                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UDCTradePhaseConfirmWidget::OnLocalTraderCheckBoxStateChanged(bool bIsChecked)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCTradePhaseConfirmWidget.OnLocalTraderCheckBoxStateChanged");
		
		UDCTradePhaseConfirmWidget_OnLocalTraderCheckBoxStateChanged_Params params {};
		params.bIsChecked = bIsChecked;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017C21D0
	 * 		Name   -> Function DungeonCrawler.DCTradePhaseConfirmWidget.OnCancelTradeButtonClicked
	 * 		Flags  -> (Final, Native, Private)
	 */
	void UDCTradePhaseConfirmWidget::OnCancelTradeButtonClicked()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCTradePhaseConfirmWidget.OnCancelTradeButtonClicked");
		
		UDCTradePhaseConfirmWidget_OnCancelTradeButtonClicked_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDCTradePhaseConfirmWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDCTradePhaseConfirmWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCTradePhaseConfirmWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017C23D0
	 * 		Name   -> Function DungeonCrawler.DCTradePhaseDealWidget.OnResponseLocalTraderRequestRequestResult
	 * 		Flags  -> (Final, Native, Private)
	 * Parameters:
	 * 		bool                                               bRequestSucceed                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UDCTradePhaseDealWidget::OnResponseLocalTraderRequestRequestResult(bool bRequestSucceed)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCTradePhaseDealWidget.OnResponseLocalTraderRequestRequestResult");
		
		UDCTradePhaseDealWidget_OnResponseLocalTraderRequestRequestResult_Params params {};
		params.bRequestSucceed = bRequestSucceed;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017C2340
	 * 		Name   -> Function DungeonCrawler.DCTradePhaseDealWidget.OnLocalTraderCheckBoxStateChanged
	 * 		Flags  -> (Final, Native, Private, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bIsChecked                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UDCTradePhaseDealWidget::OnLocalTraderCheckBoxStateChanged(bool bIsChecked)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCTradePhaseDealWidget.OnLocalTraderCheckBoxStateChanged");
		
		UDCTradePhaseDealWidget_OnLocalTraderCheckBoxStateChanged_Params params {};
		params.bIsChecked = bIsChecked;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017C21F0
	 * 		Name   -> Function DungeonCrawler.DCTradePhaseDealWidget.OnCancelTradeButtonClicked
	 * 		Flags  -> (Final, Native, Private)
	 */
	void UDCTradePhaseDealWidget::OnCancelTradeButtonClicked()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCTradePhaseDealWidget.OnCancelTradeButtonClicked");
		
		UDCTradePhaseDealWidget_OnCancelTradeButtonClicked_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDCTradePhaseDealWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDCTradePhaseDealWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCTradePhaseDealWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDCTradeRemoteBoxWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDCTradeRemoteBoxWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCTradeRemoteBoxWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017C2800
	 * 		Name   -> Function DungeonCrawler.DCWidgetBlueprintLibrary.SetPlayerCursorCenter
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UDCWidgetBlueprintLibrary::STATIC_SetPlayerCursorCenter(class UObject* WorldContextObject)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCWidgetBlueprintLibrary.SetPlayerCursorCenter");
		
		UDCWidgetBlueprintLibrary_SetPlayerCursorCenter_Params params {};
		params.WorldContextObject = WorldContextObject;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017C2640
	 * 		Name   -> Function DungeonCrawler.DCWidgetBlueprintLibrary.PopupMessageSWidgetNotify
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class APlayerController*                           InPlayer                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UClass*                                      WidgetClass                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FText                                        DescMessage                                                (Parm, NativeAccessSpecifierPublic)
	 * 		EPopupButtonType                                   ButtonType                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UDCWidgetBlueprintLibrary::STATIC_PopupMessageSWidgetNotify(class APlayerController* InPlayer, class UClass* WidgetClass, const class FText& DescMessage, EPopupButtonType ButtonType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCWidgetBlueprintLibrary.PopupMessageSWidgetNotify");
		
		UDCWidgetBlueprintLibrary_PopupMessageSWidgetNotify_Params params {};
		params.InPlayer = InPlayer;
		params.WidgetClass = WidgetClass;
		params.DescMessage = DescMessage;
		params.ButtonType = ButtonType;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017C2040
	 * 		Name   -> Function DungeonCrawler.DCWidgetBlueprintLibrary.MakePopupMessageReqeust
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UClass*                                      WidgetClass                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UPopupDataBase*                              PopupData                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FMsgWidgetPopupMessageReqeust UDCWidgetBlueprintLibrary::STATIC_MakePopupMessageReqeust(class UClass* WidgetClass, class UPopupDataBase* PopupData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCWidgetBlueprintLibrary.MakePopupMessageReqeust");
		
		UDCWidgetBlueprintLibrary_MakePopupMessageReqeust_Params params {};
		params.WidgetClass = WidgetClass;
		params.PopupData = PopupData;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017C1F10
	 * 		Name   -> Function DungeonCrawler.DCWidgetBlueprintLibrary.MakePopupDataSWidget
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		EPopupButtonType                                   PopupButtonType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FText                                        DescMessage                                                (Parm, NativeAccessSpecifierPublic)
	 */
	class UPopupDataSWidget* UDCWidgetBlueprintLibrary::STATIC_MakePopupDataSWidget(EPopupButtonType PopupButtonType, const class FText& DescMessage)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCWidgetBlueprintLibrary.MakePopupDataSWidget");
		
		UDCWidgetBlueprintLibrary_MakePopupDataSWidget_Params params {};
		params.PopupButtonType = PopupButtonType;
		params.DescMessage = DescMessage;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017C0F90
	 * 		Name   -> Function DungeonCrawler.DCWidgetBlueprintLibrary.BroadcastSystemMessageNotify
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		class APlayerController*                           InPlayer                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FText                                        OutPutMessage                                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		float                                              Duration                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UDCWidgetBlueprintLibrary::STATIC_BroadcastSystemMessageNotify(class APlayerController* InPlayer, const class FText& OutPutMessage, float Duration)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCWidgetBlueprintLibrary.BroadcastSystemMessageNotify");
		
		UDCWidgetBlueprintLibrary_BroadcastSystemMessageNotify_Params params {};
		params.InPlayer = InPlayer;
		params.OutPutMessage = OutPutMessage;
		params.Duration = Duration;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017C0E80
	 * 		Name   -> Function DungeonCrawler.DCWidgetBlueprintLibrary.BroadcastLobbySystemMessage
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		class APlayerController*                           InPlayer                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FText                                        AnnounceText                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UDCWidgetBlueprintLibrary::STATIC_BroadcastLobbySystemMessage(class APlayerController* InPlayer, const class FText& AnnounceText)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCWidgetBlueprintLibrary.BroadcastLobbySystemMessage");
		
		UDCWidgetBlueprintLibrary_BroadcastLobbySystemMessage_Params params {};
		params.InPlayer = InPlayer;
		params.AnnounceText = AnnounceText;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDCWidgetBlueprintLibrary.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDCWidgetBlueprintLibrary::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCWidgetBlueprintLibrary");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ADCWorldSettings.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ADCWorldSettings::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCWorldSettings");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.DealTableBuyWidget.OnSuccessStockBuy
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 */
	void UDealTableBuyWidget::OnSuccessStockBuy()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DealTableBuyWidget.OnSuccessStockBuy");
		
		UDealTableBuyWidget_OnSuccessStockBuy_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.DealTableBuyWidget.OnStockBuyFillItemsResponse
	 * 		Flags  -> (Event, Protected, HasOutParms, BlueprintEvent)
	 * Parameters:
	 * 		bool                                               bFillSucceed                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		TArray<struct FStockBuyRequiredData>               ResultRequiredDataArray                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UDealTableBuyWidget::OnStockBuyFillItemsResponse(bool bFillSucceed, TArray<struct FStockBuyRequiredData> ResultRequiredDataArray)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DealTableBuyWidget.OnStockBuyFillItemsResponse");
		
		UDealTableBuyWidget_OnStockBuyFillItemsResponse_Params params {};
		params.bFillSucceed = bFillSucceed;
		params.ResultRequiredDataArray = ResultRequiredDataArray;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.DealTableBuyWidget.OnSetStockBuyData
	 * 		Flags  -> (Event, Protected, HasOutParms, BlueprintEvent)
	 * Parameters:
	 * 		struct FStockBuyData                               InStockBuyBata                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UDealTableBuyWidget::OnSetStockBuyData(const struct FStockBuyData& InStockBuyBata)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DealTableBuyWidget.OnSetStockBuyData");
		
		UDealTableBuyWidget_OnSetStockBuyData_Params params {};
		params.InStockBuyBata = InStockBuyBata;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.DealTableBuyWidget.OnRemoveStockBuyData
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 */
	void UDealTableBuyWidget::OnRemoveStockBuyData()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DealTableBuyWidget.OnRemoveStockBuyData");
		
		UDealTableBuyWidget_OnRemoveStockBuyData_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017C2250
	 * 		Name   -> Function DungeonCrawler.DealTableBuyWidget.OnClickedMakeDealButton
	 * 		Flags  -> (Final, Native, Protected, BlueprintCallable)
	 */
	void UDealTableBuyWidget::OnClickedMakeDealButton()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DealTableBuyWidget.OnClickedMakeDealButton");
		
		UDealTableBuyWidget_OnClickedMakeDealButton_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017C2210
	 * 		Name   -> Function DungeonCrawler.DealTableBuyWidget.OnClickedFillAllButton
	 * 		Flags  -> (Final, Native, Protected, BlueprintCallable)
	 */
	void UDealTableBuyWidget::OnClickedFillAllButton()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DealTableBuyWidget.OnClickedFillAllButton");
		
		UDealTableBuyWidget_OnClickedFillAllButton_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDealTableBuyWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDealTableBuyWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DealTableBuyWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.DealTableCraftWidget.OnSuccessStockCraft
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 */
	void UDealTableCraftWidget::OnSuccessStockCraft()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DealTableCraftWidget.OnSuccessStockCraft");
		
		UDealTableCraftWidget_OnSuccessStockCraft_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.DealTableCraftWidget.OnStockCraftFillItemsResponse
	 * 		Flags  -> (Event, Protected, HasOutParms, BlueprintEvent)
	 * Parameters:
	 * 		bool                                               bFillSucceed                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		TArray<struct FStockCraftRequiredData>             ResultRequiredDataArray                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UDealTableCraftWidget::OnStockCraftFillItemsResponse(bool bFillSucceed, TArray<struct FStockCraftRequiredData> ResultRequiredDataArray)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DealTableCraftWidget.OnStockCraftFillItemsResponse");
		
		UDealTableCraftWidget_OnStockCraftFillItemsResponse_Params params {};
		params.bFillSucceed = bFillSucceed;
		params.ResultRequiredDataArray = ResultRequiredDataArray;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.DealTableCraftWidget.OnSetStockCraftData
	 * 		Flags  -> (Event, Protected, HasOutParms, BlueprintEvent)
	 * Parameters:
	 * 		struct FStockCraftData                             InStockCraftData                                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UDealTableCraftWidget::OnSetStockCraftData(const struct FStockCraftData& InStockCraftData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DealTableCraftWidget.OnSetStockCraftData");
		
		UDealTableCraftWidget_OnSetStockCraftData_Params params {};
		params.InStockCraftData = InStockCraftData;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.DealTableCraftWidget.OnRemoveStockCraftData
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 */
	void UDealTableCraftWidget::OnRemoveStockCraftData()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DealTableCraftWidget.OnRemoveStockCraftData");
		
		UDealTableCraftWidget_OnRemoveStockCraftData_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017C2270
	 * 		Name   -> Function DungeonCrawler.DealTableCraftWidget.OnClickedMakeDealButton
	 * 		Flags  -> (Final, Native, Protected, BlueprintCallable)
	 */
	void UDealTableCraftWidget::OnClickedMakeDealButton()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DealTableCraftWidget.OnClickedMakeDealButton");
		
		UDealTableCraftWidget_OnClickedMakeDealButton_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017C2230
	 * 		Name   -> Function DungeonCrawler.DealTableCraftWidget.OnClickedFillAllButton
	 * 		Flags  -> (Final, Native, Protected, BlueprintCallable)
	 */
	void UDealTableCraftWidget::OnClickedFillAllButton()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DealTableCraftWidget.OnClickedFillAllButton");
		
		UDealTableCraftWidget_OnClickedFillAllButton_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDealTableCraftWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDealTableCraftWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DealTableCraftWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01764730
	 * 		Name   -> Function DungeonCrawler.InventoryComponent.UnbindMsgAll
	 * 		Flags  -> (Native, Public)
	 * Parameters:
	 * 		class UObject*                                     InObject                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UInventoryComponent::UnbindMsgAll(class UObject* InObject)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.InventoryComponent.UnbindMsgAll");
		
		UInventoryComponent_UnbindMsgAll_Params params {};
		params.InObject = InObject;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01764280
	 * 		Name   -> Function DungeonCrawler.InventoryComponent.UnbindMsg
	 * 		Flags  -> (Native, Public)
	 * Parameters:
	 * 		class UScriptStruct*                               InMsgType                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UObject*                                     InObject                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UInventoryComponent::UnbindMsg(class UScriptStruct* InMsgType, class UObject* InObject)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.InventoryComponent.UnbindMsg");
		
		UInventoryComponent_UnbindMsg_Params params {};
		params.InMsgType = InMsgType;
		params.InObject = InObject;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01763EB0
	 * 		Name   -> Function DungeonCrawler.InventoryComponent.TerminateBase
	 * 		Flags  -> (Native, Public)
	 */
	void UInventoryComponent::TerminateBase()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.InventoryComponent.TerminateBase");
		
		UInventoryComponent_TerminateBase_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017F4770
	 * 		Name   -> Function DungeonCrawler.InventoryComponent.OnRep_TotalGoldCount
	 * 		Flags  -> (Native, Protected)
	 * Parameters:
	 * 		int64_t                                            OldTotalGoldCount                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UInventoryComponent::OnRep_TotalGoldCount(int64_t OldTotalGoldCount)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.InventoryComponent.OnRep_TotalGoldCount");
		
		UInventoryComponent_OnRep_TotalGoldCount_Params params {};
		params.OldTotalGoldCount = OldTotalGoldCount;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017F4650
	 * 		Name   -> Function DungeonCrawler.InventoryComponent.OnRep_ContainingItems
	 * 		Flags  -> (Native, Protected, HasOutParms)
	 * Parameters:
	 * 		TArray<struct FItemData>                           OldContainingItems                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UInventoryComponent::OnRep_ContainingItems(TArray<struct FItemData> OldContainingItems)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.InventoryComponent.OnRep_ContainingItems");
		
		UInventoryComponent_OnRep_ContainingItems_Params params {};
		params.OldContainingItems = OldContainingItems;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017F4450
	 * 		Name   -> Function DungeonCrawler.InventoryComponent.GetItemByItemUniqueId
	 * 		Flags  -> (Final, Native, Public, Const)
	 * Parameters:
	 * 		int64_t                                            InItemUniqueId                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UItem* UInventoryComponent::GetItemByItemUniqueId(int64_t InItemUniqueId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.InventoryComponent.GetItemByItemUniqueId");
		
		UInventoryComponent_GetItemByItemUniqueId_Params params {};
		params.InItemUniqueId = InItemUniqueId;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017F4430
	 * 		Name   -> Function DungeonCrawler.InventoryComponent.GetInventoryType
	 * 		Flags  -> (Final, Native, Public, Const)
	 */
	EInventoryType UInventoryComponent::GetInventoryType()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.InventoryComponent.GetInventoryType");
		
		UInventoryComponent_GetInventoryType_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017F4370
	 * 		Name   -> Function DungeonCrawler.InventoryComponent.ClientShowMessage
	 * 		Flags  -> (Final, Net, Native, Event, Private, NetClient)
	 * Parameters:
	 * 		class FText                                        OutPutMessage                                              (ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UInventoryComponent::ClientShowMessage(const class FText& OutPutMessage)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.InventoryComponent.ClientShowMessage");
		
		UInventoryComponent_ClientShowMessage_Params params {};
		params.OutPutMessage = OutPutMessage;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D3C640
	 * 		Name   -> Function DungeonCrawler.InventoryComponent.BroadcastMsgBlueprint
	 * 		Flags  -> (Native, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		int32_t                                            InMsg                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UInventoryComponent::BroadcastMsgBlueprint(int32_t InMsg)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.InventoryComponent.BroadcastMsgBlueprint");
		
		UInventoryComponent_BroadcastMsgBlueprint_Params params {};
		params.InMsg = InMsg;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017F4070
	 * 		Name   -> Function DungeonCrawler.InventoryComponent.AddContainingItem
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		struct FItemData                                   ItemData                                                   (Parm, NativeAccessSpecifierPublic)
	 */
	bool UInventoryComponent::AddContainingItem(const struct FItemData& ItemData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.InventoryComponent.AddContainingItem");
		
		UInventoryComponent_AddContainingItem_Params params {};
		params.ItemData = ItemData;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UInventoryComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UInventoryComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.InventoryComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDealTableInventoryComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDealTableInventoryComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DealTableInventoryComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.PropsActorBase.UpdateInteractDepthValue
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 * Parameters:
	 * 		int32_t                                            DepthValue                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void APropsActorBase::UpdateInteractDepthValue(int32_t DepthValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.PropsActorBase.UpdateInteractDepthValue");
		
		APropsActorBase_UpdateInteractDepthValue_Params params {};
		params.DepthValue = DepthValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01813720
	 * 		Name   -> Function DungeonCrawler.PropsActorBase.SetPropsId
	 * 		Flags  -> (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FPrimaryAssetId                             InPropsId                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void APropsActorBase::SetPropsId(const struct FPrimaryAssetId& InPropsId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.PropsActorBase.SetPropsId");
		
		APropsActorBase_SetPropsId_Params params {};
		params.InPropsId = InPropsId;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01812DF0
	 * 		Name   -> Function DungeonCrawler.PropsActorBase.GetPropsId
	 * 		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable)
	 */
	struct FPrimaryAssetId APropsActorBase::GetPropsId()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.PropsActorBase.GetPropsId");
		
		APropsActorBase_GetPropsId_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01812AF0
	 * 		Name   -> Function DungeonCrawler.PropsActorBase.GetDesignDataProps
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	struct FDesignDataProps APropsActorBase::GetDesignDataProps()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.PropsActorBase.GetDesignDataProps");
		
		APropsActorBase_GetDesignDataProps_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.PropsActorBase.GameplayTagUpdated
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 * Parameters:
	 * 		struct FGameplayTag                                InGameplayTag                                              (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            InCount                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void APropsActorBase::GameplayTagUpdated(const struct FGameplayTag& InGameplayTag, int32_t InCount)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.PropsActorBase.GameplayTagUpdated");
		
		APropsActorBase_GameplayTagUpdated_Params params {};
		params.InGameplayTag = InGameplayTag;
		params.InCount = InCount;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction APropsActorBase.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* APropsActorBase::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.PropsActorBase");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ADeathSwarmBase.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ADeathSwarmBase::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DeathSwarmBase");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDescDataParam.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDescDataParam::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DescDataParam");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017C12F0
	 * 		Name   -> Function DungeonCrawler.DescData.GetExecImpactPower
	 * 		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		class UDescDataParam*                              InDescDataParam                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	float UDescData::GetExecImpactPower(class UDescDataParam* InDescDataParam)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DescData.GetExecImpactPower");
		
		UDescData_GetExecImpactPower_Params params {};
		params.InDescDataParam = InDescDataParam;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017C11A0
	 * 		Name   -> Function DungeonCrawler.DescData.GetDescription
	 * 		Flags  -> (Native, Public, HasOutParms, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		class UDescDataParam*                              InDescDataParam                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		TArray<class FText>                                OutDescTextArray                                           (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	 */
	void UDescData::GetDescription(class UDescDataParam* InDescDataParam, TArray<class FText>* OutDescTextArray)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DescData.GetDescription");
		
		UDescData_GetDescription_Params params {};
		params.InDescDataParam = InDescDataParam;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutDescTextArray != nullptr)
			*OutDescTextArray = params.OutDescTextArray;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDescData.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDescData::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DescData");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDescDataEffect.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDescDataEffect::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DescDataEffect");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDescDataEffectTwoParam.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDescDataEffectTwoParam::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DescDataEffectTwoParam");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDescDataAbility.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDescDataAbility::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DescDataAbility");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDescDataParamAbilityWeapon.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDescDataParamAbilityWeapon::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DescDataParamAbilityWeapon");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDescDataAbilityWeapon.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDescDataAbilityWeapon::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DescDataAbilityWeapon");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDesignDataAssetGameplayAbility.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDesignDataAssetGameplayAbility::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DesignDataAssetGameplayAbility");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDesignDataAssetGameplayEffect.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDesignDataAssetGameplayEffect::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DesignDataAssetGameplayEffect");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDesignDataAssetBaseItem.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDesignDataAssetBaseItem::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DesignDataAssetBaseItem");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDesignDataAssetPlayerCharacter.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDesignDataAssetPlayerCharacter::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DesignDataAssetPlayerCharacter");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDesignDataAssetMonster.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDesignDataAssetMonster::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DesignDataAssetMonster");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDesignDataAssetAoe.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDesignDataAssetAoe::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DesignDataAssetAoe");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDesignDataAssetProps.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDesignDataAssetProps::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DesignDataAssetProps");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDesignDataAssetPropsInteract.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDesignDataAssetPropsInteract::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DesignDataAssetPropsInteract");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDesignDataAssetPropsSkillCheck.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDesignDataAssetPropsSkillCheck::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DesignDataAssetPropsSkillCheck");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDesignDataAssetItem.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDesignDataAssetItem::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DesignDataAssetItem");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDesignDataAssetItemPropertyType.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDesignDataAssetItemPropertyType::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DesignDataAssetItemPropertyType");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDesignDataAssetItemProperty.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDesignDataAssetItemProperty::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DesignDataAssetItemProperty");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDesignDataAssetItemConsume.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDesignDataAssetItemConsume::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DesignDataAssetItemConsume");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017C1E00
	 * 		Name   -> Function DungeonCrawler.DesignDataAssetItemRequirement.IsTargetFulfilledAllRequirements
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		struct FDesignDataItem                             DesignDataItem                                             (Parm, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      TargetActor                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UDesignDataAssetItemRequirement::IsTargetFulfilledAllRequirements(const struct FDesignDataItem& DesignDataItem, class AActor* TargetActor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DesignDataAssetItemRequirement.IsTargetFulfilledAllRequirements");
		
		UDesignDataAssetItemRequirement_IsTargetFulfilledAllRequirements_Params params {};
		params.DesignDataItem = DesignDataItem;
		params.TargetActor = TargetActor;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017C1B30
	 * 		Name   -> Function DungeonCrawler.DesignDataAssetItemRequirement.IsFulfilledAllRequirements
	 * 		Flags  -> (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FDesignDataItem                             DesignDataItem                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		struct FPrimaryAssetId                             PlayerCharacterId                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UDCAttributeSet*                             AttributeSet                                               (ConstParm, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		TArray<struct FPrimaryAssetId>                     PerkIdArray                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		struct FGameplayTagContainer                       GameplayTagContainer                                       (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      TargetActor                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UDesignDataAssetItemRequirement::IsFulfilledAllRequirements(const struct FDesignDataItem& DesignDataItem, const struct FPrimaryAssetId& PlayerCharacterId, class UDCAttributeSet* AttributeSet, TArray<struct FPrimaryAssetId> PerkIdArray, const struct FGameplayTagContainer& GameplayTagContainer, class AActor* TargetActor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DesignDataAssetItemRequirement.IsFulfilledAllRequirements");
		
		UDesignDataAssetItemRequirement_IsFulfilledAllRequirements_Params params {};
		params.DesignDataItem = DesignDataItem;
		params.PlayerCharacterId = PlayerCharacterId;
		params.AttributeSet = AttributeSet;
		params.PerkIdArray = PerkIdArray;
		params.GameplayTagContainer = GameplayTagContainer;
		params.TargetActor = TargetActor;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017C1A30
	 * 		Name   -> Function DungeonCrawler.DesignDataAssetItemRequirement.GetUnmetItemRequirementsTarget
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class AActor*                                      TargetActor                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	TArray<EItemRequirementType> UDesignDataAssetItemRequirement::GetUnmetItemRequirementsTarget(class AActor* TargetActor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DesignDataAssetItemRequirement.GetUnmetItemRequirementsTarget");
		
		UDesignDataAssetItemRequirement_GetUnmetItemRequirementsTarget_Params params {};
		params.TargetActor = TargetActor;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017C1860
	 * 		Name   -> Function DungeonCrawler.DesignDataAssetItemRequirement.GetUnmetItemRequirements
	 * 		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FPrimaryAssetId                             PlayerCharacterId                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UDCAttributeSet*                             AttributeSet                                               (ConstParm, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		TArray<struct FPrimaryAssetId>                     PerkIdArray                                                (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
	 */
	TArray<EItemRequirementType> UDesignDataAssetItemRequirement::GetUnmetItemRequirements(const struct FPrimaryAssetId& PlayerCharacterId, class UDCAttributeSet* AttributeSet, TArray<struct FPrimaryAssetId> PerkIdArray)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DesignDataAssetItemRequirement.GetUnmetItemRequirements");
		
		UDesignDataAssetItemRequirement_GetUnmetItemRequirements_Params params {};
		params.PlayerCharacterId = PlayerCharacterId;
		params.AttributeSet = AttributeSet;
		params.PerkIdArray = PerkIdArray;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDesignDataAssetItemRequirement.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDesignDataAssetItemRequirement::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DesignDataAssetItemRequirement");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017C10F0
	 * 		Name   -> Function DungeonCrawler.DesignDataAssetItemBundleInfo.GetBundleArtAssetByCount
	 * 		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		int32_t                                            ItemCount                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FPrimaryAssetId UDesignDataAssetItemBundleInfo::GetBundleArtAssetByCount(int32_t ItemCount)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DesignDataAssetItemBundleInfo.GetBundleArtAssetByCount");
		
		UDesignDataAssetItemBundleInfo_GetBundleArtAssetByCount_Params params {};
		params.ItemCount = ItemCount;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDesignDataAssetItemBundleInfo.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDesignDataAssetItemBundleInfo::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DesignDataAssetItemBundleInfo");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDesignDataAssetItemContainer.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDesignDataAssetItemContainer::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DesignDataAssetItemContainer");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDesignDataAssetLootDrop.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDesignDataAssetLootDrop::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DesignDataAssetLootDrop");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDesignDataAssetSpawner.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDesignDataAssetSpawner::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DesignDataAssetSpawner");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDesignDataAssetProjectile.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDesignDataAssetProjectile::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DesignDataAssetProjectile");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDesignDataAssetMeleeAttack.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDesignDataAssetMeleeAttack::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DesignDataAssetMeleeAttack");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDesignDataAssetSkill.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDesignDataAssetSkill::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DesignDataAssetSkill");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDesignDataAssetSpell.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDesignDataAssetSpell::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DesignDataAssetSpell");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDesignDataAssetPerk.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDesignDataAssetPerk::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DesignDataAssetPerk");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDesignDataAssetMovementModifier.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDesignDataAssetMovementModifier::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DesignDataAssetMovementModifier");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDesignDataAssetMerchant.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDesignDataAssetMerchant::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DesignDataAssetMerchant");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDesignDataAssetMerchantSchedule.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDesignDataAssetMerchantSchedule::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DesignDataAssetMerchantSchedule");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDesignDataAssetStockBuy.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDesignDataAssetStockBuy::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DesignDataAssetStockBuy");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDesignDataAssetStockSellBack.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDesignDataAssetStockSellBack::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DesignDataAssetStockSellBack");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDesignDataAssetStockCraft.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDesignDataAssetStockCraft::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DesignDataAssetStockCraft");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDesignDataAssetFloorRule.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDesignDataAssetFloorRule::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DesignDataAssetFloorRule");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDesignDataAssetFloorPortal.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDesignDataAssetFloorPortal::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DesignDataAssetFloorPortal");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDesignDataAssetConstant.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDesignDataAssetConstant::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DesignDataAssetConstant");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDesignDataAssetEmote.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDesignDataAssetEmote::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DesignDataAssetEmote");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDesignDataAssetIdTagGroup.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDesignDataAssetIdTagGroup::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DesignDataAssetIdTagGroup");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDesignDataAssetDungeon.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDesignDataAssetDungeon::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DesignDataAssetDungeon");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01764730
	 * 		Name   -> Function DungeonCrawler.EmoteComponent.UnbindMsgAll
	 * 		Flags  -> (Native, Public)
	 * Parameters:
	 * 		class UObject*                                     InObject                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UEmoteComponent::UnbindMsgAll(class UObject* InObject)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.EmoteComponent.UnbindMsgAll");
		
		UEmoteComponent_UnbindMsgAll_Params params {};
		params.InObject = InObject;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01764280
	 * 		Name   -> Function DungeonCrawler.EmoteComponent.UnbindMsg
	 * 		Flags  -> (Native, Public)
	 * Parameters:
	 * 		class UScriptStruct*                               InMsgType                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UObject*                                     InObject                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UEmoteComponent::UnbindMsg(class UScriptStruct* InMsgType, class UObject* InObject)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.EmoteComponent.UnbindMsg");
		
		UEmoteComponent_UnbindMsg_Params params {};
		params.InMsgType = InMsgType;
		params.InObject = InObject;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01763EB0
	 * 		Name   -> Function DungeonCrawler.EmoteComponent.TerminateBase
	 * 		Flags  -> (Native, Public)
	 */
	void UEmoteComponent::TerminateBase()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.EmoteComponent.TerminateBase");
		
		UEmoteComponent_TerminateBase_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D3C640
	 * 		Name   -> Function DungeonCrawler.EmoteComponent.BroadcastMsgBlueprint
	 * 		Flags  -> (Native, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		int32_t                                            InMsg                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UEmoteComponent::BroadcastMsgBlueprint(int32_t InMsg)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.EmoteComponent.BroadcastMsgBlueprint");
		
		UEmoteComponent_BroadcastMsgBlueprint_Params params {};
		params.InMsg = InMsg;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UEmoteComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UEmoteComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.EmoteComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017C5D10
	 * 		Name   -> Function DungeonCrawler.EquipmentSlot.GetItem
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	class UItem* UEquipmentSlot::GetItem()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.EquipmentSlot.GetItem");
		
		UEquipmentSlot_GetItem_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UEquipmentSlot.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UEquipmentSlot::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.EquipmentSlot");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UEquipmentWeaponSlot.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UEquipmentWeaponSlot::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.EquipmentWeaponSlot");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017C70D0
	 * 		Name   -> Function DungeonCrawler.EquipmentInventoryComponent.UpdateCrossHairWidget
	 * 		Flags  -> (Final, Native, Private)
	 */
	void UEquipmentInventoryComponent::UpdateCrossHairWidget()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.EquipmentInventoryComponent.UpdateCrossHairWidget");
		
		UEquipmentInventoryComponent_UpdateCrossHairWidget_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01764730
	 * 		Name   -> Function DungeonCrawler.EquipmentInventoryComponent.UnbindMsgAll
	 * 		Flags  -> (Native, Public)
	 * Parameters:
	 * 		class UObject*                                     InObject                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UEquipmentInventoryComponent::UnbindMsgAll(class UObject* InObject)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.EquipmentInventoryComponent.UnbindMsgAll");
		
		UEquipmentInventoryComponent_UnbindMsgAll_Params params {};
		params.InObject = InObject;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01764280
	 * 		Name   -> Function DungeonCrawler.EquipmentInventoryComponent.UnbindMsg
	 * 		Flags  -> (Native, Public)
	 * Parameters:
	 * 		class UScriptStruct*                               InMsgType                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UObject*                                     InObject                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UEquipmentInventoryComponent::UnbindMsg(class UScriptStruct* InMsgType, class UObject* InObject)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.EquipmentInventoryComponent.UnbindMsg");
		
		UEquipmentInventoryComponent_UnbindMsg_Params params {};
		params.InMsgType = InMsgType;
		params.InObject = InObject;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017C7030
	 * 		Name   -> Function DungeonCrawler.EquipmentInventoryComponent.TryRemoveItem
	 * 		Flags  -> (Final, Native, Private)
	 * Parameters:
	 * 		int64_t                                            RemoveItemUniqueId                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UEquipmentInventoryComponent::TryRemoveItem(int64_t RemoveItemUniqueId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.EquipmentInventoryComponent.TryRemoveItem");
		
		UEquipmentInventoryComponent_TryRemoveItem_Params params {};
		params.RemoveItemUniqueId = RemoveItemUniqueId;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017C6E60
	 * 		Name   -> Function DungeonCrawler.EquipmentInventoryComponent.TryAddItem
	 * 		Flags  -> (Final, Native, Private, HasOutParms)
	 * Parameters:
	 * 		struct FItemData                                   InItemData                                                 (Parm, OutParm, NativeAccessSpecifierPublic)
	 * 		int32_t                                            SlotId                                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               BySystem                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UEquipmentInventoryComponent::TryAddItem(struct FItemData* InItemData, int32_t SlotId, bool BySystem)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.EquipmentInventoryComponent.TryAddItem");
		
		UEquipmentInventoryComponent_TryAddItem_Params params {};
		params.SlotId = SlotId;
		params.BySystem = BySystem;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (InItemData != nullptr)
			*InItemData = params.InItemData;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01763EB0
	 * 		Name   -> Function DungeonCrawler.EquipmentInventoryComponent.TerminateBase
	 * 		Flags  -> (Native, Public)
	 */
	void UEquipmentInventoryComponent::TerminateBase()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.EquipmentInventoryComponent.TerminateBase");
		
		UEquipmentInventoryComponent_TerminateBase_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017C6C10
	 * 		Name   -> Function DungeonCrawler.EquipmentInventoryComponent.SetEquipItemAt
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		EEquipmentQuickSlotType                            QuickSlotType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bEquip                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UEquipmentInventoryComponent::SetEquipItemAt(EEquipmentQuickSlotType QuickSlotType, bool bEquip)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.EquipmentInventoryComponent.SetEquipItemAt");
		
		UEquipmentInventoryComponent_SetEquipItemAt_Params params {};
		params.QuickSlotType = QuickSlotType;
		params.bEquip = bEquip;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017C6B30
	 * 		Name   -> Function DungeonCrawler.EquipmentInventoryComponent.ServerMoveToNextSlot
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetServer)
	 * Parameters:
	 * 		EEquipmentQuickSlotType                            QuickSlotType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bNextAvailableSlot                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UEquipmentInventoryComponent::ServerMoveToNextSlot(EEquipmentQuickSlotType QuickSlotType, bool bNextAvailableSlot)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.EquipmentInventoryComponent.ServerMoveToNextSlot");
		
		UEquipmentInventoryComponent_ServerMoveToNextSlot_Params params {};
		params.QuickSlotType = QuickSlotType;
		params.bNextAvailableSlot = bNextAvailableSlot;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017C6A10
	 * 		Name   -> Function DungeonCrawler.EquipmentInventoryComponent.RemoveContaingItemActors
	 * 		Flags  -> (Final, Native, Private)
	 * Parameters:
	 * 		int64_t                                            ItemUniqueId                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UEquipmentInventoryComponent::RemoveContaingItemActors(int64_t ItemUniqueId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.EquipmentInventoryComponent.RemoveContaingItemActors");
		
		UEquipmentInventoryComponent_RemoveContaingItemActors_Params params {};
		params.ItemUniqueId = ItemUniqueId;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017C69F0
	 * 		Name   -> Function DungeonCrawler.EquipmentInventoryComponent.RemoveAllItems
	 * 		Flags  -> (Final, Native, Private)
	 */
	void UEquipmentInventoryComponent::RemoveAllItems()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.EquipmentInventoryComponent.RemoveAllItems");
		
		UEquipmentInventoryComponent_RemoveAllItems_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017C6900
	 * 		Name   -> Function DungeonCrawler.EquipmentInventoryComponent.OnRep_SheathItemActors
	 * 		Flags  -> (Final, Native, Private)
	 * Parameters:
	 * 		TArray<class AItemActor*>                          OldSheathItemActors                                        (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
	 */
	void UEquipmentInventoryComponent::OnRep_SheathItemActors(TArray<class AItemActor*> OldSheathItemActors)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.EquipmentInventoryComponent.OnRep_SheathItemActors");
		
		UEquipmentInventoryComponent_OnRep_SheathItemActors_Params params {};
		params.OldSheathItemActors = OldSheathItemActors;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017C6810
	 * 		Name   -> Function DungeonCrawler.EquipmentInventoryComponent.OnRep_EquippedItemActors
	 * 		Flags  -> (Final, Native, Private)
	 * Parameters:
	 * 		TArray<class AItemActor*>                          OldEquippedItemActors                                      (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
	 */
	void UEquipmentInventoryComponent::OnRep_EquippedItemActors(TArray<class AItemActor*> OldEquippedItemActors)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.EquipmentInventoryComponent.OnRep_EquippedItemActors");
		
		UEquipmentInventoryComponent_OnRep_EquippedItemActors_Params params {};
		params.OldEquippedItemActors = OldEquippedItemActors;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017C66F0
	 * 		Name   -> Function DungeonCrawler.EquipmentInventoryComponent.OnRep_ContainingItems
	 * 		Flags  -> (Final, Native, Private, HasOutParms)
	 * Parameters:
	 * 		TArray<struct FItemData>                           OldContainingItems                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UEquipmentInventoryComponent::OnRep_ContainingItems(TArray<struct FItemData> OldContainingItems)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.EquipmentInventoryComponent.OnRep_ContainingItems");
		
		UEquipmentInventoryComponent_OnRep_ContainingItems_Params params {};
		params.OldContainingItems = OldContainingItems;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017C60D0
	 * 		Name   -> Function DungeonCrawler.EquipmentInventoryComponent.OnFinishedActiveEquipmentQuickSlot
	 * 		Flags  -> (Native, Public)
	 * Parameters:
	 * 		EEquipmentQuickSlotType                            QuickSlotType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bSlotActive                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UEquipmentInventoryComponent::OnFinishedActiveEquipmentQuickSlot(EEquipmentQuickSlotType QuickSlotType, bool bSlotActive)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.EquipmentInventoryComponent.OnFinishedActiveEquipmentQuickSlot");
		
		UEquipmentInventoryComponent_OnFinishedActiveEquipmentQuickSlot_Params params {};
		params.QuickSlotType = QuickSlotType;
		params.bSlotActive = bSlotActive;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017C6040
	 * 		Name   -> Function DungeonCrawler.EquipmentInventoryComponent.HideEquippedItemActorsInGame
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		bool                                               bHidden                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UEquipmentInventoryComponent::HideEquippedItemActorsInGame(bool bHidden)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.EquipmentInventoryComponent.HideEquippedItemActorsInGame");
		
		UEquipmentInventoryComponent_HideEquippedItemActorsInGame_Params params {};
		params.bHidden = bHidden;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017C5FB0
	 * 		Name   -> Function DungeonCrawler.EquipmentInventoryComponent.GetSlotIdByItemSlotType
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		struct FGameplayTag                                SlotType                                                   (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	int32_t UEquipmentInventoryComponent::STATIC_GetSlotIdByItemSlotType(const struct FGameplayTag& SlotType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.EquipmentInventoryComponent.GetSlotIdByItemSlotType");
		
		UEquipmentInventoryComponent_GetSlotIdByItemSlotType_Params params {};
		params.SlotType = SlotType;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017C5EB0
	 * 		Name   -> Function DungeonCrawler.EquipmentInventoryComponent.GetQuickSlotInfoByType
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		EEquipmentQuickSlotType                            QuickSlotType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FEquipmentQuickSlotInfo UEquipmentInventoryComponent::GetQuickSlotInfoByType(EEquipmentQuickSlotType QuickSlotType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.EquipmentInventoryComponent.GetQuickSlotInfoByType");
		
		UEquipmentInventoryComponent_GetQuickSlotInfoByType_Params params {};
		params.QuickSlotType = QuickSlotType;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017C5DD0
	 * 		Name   -> Function DungeonCrawler.EquipmentInventoryComponent.GetItemsBySlotType
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		struct FGameplayTag                                ItemSlotType                                               (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	TArray<class UItem*> UEquipmentInventoryComponent::GetItemsBySlotType(const struct FGameplayTag& ItemSlotType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.EquipmentInventoryComponent.GetItemsBySlotType");
		
		UEquipmentInventoryComponent_GetItemsBySlotType_Params params {};
		params.ItemSlotType = ItemSlotType;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017C5D30
	 * 		Name   -> Function DungeonCrawler.EquipmentInventoryComponent.GetItemByItemUniqueId
	 * 		Flags  -> (Final, Native, Public, Const)
	 * Parameters:
	 * 		int64_t                                            InItemUniqueId                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UItem* UEquipmentInventoryComponent::GetItemByItemUniqueId(int64_t InItemUniqueId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.EquipmentInventoryComponent.GetItemByItemUniqueId");
		
		UEquipmentInventoryComponent_GetItemByItemUniqueId_Params params {};
		params.InItemUniqueId = InItemUniqueId;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017C5C60
	 * 		Name   -> Function DungeonCrawler.EquipmentInventoryComponent.GetCurrentHoldingItemData
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	struct FItemData UEquipmentInventoryComponent::GetCurrentHoldingItemData()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.EquipmentInventoryComponent.GetCurrentHoldingItemData");
		
		UEquipmentInventoryComponent_GetCurrentHoldingItemData_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017C5C40
	 * 		Name   -> Function DungeonCrawler.EquipmentInventoryComponent.GetCurrentActiveSlotType
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	EEquipmentQuickSlotType UEquipmentInventoryComponent::GetCurrentActiveSlotType()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.EquipmentInventoryComponent.GetCurrentActiveSlotType");
		
		UEquipmentInventoryComponent_GetCurrentActiveSlotType_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D3C640
	 * 		Name   -> Function DungeonCrawler.EquipmentInventoryComponent.BroadcastMsgBlueprint
	 * 		Flags  -> (Native, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		int32_t                                            InMsg                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UEquipmentInventoryComponent::BroadcastMsgBlueprint(int32_t InMsg)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.EquipmentInventoryComponent.BroadcastMsgBlueprint");
		
		UEquipmentInventoryComponent_BroadcastMsgBlueprint_Params params {};
		params.InMsg = InMsg;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UEquipmentInventoryComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UEquipmentInventoryComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.EquipmentInventoryComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.EquipmentInventoryGroupWidget.OnSwitchChestAndSoulHeart
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 * Parameters:
	 * 		int32_t                                            ActiveIndex                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UEquipmentInventoryGroupWidget::OnSwitchChestAndSoulHeart(int32_t ActiveIndex)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.EquipmentInventoryGroupWidget.OnSwitchChestAndSoulHeart");
		
		UEquipmentInventoryGroupWidget_OnSwitchChestAndSoulHeart_Params params {};
		params.ActiveIndex = ActiveIndex;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017C6410
	 * 		Name   -> Function DungeonCrawler.EquipmentInventoryGroupWidget.OnItemDropDetected
	 * 		Flags  -> (Final, Native, Protected, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		struct FItemData                                   ItemData                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      OldOwnerActor                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UEquipmentInventoryGroupWidget::OnItemDropDetected(const struct FItemData& ItemData, class AActor* OldOwnerActor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.EquipmentInventoryGroupWidget.OnItemDropDetected");
		
		UEquipmentInventoryGroupWidget_OnItemDropDetected_Params params {};
		params.ItemData = ItemData;
		params.OldOwnerActor = OldOwnerActor;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017C61D0
	 * 		Name   -> Function DungeonCrawler.EquipmentInventoryGroupWidget.OnItemDragOver
	 * 		Flags  -> (Final, Native, Protected, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FItemData                                   ItemData                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		struct FVector2D                                   DragScreenPos                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector2D                                   DragWidgetScreenPos                                        (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector2D                                   DragWidgetAbsoluteSize                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UEquipmentInventoryGroupWidget::OnItemDragOver(const struct FItemData& ItemData, const struct FVector2D& DragScreenPos, const struct FVector2D& DragWidgetScreenPos, const struct FVector2D& DragWidgetAbsoluteSize)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.EquipmentInventoryGroupWidget.OnItemDragOver");
		
		UEquipmentInventoryGroupWidget_OnItemDragOver_Params params {};
		params.ItemData = ItemData;
		params.DragScreenPos = DragScreenPos;
		params.DragWidgetScreenPos = DragWidgetScreenPos;
		params.DragWidgetAbsoluteSize = DragWidgetAbsoluteSize;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017C61B0
	 * 		Name   -> Function DungeonCrawler.EquipmentInventoryGroupWidget.OnItemDragLeaveOrDrop
	 * 		Flags  -> (Final, Native, Protected, BlueprintCallable)
	 */
	void UEquipmentInventoryGroupWidget::OnItemDragLeaveOrDrop()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.EquipmentInventoryGroupWidget.OnItemDragLeaveOrDrop");
		
		UEquipmentInventoryGroupWidget_OnItemDragLeaveOrDrop_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.EquipmentInventoryGroupWidget.OnDragOverChestSlot
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 * Parameters:
	 * 		bool                                               bIsDragOver                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UEquipmentInventoryGroupWidget::OnDragOverChestSlot(bool bIsDragOver)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.EquipmentInventoryGroupWidget.OnDragOverChestSlot");
		
		UEquipmentInventoryGroupWidget_OnDragOverChestSlot_Params params {};
		params.bIsDragOver = bIsDragOver;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.EquipmentInventoryGroupWidget.OnCurrentActiveSlot
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 * Parameters:
	 * 		EEquipmentQuickSlotType                            ItemQuickSlotType                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UEquipmentInventoryGroupWidget::OnCurrentActiveSlot(EEquipmentQuickSlotType ItemQuickSlotType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.EquipmentInventoryGroupWidget.OnCurrentActiveSlot");
		
		UEquipmentInventoryGroupWidget_OnCurrentActiveSlot_Params params {};
		params.ItemQuickSlotType = ItemQuickSlotType;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UEquipmentInventoryGroupWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UEquipmentInventoryGroupWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.EquipmentInventoryGroupWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017C6D70
	 * 		Name   -> Function DungeonCrawler.EquipmentSlotWidget.SetPreviewItemWidget
	 * 		Flags  -> (Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FPrimaryAssetId                             ItemId                                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Duration                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UEquipmentSlotWidget::SetPreviewItemWidget(const struct FPrimaryAssetId& ItemId, float Duration)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.EquipmentSlotWidget.SetPreviewItemWidget");
		
		UEquipmentSlotWidget_SetPreviewItemWidget_Params params {};
		params.ItemId = ItemId;
		params.Duration = Duration;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.EquipmentSlotWidget.SetActiveHoverImage
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 * Parameters:
	 * 		bool                                               bActivate                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UEquipmentSlotWidget::SetActiveHoverImage(bool bActivate)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.EquipmentSlotWidget.SetActiveHoverImage");
		
		UEquipmentSlotWidget_SetActiveHoverImage_Params params {};
		params.bActivate = bActivate;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017C6AA0
	 * 		Name   -> Function DungeonCrawler.EquipmentSlotWidget.RemovePreviewItemWidget
	 * 		Flags  -> (Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bSetItem                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UEquipmentSlotWidget::RemovePreviewItemWidget(bool bSetItem)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.EquipmentSlotWidget.RemovePreviewItemWidget");
		
		UEquipmentSlotWidget_RemovePreviewItemWidget_Params params {};
		params.bSetItem = bSetItem;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017C65A0
	 * 		Name   -> Function DungeonCrawler.EquipmentSlotWidget.OnRemoveItem
	 * 		Flags  -> (Native, Event, Protected, HasOutParms, BlueprintEvent)
	 * Parameters:
	 * 		struct FItemData                                   InItemData                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UEquipmentSlotWidget::OnRemoveItem(const struct FItemData& InItemData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.EquipmentSlotWidget.OnRemoveItem");
		
		UEquipmentSlotWidget_OnRemoveItem_Params params {};
		params.InItemData = InItemData;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.EquipmentSlotWidget.OnOverlapItemWidget
	 * 		Flags  -> (Event, Public, HasOutParms, HasDefaults, BlueprintEvent)
	 * Parameters:
	 * 		struct FPrimaryAssetId                             ItemId                                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bValidSlot                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bCanEquip                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UEquipmentSlotWidget::OnOverlapItemWidget(const struct FPrimaryAssetId& ItemId, bool bValidSlot, bool bCanEquip)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.EquipmentSlotWidget.OnOverlapItemWidget");
		
		UEquipmentSlotWidget_OnOverlapItemWidget_Params params {};
		params.ItemId = ItemId;
		params.bValidSlot = bValidSlot;
		params.bCanEquip = bCanEquip;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.EquipmentSlotWidget.OnLeaveItemWidget
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 */
	void UEquipmentSlotWidget::OnLeaveItemWidget()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.EquipmentSlotWidget.OnLeaveItemWidget");
		
		UEquipmentSlotWidget_OnLeaveItemWidget_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.EquipmentSlotWidget.OnItemSlotActivate
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 * Parameters:
	 * 		bool                                               bActivate                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UEquipmentSlotWidget::OnItemSlotActivate(bool bActivate)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.EquipmentSlotWidget.OnItemSlotActivate");
		
		UEquipmentSlotWidget_OnItemSlotActivate_Params params {};
		params.bActivate = bActivate;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.EquipmentSlotWidget.OnFinishedItemDataSet
	 * 		Flags  -> (Event, Protected, HasOutParms, BlueprintEvent)
	 * Parameters:
	 * 		struct FItemData                                   InItemData                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		struct FGameplayTag                                HandType                                                   (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FGameplayTag                                SlotType                                                   (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FItemInventorySize                          InventorySize                                              (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UEquipmentSlotWidget::OnFinishedItemDataSet(const struct FItemData& InItemData, const struct FGameplayTag& HandType, const struct FGameplayTag& SlotType, const struct FItemInventorySize& InventorySize)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.EquipmentSlotWidget.OnFinishedItemDataSet");
		
		UEquipmentSlotWidget_OnFinishedItemDataSet_Params params {};
		params.InItemData = InItemData;
		params.HandType = HandType;
		params.SlotType = SlotType;
		params.InventorySize = InventorySize;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017C5B90
	 * 		Name   -> Function DungeonCrawler.EquipmentSlotWidget.CheckAndSetActiveHoverImage
	 * 		Flags  -> (Final, Native, Protected, BlueprintCallable)
	 */
	void UEquipmentSlotWidget::CheckAndSetActiveHoverImage()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.EquipmentSlotWidget.CheckAndSetActiveHoverImage");
		
		UEquipmentSlotWidget_CheckAndSetActiveHoverImage_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UEquipmentSlotWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UEquipmentSlotWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.EquipmentSlotWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.EquipmentWeaponSlotSetWidget.SetActiveSecondaryHoverImage
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 * Parameters:
	 * 		bool                                               bActivate                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UEquipmentWeaponSlotSetWidget::SetActiveSecondaryHoverImage(bool bActivate)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.EquipmentWeaponSlotSetWidget.SetActiveSecondaryHoverImage");
		
		UEquipmentWeaponSlotSetWidget_SetActiveSecondaryHoverImage_Params params {};
		params.bActivate = bActivate;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.EquipmentWeaponSlotSetWidget.SetActivePrimaryHoverImage
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 * Parameters:
	 * 		bool                                               bActivate                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UEquipmentWeaponSlotSetWidget::SetActivePrimaryHoverImage(bool bActivate)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.EquipmentWeaponSlotSetWidget.SetActivePrimaryHoverImage");
		
		UEquipmentWeaponSlotSetWidget_SetActivePrimaryHoverImage_Params params {};
		params.bActivate = bActivate;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017C5BB0
	 * 		Name   -> Function DungeonCrawler.EquipmentWeaponSlotSetWidget.CheckAndSetActiveHoverImageBySlot
	 * 		Flags  -> (Final, Native, Protected, BlueprintCallable)
	 * Parameters:
	 * 		class UWidget*                                     SlotUnderPointerPosition                                   (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UEquipmentWeaponSlotSetWidget::CheckAndSetActiveHoverImageBySlot(class UWidget* SlotUnderPointerPosition)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.EquipmentWeaponSlotSetWidget.CheckAndSetActiveHoverImageBySlot");
		
		UEquipmentWeaponSlotSetWidget_CheckAndSetActiveHoverImageBySlot_Params params {};
		params.SlotUnderPointerPosition = SlotUnderPointerPosition;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UEquipmentWeaponSlotSetWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UEquipmentWeaponSlotSetWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.EquipmentWeaponSlotSetWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017C6CE0
	 * 		Name   -> Function DungeonCrawler.ExpandableInventoryComponent.SetExpandable
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bCanExpand                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UExpandableInventoryComponent::SetExpandable(bool bCanExpand)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.ExpandableInventoryComponent.SetExpandable");
		
		UExpandableInventoryComponent_SetExpandable_Params params {};
		params.bCanExpand = bCanExpand;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UExpandableInventoryComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UExpandableInventoryComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.ExpandableInventoryComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AFloorPortalBase.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AFloorPortalBase::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.FloorPortalBase");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AFloorPortalScrollBase.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AFloorPortalScrollBase::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.FloorPortalScrollBase");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGameActorStatusSlotItemData.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGameActorStatusSlotItemData::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.GameActorStatusSlotItemData");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.GameActorStatusSlotWidget.OnActorStatusData
	 * 		Flags  -> (Event, Public, HasOutParms, BlueprintEvent)
	 * Parameters:
	 * 		struct FActorStatusData                            NewValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FActorStatusData                            OldValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGameActorStatusSlotWidget::OnActorStatusData(const struct FActorStatusData& NewValue, const struct FActorStatusData& OldValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GameActorStatusSlotWidget.OnActorStatusData");
		
		UGameActorStatusSlotWidget_OnActorStatusData_Params params {};
		params.NewValue = NewValue;
		params.OldValue = OldValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGameActorStatusSlotWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGameActorStatusSlotWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.GameActorStatusSlotWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGameActorStatusWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGameActorStatusWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.GameActorStatusWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.GameAlivePlayerCountWidget.OnTotalPlayerCount
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 * Parameters:
	 * 		int32_t                                            NewValue                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            OldValue                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGameAlivePlayerCountWidget::OnTotalPlayerCount(int32_t NewValue, int32_t OldValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GameAlivePlayerCountWidget.OnTotalPlayerCount");
		
		UGameAlivePlayerCountWidget_OnTotalPlayerCount_Params params {};
		params.NewValue = NewValue;
		params.OldValue = OldValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.GameAlivePlayerCountWidget.OnAlivePlayerCount
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 * Parameters:
	 * 		int32_t                                            NewValue                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            OldValue                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGameAlivePlayerCountWidget::OnAlivePlayerCount(int32_t NewValue, int32_t OldValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GameAlivePlayerCountWidget.OnAlivePlayerCount");
		
		UGameAlivePlayerCountWidget_OnAlivePlayerCount_Params params {};
		params.NewValue = NewValue;
		params.OldValue = OldValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGameAlivePlayerCountWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGameAlivePlayerCountWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.GameAlivePlayerCountWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGameAmmoWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGameAmmoWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.GameAmmoWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGameCancelTipWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGameCancelTipWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.GameCancelTipWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGameCompassWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGameCompassWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.GameCompassWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.GameCrossHairWidget.OnPlayShootCrossHair
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 * Parameters:
	 * 		float                                              Rate                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGameCrossHairWidget::OnPlayShootCrossHair(float Rate)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GameCrossHairWidget.OnPlayShootCrossHair");
		
		UGameCrossHairWidget_OnPlayShootCrossHair_Params params {};
		params.Rate = Rate;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.GameCrossHairWidget.OnPlayPullingCrossHair
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 * Parameters:
	 * 		float                                              Rate                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGameCrossHairWidget::OnPlayPullingCrossHair(float Rate)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GameCrossHairWidget.OnPlayPullingCrossHair");
		
		UGameCrossHairWidget_OnPlayPullingCrossHair_Params params {};
		params.Rate = Rate;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.GameCrossHairWidget.OnInitCrossHair
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 */
	void UGameCrossHairWidget::OnInitCrossHair()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GameCrossHairWidget.OnInitCrossHair");
		
		UGameCrossHairWidget_OnInitCrossHair_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.GameCrossHairWidget.OnCrossHairVisability
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 * Parameters:
	 * 		bool                                               IsVisablile                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               SetDefault                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGameCrossHairWidget::OnCrossHairVisability(bool IsVisablile, bool SetDefault)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GameCrossHairWidget.OnCrossHairVisability");
		
		UGameCrossHairWidget_OnCrossHairVisability_Params params {};
		params.IsVisablile = IsVisablile;
		params.SetDefault = SetDefault;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.GameCrossHairWidget.OnChangeWeaponCrossHair
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 * Parameters:
	 * 		struct FGameplayTag                                WeaponTypeTag                                              (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FGameplayTag                                ItemUtilityTag                                             (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FGameplayTag                                ItemSlotTypeTags                                           (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               IsAttackEnable                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGameCrossHairWidget::OnChangeWeaponCrossHair(const struct FGameplayTag& WeaponTypeTag, const struct FGameplayTag& ItemUtilityTag, const struct FGameplayTag& ItemSlotTypeTags, bool IsAttackEnable)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GameCrossHairWidget.OnChangeWeaponCrossHair");
		
		UGameCrossHairWidget_OnChangeWeaponCrossHair_Params params {};
		params.WeaponTypeTag = WeaponTypeTag;
		params.ItemUtilityTag = ItemUtilityTag;
		params.ItemSlotTypeTags = ItemSlotTypeTags;
		params.IsAttackEnable = IsAttackEnable;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.GameCrossHairWidget.OnChangeToRangeCrossHairAndPullAction
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 * Parameters:
	 * 		struct FGameplayTag                                WeaponTypeTag                                              (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FGameplayTag                                ItemUtilityTag                                             (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGameCrossHairWidget::OnChangeToRangeCrossHairAndPullAction(const struct FGameplayTag& WeaponTypeTag, const struct FGameplayTag& ItemUtilityTag)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GameCrossHairWidget.OnChangeToRangeCrossHairAndPullAction");
		
		UGameCrossHairWidget_OnChangeToRangeCrossHairAndPullAction_Params params {};
		params.WeaponTypeTag = WeaponTypeTag;
		params.ItemUtilityTag = ItemUtilityTag;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.GameCrossHairWidget.OnChangeCrossHairInfo
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 * Parameters:
	 * 		struct FGameplayTag                                WeaponTypeTag                                              (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              ChangeAngle                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               IsPinPoint                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              RotateTime                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGameCrossHairWidget::OnChangeCrossHairInfo(const struct FGameplayTag& WeaponTypeTag, float ChangeAngle, bool IsPinPoint, float RotateTime)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GameCrossHairWidget.OnChangeCrossHairInfo");
		
		UGameCrossHairWidget_OnChangeCrossHairInfo_Params params {};
		params.WeaponTypeTag = WeaponTypeTag;
		params.ChangeAngle = ChangeAngle;
		params.IsPinPoint = IsPinPoint;
		params.RotateTime = RotateTime;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.GameCrossHairWidget.OnActivateSpellCrossHair
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 * Parameters:
	 * 		bool                                               IsActivate                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGameCrossHairWidget::OnActivateSpellCrossHair(bool IsActivate)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GameCrossHairWidget.OnActivateSpellCrossHair");
		
		UGameCrossHairWidget_OnActivateSpellCrossHair_Params params {};
		params.IsActivate = IsActivate;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGameCrossHairWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGameCrossHairWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.GameCrossHairWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017CC340
	 * 		Name   -> Function DungeonCrawler.GameEmoteSelectGroupWidget.OnSelectedEmoteIndexChanged
	 * 		Flags  -> (Final, Native, Protected, BlueprintCallable)
	 */
	void UGameEmoteSelectGroupWidget::OnSelectedEmoteIndexChanged()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GameEmoteSelectGroupWidget.OnSelectedEmoteIndexChanged");
		
		UGameEmoteSelectGroupWidget_OnSelectedEmoteIndexChanged_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.GameEmoteSelectGroupWidget.OnEmoteSelectPopup
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 */
	void UGameEmoteSelectGroupWidget::OnEmoteSelectPopup()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GameEmoteSelectGroupWidget.OnEmoteSelectPopup");
		
		UGameEmoteSelectGroupWidget_OnEmoteSelectPopup_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.GameEmoteSelectGroupWidget.OnEmoteSelectClose
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 */
	void UGameEmoteSelectGroupWidget::OnEmoteSelectClose()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GameEmoteSelectGroupWidget.OnEmoteSelectClose");
		
		UGameEmoteSelectGroupWidget_OnEmoteSelectClose_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.GameEmoteSelectGroupWidget.OnCurrentEmoteSlotChanged
	 * 		Flags  -> (Event, Protected, HasOutParms, BlueprintEvent)
	 * Parameters:
	 * 		class FText                                        InName                                                     (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UGameEmoteSelectGroupWidget::OnCurrentEmoteSlotChanged(const class FText& InName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GameEmoteSelectGroupWidget.OnCurrentEmoteSlotChanged");
		
		UGameEmoteSelectGroupWidget_OnCurrentEmoteSlotChanged_Params params {};
		params.InName = InName;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGameEmoteSelectGroupWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGameEmoteSelectGroupWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.GameEmoteSelectGroupWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017CC860
	 * 		Name   -> Function DungeonCrawler.GameEmoteSlotWidget.SetEmoteData
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		class UDCEmoteDataAsset*                           InDesignDataEmote                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGameEmoteSlotWidget::SetEmoteData(class UDCEmoteDataAsset* InDesignDataEmote)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GameEmoteSlotWidget.SetEmoteData");
		
		UGameEmoteSlotWidget_SetEmoteData_Params params {};
		params.InDesignDataEmote = InDesignDataEmote;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017CC400
	 * 		Name   -> Function DungeonCrawler.GameEmoteSlotWidget.SelectionChange
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		bool                                               bIsSelected                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGameEmoteSlotWidget::SelectionChange(bool bIsSelected)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GameEmoteSlotWidget.SelectionChange");
		
		UGameEmoteSlotWidget_SelectionChange_Params params {};
		params.bIsSelected = bIsSelected;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017CC3E0
	 * 		Name   -> Function DungeonCrawler.GameEmoteSlotWidget.Reset
	 * 		Flags  -> (Final, Native, Public)
	 */
	void UGameEmoteSlotWidget::Reset()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GameEmoteSlotWidget.Reset");
		
		UGameEmoteSlotWidget_Reset_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.GameEmoteSlotWidget.OnSetEmoteArtData
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 * Parameters:
	 * 		class UArtDataEmote*                               InArtEmoteData                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGameEmoteSlotWidget::OnSetEmoteArtData(class UArtDataEmote* InArtEmoteData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GameEmoteSlotWidget.OnSetEmoteArtData");
		
		UGameEmoteSlotWidget_OnSetEmoteArtData_Params params {};
		params.InArtEmoteData = InArtEmoteData;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.GameEmoteSlotWidget.OnSelectionChanged
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 * Parameters:
	 * 		bool                                               bIsSelected                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGameEmoteSlotWidget::OnSelectionChanged(bool bIsSelected)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GameEmoteSlotWidget.OnSelectionChanged");
		
		UGameEmoteSlotWidget_OnSelectionChanged_Params params {};
		params.bIsSelected = bIsSelected;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.GameEmoteSlotWidget.OnReset
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 */
	void UGameEmoteSlotWidget::OnReset()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GameEmoteSlotWidget.OnReset");
		
		UGameEmoteSlotWidget_OnReset_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGameEmoteSlotWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGameEmoteSlotWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.GameEmoteSlotWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGameHeadupWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGameHeadupWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.GameHeadupWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGameHeadupAccountWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGameHeadupAccountWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.GameHeadupAccountWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017CCB60
	 * 		Name   -> Function DungeonCrawler.GameHeadupWidgetComponent.UnbindMsgAll
	 * 		Flags  -> (Native, Public)
	 * Parameters:
	 * 		class UObject*                                     InObject                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGameHeadupWidgetComponent::UnbindMsgAll(class UObject* InObject)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GameHeadupWidgetComponent.UnbindMsgAll");
		
		UGameHeadupWidgetComponent_UnbindMsgAll_Params params {};
		params.InObject = InObject;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017CCA90
	 * 		Name   -> Function DungeonCrawler.GameHeadupWidgetComponent.UnbindMsg
	 * 		Flags  -> (Native, Public)
	 * Parameters:
	 * 		class UScriptStruct*                               InMsgType                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UObject*                                     InObject                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGameHeadupWidgetComponent::UnbindMsg(class UScriptStruct* InMsgType, class UObject* InObject)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GameHeadupWidgetComponent.UnbindMsg");
		
		UGameHeadupWidgetComponent_UnbindMsg_Params params {};
		params.InMsgType = InMsgType;
		params.InObject = InObject;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017CCA60
	 * 		Name   -> Function DungeonCrawler.GameHeadupWidgetComponent.TerminateBase
	 * 		Flags  -> (Native, Public)
	 */
	void UGameHeadupWidgetComponent::TerminateBase()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GameHeadupWidgetComponent.TerminateBase");
		
		UGameHeadupWidgetComponent_TerminateBase_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D3C640
	 * 		Name   -> Function DungeonCrawler.GameHeadupWidgetComponent.BroadcastMsgBlueprint
	 * 		Flags  -> (Native, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		int32_t                                            InMsg                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGameHeadupWidgetComponent::BroadcastMsgBlueprint(int32_t InMsg)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GameHeadupWidgetComponent.BroadcastMsgBlueprint");
		
		UGameHeadupWidgetComponent_BroadcastMsgBlueprint_Params params {};
		params.InMsg = InMsg;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGameHeadupWidgetComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGameHeadupWidgetComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.GameHeadupWidgetComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGameHitDirectionManagerWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGameHitDirectionManagerWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.GameHitDirectionManagerWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017CC8F0
	 * 		Name   -> Function DungeonCrawler.GameHitDirectionWidget.SetHitDirection
	 * 		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FVector                                     Direction                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGameHitDirectionWidget::SetHitDirection(const struct FVector& Direction)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GameHitDirectionWidget.SetHitDirection");
		
		UGameHitDirectionWidget_SetHitDirection_Params params {};
		params.Direction = Direction;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.GameHitDirectionWidget.OnAnimation
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 */
	void UGameHitDirectionWidget::OnAnimation()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GameHitDirectionWidget.OnAnimation");
		
		UGameHitDirectionWidget_OnAnimation_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGameHitDirectionWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGameHitDirectionWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.GameHitDirectionWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.GameInteractionDescriptionWidget.OnInteractTargetData
	 * 		Flags  -> (Event, Protected, HasOutParms, BlueprintEvent)
	 * Parameters:
	 * 		struct FInteractTargetData                         NewValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		struct FInteractTargetData                         OldValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UGameInteractionDescriptionWidget::OnInteractTargetData(const struct FInteractTargetData& NewValue, const struct FInteractTargetData& OldValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GameInteractionDescriptionWidget.OnInteractTargetData");
		
		UGameInteractionDescriptionWidget_OnInteractTargetData_Params params {};
		params.NewValue = NewValue;
		params.OldValue = OldValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.GameInteractionDescriptionWidget.OnInteractableDataByStateMap
	 * 		Flags  -> (Event, Protected, HasOutParms, BlueprintEvent)
	 * Parameters:
	 * 		TMap<struct FGameplayTag, struct FInteractionData> NewValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		TMap<struct FGameplayTag, struct FInteractionData> OldValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UGameInteractionDescriptionWidget::OnInteractableDataByStateMap(TMap<struct FGameplayTag, struct FInteractionData> NewValue, TMap<struct FGameplayTag, struct FInteractionData> OldValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GameInteractionDescriptionWidget.OnInteractableDataByStateMap");
		
		UGameInteractionDescriptionWidget_OnInteractableDataByStateMap_Params params {};
		params.NewValue = NewValue;
		params.OldValue = OldValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.GameInteractionDescriptionWidget.OnInputType
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 * Parameters:
	 * 		ECommonInputType                                   NewValue                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		ECommonInputType                                   OldValue                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGameInteractionDescriptionWidget::OnInputType(ECommonInputType NewValue, ECommonInputType OldValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GameInteractionDescriptionWidget.OnInputType");
		
		UGameInteractionDescriptionWidget_OnInputType_Params params {};
		params.NewValue = NewValue;
		params.OldValue = OldValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGameInteractionDescriptionWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGameInteractionDescriptionWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.GameInteractionDescriptionWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.GameInteractionSkillCheckWidget.OnInteractSkillCheckStart
	 * 		Flags  -> (Event, Protected, HasOutParms, BlueprintEvent)
	 * Parameters:
	 * 		struct FSkillCheckData                             SkillCheckData                                             (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UGameInteractionSkillCheckWidget::OnInteractSkillCheckStart(const struct FSkillCheckData& SkillCheckData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GameInteractionSkillCheckWidget.OnInteractSkillCheckStart");
		
		UGameInteractionSkillCheckWidget_OnInteractSkillCheckStart_Params params {};
		params.SkillCheckData = SkillCheckData;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.GameInteractionSkillCheckWidget.OnInteractSkillCheckEnd
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 * Parameters:
	 * 		ESkillCheckResult                                  SkillCheckResult                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGameInteractionSkillCheckWidget::OnInteractSkillCheckEnd(ESkillCheckResult SkillCheckResult)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GameInteractionSkillCheckWidget.OnInteractSkillCheckEnd");
		
		UGameInteractionSkillCheckWidget_OnInteractSkillCheckEnd_Params params {};
		params.SkillCheckResult = SkillCheckResult;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGameInteractionSkillCheckWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGameInteractionSkillCheckWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.GameInteractionSkillCheckWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017CBFE0
	 * 		Name   -> Function DungeonCrawler.GameInventoryGroupWidget.OnPopItemSelectWidget
	 * 		Flags  -> (Final, Native, Protected, BlueprintCallable)
	 * Parameters:
	 * 		struct FItemData                                   ItemData                                                   (Parm, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      OldOwnerActor                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGameInventoryGroupWidget::OnPopItemSelectWidget(const struct FItemData& ItemData, class AActor* OldOwnerActor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GameInventoryGroupWidget.OnPopItemSelectWidget");
		
		UGameInventoryGroupWidget_OnPopItemSelectWidget_Params params {};
		params.ItemData = ItemData;
		params.OldOwnerActor = OldOwnerActor;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017CBC20
	 * 		Name   -> Function DungeonCrawler.GameInventoryGroupWidget.OnItemDropOne
	 * 		Flags  -> (Final, Native, Protected, BlueprintCallable)
	 * Parameters:
	 * 		struct FItemData                                   ItemData                                                   (Parm, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      OldOwnerActor                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGameInventoryGroupWidget::OnItemDropOne(const struct FItemData& ItemData, class AActor* OldOwnerActor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GameInventoryGroupWidget.OnItemDropOne");
		
		UGameInventoryGroupWidget_OnItemDropOne_Params params {};
		params.ItemData = ItemData;
		params.OldOwnerActor = OldOwnerActor;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017CB8E0
	 * 		Name   -> Function DungeonCrawler.GameInventoryGroupWidget.OnItemDrop
	 * 		Flags  -> (Final, Native, Protected, BlueprintCallable)
	 * Parameters:
	 * 		struct FItemData                                   ItemData                                                   (Parm, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      OldOwnerActor                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGameInventoryGroupWidget::OnItemDrop(const struct FItemData& ItemData, class AActor* OldOwnerActor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GameInventoryGroupWidget.OnItemDrop");
		
		UGameInventoryGroupWidget_OnItemDrop_Params params {};
		params.ItemData = ItemData;
		params.OldOwnerActor = OldOwnerActor;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGameInventoryGroupWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGameInventoryGroupWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.GameInventoryGroupWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGameItemWearingBarWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGameItemWearingBarWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.GameItemWearingBarWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017CC980
	 * 		Name   -> Function DungeonCrawler.GameMenuOptionComboBoxWidget.SetTitle
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		class FText                                        InText                                                     (Parm, NativeAccessSpecifierPublic)
	 */
	void UGameMenuOptionComboBoxWidget::SetTitle(const class FText& InText)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GameMenuOptionComboBoxWidget.SetTitle");
		
		UGameMenuOptionComboBoxWidget_SetTitle_Params params {};
		params.InText = InText;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017CC6B0
	 * 		Name   -> Function DungeonCrawler.GameMenuOptionComboBoxWidget.SetComboBoxList
	 * 		Flags  -> (Final, Native, Public, HasOutParms)
	 * Parameters:
	 * 		TArray<class FString>                              InComboBoxDataList                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UGameMenuOptionComboBoxWidget::SetComboBoxList(TArray<class FString> InComboBoxDataList)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GameMenuOptionComboBoxWidget.SetComboBoxList");
		
		UGameMenuOptionComboBoxWidget_SetComboBoxList_Params params {};
		params.InComboBoxDataList = InComboBoxDataList;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017CC620
	 * 		Name   -> Function DungeonCrawler.GameMenuOptionComboBoxWidget.SetComboBoxIndex
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		int32_t                                            InIndex                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGameMenuOptionComboBoxWidget::SetComboBoxIndex(int32_t InIndex)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GameMenuOptionComboBoxWidget.SetComboBoxIndex");
		
		UGameMenuOptionComboBoxWidget_SetComboBoxIndex_Params params {};
		params.InIndex = InIndex;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017CB660
	 * 		Name   -> Function DungeonCrawler.GameMenuOptionComboBoxWidget.GetSelectedComboBoxText
	 * 		Flags  -> (Final, Native, Public)
	 */
	class FString UGameMenuOptionComboBoxWidget::GetSelectedComboBoxText()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GameMenuOptionComboBoxWidget.GetSelectedComboBoxText");
		
		UGameMenuOptionComboBoxWidget_GetSelectedComboBoxText_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017CB630
	 * 		Name   -> Function DungeonCrawler.GameMenuOptionComboBoxWidget.GetSelectedComboBoxIndex
	 * 		Flags  -> (Final, Native, Public)
	 */
	int32_t UGameMenuOptionComboBoxWidget::GetSelectedComboBoxIndex()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GameMenuOptionComboBoxWidget.GetSelectedComboBoxIndex");
		
		UGameMenuOptionComboBoxWidget_GetSelectedComboBoxIndex_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017CB610
	 * 		Name   -> Function DungeonCrawler.GameMenuOptionComboBoxWidget.ClearComboBox
	 * 		Flags  -> (Final, Native, Public)
	 */
	void UGameMenuOptionComboBoxWidget::ClearComboBox()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GameMenuOptionComboBoxWidget.ClearComboBox");
		
		UGameMenuOptionComboBoxWidget_ClearComboBox_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017CB570
	 * 		Name   -> Function DungeonCrawler.GameMenuOptionComboBoxWidget.AddComboBox
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		class FString                                      InComboBoxData                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGameMenuOptionComboBoxWidget::AddComboBox(const class FString& InComboBoxData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GameMenuOptionComboBoxWidget.AddComboBox");
		
		UGameMenuOptionComboBoxWidget_AddComboBox_Params params {};
		params.InComboBoxData = InComboBoxData;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGameMenuOptionComboBoxWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGameMenuOptionComboBoxWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.GameMenuOptionComboBoxWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.GameMenuOptionPopupWidget.UpdateDetailText
	 * 		Flags  -> (Event, Public, HasOutParms, BlueprintEvent)
	 * Parameters:
	 * 		class FText                                        InDetailText                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UGameMenuOptionPopupWidget::UpdateDetailText(const class FText& InDetailText)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GameMenuOptionPopupWidget.UpdateDetailText");
		
		UGameMenuOptionPopupWidget_UpdateDetailText_Params params {};
		params.InDetailText = InDetailText;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.GameMenuOptionPopupWidget.UpdateButtonText
	 * 		Flags  -> (Event, Public, HasOutParms, BlueprintEvent)
	 * Parameters:
	 * 		class FText                                        InLeftText                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		class FText                                        InRightText                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UGameMenuOptionPopupWidget::UpdateButtonText(const class FText& InLeftText, const class FText& InRightText)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GameMenuOptionPopupWidget.UpdateButtonText");
		
		UGameMenuOptionPopupWidget_UpdateButtonText_Params params {};
		params.InLeftText = InLeftText;
		params.InRightText = InRightText;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017CC780
	 * 		Name   -> Function DungeonCrawler.GameMenuOptionPopupWidget.SetDetailText
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		class FText                                        InDetailText                                               (Parm, NativeAccessSpecifierPublic)
	 */
	void UGameMenuOptionPopupWidget::SetDetailText(const class FText& InDetailText)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GameMenuOptionPopupWidget.SetDetailText");
		
		UGameMenuOptionPopupWidget_SetDetailText_Params params {};
		params.InDetailText = InDetailText;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017CC490
	 * 		Name   -> Function DungeonCrawler.GameMenuOptionPopupWidget.SetButtonText
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		class FText                                        InLeftText                                                 (Parm, NativeAccessSpecifierPublic)
	 * 		class FText                                        InRightText                                                (Parm, NativeAccessSpecifierPublic)
	 */
	void UGameMenuOptionPopupWidget::SetButtonText(const class FText& InLeftText, const class FText& InRightText)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GameMenuOptionPopupWidget.SetButtonText");
		
		UGameMenuOptionPopupWidget_SetButtonText_Params params {};
		params.InLeftText = InLeftText;
		params.InRightText = InRightText;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017CB700
	 * 		Name   -> Function DungeonCrawler.GameMenuOptionPopupWidget.HandleRightButtonClicked
	 * 		Flags  -> (Final, Native, Protected)
	 */
	void UGameMenuOptionPopupWidget::HandleRightButtonClicked()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GameMenuOptionPopupWidget.HandleRightButtonClicked");
		
		UGameMenuOptionPopupWidget_HandleRightButtonClicked_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017CB6E0
	 * 		Name   -> Function DungeonCrawler.GameMenuOptionPopupWidget.HandleLeftButtonClicked
	 * 		Flags  -> (Final, Native, Protected)
	 */
	void UGameMenuOptionPopupWidget::HandleLeftButtonClicked()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GameMenuOptionPopupWidget.HandleLeftButtonClicked");
		
		UGameMenuOptionPopupWidget_HandleLeftButtonClicked_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGameMenuOptionPopupWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGameMenuOptionPopupWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.GameMenuOptionPopupWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.GameMenuOptionsAudioWidget.UpdateWindowFocusChanged
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 * Parameters:
	 * 		bool                                               IsFocus                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               IsBackgroundOption                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              TotalVolume                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGameMenuOptionsAudioWidget::UpdateWindowFocusChanged(bool IsFocus, bool IsBackgroundOption, float TotalVolume)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GameMenuOptionsAudioWidget.UpdateWindowFocusChanged");
		
		UGameMenuOptionsAudioWidget_UpdateWindowFocusChanged_Params params {};
		params.IsFocus = IsFocus;
		params.IsBackgroundOption = IsBackgroundOption;
		params.TotalVolume = TotalVolume;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017CC360
	 * 		Name   -> Function DungeonCrawler.GameMenuOptionsAudioWidget.OnTotalVolumeValueChanged
	 * 		Flags  -> (Final, Native, Private)
	 * Parameters:
	 * 		float                                              NewValue                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGameMenuOptionsAudioWidget::OnTotalVolumeValueChanged(float NewValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GameMenuOptionsAudioWidget.OnTotalVolumeValueChanged");
		
		UGameMenuOptionsAudioWidget_OnTotalVolumeValueChanged_Params params {};
		params.NewValue = NewValue;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017CC320
	 * 		Name   -> Function DungeonCrawler.GameMenuOptionsAudioWidget.OnResetButtionClicked
	 * 		Flags  -> (Final, Native, Protected, BlueprintCallable)
	 */
	void UGameMenuOptionsAudioWidget::OnResetButtionClicked()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GameMenuOptionsAudioWidget.OnResetButtionClicked");
		
		UGameMenuOptionsAudioWidget_OnResetButtionClicked_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017CBF60
	 * 		Name   -> Function DungeonCrawler.GameMenuOptionsAudioWidget.OnMusicVolumeValueChanged
	 * 		Flags  -> (Final, Native, Private)
	 * Parameters:
	 * 		float                                              NewValue                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGameMenuOptionsAudioWidget::OnMusicVolumeValueChanged(float NewValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GameMenuOptionsAudioWidget.OnMusicVolumeValueChanged");
		
		UGameMenuOptionsAudioWidget_OnMusicVolumeValueChanged_Params params {};
		params.NewValue = NewValue;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.GameMenuOptionsAudioWidget.OnGameUserSettingAudios
	 * 		Flags  -> (Event, Protected, HasOutParms, BlueprintEvent)
	 * Parameters:
	 * 		struct FGameUserSettingAudios                      NewValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 * 		struct FGameUserSettingAudios                      OldValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UGameMenuOptionsAudioWidget::OnGameUserSettingAudios(const struct FGameUserSettingAudios& NewValue, const struct FGameUserSettingAudios& OldValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GameMenuOptionsAudioWidget.OnGameUserSettingAudios");
		
		UGameMenuOptionsAudioWidget_OnGameUserSettingAudios_Params params {};
		params.NewValue = NewValue;
		params.OldValue = OldValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017CB860
	 * 		Name   -> Function DungeonCrawler.GameMenuOptionsAudioWidget.OnEffectVolumeValueChanged
	 * 		Flags  -> (Final, Native, Private)
	 * Parameters:
	 * 		float                                              NewValue                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGameMenuOptionsAudioWidget::OnEffectVolumeValueChanged(float NewValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GameMenuOptionsAudioWidget.OnEffectVolumeValueChanged");
		
		UGameMenuOptionsAudioWidget_OnEffectVolumeValueChanged_Params params {};
		params.NewValue = NewValue;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017CB7D0
	 * 		Name   -> Function DungeonCrawler.GameMenuOptionsAudioWidget.OnBackgroundMusicChanged
	 * 		Flags  -> (Final, Native, Private)
	 * Parameters:
	 * 		bool                                               IsToggle                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGameMenuOptionsAudioWidget::OnBackgroundMusicChanged(bool IsToggle)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GameMenuOptionsAudioWidget.OnBackgroundMusicChanged");
		
		UGameMenuOptionsAudioWidget_OnBackgroundMusicChanged_Params params {};
		params.IsToggle = IsToggle;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017CB7B0
	 * 		Name   -> Function DungeonCrawler.GameMenuOptionsAudioWidget.OnApplyButtonClicked
	 * 		Flags  -> (Final, Native, Protected, BlueprintCallable)
	 */
	void UGameMenuOptionsAudioWidget::OnApplyButtonClicked()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GameMenuOptionsAudioWidget.OnApplyButtonClicked");
		
		UGameMenuOptionsAudioWidget_OnApplyButtonClicked_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017CB720
	 * 		Name   -> Function DungeonCrawler.GameMenuOptionsAudioWidget.OnAppActivateStateChanged
	 * 		Flags  -> (Final, Native, Private)
	 * Parameters:
	 * 		bool                                               IsAppActivateChange                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGameMenuOptionsAudioWidget::OnAppActivateStateChanged(bool IsAppActivateChange)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GameMenuOptionsAudioWidget.OnAppActivateStateChanged");
		
		UGameMenuOptionsAudioWidget_OnAppActivateStateChanged_Params params {};
		params.IsAppActivateChange = IsAppActivateChange;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGameMenuOptionsAudioWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGameMenuOptionsAudioWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.GameMenuOptionsAudioWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017D1770
	 * 		Name   -> Function DungeonCrawler.GameMenuOptionsControlsWidget.OnStreamingModeClicked
	 * 		Flags  -> (Final, Native, Private)
	 * Parameters:
	 * 		bool                                               IsClick                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGameMenuOptionsControlsWidget::OnStreamingModeClicked(bool IsClick)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GameMenuOptionsControlsWidget.OnStreamingModeClicked");
		
		UGameMenuOptionsControlsWidget_OnStreamingModeClicked_Params params {};
		params.IsClick = IsClick;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017D16D0
	 * 		Name   -> Function DungeonCrawler.GameMenuOptionsControlsWidget.OnResetButtonClicked
	 * 		Flags  -> (Final, Native, Private)
	 */
	void UGameMenuOptionsControlsWidget::OnResetButtonClicked()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GameMenuOptionsControlsWidget.OnResetButtonClicked");
		
		UGameMenuOptionsControlsWidget_OnResetButtonClicked_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017D1610
	 * 		Name   -> Function DungeonCrawler.GameMenuOptionsControlsWidget.OnMouseSensitivitySliderValueChenged
	 * 		Flags  -> (Final, Native, Private)
	 * Parameters:
	 * 		float                                              InValue                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGameMenuOptionsControlsWidget::OnMouseSensitivitySliderValueChenged(float InValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GameMenuOptionsControlsWidget.OnMouseSensitivitySliderValueChenged");
		
		UGameMenuOptionsControlsWidget_OnMouseSensitivitySliderValueChenged_Params params {};
		params.InValue = InValue;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017D1590
	 * 		Name   -> Function DungeonCrawler.GameMenuOptionsControlsWidget.OnKoreanButtonClicked
	 * 		Flags  -> (Final, Native, Private)
	 */
	void UGameMenuOptionsControlsWidget::OnKoreanButtonClicked()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GameMenuOptionsControlsWidget.OnKoreanButtonClicked");
		
		UGameMenuOptionsControlsWidget_OnKoreanButtonClicked_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017D1500
	 * 		Name   -> Function DungeonCrawler.GameMenuOptionsControlsWidget.OnInvertMouseVerticalAxisClicked
	 * 		Flags  -> (Final, Native, Private)
	 * Parameters:
	 * 		bool                                               IsClick                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGameMenuOptionsControlsWidget::OnInvertMouseVerticalAxisClicked(bool IsClick)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GameMenuOptionsControlsWidget.OnInvertMouseVerticalAxisClicked");
		
		UGameMenuOptionsControlsWidget_OnInvertMouseVerticalAxisClicked_Params params {};
		params.IsClick = IsClick;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017D1470
	 * 		Name   -> Function DungeonCrawler.GameMenuOptionsControlsWidget.OnInvertMouseHorizontalAxisClicked
	 * 		Flags  -> (Final, Native, Private)
	 * Parameters:
	 * 		bool                                               IsClick                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGameMenuOptionsControlsWidget::OnInvertMouseHorizontalAxisClicked(bool IsClick)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GameMenuOptionsControlsWidget.OnInvertMouseHorizontalAxisClicked");
		
		UGameMenuOptionsControlsWidget_OnInvertMouseHorizontalAxisClicked_Params params {};
		params.IsClick = IsClick;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017D1330
	 * 		Name   -> Function DungeonCrawler.GameMenuOptionsControlsWidget.OnIgnoreInvitationClicked
	 * 		Flags  -> (Final, Native, Private)
	 * Parameters:
	 * 		bool                                               IsClick                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGameMenuOptionsControlsWidget::OnIgnoreInvitationClicked(bool IsClick)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GameMenuOptionsControlsWidget.OnIgnoreInvitationClicked");
		
		UGameMenuOptionsControlsWidget_OnIgnoreInvitationClicked_Params params {};
		params.IsClick = IsClick;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.GameMenuOptionsControlsWidget.OnGameUserSettingControls
	 * 		Flags  -> (Event, Protected, HasOutParms, BlueprintEvent)
	 * Parameters:
	 * 		struct FGameUserSettingControls                    NewValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		struct FGameUserSettingControls                    OldValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UGameMenuOptionsControlsWidget::OnGameUserSettingControls(const struct FGameUserSettingControls& NewValue, const struct FGameUserSettingControls& OldValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GameMenuOptionsControlsWidget.OnGameUserSettingControls");
		
		UGameMenuOptionsControlsWidget_OnGameUserSettingControls_Params params {};
		params.NewValue = NewValue;
		params.OldValue = OldValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017D1240
	 * 		Name   -> Function DungeonCrawler.GameMenuOptionsControlsWidget.OnEnglishButtonClicked
	 * 		Flags  -> (Final, Native, Private)
	 */
	void UGameMenuOptionsControlsWidget::OnEnglishButtonClicked()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GameMenuOptionsControlsWidget.OnEnglishButtonClicked");
		
		UGameMenuOptionsControlsWidget_OnEnglishButtonClicked_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017D1040
	 * 		Name   -> Function DungeonCrawler.GameMenuOptionsControlsWidget.OnApplyButtonClicked
	 * 		Flags  -> (Final, Native, Private)
	 */
	void UGameMenuOptionsControlsWidget::OnApplyButtonClicked()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GameMenuOptionsControlsWidget.OnApplyButtonClicked");
		
		UGameMenuOptionsControlsWidget_OnApplyButtonClicked_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGameMenuOptionsControlsWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGameMenuOptionsControlsWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.GameMenuOptionsControlsWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGameMenuOptionsInputBindPopupWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGameMenuOptionsInputBindPopupWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.GameMenuOptionsInputBindPopupWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGameMenuOptionInputBindSlotItemData.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGameMenuOptionInputBindSlotItemData::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.GameMenuOptionInputBindSlotItemData");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017D1750
	 * 		Name   -> Function DungeonCrawler.GameMenuOptionsInputBindSlotWidget.OnSecondaryKeyBindButtonClicked
	 * 		Flags  -> (Final, Native, Protected)
	 */
	void UGameMenuOptionsInputBindSlotWidget::OnSecondaryKeyBindButtonClicked()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GameMenuOptionsInputBindSlotWidget.OnSecondaryKeyBindButtonClicked");
		
		UGameMenuOptionsInputBindSlotWidget_OnSecondaryKeyBindButtonClicked_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017D16B0
	 * 		Name   -> Function DungeonCrawler.GameMenuOptionsInputBindSlotWidget.OnPrimaryKeyBindButtonClicked
	 * 		Flags  -> (Final, Native, Protected)
	 */
	void UGameMenuOptionsInputBindSlotWidget::OnPrimaryKeyBindButtonClicked()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GameMenuOptionsInputBindSlotWidget.OnPrimaryKeyBindButtonClicked");
		
		UGameMenuOptionsInputBindSlotWidget_OnPrimaryKeyBindButtonClicked_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017D1170
	 * 		Name   -> Function DungeonCrawler.GameMenuOptionsInputBindSlotWidget.OnClearButtonClicked
	 * 		Flags  -> (Final, Native, Protected)
	 */
	void UGameMenuOptionsInputBindSlotWidget::OnClearButtonClicked()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GameMenuOptionsInputBindSlotWidget.OnClearButtonClicked");
		
		UGameMenuOptionsInputBindSlotWidget_OnClearButtonClicked_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017D0F30
	 * 		Name   -> Function DungeonCrawler.GameMenuOptionsInputBindSlotWidget.HandleSecondaryKeyPressed
	 * 		Flags  -> (Final, Native, Protected)
	 * Parameters:
	 * 		struct FKey                                        InKey                                                      (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGameMenuOptionsInputBindSlotWidget::HandleSecondaryKeyPressed(const struct FKey& InKey)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GameMenuOptionsInputBindSlotWidget.HandleSecondaryKeyPressed");
		
		UGameMenuOptionsInputBindSlotWidget_HandleSecondaryKeyPressed_Params params {};
		params.InKey = InKey;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017D0E40
	 * 		Name   -> Function DungeonCrawler.GameMenuOptionsInputBindSlotWidget.HandlePrimaryKeyPressed
	 * 		Flags  -> (Final, Native, Protected)
	 * Parameters:
	 * 		struct FKey                                        InKey                                                      (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGameMenuOptionsInputBindSlotWidget::HandlePrimaryKeyPressed(const struct FKey& InKey)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GameMenuOptionsInputBindSlotWidget.HandlePrimaryKeyPressed");
		
		UGameMenuOptionsInputBindSlotWidget_HandlePrimaryKeyPressed_Params params {};
		params.InKey = InKey;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017D0AD0
	 * 		Name   -> Function DungeonCrawler.GameMenuOptionsInputBindSlotWidget.ChangeBinding
	 * 		Flags  -> (Final, Native, Protected)
	 * Parameters:
	 * 		int32_t                                            InKeyBindSlot                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FKey                                        InKey                                                      (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGameMenuOptionsInputBindSlotWidget::ChangeBinding(int32_t InKeyBindSlot, const struct FKey& InKey)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GameMenuOptionsInputBindSlotWidget.ChangeBinding");
		
		UGameMenuOptionsInputBindSlotWidget_ChangeBinding_Params params {};
		params.InKeyBindSlot = InKeyBindSlot;
		params.InKey = InKey;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGameMenuOptionsInputBindSlotWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGameMenuOptionsInputBindSlotWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.GameMenuOptionsInputBindSlotWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGameMenuOptionInputSlotItemData.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGameMenuOptionInputSlotItemData::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.GameMenuOptionInputSlotItemData");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGameMenuOptionsInputSlotWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGameMenuOptionsInputSlotWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.GameMenuOptionsInputSlotWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017D1930
	 * 		Name   -> Function DungeonCrawler.GameMenuOptionsInputWidget.RefreshWidget
	 * 		Flags  -> (Final, Native, Private)
	 */
	void UGameMenuOptionsInputWidget::RefreshWidget()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GameMenuOptionsInputWidget.RefreshWidget");
		
		UGameMenuOptionsInputWidget_RefreshWidget_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017D16F0
	 * 		Name   -> Function DungeonCrawler.GameMenuOptionsInputWidget.OnResetButtonClicked
	 * 		Flags  -> (Final, Native, Private)
	 */
	void UGameMenuOptionsInputWidget::OnResetButtonClicked()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GameMenuOptionsInputWidget.OnResetButtonClicked");
		
		UGameMenuOptionsInputWidget_OnResetButtonClicked_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017D13C0
	 * 		Name   -> Function DungeonCrawler.GameMenuOptionsInputWidget.OnInputBindPendingChange
	 * 		Flags  -> (Final, Native, Private)
	 */
	void UGameMenuOptionsInputWidget::OnInputBindPendingChange()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GameMenuOptionsInputWidget.OnInputBindPendingChange");
		
		UGameMenuOptionsInputWidget_OnInputBindPendingChange_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017D1060
	 * 		Name   -> Function DungeonCrawler.GameMenuOptionsInputWidget.OnApplyButtonClicked
	 * 		Flags  -> (Final, Native, Private)
	 */
	void UGameMenuOptionsInputWidget::OnApplyButtonClicked()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GameMenuOptionsInputWidget.OnApplyButtonClicked");
		
		UGameMenuOptionsInputWidget_OnApplyButtonClicked_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGameMenuOptionsInputWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGameMenuOptionsInputWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.GameMenuOptionsInputWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.GameMenuOptionSliderWidget.UpdateSliderValue
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		float                                              NewValue                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGameMenuOptionSliderWidget::UpdateSliderValue(float NewValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GameMenuOptionSliderWidget.UpdateSliderValue");
		
		UGameMenuOptionSliderWidget_UpdateSliderValue_Params params {};
		params.NewValue = NewValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.GameMenuOptionSliderWidget.UpdateSliderMinMaxValue
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 */
	void UGameMenuOptionSliderWidget::UpdateSliderMinMaxValue()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GameMenuOptionSliderWidget.UpdateSliderMinMaxValue");
		
		UGameMenuOptionSliderWidget_UpdateSliderMinMaxValue_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017D1DE0
	 * 		Name   -> Function DungeonCrawler.GameMenuOptionSliderWidget.SetTitle
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		class FText                                        InText                                                     (Parm, NativeAccessSpecifierPublic)
	 */
	void UGameMenuOptionSliderWidget::SetTitle(const class FText& InText)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GameMenuOptionSliderWidget.SetTitle");
		
		UGameMenuOptionSliderWidget_SetTitle_Params params {};
		params.InText = InText;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017D1CC0
	 * 		Name   -> Function DungeonCrawler.GameMenuOptionSliderWidget.SetSliderMinMaxValue
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		float                                              InMinValue                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              InMaxValue                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              InStepSize                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGameMenuOptionSliderWidget::SetSliderMinMaxValue(float InMinValue, float InMaxValue, float InStepSize)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GameMenuOptionSliderWidget.SetSliderMinMaxValue");
		
		UGameMenuOptionSliderWidget_SetSliderMinMaxValue_Params params {};
		params.InMinValue = InMinValue;
		params.InMaxValue = InMaxValue;
		params.InStepSize = InStepSize;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017D1BB0
	 * 		Name   -> Function DungeonCrawler.GameMenuOptionSliderWidget.SetOptionValue
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		float                                              InValue                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGameMenuOptionSliderWidget::SetOptionValue(float InValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GameMenuOptionSliderWidget.SetOptionValue");
		
		UGameMenuOptionSliderWidget_SetOptionValue_Params params {};
		params.InValue = InValue;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017D0DB0
	 * 		Name   -> Function DungeonCrawler.GameMenuOptionSliderWidget.GetOptionValuePercent
	 * 		Flags  -> (Final, Native, Public)
	 */
	float UGameMenuOptionSliderWidget::GetOptionValuePercent()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GameMenuOptionSliderWidget.GetOptionValuePercent");
		
		UGameMenuOptionSliderWidget_GetOptionValuePercent_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017D0D80
	 * 		Name   -> Function DungeonCrawler.GameMenuOptionSliderWidget.GetOptionValue
	 * 		Flags  -> (Final, Native, Public)
	 */
	float UGameMenuOptionSliderWidget::GetOptionValue()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GameMenuOptionSliderWidget.GetOptionValue");
		
		UGameMenuOptionSliderWidget_GetOptionValue_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.GameMenuOptionSliderWidget.GetCurrentOptionValueByPercent
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 */
	void UGameMenuOptionSliderWidget::GetCurrentOptionValueByPercent()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GameMenuOptionSliderWidget.GetCurrentOptionValueByPercent");
		
		UGameMenuOptionSliderWidget_GetCurrentOptionValueByPercent_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.GameMenuOptionSliderWidget.GetCurrentOptionValue
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 */
	void UGameMenuOptionSliderWidget::GetCurrentOptionValue()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GameMenuOptionSliderWidget.GetCurrentOptionValue");
		
		UGameMenuOptionSliderWidget_GetCurrentOptionValue_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017D0C10
	 * 		Name   -> Function DungeonCrawler.GameMenuOptionSliderWidget.ExtractOnlyNumberics
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class FString                                      Message                                                    (ConstParm, Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               IsInteger                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class FString UGameMenuOptionSliderWidget::STATIC_ExtractOnlyNumberics(const class FString& Message, bool IsInteger)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GameMenuOptionSliderWidget.ExtractOnlyNumberics");
		
		UGameMenuOptionSliderWidget_ExtractOnlyNumberics_Params params {};
		params.Message = Message;
		params.IsInteger = IsInteger;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGameMenuOptionSliderWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGameMenuOptionSliderWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.GameMenuOptionSliderWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017D1EC0
	 * 		Name   -> Function DungeonCrawler.GameMenuOptionsVideosSlotWidget.SetTitle
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		class FText                                        InTitle                                                    (Parm, NativeAccessSpecifierPublic)
	 */
	void UGameMenuOptionsVideosSlotWidget::SetTitle(const class FText& InTitle)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GameMenuOptionsVideosSlotWidget.SetTitle");
		
		UGameMenuOptionsVideosSlotWidget_SetTitle_Params params {};
		params.InTitle = InTitle;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017D1C30
	 * 		Name   -> Function DungeonCrawler.GameMenuOptionsVideosSlotWidget.SetQualityLevel
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		int32_t                                            InQualityLevel                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGameMenuOptionsVideosSlotWidget::SetQualityLevel(int32_t InQualityLevel)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GameMenuOptionsVideosSlotWidget.SetQualityLevel");
		
		UGameMenuOptionsVideosSlotWidget_SetQualityLevel_Params params {};
		params.InQualityLevel = InQualityLevel;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.GameMenuOptionsVideosSlotWidget.OnQualityLevel
	 * 		Flags  -> (Event, Protected, HasOutParms, BlueprintEvent)
	 * Parameters:
	 * 		int32_t                                            NewValue                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            OldValue                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGameMenuOptionsVideosSlotWidget::OnQualityLevel(int32_t NewValue, int32_t OldValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GameMenuOptionsVideosSlotWidget.OnQualityLevel");
		
		UGameMenuOptionsVideosSlotWidget_OnQualityLevel_Params params {};
		params.NewValue = NewValue;
		params.OldValue = OldValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017D15F0
	 * 		Name   -> Function DungeonCrawler.GameMenuOptionsVideosSlotWidget.OnMediumButtonClicked
	 * 		Flags  -> (Final, Native, Protected, BlueprintCallable)
	 */
	void UGameMenuOptionsVideosSlotWidget::OnMediumButtonClicked()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GameMenuOptionsVideosSlotWidget.OnMediumButtonClicked");
		
		UGameMenuOptionsVideosSlotWidget_OnMediumButtonClicked_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017D15D0
	 * 		Name   -> Function DungeonCrawler.GameMenuOptionsVideosSlotWidget.OnLowButtonClicked
	 * 		Flags  -> (Final, Native, Protected, BlueprintCallable)
	 */
	void UGameMenuOptionsVideosSlotWidget::OnLowButtonClicked()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GameMenuOptionsVideosSlotWidget.OnLowButtonClicked");
		
		UGameMenuOptionsVideosSlotWidget_OnLowButtonClicked_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017D1310
	 * 		Name   -> Function DungeonCrawler.GameMenuOptionsVideosSlotWidget.OnHighButtonClicked
	 * 		Flags  -> (Final, Native, Protected, BlueprintCallable)
	 */
	void UGameMenuOptionsVideosSlotWidget::OnHighButtonClicked()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GameMenuOptionsVideosSlotWidget.OnHighButtonClicked");
		
		UGameMenuOptionsVideosSlotWidget_OnHighButtonClicked_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017D1260
	 * 		Name   -> Function DungeonCrawler.GameMenuOptionsVideosSlotWidget.OnEpicButtonClicked
	 * 		Flags  -> (Final, Native, Protected, BlueprintCallable)
	 */
	void UGameMenuOptionsVideosSlotWidget::OnEpicButtonClicked()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GameMenuOptionsVideosSlotWidget.OnEpicButtonClicked");
		
		UGameMenuOptionsVideosSlotWidget_OnEpicButtonClicked_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017D0DE0
	 * 		Name   -> Function DungeonCrawler.GameMenuOptionsVideosSlotWidget.GetQualityLevel
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	int32_t UGameMenuOptionsVideosSlotWidget::GetQualityLevel()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GameMenuOptionsVideosSlotWidget.GetQualityLevel");
		
		UGameMenuOptionsVideosSlotWidget_GetQualityLevel_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGameMenuOptionsVideosSlotWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGameMenuOptionsVideosSlotWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.GameMenuOptionsVideosSlotWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017D20C0
	 * 		Name   -> Function DungeonCrawler.GameMenuOptionsVideoWidget.UpdateGammaValue
	 * 		Flags  -> (Final, Native, Protected, BlueprintCallable)
	 * Parameters:
	 * 		float                                              NewValue                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGameMenuOptionsVideoWidget::UpdateGammaValue(float NewValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GameMenuOptionsVideoWidget.UpdateGammaValue");
		
		UGameMenuOptionsVideoWidget_UpdateGammaValue_Params params {};
		params.NewValue = NewValue;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017D2030
	 * 		Name   -> Function DungeonCrawler.GameMenuOptionsVideoWidget.UpdateDisplayModeOption
	 * 		Flags  -> (Final, Native, Protected, BlueprintCallable)
	 * Parameters:
	 * 		int32_t                                            InUpdateIndex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGameMenuOptionsVideoWidget::UpdateDisplayModeOption(int32_t InUpdateIndex)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GameMenuOptionsVideoWidget.UpdateDisplayModeOption");
		
		UGameMenuOptionsVideoWidget_UpdateDisplayModeOption_Params params {};
		params.InUpdateIndex = InUpdateIndex;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017D1950
	 * 		Name   -> Function DungeonCrawler.GameMenuOptionsVideoWidget.RevertDisplayModeOption
	 * 		Flags  -> (Final, Native, Protected)
	 * Parameters:
	 * 		int32_t                                            InDisplayIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            InResolutionindex                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGameMenuOptionsVideoWidget::RevertDisplayModeOption(int32_t InDisplayIndex, int32_t InResolutionindex)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GameMenuOptionsVideoWidget.RevertDisplayModeOption");
		
		UGameMenuOptionsVideoWidget_RevertDisplayModeOption_Params params {};
		params.InDisplayIndex = InDisplayIndex;
		params.InResolutionindex = InResolutionindex;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017D1730
	 * 		Name   -> Function DungeonCrawler.GameMenuOptionsVideoWidget.OnRevertDisplayOption
	 * 		Flags  -> (Final, Native, Protected, BlueprintCallable)
	 */
	void UGameMenuOptionsVideoWidget::OnRevertDisplayOption()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GameMenuOptionsVideoWidget.OnRevertDisplayOption");
		
		UGameMenuOptionsVideoWidget_OnRevertDisplayOption_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017D1710
	 * 		Name   -> Function DungeonCrawler.GameMenuOptionsVideoWidget.OnResetButtonClicked
	 * 		Flags  -> (Final, Native, Protected, BlueprintCallable)
	 */
	void UGameMenuOptionsVideoWidget::OnResetButtonClicked()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GameMenuOptionsVideoWidget.OnResetButtonClicked");
		
		UGameMenuOptionsVideoWidget_OnResetButtonClicked_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.GameMenuOptionsVideoWidget.OnDisplayOptionChangePopup
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 */
	void UGameMenuOptionsVideoWidget::OnDisplayOptionChangePopup()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GameMenuOptionsVideoWidget.OnDisplayOptionChangePopup");
		
		UGameMenuOptionsVideoWidget_OnDisplayOptionChangePopup_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017D10A0
	 * 		Name   -> Function DungeonCrawler.GameMenuOptionsVideoWidget.OnApplyDisplayOption
	 * 		Flags  -> (Final, Native, Protected, BlueprintCallable)
	 */
	void UGameMenuOptionsVideoWidget::OnApplyDisplayOption()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GameMenuOptionsVideoWidget.OnApplyDisplayOption");
		
		UGameMenuOptionsVideoWidget_OnApplyDisplayOption_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017D1080
	 * 		Name   -> Function DungeonCrawler.GameMenuOptionsVideoWidget.OnApplyButtonClicked
	 * 		Flags  -> (Final, Native, Protected, BlueprintCallable)
	 */
	void UGameMenuOptionsVideoWidget::OnApplyButtonClicked()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GameMenuOptionsVideoWidget.OnApplyButtonClicked");
		
		UGameMenuOptionsVideoWidget_OnApplyButtonClicked_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGameMenuOptionsVideoWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGameMenuOptionsVideoWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.GameMenuOptionsVideoWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.GameMenuOptionsWidget.OnWidgetToggleNotify
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 * Parameters:
	 * 		ESlateVisibility                                   Invisibility                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGameMenuOptionsWidget::OnWidgetToggleNotify(ESlateVisibility Invisibility)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GameMenuOptionsWidget.OnWidgetToggleNotify");
		
		UGameMenuOptionsWidget_OnWidgetToggleNotify_Params params {};
		params.Invisibility = Invisibility;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017D18A0
	 * 		Name   -> Function DungeonCrawler.GameMenuOptionsWidget.OnVideoButtonChecked
	 * 		Flags  -> (Final, Native, Private)
	 * Parameters:
	 * 		bool                                               bIsChecked                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGameMenuOptionsWidget::OnVideoButtonChecked(bool bIsChecked)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GameMenuOptionsWidget.OnVideoButtonChecked");
		
		UGameMenuOptionsWidget_OnVideoButtonChecked_Params params {};
		params.bIsChecked = bIsChecked;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017D1820
	 * 		Name   -> Function DungeonCrawler.GameMenuOptionsWidget.OnToggled
	 * 		Flags  -> (Final, Native, Private)
	 * Parameters:
	 * 		ESlateVisibility                                   Invisibility                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGameMenuOptionsWidget::OnToggled(ESlateVisibility Invisibility)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GameMenuOptionsWidget.OnToggled");
		
		UGameMenuOptionsWidget_OnToggled_Params params {};
		params.Invisibility = Invisibility;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017D13E0
	 * 		Name   -> Function DungeonCrawler.GameMenuOptionsWidget.OnInputButtonChecked
	 * 		Flags  -> (Final, Native, Private)
	 * Parameters:
	 * 		bool                                               bIsChecked                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGameMenuOptionsWidget::OnInputButtonChecked(bool bIsChecked)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GameMenuOptionsWidget.OnInputButtonChecked");
		
		UGameMenuOptionsWidget_OnInputButtonChecked_Params params {};
		params.bIsChecked = bIsChecked;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017D1280
	 * 		Name   -> Function DungeonCrawler.GameMenuOptionsWidget.OnGameplayButtonChecked
	 * 		Flags  -> (Final, Native, Private)
	 * Parameters:
	 * 		bool                                               bIsChecked                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGameMenuOptionsWidget::OnGameplayButtonChecked(bool bIsChecked)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GameMenuOptionsWidget.OnGameplayButtonChecked");
		
		UGameMenuOptionsWidget_OnGameplayButtonChecked_Params params {};
		params.bIsChecked = bIsChecked;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017D11B0
	 * 		Name   -> Function DungeonCrawler.GameMenuOptionsWidget.OnControlsButtonChecked
	 * 		Flags  -> (Final, Native, Private)
	 * Parameters:
	 * 		bool                                               bIsChecked                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGameMenuOptionsWidget::OnControlsButtonChecked(bool bIsChecked)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GameMenuOptionsWidget.OnControlsButtonChecked");
		
		UGameMenuOptionsWidget_OnControlsButtonChecked_Params params {};
		params.bIsChecked = bIsChecked;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017D10C0
	 * 		Name   -> Function DungeonCrawler.GameMenuOptionsWidget.OnAudioButtonChecked
	 * 		Flags  -> (Final, Native, Private)
	 * Parameters:
	 * 		bool                                               bIsChecked                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGameMenuOptionsWidget::OnAudioButtonChecked(bool bIsChecked)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GameMenuOptionsWidget.OnAudioButtonChecked");
		
		UGameMenuOptionsWidget_OnAudioButtonChecked_Params params {};
		params.bIsChecked = bIsChecked;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGameMenuOptionsWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGameMenuOptionsWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.GameMenuOptionsWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.GameMenuOptionToggleSwitchWidget.UpdateButtonText
	 * 		Flags  -> (Event, Protected, HasOutParms, BlueprintEvent)
	 * Parameters:
	 * 		class FText                                        LeftText                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		class FText                                        RightText                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UGameMenuOptionToggleSwitchWidget::UpdateButtonText(const class FText& LeftText, const class FText& RightText)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GameMenuOptionToggleSwitchWidget.UpdateButtonText");
		
		UGameMenuOptionToggleSwitchWidget_UpdateButtonText_Params params {};
		params.LeftText = LeftText;
		params.RightText = RightText;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017D1FA0
	 * 		Name   -> Function DungeonCrawler.GameMenuOptionToggleSwitchWidget.SetToggleSwitch
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               InSwitch                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGameMenuOptionToggleSwitchWidget::SetToggleSwitch(bool InSwitch)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GameMenuOptionToggleSwitchWidget.SetToggleSwitch");
		
		UGameMenuOptionToggleSwitchWidget_SetToggleSwitch_Params params {};
		params.InSwitch = InSwitch;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017D1DE0
	 * 		Name   -> Function DungeonCrawler.GameMenuOptionToggleSwitchWidget.SetTitle
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		class FText                                        InTitle                                                    (Parm, NativeAccessSpecifierPublic)
	 */
	void UGameMenuOptionToggleSwitchWidget::SetTitle(const class FText& InTitle)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GameMenuOptionToggleSwitchWidget.SetTitle");
		
		UGameMenuOptionToggleSwitchWidget_SetTitle_Params params {};
		params.InTitle = InTitle;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017D1A20
	 * 		Name   -> Function DungeonCrawler.GameMenuOptionToggleSwitchWidget.SetButtonText
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		class FText                                        LeftText                                                   (Parm, NativeAccessSpecifierPublic)
	 * 		class FText                                        RightText                                                  (Parm, NativeAccessSpecifierPublic)
	 */
	void UGameMenuOptionToggleSwitchWidget::SetButtonText(const class FText& LeftText, const class FText& RightText)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GameMenuOptionToggleSwitchWidget.SetButtonText");
		
		UGameMenuOptionToggleSwitchWidget_SetButtonText_Params params {};
		params.LeftText = LeftText;
		params.RightText = RightText;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017D1800
	 * 		Name   -> Function DungeonCrawler.GameMenuOptionToggleSwitchWidget.OnToggleSwitchClicked
	 * 		Flags  -> (Final, Native, Protected, BlueprintCallable)
	 */
	void UGameMenuOptionToggleSwitchWidget::OnToggleSwitchClicked()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GameMenuOptionToggleSwitchWidget.OnToggleSwitchClicked");
		
		UGameMenuOptionToggleSwitchWidget_OnToggleSwitchClicked_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.GameMenuOptionToggleSwitchWidget.OnToggleSwitch
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 * Parameters:
	 * 		bool                                               InSwitch                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGameMenuOptionToggleSwitchWidget::OnToggleSwitch(bool InSwitch)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GameMenuOptionToggleSwitchWidget.OnToggleSwitch");
		
		UGameMenuOptionToggleSwitchWidget_OnToggleSwitch_Params params {};
		params.InSwitch = InSwitch;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017D1020
	 * 		Name   -> Function DungeonCrawler.GameMenuOptionToggleSwitchWidget.OffToggleSwitchClicked
	 * 		Flags  -> (Final, Native, Protected, BlueprintCallable)
	 */
	void UGameMenuOptionToggleSwitchWidget::OffToggleSwitchClicked()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GameMenuOptionToggleSwitchWidget.OffToggleSwitchClicked");
		
		UGameMenuOptionToggleSwitchWidget_OffToggleSwitchClicked_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017D0E10
	 * 		Name   -> Function DungeonCrawler.GameMenuOptionToggleSwitchWidget.GetToggleSwitch
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	bool UGameMenuOptionToggleSwitchWidget::GetToggleSwitch()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GameMenuOptionToggleSwitchWidget.GetToggleSwitch");
		
		UGameMenuOptionToggleSwitchWidget_GetToggleSwitch_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGameMenuOptionToggleSwitchWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGameMenuOptionToggleSwitchWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.GameMenuOptionToggleSwitchWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017D1690
	 * 		Name   -> Function DungeonCrawler.GameMenuWidget.OnOptionsButtonClicked
	 * 		Flags  -> (Final, Native, Private)
	 */
	void UGameMenuWidget::OnOptionsButtonClicked()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GameMenuWidget.OnOptionsButtonClicked");
		
		UGameMenuWidget_OnOptionsButtonClicked_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.GameMenuWidget.OnMenuPop
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 */
	void UGameMenuWidget::OnMenuPop()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GameMenuWidget.OnMenuPop");
		
		UGameMenuWidget_OnMenuPop_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017D15B0
	 * 		Name   -> Function DungeonCrawler.GameMenuWidget.OnLobbyButtonClicked
	 * 		Flags  -> (Final, Native, Private)
	 */
	void UGameMenuWidget::OnLobbyButtonClicked()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GameMenuWidget.OnLobbyButtonClicked");
		
		UGameMenuWidget_OnLobbyButtonClicked_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0172EF60
	 * 		Name   -> Function DungeonCrawler.GameMenuWidget.OnExitButtonClicked
	 * 		Flags  -> (Final, Native, Private)
	 */
	void UGameMenuWidget::OnExitButtonClicked()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GameMenuWidget.OnExitButtonClicked");
		
		UGameMenuWidget_OnExitButtonClicked_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.GameMenuWidget.OnDisplayOptionApplyPopup
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 */
	void UGameMenuWidget::OnDisplayOptionApplyPopup()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GameMenuWidget.OnDisplayOptionApplyPopup");
		
		UGameMenuWidget_OnDisplayOptionApplyPopup_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017D1190
	 * 		Name   -> Function DungeonCrawler.GameMenuWidget.OnContinueButtonClicked
	 * 		Flags  -> (Final, Native, Private)
	 */
	void UGameMenuWidget::OnContinueButtonClicked()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GameMenuWidget.OnContinueButtonClicked");
		
		UGameMenuWidget_OnContinueButtonClicked_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017D1150
	 * 		Name   -> Function DungeonCrawler.GameMenuWidget.OnCharacterSelectClicked
	 * 		Flags  -> (Final, Native, Private)
	 */
	void UGameMenuWidget::OnCharacterSelectClicked()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GameMenuWidget.OnCharacterSelectClicked");
		
		UGameMenuWidget_OnCharacterSelectClicked_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGameMenuWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGameMenuWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.GameMenuWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.GameMiniMapWidget.OnMiniMapName
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 * Parameters:
	 * 		class FString                                      NewMiniMapName                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FString                                      OldMiniMapName                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGameMiniMapWidget::OnMiniMapName(const class FString& NewMiniMapName, const class FString& OldMiniMapName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GameMiniMapWidget.OnMiniMapName");
		
		UGameMiniMapWidget_OnMiniMapName_Params params {};
		params.NewMiniMapName = NewMiniMapName;
		params.OldMiniMapName = OldMiniMapName;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.GameMiniMapWidget.OnMiniMapDeathSwarmData
	 * 		Flags  -> (Event, Protected, HasOutParms, BlueprintEvent)
	 * Parameters:
	 * 		struct FMiniMapDeathSwarmData                      NewValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 * 		struct FMiniMapDeathSwarmData                      OldValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UGameMiniMapWidget::OnMiniMapDeathSwarmData(const struct FMiniMapDeathSwarmData& NewValue, const struct FMiniMapDeathSwarmData& OldValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GameMiniMapWidget.OnMiniMapDeathSwarmData");
		
		UGameMiniMapWidget_OnMiniMapDeathSwarmData_Params params {};
		params.NewValue = NewValue;
		params.OldValue = OldValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGameMiniMapWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGameMiniMapWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.GameMiniMapWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGamePartyManagePartyMemberWidgetData.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGamePartyManagePartyMemberWidgetData::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.GamePartyManagePartyMemberWidgetData");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.GamePartyManagePartyMemberWidget.OnAccountDataReplication
	 * 		Flags  -> (Event, Protected, HasOutParms, BlueprintEvent)
	 * Parameters:
	 * 		struct FAccountDataReplication                     NewValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		struct FAccountDataReplication                     OldValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UGamePartyManagePartyMemberWidget::OnAccountDataReplication(const struct FAccountDataReplication& NewValue, const struct FAccountDataReplication& OldValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GamePartyManagePartyMemberWidget.OnAccountDataReplication");
		
		UGamePartyManagePartyMemberWidget_OnAccountDataReplication_Params params {};
		params.NewValue = NewValue;
		params.OldValue = OldValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGamePartyManagePartyMemberWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGamePartyManagePartyMemberWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.GamePartyManagePartyMemberWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGamePartyManagePartyWidgetData.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGamePartyManagePartyWidgetData::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.GamePartyManagePartyWidgetData");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017D7620
	 * 		Name   -> Function DungeonCrawler.GamePartyManagePartyWidget.PartyJoin
	 * 		Flags  -> (Final, Native, Private)
	 */
	void UGamePartyManagePartyWidget::PartyJoin()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GamePartyManagePartyWidget.PartyJoin");
		
		UGamePartyManagePartyWidget_PartyJoin_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.GamePartyManagePartyWidget.OnPartyData
	 * 		Flags  -> (Event, Protected, HasOutParms, BlueprintEvent)
	 * Parameters:
	 * 		struct FPartyData                                  NewValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		struct FPartyData                                  OldValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UGamePartyManagePartyWidget::OnPartyData(const struct FPartyData& NewValue, const struct FPartyData& OldValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GamePartyManagePartyWidget.OnPartyData");
		
		UGamePartyManagePartyWidget_OnPartyData_Params params {};
		params.NewValue = NewValue;
		params.OldValue = OldValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGamePartyManagePartyWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGamePartyManagePartyWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.GamePartyManagePartyWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGamePartyManageWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGamePartyManageWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.GamePartyManageWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGamePartyMemberWidgetData.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGamePartyMemberWidgetData::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.GamePartyMemberWidgetData");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGamePartyMemberWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGamePartyMemberWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.GamePartyMemberWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017D7490
	 * 		Name   -> Function DungeonCrawler.GamePartyWidget.OnPartyData
	 * 		Flags  -> (Native, Event, Protected, HasOutParms, BlueprintEvent)
	 * Parameters:
	 * 		struct FPartyData                                  NewValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		struct FPartyData                                  OldValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UGamePartyWidget::OnPartyData(const struct FPartyData& NewValue, const struct FPartyData& OldValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GamePartyWidget.OnPartyData");
		
		UGamePartyWidget_OnPartyData_Params params {};
		params.NewValue = NewValue;
		params.OldValue = OldValue;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017D71D0
	 * 		Name   -> Function DungeonCrawler.GamePartyWidget.OnAccountDataReplication
	 * 		Flags  -> (Native, Event, Protected, HasOutParms, BlueprintEvent)
	 * Parameters:
	 * 		struct FAccountDataReplication                     NewValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		struct FAccountDataReplication                     OldValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UGamePartyWidget::OnAccountDataReplication(const struct FAccountDataReplication& NewValue, const struct FAccountDataReplication& OldValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GamePartyWidget.OnAccountDataReplication");
		
		UGamePartyWidget_OnAccountDataReplication_Params params {};
		params.NewValue = NewValue;
		params.OldValue = OldValue;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGamePartyWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGamePartyWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.GamePartyWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.GamePlayerCharacterWidget.OnCurrentActiveSlot
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 * Parameters:
	 * 		class UEquipmentSlotWidget*                        CurrentActiveWidget                                        (ConstParm, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGamePlayerCharacterWidget::OnCurrentActiveSlot(class UEquipmentSlotWidget* CurrentActiveWidget)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GamePlayerCharacterWidget.OnCurrentActiveSlot");
		
		UGamePlayerCharacterWidget_OnCurrentActiveSlot_Params params {};
		params.CurrentActiveWidget = CurrentActiveWidget;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGamePlayerCharacterWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGamePlayerCharacterWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.GamePlayerCharacterWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGameplayAbilityRelationshipData.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGameplayAbilityRelationshipData::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.GameplayAbilityRelationshipData");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGameplayTagMessageRelationshipData.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGameplayTagMessageRelationshipData::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.GameplayTagMessageRelationshipData");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UCannotMoveGameplayTagData.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UCannotMoveGameplayTagData::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.CannotMoveGameplayTagData");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGameplayCueRelationshipData.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGameplayCueRelationshipData::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.GameplayCueRelationshipData");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGameplayTagSoundConditionData.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGameplayTagSoundConditionData::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.GameplayTagSoundConditionData");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGameProgressBarWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGameProgressBarWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.GameProgressBarWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017D7B60
	 * 		Name   -> Function DungeonCrawler.GameSkillSlotWidget.UpdateSkillSlotCooldownData
	 * 		Flags  -> (Final, Native, Private)
	 * Parameters:
	 * 		int32_t                                            Index                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FGameplayTag                                SkillTag                                                   (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              MaxDuration                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              RemainDuration                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGameSkillSlotWidget::UpdateSkillSlotCooldownData(int32_t Index, const struct FGameplayTag& SkillTag, float MaxDuration, float RemainDuration)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GameSkillSlotWidget.UpdateSkillSlotCooldownData");
		
		UGameSkillSlotWidget_UpdateSkillSlotCooldownData_Params params {};
		params.Index = Index;
		params.SkillTag = SkillTag;
		params.MaxDuration = MaxDuration;
		params.RemainDuration = RemainDuration;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017D7A70
	 * 		Name   -> Function DungeonCrawler.GameSkillSlotWidget.UpdateSkillDescData
	 * 		Flags  -> (Final, Native, Private, HasOutParms)
	 * Parameters:
	 * 		int32_t                                            Index                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FSkillData                                  NewSkillData                                               (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UGameSkillSlotWidget::UpdateSkillDescData(int32_t Index, struct FSkillData* NewSkillData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GameSkillSlotWidget.UpdateSkillDescData");
		
		UGameSkillSlotWidget_UpdateSkillDescData_Params params {};
		params.Index = Index;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (NewSkillData != nullptr)
			*NewSkillData = params.NewSkillData;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017D7980
	 * 		Name   -> Function DungeonCrawler.GameSkillSlotWidget.UpdateSkillData
	 * 		Flags  -> (Final, Native, Private, HasOutParms)
	 * Parameters:
	 * 		int32_t                                            Index                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FSkillData                                  NewSkillData                                               (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UGameSkillSlotWidget::UpdateSkillData(int32_t Index, struct FSkillData* NewSkillData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GameSkillSlotWidget.UpdateSkillData");
		
		UGameSkillSlotWidget_UpdateSkillData_Params params {};
		params.Index = Index;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (NewSkillData != nullptr)
			*NewSkillData = params.NewSkillData;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017D7900
	 * 		Name   -> Function DungeonCrawler.GameSkillSlotWidget.UpdateSkillCooldownDuration
	 * 		Flags  -> (Final, Native, Protected, BlueprintCallable)
	 * Parameters:
	 * 		float                                              DeltaTime                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGameSkillSlotWidget::UpdateSkillCooldownDuration(float DeltaTime)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GameSkillSlotWidget.UpdateSkillCooldownDuration");
		
		UGameSkillSlotWidget_UpdateSkillCooldownDuration_Params params {};
		params.DeltaTime = DeltaTime;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017D7810
	 * 		Name   -> Function DungeonCrawler.GameSkillSlotWidget.UpdateSkillArtData
	 * 		Flags  -> (Final, Native, Private, HasOutParms)
	 * Parameters:
	 * 		int32_t                                            Index                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FSkillData                                  NewSkillData                                               (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UGameSkillSlotWidget::UpdateSkillArtData(int32_t Index, struct FSkillData* NewSkillData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GameSkillSlotWidget.UpdateSkillArtData");
		
		UGameSkillSlotWidget_UpdateSkillArtData_Params params {};
		params.Index = Index;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (NewSkillData != nullptr)
			*NewSkillData = params.NewSkillData;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.GameSkillSlotWidget.OnUpdateSkillSlotVisible
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 * Parameters:
	 * 		int32_t                                            SlotIndex                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               IsVisibility                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGameSkillSlotWidget::OnUpdateSkillSlotVisible(int32_t SlotIndex, bool IsVisibility)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GameSkillSlotWidget.OnUpdateSkillSlotVisible");
		
		UGameSkillSlotWidget_OnUpdateSkillSlotVisible_Params params {};
		params.SlotIndex = SlotIndex;
		params.IsVisibility = IsVisibility;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.GameSkillSlotWidget.OnUpdateSkillSlot
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 * Parameters:
	 * 		int32_t                                            Index                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FGameplayTag                                SkillTag                                                   (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Duration                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGameSkillSlotWidget::OnUpdateSkillSlot(int32_t Index, const struct FGameplayTag& SkillTag, float Duration)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GameSkillSlotWidget.OnUpdateSkillSlot");
		
		UGameSkillSlotWidget_OnUpdateSkillSlot_Params params {};
		params.Index = Index;
		params.SkillTag = SkillTag;
		params.Duration = Duration;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.GameSkillSlotWidget.OnUpdateSkillDesc
	 * 		Flags  -> (Event, Protected, HasOutParms, BlueprintEvent)
	 * Parameters:
	 * 		int32_t                                            Index                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FText                                        SkillName                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		class FText                                        SkillDesc                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UGameSkillSlotWidget::OnUpdateSkillDesc(int32_t Index, const class FText& SkillName, const class FText& SkillDesc)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GameSkillSlotWidget.OnUpdateSkillDesc");
		
		UGameSkillSlotWidget_OnUpdateSkillDesc_Params params {};
		params.Index = Index;
		params.SkillName = SkillName;
		params.SkillDesc = SkillDesc;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.GameSkillSlotWidget.OnUpdateSkillData
	 * 		Flags  -> (Event, Protected, HasOutParms, BlueprintEvent)
	 * Parameters:
	 * 		int32_t                                            Index                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FSkillData                                  InSkillData                                                (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 * 		struct FDesignDataSkill                            InDesignDataSkill                                          (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UGameSkillSlotWidget::OnUpdateSkillData(int32_t Index, const struct FSkillData& InSkillData, const struct FDesignDataSkill& InDesignDataSkill)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GameSkillSlotWidget.OnUpdateSkillData");
		
		UGameSkillSlotWidget_OnUpdateSkillData_Params params {};
		params.Index = Index;
		params.InSkillData = InSkillData;
		params.InDesignDataSkill = InDesignDataSkill;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.GameSkillSlotWidget.OnUpdateSkillArtData
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 * Parameters:
	 * 		int32_t                                            Index                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UArtDataSkill*                               SkillArtData                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGameSkillSlotWidget::OnUpdateSkillArtData(int32_t Index, class UArtDataSkill* SkillArtData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GameSkillSlotWidget.OnUpdateSkillArtData");
		
		UGameSkillSlotWidget_OnUpdateSkillArtData_Params params {};
		params.Index = Index;
		params.SkillArtData = SkillArtData;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.GameSkillSlotWidget.OnSkillFailedSystemMessage
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 */
	void UGameSkillSlotWidget::OnSkillFailedSystemMessage()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GameSkillSlotWidget.OnSkillFailedSystemMessage");
		
		UGameSkillSlotWidget_OnSkillFailedSystemMessage_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.GameSkillSlotWidget.OnSkillCooldownEnd
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 * Parameters:
	 * 		int32_t                                            SlotIndex                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGameSkillSlotWidget::OnSkillCooldownEnd(int32_t SlotIndex)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GameSkillSlotWidget.OnSkillCooldownEnd");
		
		UGameSkillSlotWidget_OnSkillCooldownEnd_Params params {};
		params.SlotIndex = SlotIndex;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.GameSkillSlotWidget.OnResetSkillDesc
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 * Parameters:
	 * 		int32_t                                            Index                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGameSkillSlotWidget::OnResetSkillDesc(int32_t Index)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GameSkillSlotWidget.OnResetSkillDesc");
		
		UGameSkillSlotWidget_OnResetSkillDesc_Params params {};
		params.Index = Index;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.GameSkillSlotWidget.OnResetSkillCooldownUI
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 */
	void UGameSkillSlotWidget::OnResetSkillCooldownUI()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GameSkillSlotWidget.OnResetSkillCooldownUI");
		
		UGameSkillSlotWidget_OnResetSkillCooldownUI_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017D7400
	 * 		Name   -> Function DungeonCrawler.GameSkillSlotWidget.OnLinkedPawnDestroyed
	 * 		Flags  -> (Final, Native, Private)
	 * Parameters:
	 * 		class AActor*                                      InActor                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGameSkillSlotWidget::OnLinkedPawnDestroyed(class AActor* InActor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GameSkillSlotWidget.OnLinkedPawnDestroyed");
		
		UGameSkillSlotWidget_OnLinkedPawnDestroyed_Params params {};
		params.InActor = InActor;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017D7130
	 * 		Name   -> Function DungeonCrawler.GameSkillSlotWidget.GetSkillSlotCooldownPercent
	 * 		Flags  -> (Final, Native, Protected, BlueprintCallable)
	 * Parameters:
	 * 		int32_t                                            Index                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	float UGameSkillSlotWidget::GetSkillSlotCooldownPercent(int32_t Index)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GameSkillSlotWidget.GetSkillSlotCooldownPercent");
		
		UGameSkillSlotWidget_GetSkillSlotCooldownPercent_Params params {};
		params.Index = Index;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017D7090
	 * 		Name   -> Function DungeonCrawler.GameSkillSlotWidget.GetSkillSlotCooldownDuration
	 * 		Flags  -> (Final, Native, Protected, BlueprintCallable)
	 * Parameters:
	 * 		int32_t                                            Index                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	float UGameSkillSlotWidget::GetSkillSlotCooldownDuration(int32_t Index)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GameSkillSlotWidget.GetSkillSlotCooldownDuration");
		
		UGameSkillSlotWidget_GetSkillSlotCooldownDuration_Params params {};
		params.Index = Index;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017D7000
	 * 		Name   -> Function DungeonCrawler.GameSkillSlotWidget.CheckSkillCooldownComplete
	 * 		Flags  -> (Final, Native, Private)
	 * Parameters:
	 * 		int32_t                                            Index                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGameSkillSlotWidget::CheckSkillCooldownComplete(int32_t Index)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GameSkillSlotWidget.CheckSkillCooldownComplete");
		
		UGameSkillSlotWidget_CheckSkillCooldownComplete_Params params {};
		params.Index = Index;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGameSkillSlotWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGameSkillSlotWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.GameSkillSlotWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.GameSpellCastingBarWidget.OnSpellChannelingStart
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 */
	void UGameSpellCastingBarWidget::OnSpellChannelingStart()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GameSpellCastingBarWidget.OnSpellChannelingStart");
		
		UGameSpellCastingBarWidget_OnSpellChannelingStart_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.GameSpellCastingBarWidget.OnSpellChannelingEnd
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 */
	void UGameSpellCastingBarWidget::OnSpellChannelingEnd()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GameSpellCastingBarWidget.OnSpellChannelingEnd");
		
		UGameSpellCastingBarWidget_OnSpellChannelingEnd_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.GameSpellCastingBarWidget.OnSpellCastSucceed
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 */
	void UGameSpellCastingBarWidget::OnSpellCastSucceed()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GameSpellCastingBarWidget.OnSpellCastSucceed");
		
		UGameSpellCastingBarWidget_OnSpellCastSucceed_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.GameSpellCastingBarWidget.OnSpellCastStart
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 */
	void UGameSpellCastingBarWidget::OnSpellCastStart()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GameSpellCastingBarWidget.OnSpellCastStart");
		
		UGameSpellCastingBarWidget_OnSpellCastStart_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.GameSpellCastingBarWidget.OnSpellCastEnd
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 */
	void UGameSpellCastingBarWidget::OnSpellCastEnd()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GameSpellCastingBarWidget.OnSpellCastEnd");
		
		UGameSpellCastingBarWidget_OnSpellCastEnd_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGameSpellCastingBarWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGameSpellCastingBarWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.GameSpellCastingBarWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017D7640
	 * 		Name   -> Function DungeonCrawler.GameSpellCurrentSlotWidget.SetSpellData
	 * 		Flags  -> (Final, Native, Public, HasOutParms)
	 * Parameters:
	 * 		struct FSpellData                                  InSpellData                                                (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 * 		struct FDesignDataSpell                            InDesignDataSpell                                          (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UGameSpellCurrentSlotWidget::SetSpellData(const struct FSpellData& InSpellData, const struct FDesignDataSpell& InDesignDataSpell)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GameSpellCurrentSlotWidget.SetSpellData");
		
		UGameSpellCurrentSlotWidget_SetSpellData_Params params {};
		params.InSpellData = InSpellData;
		params.InDesignDataSpell = InDesignDataSpell;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.GameSpellCurrentSlotWidget.OnSpellDataChanged
	 * 		Flags  -> (Event, Protected, HasOutParms, BlueprintEvent)
	 * Parameters:
	 * 		struct FSpellData                                  InSpellData                                                (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 * 		struct FDesignDataSpell                            InDesignDataSpell                                          (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UGameSpellCurrentSlotWidget::OnSpellDataChanged(const struct FSpellData& InSpellData, const struct FDesignDataSpell& InDesignDataSpell)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GameSpellCurrentSlotWidget.OnSpellDataChanged");
		
		UGameSpellCurrentSlotWidget_OnSpellDataChanged_Params params {};
		params.InSpellData = InSpellData;
		params.InDesignDataSpell = InDesignDataSpell;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.GameSpellCurrentSlotWidget.OnSetSpellArtData
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 * Parameters:
	 * 		class UArtDataSpell*                               InArtSpellData                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGameSpellCurrentSlotWidget::OnSetSpellArtData(class UArtDataSpell* InArtSpellData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GameSpellCurrentSlotWidget.OnSetSpellArtData");
		
		UGameSpellCurrentSlotWidget_OnSetSpellArtData_Params params {};
		params.InArtSpellData = InArtSpellData;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGameSpellCurrentSlotWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGameSpellCurrentSlotWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.GameSpellCurrentSlotWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.GameSpellSelectGroupWidget.OnSpellSelectPopup
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 */
	void UGameSpellSelectGroupWidget::OnSpellSelectPopup()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GameSpellSelectGroupWidget.OnSpellSelectPopup");
		
		UGameSpellSelectGroupWidget_OnSpellSelectPopup_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.GameSpellSelectGroupWidget.OnSpellSelectClose
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 */
	void UGameSpellSelectGroupWidget::OnSpellSelectClose()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GameSpellSelectGroupWidget.OnSpellSelectClose");
		
		UGameSpellSelectGroupWidget_OnSpellSelectClose_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017DE730
	 * 		Name   -> Function DungeonCrawler.GameSpellSelectGroupWidget.OnSelectedSpellIndexChanged
	 * 		Flags  -> (Final, Native, Protected, BlueprintCallable)
	 */
	void UGameSpellSelectGroupWidget::OnSelectedSpellIndexChanged()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GameSpellSelectGroupWidget.OnSelectedSpellIndexChanged");
		
		UGameSpellSelectGroupWidget_OnSelectedSpellIndexChanged_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.GameSpellSelectGroupWidget.OnCurrentSpellSlotChanged
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 * Parameters:
	 * 		class UGameSpellSlotWidget*                        InSelectedSlot                                             (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGameSpellSelectGroupWidget::OnCurrentSpellSlotChanged(class UGameSpellSlotWidget* InSelectedSlot)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GameSpellSelectGroupWidget.OnCurrentSpellSlotChanged");
		
		UGameSpellSelectGroupWidget_OnCurrentSpellSlotChanged_Params params {};
		params.InSelectedSlot = InSelectedSlot;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGameSpellSelectGroupWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGameSpellSelectGroupWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.GameSpellSelectGroupWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017DEB00
	 * 		Name   -> Function DungeonCrawler.GameSpellSlotWidget.SelectionChange
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		bool                                               bIsSelected                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGameSpellSlotWidget::SelectionChange(bool bIsSelected)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GameSpellSlotWidget.SelectionChange");
		
		UGameSpellSlotWidget_SelectionChange_Params params {};
		params.bIsSelected = bIsSelected;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.GameSpellSlotWidget.OnSelectionChanged
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 * Parameters:
	 * 		bool                                               bIsSelected                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGameSpellSlotWidget::OnSelectionChanged(bool bIsSelected)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GameSpellSlotWidget.OnSelectionChanged");
		
		UGameSpellSlotWidget_OnSelectionChanged_Params params {};
		params.bIsSelected = bIsSelected;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGameSpellSlotWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGameSpellSlotWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.GameSpellSlotWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01822950
	 * 		Name   -> Function DungeonCrawler.TimerWidgetBase.StartTimer
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		float                                              InEndServerWorldTime                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UTimerWidgetBase::StartTimer(float InEndServerWorldTime)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.TimerWidgetBase.StartTimer");
		
		UTimerWidgetBase_StartTimer_Params params {};
		params.InEndServerWorldTime = InEndServerWorldTime;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.TimerWidgetBase.OnProgress
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 * Parameters:
	 * 		float                                              NewValue                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              OldValue                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UTimerWidgetBase::OnProgress(float NewValue, float OldValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.TimerWidgetBase.OnProgress");
		
		UTimerWidgetBase_OnProgress_Params params {};
		params.NewValue = NewValue;
		params.OldValue = OldValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.TimerWidgetBase.OnLeftSecond
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 * Parameters:
	 * 		int32_t                                            NewValue                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            OldValue                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UTimerWidgetBase::OnLeftSecond(int32_t NewValue, int32_t OldValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.TimerWidgetBase.OnLeftSecond");
		
		UTimerWidgetBase_OnLeftSecond_Params params {};
		params.NewValue = NewValue;
		params.OldValue = OldValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.TimerWidgetBase.OnLeftMinute
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 * Parameters:
	 * 		int32_t                                            NewValue                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            OldValue                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UTimerWidgetBase::OnLeftMinute(int32_t NewValue, int32_t OldValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.TimerWidgetBase.OnLeftMinute");
		
		UTimerWidgetBase_OnLeftMinute_Params params {};
		params.NewValue = NewValue;
		params.OldValue = OldValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.TimerWidgetBase.OnLeftHour
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 * Parameters:
	 * 		int32_t                                            NewValue                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            OldValue                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UTimerWidgetBase::OnLeftHour(int32_t NewValue, int32_t OldValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.TimerWidgetBase.OnLeftHour");
		
		UTimerWidgetBase_OnLeftHour_Params params {};
		params.NewValue = NewValue;
		params.OldValue = OldValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x018226A0
	 * 		Name   -> Function DungeonCrawler.TimerWidgetBase.OnFMsgAccountLinkAccountDataReplicationNotifyBlueprint
	 * 		Flags  -> (Native, Event, Protected, HasOutParms, BlueprintEvent)
	 * Parameters:
	 * 		struct FMsgAccountLinkAccountDataReplicationNotify InMsg                                                      (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	void UTimerWidgetBase::OnFMsgAccountLinkAccountDataReplicationNotifyBlueprint(const struct FMsgAccountLinkAccountDataReplicationNotify& InMsg)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.TimerWidgetBase.OnFMsgAccountLinkAccountDataReplicationNotifyBlueprint");
		
		UTimerWidgetBase_OnFMsgAccountLinkAccountDataReplicationNotifyBlueprint_Params params {};
		params.InMsg = InMsg;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UTimerWidgetBase.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UTimerWidgetBase::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.TimerWidgetBase");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.GameTavernStartTimerWidget.OnPlayerLimit
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 * Parameters:
	 * 		int32_t                                            NewValue                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            OldValue                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGameTavernStartTimerWidget::OnPlayerLimit(int32_t NewValue, int32_t OldValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GameTavernStartTimerWidget.OnPlayerLimit");
		
		UGameTavernStartTimerWidget_OnPlayerLimit_Params params {};
		params.NewValue = NewValue;
		params.OldValue = OldValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.GameTavernStartTimerWidget.OnPlayerCount
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 * Parameters:
	 * 		int32_t                                            NewValue                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            OldValue                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGameTavernStartTimerWidget::OnPlayerCount(int32_t NewValue, int32_t OldValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GameTavernStartTimerWidget.OnPlayerCount");
		
		UGameTavernStartTimerWidget_OnPlayerCount_Params params {};
		params.NewValue = NewValue;
		params.OldValue = OldValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGameTavernStartTimerWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGameTavernStartTimerWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.GameTavernStartTimerWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01764730
	 * 		Name   -> Function DungeonCrawler.GameTestComponent.UnbindMsgAll
	 * 		Flags  -> (Native, Public)
	 * Parameters:
	 * 		class UObject*                                     InObject                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGameTestComponent::UnbindMsgAll(class UObject* InObject)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GameTestComponent.UnbindMsgAll");
		
		UGameTestComponent_UnbindMsgAll_Params params {};
		params.InObject = InObject;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01764280
	 * 		Name   -> Function DungeonCrawler.GameTestComponent.UnbindMsg
	 * 		Flags  -> (Native, Public)
	 * Parameters:
	 * 		class UScriptStruct*                               InMsgType                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UObject*                                     InObject                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGameTestComponent::UnbindMsg(class UScriptStruct* InMsgType, class UObject* InObject)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GameTestComponent.UnbindMsg");
		
		UGameTestComponent_UnbindMsg_Params params {};
		params.InMsgType = InMsgType;
		params.InObject = InObject;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01763EB0
	 * 		Name   -> Function DungeonCrawler.GameTestComponent.TerminateBase
	 * 		Flags  -> (Native, Public)
	 */
	void UGameTestComponent::TerminateBase()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GameTestComponent.TerminateBase");
		
		UGameTestComponent_TerminateBase_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017DDA10
	 * 		Name   -> Function DungeonCrawler.GameTestComponent.MsgGameTestChangePlayerCharacterClassResponse
	 * 		Flags  -> (Final, Net, NetReliable, Native, Event, Private, NetClient)
	 * Parameters:
	 * 		struct FDungeonCrawler_FMsgGameTestChangePlayerCharacterClassResponse InMsg                                                      (ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UGameTestComponent::MsgGameTestChangePlayerCharacterClassResponse(const struct FDungeonCrawler_FMsgGameTestChangePlayerCharacterClassResponse& InMsg)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GameTestComponent.MsgGameTestChangePlayerCharacterClassResponse");
		
		UGameTestComponent_MsgGameTestChangePlayerCharacterClassResponse_Params params {};
		params.InMsg = InMsg;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017DD920
	 * 		Name   -> Function DungeonCrawler.GameTestComponent.MsgGameTestChangePlayerCharacterClassRequest
	 * 		Flags  -> (Final, Net, NetReliable, Native, Event, Private, NetServer)
	 * Parameters:
	 * 		struct FDungeonCrawler_FMsgGameTestChangePlayerCharacterClassRequest InMsg                                                      (ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UGameTestComponent::MsgGameTestChangePlayerCharacterClassRequest(const struct FDungeonCrawler_FMsgGameTestChangePlayerCharacterClassRequest& InMsg)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GameTestComponent.MsgGameTestChangePlayerCharacterClassRequest");
		
		UGameTestComponent_MsgGameTestChangePlayerCharacterClassRequest_Params params {};
		params.InMsg = InMsg;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017DD440
	 * 		Name   -> Function DungeonCrawler.GameTestComponent.ClientMsgClassSpellSlotMoveResponse
	 * 		Flags  -> (Final, Net, NetReliable, Native, Event, Private, NetClient)
	 * Parameters:
	 * 		struct FDungeonCrawler_FClientMsgClassSpellSlotMoveResponse InMsg                                                      (ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UGameTestComponent::ClientMsgClassSpellSlotMoveResponse(const struct FDungeonCrawler_FClientMsgClassSpellSlotMoveResponse& InMsg)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GameTestComponent.ClientMsgClassSpellSlotMoveResponse");
		
		UGameTestComponent_ClientMsgClassSpellSlotMoveResponse_Params params {};
		params.InMsg = InMsg;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017DD340
	 * 		Name   -> Function DungeonCrawler.GameTestComponent.ClientMsgClassSpellSlotMoveRequest
	 * 		Flags  -> (Final, Net, NetReliable, Native, Event, Private, NetServer)
	 * Parameters:
	 * 		struct FDungeonCrawler_FClientMsgClassSpellSlotMoveRequest InMsg                                                      (ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UGameTestComponent::ClientMsgClassSpellSlotMoveRequest(const struct FDungeonCrawler_FClientMsgClassSpellSlotMoveRequest& InMsg)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GameTestComponent.ClientMsgClassSpellSlotMoveRequest");
		
		UGameTestComponent_ClientMsgClassSpellSlotMoveRequest_Params params {};
		params.InMsg = InMsg;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017DD210
	 * 		Name   -> Function DungeonCrawler.GameTestComponent.ClientMsgClassSpellSequenceChangeResponse
	 * 		Flags  -> (Final, Net, NetReliable, Native, Event, Private, NetClient)
	 * Parameters:
	 * 		struct FDungeonCrawler_FClientMsgClassSpellSequenceChangeResponse InMsg                                                      (ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UGameTestComponent::ClientMsgClassSpellSequenceChangeResponse(const struct FDungeonCrawler_FClientMsgClassSpellSequenceChangeResponse& InMsg)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GameTestComponent.ClientMsgClassSpellSequenceChangeResponse");
		
		UGameTestComponent_ClientMsgClassSpellSequenceChangeResponse_Params params {};
		params.InMsg = InMsg;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017DD110
	 * 		Name   -> Function DungeonCrawler.GameTestComponent.ClientMsgClassSpellSequenceChangeRequest
	 * 		Flags  -> (Final, Net, NetReliable, Native, Event, Private, NetServer)
	 * Parameters:
	 * 		struct FDungeonCrawler_FClientMsgClassSpellSequenceChangeRequest InMsg                                                      (ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UGameTestComponent::ClientMsgClassSpellSequenceChangeRequest(const struct FDungeonCrawler_FClientMsgClassSpellSequenceChangeRequest& InMsg)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GameTestComponent.ClientMsgClassSpellSequenceChangeRequest");
		
		UGameTestComponent_ClientMsgClassSpellSequenceChangeRequest_Params params {};
		params.InMsg = InMsg;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017DCFE0
	 * 		Name   -> Function DungeonCrawler.GameTestComponent.ClientMsgClassSpellListResponse
	 * 		Flags  -> (Final, Net, NetReliable, Native, Event, Private, NetClient)
	 * Parameters:
	 * 		struct FDungeonCrawler_FClientMsgClassSpellListResponse InMsg                                                      (ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UGameTestComponent::ClientMsgClassSpellListResponse(const struct FDungeonCrawler_FClientMsgClassSpellListResponse& InMsg)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GameTestComponent.ClientMsgClassSpellListResponse");
		
		UGameTestComponent_ClientMsgClassSpellListResponse_Params params {};
		params.InMsg = InMsg;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017DCEF0
	 * 		Name   -> Function DungeonCrawler.GameTestComponent.ClientMsgClassSpellListRequest
	 * 		Flags  -> (Final, Net, NetReliable, Native, Event, Private, NetServer)
	 * Parameters:
	 * 		struct FDungeonCrawler_FClientMsgClassSpellListRequest InMsg                                                      (ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UGameTestComponent::ClientMsgClassSpellListRequest(const struct FDungeonCrawler_FClientMsgClassSpellListRequest& InMsg)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GameTestComponent.ClientMsgClassSpellListRequest");
		
		UGameTestComponent_ClientMsgClassSpellListRequest_Params params {};
		params.InMsg = InMsg;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017DCDC0
	 * 		Name   -> Function DungeonCrawler.GameTestComponent.ClientMsgClassSkillListResponse
	 * 		Flags  -> (Final, Net, NetReliable, Native, Event, Private, NetClient)
	 * Parameters:
	 * 		struct FDungeonCrawler_FClientMsgClassSkillListResponse InMsg                                                      (ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UGameTestComponent::ClientMsgClassSkillListResponse(const struct FDungeonCrawler_FClientMsgClassSkillListResponse& InMsg)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GameTestComponent.ClientMsgClassSkillListResponse");
		
		UGameTestComponent_ClientMsgClassSkillListResponse_Params params {};
		params.InMsg = InMsg;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017DCCD0
	 * 		Name   -> Function DungeonCrawler.GameTestComponent.ClientMsgClassSkillListRequest
	 * 		Flags  -> (Final, Net, NetReliable, Native, Event, Private, NetServer)
	 * Parameters:
	 * 		struct FDungeonCrawler_FClientMsgClassSkillListRequest InMsg                                                      (ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UGameTestComponent::ClientMsgClassSkillListRequest(const struct FDungeonCrawler_FClientMsgClassSkillListRequest& InMsg)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GameTestComponent.ClientMsgClassSkillListRequest");
		
		UGameTestComponent_ClientMsgClassSkillListRequest_Params params {};
		params.InMsg = InMsg;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017DCBA0
	 * 		Name   -> Function DungeonCrawler.GameTestComponent.ClientMsgClassPerkListResponse
	 * 		Flags  -> (Final, Net, NetReliable, Native, Event, Private, NetClient)
	 * Parameters:
	 * 		struct FDungeonCrawler_FClientMsgClassPerkListResponse InMsg                                                      (ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UGameTestComponent::ClientMsgClassPerkListResponse(const struct FDungeonCrawler_FClientMsgClassPerkListResponse& InMsg)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GameTestComponent.ClientMsgClassPerkListResponse");
		
		UGameTestComponent_ClientMsgClassPerkListResponse_Params params {};
		params.InMsg = InMsg;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017DCAB0
	 * 		Name   -> Function DungeonCrawler.GameTestComponent.ClientMsgClassPerkListRequest
	 * 		Flags  -> (Final, Net, NetReliable, Native, Event, Private, NetServer)
	 * Parameters:
	 * 		struct FDungeonCrawler_FClientMsgClassPerkListRequest InMsg                                                      (ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UGameTestComponent::ClientMsgClassPerkListRequest(const struct FDungeonCrawler_FClientMsgClassPerkListRequest& InMsg)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GameTestComponent.ClientMsgClassPerkListRequest");
		
		UGameTestComponent_ClientMsgClassPerkListRequest_Params params {};
		params.InMsg = InMsg;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017DC9C0
	 * 		Name   -> Function DungeonCrawler.GameTestComponent.ClientMsgClassLevelInfoResponse
	 * 		Flags  -> (Final, Net, NetReliable, Native, Event, Private, NetClient)
	 * Parameters:
	 * 		struct FDungeonCrawler_FClientMsgClassLevelInfoResponse InMsg                                                      (ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UGameTestComponent::ClientMsgClassLevelInfoResponse(const struct FDungeonCrawler_FClientMsgClassLevelInfoResponse& InMsg)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GameTestComponent.ClientMsgClassLevelInfoResponse");
		
		UGameTestComponent_ClientMsgClassLevelInfoResponse_Params params {};
		params.InMsg = InMsg;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017DC8D0
	 * 		Name   -> Function DungeonCrawler.GameTestComponent.ClientMsgClassLevelInfoRequest
	 * 		Flags  -> (Final, Net, NetReliable, Native, Event, Private, NetServer)
	 * Parameters:
	 * 		struct FDungeonCrawler_FClientMsgClassLevelInfoRequest InMsg                                                      (ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UGameTestComponent::ClientMsgClassLevelInfoRequest(const struct FDungeonCrawler_FClientMsgClassLevelInfoRequest& InMsg)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GameTestComponent.ClientMsgClassLevelInfoRequest");
		
		UGameTestComponent_ClientMsgClassLevelInfoRequest_Params params {};
		params.InMsg = InMsg;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017DC7A0
	 * 		Name   -> Function DungeonCrawler.GameTestComponent.ClientMsgClassItemMoveResponse
	 * 		Flags  -> (Final, Net, NetReliable, Native, Event, Private, NetClient)
	 * Parameters:
	 * 		struct FDungeonCrawler_FClientMsgClassItemMoveResponse InMsg                                                      (ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UGameTestComponent::ClientMsgClassItemMoveResponse(const struct FDungeonCrawler_FClientMsgClassItemMoveResponse& InMsg)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GameTestComponent.ClientMsgClassItemMoveResponse");
		
		UGameTestComponent_ClientMsgClassItemMoveResponse_Params params {};
		params.InMsg = InMsg;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017DC670
	 * 		Name   -> Function DungeonCrawler.GameTestComponent.ClientMsgClassItemMoveRequest
	 * 		Flags  -> (Final, Net, NetReliable, Native, Event, Private, NetServer)
	 * Parameters:
	 * 		struct FDungeonCrawler_FClientMsgClassItemMoveRequest InMsg                                                      (ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UGameTestComponent::ClientMsgClassItemMoveRequest(const struct FDungeonCrawler_FClientMsgClassItemMoveRequest& InMsg)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GameTestComponent.ClientMsgClassItemMoveRequest");
		
		UGameTestComponent_ClientMsgClassItemMoveRequest_Params params {};
		params.InMsg = InMsg;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D3C640
	 * 		Name   -> Function DungeonCrawler.GameTestComponent.BroadcastMsgBlueprint
	 * 		Flags  -> (Native, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		int32_t                                            InMsg                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGameTestComponent::BroadcastMsgBlueprint(int32_t InMsg)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GameTestComponent.BroadcastMsgBlueprint");
		
		UGameTestComponent_BroadcastMsgBlueprint_Params params {};
		params.InMsg = InMsg;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGameTestComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGameTestComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.GameTestComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017DE8B0
	 * 		Name   -> Function DungeonCrawler.GA_ActivateItemBase.ReceivedEvent
	 * 		Flags  -> (Native, Event, Protected, BlueprintEvent)
	 * Parameters:
	 * 		struct FGameplayTag                                EventTag                                                   (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FGameplayEventData                          EventData                                                  (Parm, NativeAccessSpecifierPublic)
	 */
	void UGA_ActivateItemBase::ReceivedEvent(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GA_ActivateItemBase.ReceivedEvent");
		
		UGA_ActivateItemBase_ReceivedEvent_Params params {};
		params.EventTag = EventTag;
		params.EventData = EventData;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017DE800
	 * 		Name   -> Function DungeonCrawler.GA_ActivateItemBase.OtherHandIAStarted
	 * 		Flags  -> (Final, Native, Protected, HasOutParms)
	 * Parameters:
	 * 		struct FInputActionValue                           InputActionValue                                           (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UGA_ActivateItemBase::OtherHandIAStarted(const struct FInputActionValue& InputActionValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GA_ActivateItemBase.OtherHandIAStarted");
		
		UGA_ActivateItemBase_OtherHandIAStarted_Params params {};
		params.InputActionValue = InputActionValue;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017DE750
	 * 		Name   -> Function DungeonCrawler.GA_ActivateItemBase.OtherHandIACompleted
	 * 		Flags  -> (Final, Native, Protected, HasOutParms)
	 * Parameters:
	 * 		struct FInputActionValue                           InputActionValue                                           (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UGA_ActivateItemBase::OtherHandIACompleted(const struct FInputActionValue& InputActionValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GA_ActivateItemBase.OtherHandIACompleted");
		
		UGA_ActivateItemBase_OtherHandIACompleted_Params params {};
		params.InputActionValue = InputActionValue;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017DE4E0
	 * 		Name   -> Function DungeonCrawler.GA_ActivateItemBase.OnCompleted
	 * 		Flags  -> (Final, Native, Protected)
	 * Parameters:
	 * 		struct FGameplayTag                                EventTag                                                   (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FGameplayEventData                          EventData                                                  (Parm, NativeAccessSpecifierPublic)
	 */
	void UGA_ActivateItemBase::OnCompleted(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GA_ActivateItemBase.OnCompleted");
		
		UGA_ActivateItemBase_OnCompleted_Params params {};
		params.EventTag = EventTag;
		params.EventData = EventData;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017DE290
	 * 		Name   -> Function DungeonCrawler.GA_ActivateItemBase.OnCancelled
	 * 		Flags  -> (Final, Native, Protected)
	 * Parameters:
	 * 		struct FGameplayTag                                EventTag                                                   (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FGameplayEventData                          EventData                                                  (Parm, NativeAccessSpecifierPublic)
	 */
	void UGA_ActivateItemBase::OnCancelled(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GA_ActivateItemBase.OnCancelled");
		
		UGA_ActivateItemBase_OnCancelled_Params params {};
		params.EventTag = EventTag;
		params.EventData = EventData;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017DD570
	 * 		Name   -> Function DungeonCrawler.GA_ActivateItemBase.EventReceived
	 * 		Flags  -> (Final, Native, Protected)
	 * Parameters:
	 * 		struct FGameplayTag                                EventTag                                                   (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FGameplayEventData                          EventData                                                  (Parm, NativeAccessSpecifierPublic)
	 */
	void UGA_ActivateItemBase::EventReceived(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GA_ActivateItemBase.EventReceived");
		
		UGA_ActivateItemBase_EventReceived_Params params {};
		params.EventTag = EventTag;
		params.EventData = EventData;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.GA_ActivateItemBase.AbilityActivated
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 * Parameters:
	 * 		struct FGameplayEventData                          TriggerEventData                                           (ConstParm, Parm, NativeAccessSpecifierPublic)
	 */
	void UGA_ActivateItemBase::AbilityActivated(const struct FGameplayEventData& TriggerEventData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GA_ActivateItemBase.AbilityActivated");
		
		UGA_ActivateItemBase_AbilityActivated_Params params {};
		params.TriggerEventData = TriggerEventData;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGA_ActivateItemBase.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGA_ActivateItemBase::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.GA_ActivateItemBase");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017DE130
	 * 		Name   -> Function DungeonCrawler.GA_AuraBase.OnAuraOverlapEnd
	 * 		Flags  -> (Final, Native, Private)
	 * Parameters:
	 * 		class UPrimitiveComponent*                         OverlappedComp                                             (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      Other                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UPrimitiveComponent*                         OtherComp                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            OtherBodyIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGA_AuraBase::OnAuraOverlapEnd(class UPrimitiveComponent* OverlappedComp, class AActor* Other, class UPrimitiveComponent* OtherComp, int32_t OtherBodyIndex)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GA_AuraBase.OnAuraOverlapEnd");
		
		UGA_AuraBase_OnAuraOverlapEnd_Params params {};
		params.OverlappedComp = OverlappedComp;
		params.Other = Other;
		params.OtherComp = OtherComp;
		params.OtherBodyIndex = OtherBodyIndex;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017DDEC0
	 * 		Name   -> Function DungeonCrawler.GA_AuraBase.OnAuraOverlapBegin
	 * 		Flags  -> (Final, Native, Private, HasOutParms)
	 * Parameters:
	 * 		class UPrimitiveComponent*                         OverlappedComp                                             (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      Other                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UPrimitiveComponent*                         OtherComp                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            OtherBodyIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bFromSweep                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FHitResult                                  SweepResult                                                (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	void UGA_AuraBase::OnAuraOverlapBegin(class UPrimitiveComponent* OverlappedComp, class AActor* Other, class UPrimitiveComponent* OtherComp, int32_t OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GA_AuraBase.OnAuraOverlapBegin");
		
		UGA_AuraBase_OnAuraOverlapBegin_Params params {};
		params.OverlappedComp = OverlappedComp;
		params.Other = Other;
		params.OtherComp = OtherComp;
		params.OtherBodyIndex = OtherBodyIndex;
		params.bFromSweep = bFromSweep;
		params.SweepResult = SweepResult;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017DDD60
	 * 		Name   -> Function DungeonCrawler.GA_AuraBase.OnAntiAuraOverlapEnd
	 * 		Flags  -> (Final, Native, Private)
	 * Parameters:
	 * 		class UPrimitiveComponent*                         OverlappedComp                                             (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      Other                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UPrimitiveComponent*                         OtherComp                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            OtherBodyIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGA_AuraBase::OnAntiAuraOverlapEnd(class UPrimitiveComponent* OverlappedComp, class AActor* Other, class UPrimitiveComponent* OtherComp, int32_t OtherBodyIndex)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GA_AuraBase.OnAntiAuraOverlapEnd");
		
		UGA_AuraBase_OnAntiAuraOverlapEnd_Params params {};
		params.OverlappedComp = OverlappedComp;
		params.Other = Other;
		params.OtherComp = OtherComp;
		params.OtherBodyIndex = OtherBodyIndex;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017DDAF0
	 * 		Name   -> Function DungeonCrawler.GA_AuraBase.OnAntiAuraOverlapBegin
	 * 		Flags  -> (Final, Native, Private, HasOutParms)
	 * Parameters:
	 * 		class UPrimitiveComponent*                         OverlappedComp                                             (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      Other                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UPrimitiveComponent*                         OtherComp                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            OtherBodyIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bFromSweep                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FHitResult                                  SweepResult                                                (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	void UGA_AuraBase::OnAntiAuraOverlapBegin(class UPrimitiveComponent* OverlappedComp, class AActor* Other, class UPrimitiveComponent* OtherComp, int32_t OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GA_AuraBase.OnAntiAuraOverlapBegin");
		
		UGA_AuraBase_OnAntiAuraOverlapBegin_Params params {};
		params.OverlappedComp = OverlappedComp;
		params.Other = Other;
		params.OtherComp = OtherComp;
		params.OtherBodyIndex = OtherBodyIndex;
		params.bFromSweep = bFromSweep;
		params.SweepResult = SweepResult;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGA_AuraBase.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGA_AuraBase::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.GA_AuraBase");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017E2510
	 * 		Name   -> Function DungeonCrawler.GA_RangedAttackBase.ReceivedEvent
	 * 		Flags  -> (Native, Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		struct FGameplayTag                                EventTag                                                   (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FGameplayEventData                          EventData                                                  (Parm, NativeAccessSpecifierPublic)
	 */
	void UGA_RangedAttackBase::ReceivedEvent(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GA_RangedAttackBase.ReceivedEvent");
		
		UGA_RangedAttackBase_ReceivedEvent_Params params {};
		params.EventTag = EventTag;
		params.EventData = EventData;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.GA_RangedAttackBase.ProjectileFired
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 */
	void UGA_RangedAttackBase::ProjectileFired()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GA_RangedAttackBase.ProjectileFired");
		
		UGA_RangedAttackBase_ProjectileFired_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017DE4E0
	 * 		Name   -> Function DungeonCrawler.GA_RangedAttackBase.OnCompleted
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		struct FGameplayTag                                EventTag                                                   (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FGameplayEventData                          EventData                                                  (Parm, NativeAccessSpecifierPublic)
	 */
	void UGA_RangedAttackBase::OnCompleted(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GA_RangedAttackBase.OnCompleted");
		
		UGA_RangedAttackBase_OnCompleted_Params params {};
		params.EventTag = EventTag;
		params.EventData = EventData;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017DE290
	 * 		Name   -> Function DungeonCrawler.GA_RangedAttackBase.OnCancelled
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		struct FGameplayTag                                EventTag                                                   (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FGameplayEventData                          EventData                                                  (Parm, NativeAccessSpecifierPublic)
	 */
	void UGA_RangedAttackBase::OnCancelled(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GA_RangedAttackBase.OnCancelled");
		
		UGA_RangedAttackBase_OnCancelled_Params params {};
		params.EventTag = EventTag;
		params.EventData = EventData;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017E9AB0
	 * 		Name   -> Function DungeonCrawler.GA_RangedAttackBase.MultiFireProjectiles
	 * 		Flags  -> (Native, Protected)
	 * Parameters:
	 * 		struct FGameplayTag                                EventTag                                                   (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FGameplayEventData                          EventData                                                  (Parm, NativeAccessSpecifierPublic)
	 * 		float                                              FirePower                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGA_RangedAttackBase::MultiFireProjectiles(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData, float FirePower)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GA_RangedAttackBase.MultiFireProjectiles");
		
		UGA_RangedAttackBase_MultiFireProjectiles_Params params {};
		params.EventTag = EventTag;
		params.EventData = EventData;
		params.FirePower = FirePower;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017E99E0
	 * 		Name   -> Function DungeonCrawler.GA_RangedAttackBase.GetProjectileActorClass
	 * 		Flags  -> (Final, Native, Public, Const)
	 */
	class UClass* UGA_RangedAttackBase::GetProjectileActorClass()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GA_RangedAttackBase.GetProjectileActorClass");
		
		UGA_RangedAttackBase_GetProjectileActorClass_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017E98A0
	 * 		Name   -> Function DungeonCrawler.GA_RangedAttackBase.FireSocketSightUnblocked
	 * 		Flags  -> (Final, Native, Protected, HasOutParms)
	 * Parameters:
	 * 		struct FGameplayAbilityTargetDataHandle            InData                                                     (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UGA_RangedAttackBase::FireSocketSightUnblocked(const struct FGameplayAbilityTargetDataHandle& InData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GA_RangedAttackBase.FireSocketSightUnblocked");
		
		UGA_RangedAttackBase_FireSocketSightUnblocked_Params params {};
		params.InData = InData;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017E9760
	 * 		Name   -> Function DungeonCrawler.GA_RangedAttackBase.FireSocketSightBlocked
	 * 		Flags  -> (Final, Native, Protected, HasOutParms)
	 * Parameters:
	 * 		struct FGameplayAbilityTargetDataHandle            InData                                                     (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UGA_RangedAttackBase::FireSocketSightBlocked(const struct FGameplayAbilityTargetDataHandle& InData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GA_RangedAttackBase.FireSocketSightBlocked");
		
		UGA_RangedAttackBase_FireSocketSightBlocked_Params params {};
		params.InData = InData;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017E94A0
	 * 		Name   -> Function DungeonCrawler.GA_RangedAttackBase.FireProjectile
	 * 		Flags  -> (Native, Protected)
	 * Parameters:
	 * 		struct FGameplayTag                                EventTag                                                   (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FGameplayEventData                          EventData                                                  (Parm, NativeAccessSpecifierPublic)
	 * 		float                                              FirePower                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGA_RangedAttackBase::FireProjectile(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData, float FirePower)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GA_RangedAttackBase.FireProjectile");
		
		UGA_RangedAttackBase_FireProjectile_Params params {};
		params.EventTag = EventTag;
		params.EventData = EventData;
		params.FirePower = FirePower;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017DE8B0
	 * 		Name   -> Function DungeonCrawler.GA_RangedAttackBase.EventReceived
	 * 		Flags  -> (Native, Public)
	 * Parameters:
	 * 		struct FGameplayTag                                EventTag                                                   (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FGameplayEventData                          EventData                                                  (Parm, NativeAccessSpecifierPublic)
	 */
	void UGA_RangedAttackBase::EventReceived(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GA_RangedAttackBase.EventReceived");
		
		UGA_RangedAttackBase_EventReceived_Params params {};
		params.EventTag = EventTag;
		params.EventData = EventData;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.GA_RangedAttackBase.CreateProjectiles
	 * 		Flags  -> (Event, Protected, HasDefaults, BlueprintEvent)
	 * Parameters:
	 * 		struct FGameplayTag                                EventTag                                                   (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FGameplayEventData                          EventData                                                  (Parm, NativeAccessSpecifierPublic)
	 * 		float                                              FirePower                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     StartLocation                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGA_RangedAttackBase::CreateProjectiles(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData, float FirePower, const struct FVector& StartLocation)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GA_RangedAttackBase.CreateProjectiles");
		
		UGA_RangedAttackBase_CreateProjectiles_Params params {};
		params.EventTag = EventTag;
		params.EventData = EventData;
		params.FirePower = FirePower;
		params.StartLocation = StartLocation;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017E91E0
	 * 		Name   -> Function DungeonCrawler.GA_RangedAttackBase.CreatedProjectile
	 * 		Flags  -> (Native, Protected, BlueprintCallable)
	 * Parameters:
	 * 		class AProjectileActor*                            Projectile                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FHitResult                                  HitResult                                                  (Parm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 * 		struct FGameplayTag                                EventTag                                                   (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGA_RangedAttackBase::CreatedProjectile(class AProjectileActor* Projectile, const struct FHitResult& HitResult, const struct FGameplayTag& EventTag)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GA_RangedAttackBase.CreatedProjectile");
		
		UGA_RangedAttackBase_CreatedProjectile_Params params {};
		params.Projectile = Projectile;
		params.HitResult = HitResult;
		params.EventTag = EventTag;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017E8E20
	 * 		Name   -> Function DungeonCrawler.GA_RangedAttackBase.CheckedCrossHairRecoveryForThrowingItems
	 * 		Flags  -> (Final, Native, Protected)
	 * Parameters:
	 * 		class APlayerController*                           PlayerController                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UGA_RangedAttackBase::CheckedCrossHairRecoveryForThrowingItems(class APlayerController* PlayerController)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GA_RangedAttackBase.CheckedCrossHairRecoveryForThrowingItems");
		
		UGA_RangedAttackBase_CheckedCrossHairRecoveryForThrowingItems_Params params {};
		params.PlayerController = PlayerController;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017E8C60
	 * 		Name   -> Function DungeonCrawler.GA_RangedAttackBase.ActivateCrossHairPullAnimation
	 * 		Flags  -> (Final, Native, Protected)
	 * Parameters:
	 * 		class APlayerController*                           PlayerController                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGA_RangedAttackBase::ActivateCrossHairPullAnimation(class APlayerController* PlayerController)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GA_RangedAttackBase.ActivateCrossHairPullAnimation");
		
		UGA_RangedAttackBase_ActivateCrossHairPullAnimation_Params params {};
		params.PlayerController = PlayerController;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.GA_RangedAttackBase.AbilityActivated
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		struct FGameplayEventData                          TriggerEventData                                           (ConstParm, Parm, NativeAccessSpecifierPublic)
	 */
	void UGA_RangedAttackBase::AbilityActivated(const struct FGameplayEventData& TriggerEventData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GA_RangedAttackBase.AbilityActivated");
		
		UGA_RangedAttackBase_AbilityActivated_Params params {};
		params.TriggerEventData = TriggerEventData;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGA_RangedAttackBase.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGA_RangedAttackBase::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.GA_RangedAttackBase");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017E52E0
	 * 		Name   -> Function DungeonCrawler.GA_ChargedRangedAttackBase.SendPlayShootCrossHairNotify
	 * 		Flags  -> (Final, Native, Protected)
	 */
	void UGA_ChargedRangedAttackBase::SendPlayShootCrossHairNotify()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GA_ChargedRangedAttackBase.SendPlayShootCrossHairNotify");
		
		UGA_ChargedRangedAttackBase_SendPlayShootCrossHairNotify_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017E4570
	 * 		Name   -> Function DungeonCrawler.GA_ChargedRangedAttackBase.OnMutiShotSkill
	 * 		Flags  -> (Final, Native, Protected)
	 * Parameters:
	 * 		struct FGameplayTag                                EventTag                                                   (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FGameplayEventData                          EventData                                                  (Parm, NativeAccessSpecifierPublic)
	 * 		float                                              FirePower                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGA_ChargedRangedAttackBase::OnMutiShotSkill(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData, float FirePower)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GA_ChargedRangedAttackBase.OnMutiShotSkill");
		
		UGA_ChargedRangedAttackBase_OnMutiShotSkill_Params params {};
		params.EventTag = EventTag;
		params.EventData = EventData;
		params.FirePower = FirePower;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017E3350
	 * 		Name   -> Function DungeonCrawler.GA_ChargedRangedAttackBase.InputActionStarted
	 * 		Flags  -> (Final, Native, Protected, HasOutParms)
	 * Parameters:
	 * 		struct FInputActionValue                           InputActionValue                                           (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UGA_ChargedRangedAttackBase::InputActionStarted(const struct FInputActionValue& InputActionValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GA_ChargedRangedAttackBase.InputActionStarted");
		
		UGA_ChargedRangedAttackBase_InputActionStarted_Params params {};
		params.InputActionValue = InputActionValue;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017E32A0
	 * 		Name   -> Function DungeonCrawler.GA_ChargedRangedAttackBase.InputActionCompleted
	 * 		Flags  -> (Final, Native, Protected, HasOutParms)
	 * Parameters:
	 * 		struct FInputActionValue                           InputActionValue                                           (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UGA_ChargedRangedAttackBase::InputActionCompleted(const struct FInputActionValue& InputActionValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GA_ChargedRangedAttackBase.InputActionCompleted");
		
		UGA_ChargedRangedAttackBase_InputActionCompleted_Params params {};
		params.InputActionValue = InputActionValue;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.GA_ChargedRangedAttackBase.CreateMultiShotProjectiles
	 * 		Flags  -> (Event, Protected, HasDefaults, BlueprintEvent)
	 * Parameters:
	 * 		struct FGameplayTag                                EventTag                                                   (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FGameplayEventData                          EventData                                                  (Parm, NativeAccessSpecifierPublic)
	 * 		float                                              FirePower                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     StartLocation                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGA_ChargedRangedAttackBase::CreateMultiShotProjectiles(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData, float FirePower, const struct FVector& StartLocation)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GA_ChargedRangedAttackBase.CreateMultiShotProjectiles");
		
		UGA_ChargedRangedAttackBase_CreateMultiShotProjectiles_Params params {};
		params.EventTag = EventTag;
		params.EventData = EventData;
		params.FirePower = FirePower;
		params.StartLocation = StartLocation;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGA_ChargedRangedAttackBase.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGA_ChargedRangedAttackBase::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.GA_ChargedRangedAttackBase");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGA_BowAttackBase.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGA_BowAttackBase::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.GA_BowAttackBase");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017DD870
	 * 		Name   -> Function DungeonCrawler.GA_BowQuickShotBase.InputActionStarted
	 * 		Flags  -> (Final, Native, Protected, HasOutParms)
	 * Parameters:
	 * 		struct FInputActionValue                           InputActionValue                                           (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UGA_BowQuickShotBase::InputActionStarted(const struct FInputActionValue& InputActionValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GA_BowQuickShotBase.InputActionStarted");
		
		UGA_BowQuickShotBase_InputActionStarted_Params params {};
		params.InputActionValue = InputActionValue;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017DD7C0
	 * 		Name   -> Function DungeonCrawler.GA_BowQuickShotBase.InputActionCompleted
	 * 		Flags  -> (Final, Native, Protected, HasOutParms)
	 * Parameters:
	 * 		struct FInputActionValue                           InputActionValue                                           (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UGA_BowQuickShotBase::InputActionCompleted(const struct FInputActionValue& InputActionValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GA_BowQuickShotBase.InputActionCompleted");
		
		UGA_BowQuickShotBase_InputActionCompleted_Params params {};
		params.InputActionValue = InputActionValue;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGA_BowQuickShotBase.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGA_BowQuickShotBase::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.GA_BowQuickShotBase");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017DE4E0
	 * 		Name   -> Function DungeonCrawler.GA_ChangeIdle.OnCompleted
	 * 		Flags  -> (Final, Native, Protected)
	 * Parameters:
	 * 		struct FGameplayTag                                EventTag                                                   (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FGameplayEventData                          EventData                                                  (Parm, NativeAccessSpecifierPublic)
	 */
	void UGA_ChangeIdle::OnCompleted(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GA_ChangeIdle.OnCompleted");
		
		UGA_ChangeIdle_OnCompleted_Params params {};
		params.EventTag = EventTag;
		params.EventData = EventData;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017DE4E0
	 * 		Name   -> Function DungeonCrawler.GA_ChangeIdle.OnBlendOut
	 * 		Flags  -> (Final, Native, Protected)
	 * Parameters:
	 * 		struct FGameplayTag                                EventTag                                                   (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FGameplayEventData                          EventData                                                  (Parm, NativeAccessSpecifierPublic)
	 */
	void UGA_ChangeIdle::OnBlendOut(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GA_ChangeIdle.OnBlendOut");
		
		UGA_ChangeIdle_OnBlendOut_Params params {};
		params.EventTag = EventTag;
		params.EventData = EventData;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.GA_ChangeIdle.AbilityActivated
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 * Parameters:
	 * 		struct FGameplayEventData                          TriggerEventData                                           (ConstParm, Parm, NativeAccessSpecifierPublic)
	 */
	void UGA_ChangeIdle::AbilityActivated(const struct FGameplayEventData& TriggerEventData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GA_ChangeIdle.AbilityActivated");
		
		UGA_ChangeIdle_AbilityActivated_Params params {};
		params.TriggerEventData = TriggerEventData;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGA_ChangeIdle.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGA_ChangeIdle::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.GA_ChangeIdle");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017E44F0
	 * 		Name   -> Function DungeonCrawler.GA_CharacterJump.OnMovementModeChange
	 * 		Flags  -> (Final, Native, Private)
	 * Parameters:
	 * 		EMovementMode                                      MovementMode                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGA_CharacterJump::OnMovementModeChange(EMovementMode MovementMode)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GA_CharacterJump.OnMovementModeChange");
		
		UGA_CharacterJump_OnMovementModeChange_Params params {};
		params.MovementMode = MovementMode;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017E2760
	 * 		Name   -> Function DungeonCrawler.GA_CharacterJump.EventReceived
	 * 		Flags  -> (Final, Native, Private)
	 * Parameters:
	 * 		struct FGameplayEventData                          EventData                                                  (Parm, NativeAccessSpecifierPublic)
	 */
	void UGA_CharacterJump::EventReceived(const struct FGameplayEventData& EventData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GA_CharacterJump.EventReceived");
		
		UGA_CharacterJump_EventReceived_Params params {};
		params.EventData = EventData;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGA_CharacterJump.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGA_CharacterJump::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.GA_CharacterJump");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017E3D10
	 * 		Name   -> Function DungeonCrawler.GA_Drop.OnEndSync
	 * 		Flags  -> (Final, Native, Private)
	 */
	void UGA_Drop::OnEndSync()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GA_Drop.OnEndSync");
		
		UGA_Drop_OnEndSync_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGA_Drop.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGA_Drop::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.GA_Drop");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017E4A90
	 * 		Name   -> Function DungeonCrawler.GA_Equip.OnTaskCompleted
	 * 		Flags  -> (Final, Native, Private)
	 * Parameters:
	 * 		struct FGameplayTag                                EventTag                                                   (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FGameplayEventData                          EventData                                                  (Parm, NativeAccessSpecifierPublic)
	 */
	void UGA_Equip::OnTaskCompleted(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GA_Equip.OnTaskCompleted");
		
		UGA_Equip_OnTaskCompleted_Params params {};
		params.EventTag = EventTag;
		params.EventData = EventData;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017E3ED0
	 * 		Name   -> Function DungeonCrawler.GA_Equip.OnGameplayEventReceived
	 * 		Flags  -> (Final, Native, Private)
	 * Parameters:
	 * 		struct FGameplayTag                                EventTag                                                   (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FGameplayEventData                          EventData                                                  (Parm, NativeAccessSpecifierPublic)
	 */
	void UGA_Equip::OnGameplayEventReceived(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GA_Equip.OnGameplayEventReceived");
		
		UGA_Equip_OnGameplayEventReceived_Params params {};
		params.EventTag = EventTag;
		params.EventData = EventData;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017DE290
	 * 		Name   -> Function DungeonCrawler.GA_Equip.OnCancelled
	 * 		Flags  -> (Final, Native, Private)
	 * Parameters:
	 * 		struct FGameplayTag                                EventTag                                                   (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FGameplayEventData                          EventData                                                  (Parm, NativeAccessSpecifierPublic)
	 */
	void UGA_Equip::OnCancelled(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GA_Equip.OnCancelled");
		
		UGA_Equip_OnCancelled_Params params {};
		params.EventTag = EventTag;
		params.EventData = EventData;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGA_Equip.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGA_Equip::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.GA_Equip");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00A2B690
	 * 		Name   -> Function DungeonCrawler.GA_Interact.OnVelocityChange
	 * 		Flags  -> (Final, Native, Protected)
	 */
	void UGA_Interact::OnVelocityChange()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GA_Interact.OnVelocityChange");
		
		UGA_Interact_OnVelocityChange_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017E4940
	 * 		Name   -> Function DungeonCrawler.GA_Interact.OnStartSync
	 * 		Flags  -> (Final, Native, Protected)
	 */
	void UGA_Interact::OnStartSync()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GA_Interact.OnStartSync");
		
		UGA_Interact_OnStartSync_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017E4920
	 * 		Name   -> Function DungeonCrawler.GA_Interact.OnStartDelayFinished
	 * 		Flags  -> (Final, Native, Protected)
	 */
	void UGA_Interact::OnStartDelayFinished()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GA_Interact.OnStartDelayFinished");
		
		UGA_Interact_OnStartDelayFinished_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017E4900
	 * 		Name   -> Function DungeonCrawler.GA_Interact.OnSkillCheckSucceed
	 * 		Flags  -> (Final, Native, Protected)
	 */
	void UGA_Interact::OnSkillCheckSucceed()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GA_Interact.OnSkillCheckSucceed");
		
		UGA_Interact_OnSkillCheckSucceed_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017E48E0
	 * 		Name   -> Function DungeonCrawler.GA_Interact.OnSkillCheckPerfectSucceed
	 * 		Flags  -> (Final, Native, Protected)
	 */
	void UGA_Interact::OnSkillCheckPerfectSucceed()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GA_Interact.OnSkillCheckPerfectSucceed");
		
		UGA_Interact_OnSkillCheckPerfectSucceed_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017E4860
	 * 		Name   -> Function DungeonCrawler.GA_Interact.OnSkillCheckFinished
	 * 		Flags  -> (Final, Native, Protected)
	 * Parameters:
	 * 		ESkillCheckResult                                  Result                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGA_Interact::OnSkillCheckFinished(ESkillCheckResult Result)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GA_Interact.OnSkillCheckFinished");
		
		UGA_Interact_OnSkillCheckFinished_Params params {};
		params.Result = Result;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017E4840
	 * 		Name   -> Function DungeonCrawler.GA_Interact.OnSkillCheckFailed
	 * 		Flags  -> (Final, Native, Protected)
	 */
	void UGA_Interact::OnSkillCheckFailed()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GA_Interact.OnSkillCheckFailed");
		
		UGA_Interact_OnSkillCheckFailed_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017E4820
	 * 		Name   -> Function DungeonCrawler.GA_Interact.OnSkillCheck
	 * 		Flags  -> (Final, Native, Protected)
	 */
	void UGA_Interact::OnSkillCheck()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GA_Interact.OnSkillCheck");
		
		UGA_Interact_OnSkillCheck_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017E3D50
	 * 		Name   -> Function DungeonCrawler.GA_Interact.OnFinish
	 * 		Flags  -> (Final, Native, Protected)
	 */
	void UGA_Interact::OnFinish()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GA_Interact.OnFinish");
		
		UGA_Interact_OnFinish_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017E3D30
	 * 		Name   -> Function DungeonCrawler.GA_Interact.OnEndSync
	 * 		Flags  -> (Final, Native, Protected)
	 */
	void UGA_Interact::OnEndSync()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GA_Interact.OnEndSync");
		
		UGA_Interact_OnEndSync_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00A2B690
	 * 		Name   -> Function DungeonCrawler.GA_Interact.OnCancelled
	 * 		Flags  -> (Final, Native, Protected)
	 */
	void UGA_Interact::OnCancelled()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GA_Interact.OnCancelled");
		
		UGA_Interact_OnCancelled_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00A2B690
	 * 		Name   -> Function DungeonCrawler.GA_Interact.OnAimDirectionChange
	 * 		Flags  -> (Final, Native, Protected)
	 */
	void UGA_Interact::OnAimDirectionChange()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GA_Interact.OnAimDirectionChange");
		
		UGA_Interact_OnAimDirectionChange_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017E3400
	 * 		Name   -> Function DungeonCrawler.GA_Interact.IsValidData
	 * 		Flags  -> (Final, Native, Protected, HasOutParms)
	 * Parameters:
	 * 		struct FGameplayEventData                          EventData                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	bool UGA_Interact::IsValidData(const struct FGameplayEventData& EventData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GA_Interact.IsValidData");
		
		UGA_Interact_IsValidData_Params params {};
		params.EventData = EventData;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017E2960
	 * 		Name   -> Function DungeonCrawler.GA_Interact.EventReceived
	 * 		Flags  -> (Final, Native, Protected)
	 * Parameters:
	 * 		struct FGameplayTag                                EventTag                                                   (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FGameplayEventData                          EventData                                                  (Parm, NativeAccessSpecifierPublic)
	 */
	void UGA_Interact::EventReceived(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GA_Interact.EventReceived");
		
		UGA_Interact_EventReceived_Params params {};
		params.EventTag = EventTag;
		params.EventData = EventData;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGA_Interact.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGA_Interact::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.GA_Interact");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017EF890
	 * 		Name   -> Function DungeonCrawler.GA_StoppablePassiveBase.OnStateTagRemoved
	 * 		Flags  -> (Final, Native, Private)
	 */
	void UGA_StoppablePassiveBase::OnStateTagRemoved()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GA_StoppablePassiveBase.OnStateTagRemoved");
		
		UGA_StoppablePassiveBase_OnStateTagRemoved_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017EF870
	 * 		Name   -> Function DungeonCrawler.GA_StoppablePassiveBase.OnStateTagAdded
	 * 		Flags  -> (Final, Native, Private)
	 */
	void UGA_StoppablePassiveBase::OnStateTagAdded()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GA_StoppablePassiveBase.OnStateTagAdded");
		
		UGA_StoppablePassiveBase_OnStateTagAdded_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00F4FAE0
	 * 		Name   -> Function DungeonCrawler.GA_StoppablePassiveBase.OnPassiveStop
	 * 		Flags  -> (Native, Event, Protected, BlueprintEvent)
	 */
	void UGA_StoppablePassiveBase::OnPassiveStop()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GA_StoppablePassiveBase.OnPassiveStop");
		
		UGA_StoppablePassiveBase_OnPassiveStop_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017EE470
	 * 		Name   -> Function DungeonCrawler.GA_StoppablePassiveBase.OnPassiveStart
	 * 		Flags  -> (Native, Event, Protected, BlueprintEvent)
	 */
	void UGA_StoppablePassiveBase::OnPassiveStart()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GA_StoppablePassiveBase.OnPassiveStart");
		
		UGA_StoppablePassiveBase_OnPassiveStart_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGA_StoppablePassiveBase.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGA_StoppablePassiveBase::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.GA_StoppablePassiveBase");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017E52C0
	 * 		Name   -> Function DungeonCrawler.GA_InteractPassive.RefreshInteractionData
	 * 		Flags  -> (Final, Native, Protected)
	 */
	void UGA_InteractPassive::RefreshInteractionData()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GA_InteractPassive.RefreshInteractionData");
		
		UGA_InteractPassive_RefreshInteractionData_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017E4CE0
	 * 		Name   -> Function DungeonCrawler.GA_InteractPassive.ReceivedEvent
	 * 		Flags  -> (Final, Native, Protected)
	 * Parameters:
	 * 		struct FGameplayTag                                EventTag                                                   (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FGameplayEventData                          EventData                                                  (Parm, NativeAccessSpecifierPublic)
	 */
	void UGA_InteractPassive::ReceivedEvent(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GA_InteractPassive.ReceivedEvent");
		
		UGA_InteractPassive_ReceivedEvent_Params params {};
		params.EventTag = EventTag;
		params.EventData = EventData;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017E49C0
	 * 		Name   -> Function DungeonCrawler.GA_InteractPassive.OnTargetGameplayTagChange
	 * 		Flags  -> (Final, Native, Protected)
	 * Parameters:
	 * 		struct FGameplayTag                                InGameplayTag                                              (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            InCount                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGA_InteractPassive::OnTargetGameplayTagChange(const struct FGameplayTag& InGameplayTag, int32_t InCount)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GA_InteractPassive.OnTargetGameplayTagChange");
		
		UGA_InteractPassive_OnTargetGameplayTagChange_Params params {};
		params.InGameplayTag = InGameplayTag;
		params.InCount = InCount;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017E43B0
	 * 		Name   -> Function DungeonCrawler.GA_InteractPassive.OnLostInteractableTarget
	 * 		Flags  -> (Final, Native, Protected, HasOutParms)
	 * Parameters:
	 * 		struct FGameplayAbilityTargetDataHandle            Data                                                       (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UGA_InteractPassive::OnLostInteractableTarget(const struct FGameplayAbilityTargetDataHandle& Data)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GA_InteractPassive.OnLostInteractableTarget");
		
		UGA_InteractPassive_OnLostInteractableTarget_Params params {};
		params.Data = Data;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017E3D90
	 * 		Name   -> Function DungeonCrawler.GA_InteractPassive.OnFoundNewInteractableTarget
	 * 		Flags  -> (Final, Native, Protected, HasOutParms)
	 * Parameters:
	 * 		struct FGameplayAbilityTargetDataHandle            Data                                                       (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UGA_InteractPassive::OnFoundNewInteractableTarget(const struct FGameplayAbilityTargetDataHandle& Data)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GA_InteractPassive.OnFoundNewInteractableTarget");
		
		UGA_InteractPassive_OnFoundNewInteractableTarget_Params params {};
		params.Data = Data;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGA_InteractPassive.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGA_InteractPassive::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.GA_InteractPassive");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.GA_ItemActivateBase.ReceivedEvent
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 * Parameters:
	 * 		struct FGameplayTag                                EventTag                                                   (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FGameplayEventData                          EventData                                                  (Parm, NativeAccessSpecifierPublic)
	 */
	void UGA_ItemActivateBase::ReceivedEvent(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GA_ItemActivateBase.ReceivedEvent");
		
		UGA_ItemActivateBase_ReceivedEvent_Params params {};
		params.EventTag = EventTag;
		params.EventData = EventData;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017E2BB0
	 * 		Name   -> Function DungeonCrawler.GA_ItemActivateBase.EventReceived
	 * 		Flags  -> (Final, Native, Protected)
	 * Parameters:
	 * 		struct FGameplayTag                                EventTag                                                   (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FGameplayEventData                          EventData                                                  (Parm, NativeAccessSpecifierPublic)
	 */
	void UGA_ItemActivateBase::EventReceived(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GA_ItemActivateBase.EventReceived");
		
		UGA_ItemActivateBase_EventReceived_Params params {};
		params.EventTag = EventTag;
		params.EventData = EventData;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.GA_ItemActivateBase.Deactivated
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 */
	void UGA_ItemActivateBase::Deactivated()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GA_ItemActivateBase.Deactivated");
		
		UGA_ItemActivateBase_Deactivated_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.GA_ItemActivateBase.Activated
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 */
	void UGA_ItemActivateBase::Activated()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GA_ItemActivateBase.Activated");
		
		UGA_ItemActivateBase_Activated_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGA_ItemActivateBase.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGA_ItemActivateBase::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.GA_ItemActivateBase");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017E4960
	 * 		Name   -> Function DungeonCrawler.GA_ItemConsumeBase.OnStartSync
	 * 		Flags  -> (Final, Native, Protected)
	 */
	void UGA_ItemConsumeBase::OnStartSync()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GA_ItemConsumeBase.OnStartSync");
		
		UGA_ItemConsumeBase_OnStartSync_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017E3D70
	 * 		Name   -> Function DungeonCrawler.GA_ItemConsumeBase.OnFinish
	 * 		Flags  -> (Final, Native, Protected)
	 */
	void UGA_ItemConsumeBase::OnFinish()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GA_ItemConsumeBase.OnFinish");
		
		UGA_ItemConsumeBase_OnFinish_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017E3D30
	 * 		Name   -> Function DungeonCrawler.GA_ItemConsumeBase.OnEndSync
	 * 		Flags  -> (Final, Native, Protected)
	 */
	void UGA_ItemConsumeBase::OnEndSync()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GA_ItemConsumeBase.OnEndSync");
		
		UGA_ItemConsumeBase_OnEndSync_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.GA_ItemConsumeBase.OnConsumeStartEventReceived
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 * Parameters:
	 * 		float                                              ConsumeDuration                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGA_ItemConsumeBase::OnConsumeStartEventReceived(float ConsumeDuration)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GA_ItemConsumeBase.OnConsumeStartEventReceived");
		
		UGA_ItemConsumeBase_OnConsumeStartEventReceived_Params params {};
		params.ConsumeDuration = ConsumeDuration;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017E3AC0
	 * 		Name   -> Function DungeonCrawler.GA_ItemConsumeBase.OnConsumeMontageCompleted
	 * 		Flags  -> (Final, Native, Protected)
	 * Parameters:
	 * 		struct FGameplayTag                                EventTag                                                   (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FGameplayEventData                          EventData                                                  (Parm, NativeAccessSpecifierPublic)
	 */
	void UGA_ItemConsumeBase::OnConsumeMontageCompleted(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GA_ItemConsumeBase.OnConsumeMontageCompleted");
		
		UGA_ItemConsumeBase_OnConsumeMontageCompleted_Params params {};
		params.EventTag = EventTag;
		params.EventData = EventData;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.GA_ItemConsumeBase.OnConsumeEndEventReceived
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 */
	void UGA_ItemConsumeBase::OnConsumeEndEventReceived()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GA_ItemConsumeBase.OnConsumeEndEventReceived");
		
		UGA_ItemConsumeBase_OnConsumeEndEventReceived_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017DE8B0
	 * 		Name   -> Function DungeonCrawler.GA_ItemConsumeBase.EventReceived
	 * 		Flags  -> (Native, Protected)
	 * Parameters:
	 * 		struct FGameplayTag                                EventTag                                                   (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FGameplayEventData                          EventData                                                  (Parm, NativeAccessSpecifierPublic)
	 */
	void UGA_ItemConsumeBase::EventReceived(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GA_ItemConsumeBase.EventReceived");
		
		UGA_ItemConsumeBase_EventReceived_Params params {};
		params.EventTag = EventTag;
		params.EventData = EventData;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017E2510
	 * 		Name   -> Function DungeonCrawler.GA_ItemConsumeBase.ConsumeEventReceived
	 * 		Flags  -> (Native, Protected)
	 * Parameters:
	 * 		struct FGameplayTag                                EventTag                                                   (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FGameplayEventData                          EventData                                                  (Parm, NativeAccessSpecifierPublic)
	 */
	void UGA_ItemConsumeBase::ConsumeEventReceived(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GA_ItemConsumeBase.ConsumeEventReceived");
		
		UGA_ItemConsumeBase_ConsumeEventReceived_Params params {};
		params.EventTag = EventTag;
		params.EventData = EventData;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.GA_ItemConsumeBase.AbilityActivated
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 * Parameters:
	 * 		struct FGameplayEventData                          TriggerEventData                                           (ConstParm, Parm, NativeAccessSpecifierPublic)
	 */
	void UGA_ItemConsumeBase::AbilityActivated(const struct FGameplayEventData& TriggerEventData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GA_ItemConsumeBase.AbilityActivated");
		
		UGA_ItemConsumeBase_AbilityActivated_Params params {};
		params.TriggerEventData = TriggerEventData;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGA_ItemConsumeBase.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGA_ItemConsumeBase::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.GA_ItemConsumeBase");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017E54C0
	 * 		Name   -> Function DungeonCrawler.GA_MeleeAttackBase.ServerTargetDataReceived
	 * 		Flags  -> (Native, Event, Protected, BlueprintEvent)
	 * Parameters:
	 * 		struct FGameplayTag                                EventTag                                                   (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FGameplayTag                                InChannelTag                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FGameplayEventData                          EventData                                                  (Parm, NativeAccessSpecifierPublic)
	 */
	void UGA_MeleeAttackBase::ServerTargetDataReceived(const struct FGameplayTag& EventTag, const struct FGameplayTag& InChannelTag, const struct FGameplayEventData& EventData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GA_MeleeAttackBase.ServerTargetDataReceived");
		
		UGA_MeleeAttackBase_ServerTargetDataReceived_Params params {};
		params.EventTag = EventTag;
		params.InChannelTag = InChannelTag;
		params.EventData = EventData;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017E5300
	 * 		Name   -> Function DungeonCrawler.GA_MeleeAttackBase.ServerReceivedTargetData
	 * 		Flags  -> (Native, Protected, HasOutParms)
	 * Parameters:
	 * 		struct FGameplayTag                                InEffectTag                                                (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FGameplayTag                                InChannelTag                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FGameplayAbilityTargetDataHandle            InData                                                     (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UGA_MeleeAttackBase::ServerReceivedTargetData(const struct FGameplayTag& InEffectTag, const struct FGameplayTag& InChannelTag, const struct FGameplayAbilityTargetDataHandle& InData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GA_MeleeAttackBase.ServerReceivedTargetData");
		
		UGA_MeleeAttackBase_ServerReceivedTargetData_Params params {};
		params.InEffectTag = InEffectTag;
		params.InChannelTag = InChannelTag;
		params.InData = InData;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017E5180
	 * 		Name   -> Function DungeonCrawler.GA_MeleeAttackBase.ReceivedTargetData
	 * 		Flags  -> (Final, Native, Protected, HasOutParms)
	 * Parameters:
	 * 		struct FGameplayAbilityTargetDataHandle            InData                                                     (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UGA_MeleeAttackBase::ReceivedTargetData(const struct FGameplayAbilityTargetDataHandle& InData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GA_MeleeAttackBase.ReceivedTargetData");
		
		UGA_MeleeAttackBase_ReceivedTargetData_Params params {};
		params.InData = InData;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017E4F30
	 * 		Name   -> Function DungeonCrawler.GA_MeleeAttackBase.ReceivedEvent
	 * 		Flags  -> (Native, Event, Protected, BlueprintEvent)
	 * Parameters:
	 * 		struct FGameplayTag                                EventTag                                                   (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FGameplayEventData                          EventData                                                  (Parm, NativeAccessSpecifierPublic)
	 */
	void UGA_MeleeAttackBase::ReceivedEvent(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GA_MeleeAttackBase.ReceivedEvent");
		
		UGA_MeleeAttackBase_ReceivedEvent_Params params {};
		params.EventTag = EventTag;
		params.EventData = EventData;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017E49A0
	 * 		Name   -> Function DungeonCrawler.GA_MeleeAttackBase.OnStuckFinish
	 * 		Flags  -> (Final, Native, Protected)
	 */
	void UGA_MeleeAttackBase::OnStuckFinish()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GA_MeleeAttackBase.OnStuckFinish");
		
		UGA_MeleeAttackBase_OnStuckFinish_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017E4980
	 * 		Name   -> Function DungeonCrawler.GA_MeleeAttackBase.OnStuck
	 * 		Flags  -> (Final, Native, Protected)
	 */
	void UGA_MeleeAttackBase::OnStuck()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GA_MeleeAttackBase.OnStuck");
		
		UGA_MeleeAttackBase_OnStuck_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00A2B690
	 * 		Name   -> Function DungeonCrawler.GA_MeleeAttackBase.OnInterruptFinish
	 * 		Flags  -> (Final, Native, Protected)
	 */
	void UGA_MeleeAttackBase::OnInterruptFinish()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GA_MeleeAttackBase.OnInterruptFinish");
		
		UGA_MeleeAttackBase_OnInterruptFinish_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017E2510
	 * 		Name   -> Function DungeonCrawler.GA_MeleeAttackBase.OnInterrupted
	 * 		Flags  -> (Native, Protected)
	 * Parameters:
	 * 		struct FGameplayTag                                EventTag                                                   (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FGameplayEventData                          EventData                                                  (Parm, NativeAccessSpecifierPublic)
	 */
	void UGA_MeleeAttackBase::OnInterrupted(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GA_MeleeAttackBase.OnInterrupted");
		
		UGA_MeleeAttackBase_OnInterrupted_Params params {};
		params.EventTag = EventTag;
		params.EventData = EventData;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017E4140
	 * 		Name   -> Function DungeonCrawler.GA_MeleeAttackBase.OnHitFinish
	 * 		Flags  -> (Final, Native, Protected)
	 */
	void UGA_MeleeAttackBase::OnHitFinish()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GA_MeleeAttackBase.OnHitFinish");
		
		UGA_MeleeAttackBase_OnHitFinish_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017E4120
	 * 		Name   -> Function DungeonCrawler.GA_MeleeAttackBase.OnHit
	 * 		Flags  -> (Final, Native, Protected)
	 */
	void UGA_MeleeAttackBase::OnHit()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GA_MeleeAttackBase.OnHit");
		
		UGA_MeleeAttackBase_OnHit_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017E3870
	 * 		Name   -> Function DungeonCrawler.GA_MeleeAttackBase.OnCompleted
	 * 		Flags  -> (Native, Protected)
	 * Parameters:
	 * 		struct FGameplayTag                                EventTag                                                   (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FGameplayEventData                          EventData                                                  (Parm, NativeAccessSpecifierPublic)
	 */
	void UGA_MeleeAttackBase::OnCompleted(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GA_MeleeAttackBase.OnCompleted");
		
		UGA_MeleeAttackBase_OnCompleted_Params params {};
		params.EventTag = EventTag;
		params.EventData = EventData;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017DE8B0
	 * 		Name   -> Function DungeonCrawler.GA_MeleeAttackBase.OnCancelled
	 * 		Flags  -> (Native, Protected)
	 * Parameters:
	 * 		struct FGameplayTag                                EventTag                                                   (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FGameplayEventData                          EventData                                                  (Parm, NativeAccessSpecifierPublic)
	 */
	void UGA_MeleeAttackBase::OnCancelled(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GA_MeleeAttackBase.OnCancelled");
		
		UGA_MeleeAttackBase_OnCancelled_Params params {};
		params.EventTag = EventTag;
		params.EventData = EventData;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017E3620
	 * 		Name   -> Function DungeonCrawler.GA_MeleeAttackBase.OnBlendOut
	 * 		Flags  -> (Native, Protected)
	 * Parameters:
	 * 		struct FGameplayTag                                EventTag                                                   (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FGameplayEventData                          EventData                                                  (Parm, NativeAccessSpecifierPublic)
	 */
	void UGA_MeleeAttackBase::OnBlendOut(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GA_MeleeAttackBase.OnBlendOut");
		
		UGA_MeleeAttackBase_OnBlendOut_Params params {};
		params.EventTag = EventTag;
		params.EventData = EventData;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017E3600
	 * 		Name   -> Function DungeonCrawler.GA_MeleeAttackBase.MontageJumpToNextSection
	 * 		Flags  -> (Final, Native, Protected)
	 */
	void UGA_MeleeAttackBase::MontageJumpToNextSection()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GA_MeleeAttackBase.MontageJumpToNextSection");
		
		UGA_MeleeAttackBase_MontageJumpToNextSection_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017E2E00
	 * 		Name   -> Function DungeonCrawler.GA_MeleeAttackBase.EventReceived
	 * 		Flags  -> (Native, Protected)
	 * Parameters:
	 * 		struct FGameplayTag                                EventTag                                                   (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FGameplayEventData                          EventData                                                  (Parm, NativeAccessSpecifierPublic)
	 */
	void UGA_MeleeAttackBase::EventReceived(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GA_MeleeAttackBase.EventReceived");
		
		UGA_MeleeAttackBase_EventReceived_Params params {};
		params.EventTag = EventTag;
		params.EventData = EventData;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017E2270
	 * 		Name   -> Function DungeonCrawler.GA_MeleeAttackBase.ClientTargetDataReceived
	 * 		Flags  -> (Native, Event, Protected, BlueprintEvent)
	 * Parameters:
	 * 		struct FGameplayTag                                EventTag                                                   (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FGameplayTag                                InChannelTag                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FGameplayEventData                          EventData                                                  (Parm, NativeAccessSpecifierPublic)
	 */
	void UGA_MeleeAttackBase::ClientTargetDataReceived(const struct FGameplayTag& EventTag, const struct FGameplayTag& InChannelTag, const struct FGameplayEventData& EventData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GA_MeleeAttackBase.ClientTargetDataReceived");
		
		UGA_MeleeAttackBase_ClientTargetDataReceived_Params params {};
		params.EventTag = EventTag;
		params.InChannelTag = InChannelTag;
		params.EventData = EventData;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017E20B0
	 * 		Name   -> Function DungeonCrawler.GA_MeleeAttackBase.ClientReceivedTargetData
	 * 		Flags  -> (Final, Native, Protected, HasOutParms)
	 * Parameters:
	 * 		struct FGameplayTag                                InEffectTag                                                (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FGameplayTag                                InChannelTag                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FGameplayAbilityTargetDataHandle            InData                                                     (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UGA_MeleeAttackBase::ClientReceivedTargetData(const struct FGameplayTag& InEffectTag, const struct FGameplayTag& InChannelTag, const struct FGameplayAbilityTargetDataHandle& InData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GA_MeleeAttackBase.ClientReceivedTargetData");
		
		UGA_MeleeAttackBase_ClientReceivedTargetData_Params params {};
		params.InEffectTag = InEffectTag;
		params.InChannelTag = InChannelTag;
		params.InData = InData;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017E2090
	 * 		Name   -> Function DungeonCrawler.GA_MeleeAttackBase.ChangeToDefaultCrossHair
	 * 		Flags  -> (Final, Native, Protected)
	 */
	void UGA_MeleeAttackBase::ChangeToDefaultCrossHair()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GA_MeleeAttackBase.ChangeToDefaultCrossHair");
		
		UGA_MeleeAttackBase_ChangeToDefaultCrossHair_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017E2070
	 * 		Name   -> Function DungeonCrawler.GA_MeleeAttackBase.ActivateCrossHairAction
	 * 		Flags  -> (Final, Native, Protected)
	 */
	void UGA_MeleeAttackBase::ActivateCrossHairAction()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GA_MeleeAttackBase.ActivateCrossHairAction");
		
		UGA_MeleeAttackBase_ActivateCrossHairAction_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.GA_MeleeAttackBase.AbilityActivated
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 * Parameters:
	 * 		struct FGameplayEventData                          TriggerEventData                                           (ConstParm, Parm, NativeAccessSpecifierPublic)
	 */
	void UGA_MeleeAttackBase::AbilityActivated(const struct FGameplayEventData& TriggerEventData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GA_MeleeAttackBase.AbilityActivated");
		
		UGA_MeleeAttackBase_AbilityActivated_Params params {};
		params.TriggerEventData = TriggerEventData;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGA_MeleeAttackBase.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGA_MeleeAttackBase::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.GA_MeleeAttackBase");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGA_MonsterRangedAttackBase.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGA_MonsterRangedAttackBase::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.GA_MonsterRangedAttackBase");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGA_MonsterChargedRangedAttackBase.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGA_MonsterChargedRangedAttackBase::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.GA_MonsterChargedRangedAttackBase");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGA_MonsterMeleeAttackBase.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGA_MonsterMeleeAttackBase::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.GA_MonsterMeleeAttackBase");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017DD870
	 * 		Name   -> Function DungeonCrawler.GA_MultiShotBase.InputActionStarted
	 * 		Flags  -> (Final, Native, Protected, HasOutParms)
	 * Parameters:
	 * 		struct FInputActionValue                           InputActionValue                                           (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UGA_MultiShotBase::InputActionStarted(const struct FInputActionValue& InputActionValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GA_MultiShotBase.InputActionStarted");
		
		UGA_MultiShotBase_InputActionStarted_Params params {};
		params.InputActionValue = InputActionValue;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017DD7C0
	 * 		Name   -> Function DungeonCrawler.GA_MultiShotBase.InputActionCompleted
	 * 		Flags  -> (Final, Native, Protected, HasOutParms)
	 * Parameters:
	 * 		struct FInputActionValue                           InputActionValue                                           (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UGA_MultiShotBase::InputActionCompleted(const struct FInputActionValue& InputActionValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GA_MultiShotBase.InputActionCompleted");
		
		UGA_MultiShotBase_InputActionCompleted_Params params {};
		params.InputActionValue = InputActionValue;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGA_MultiShotBase.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGA_MultiShotBase::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.GA_MultiShotBase");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017DE8B0
	 * 		Name   -> Function DungeonCrawler.GA_PaviseInstall.ReceivedEvent
	 * 		Flags  -> (Native, Event, Protected, BlueprintEvent)
	 * Parameters:
	 * 		struct FGameplayTag                                EventTag                                                   (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FGameplayEventData                          EventData                                                  (Parm, NativeAccessSpecifierPublic)
	 */
	void UGA_PaviseInstall::ReceivedEvent(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GA_PaviseInstall.ReceivedEvent");
		
		UGA_PaviseInstall_ReceivedEvent_Params params {};
		params.EventTag = EventTag;
		params.EventData = EventData;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017E4160
	 * 		Name   -> Function DungeonCrawler.GA_PaviseInstall.OnInterrupted
	 * 		Flags  -> (Final, Native, Protected)
	 * Parameters:
	 * 		struct FGameplayTag                                EventTag                                                   (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FGameplayEventData                          EventData                                                  (Parm, NativeAccessSpecifierPublic)
	 */
	void UGA_PaviseInstall::OnInterrupted(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GA_PaviseInstall.OnInterrupted");
		
		UGA_PaviseInstall_OnInterrupted_Params params {};
		params.EventTag = EventTag;
		params.EventData = EventData;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017DE4E0
	 * 		Name   -> Function DungeonCrawler.GA_PaviseInstall.OnCompleted
	 * 		Flags  -> (Final, Native, Protected)
	 * Parameters:
	 * 		struct FGameplayTag                                EventTag                                                   (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FGameplayEventData                          EventData                                                  (Parm, NativeAccessSpecifierPublic)
	 */
	void UGA_PaviseInstall::OnCompleted(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GA_PaviseInstall.OnCompleted");
		
		UGA_PaviseInstall_OnCompleted_Params params {};
		params.EventTag = EventTag;
		params.EventData = EventData;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017E3050
	 * 		Name   -> Function DungeonCrawler.GA_PaviseInstall.EventReceived
	 * 		Flags  -> (Final, Native, Protected)
	 * Parameters:
	 * 		struct FGameplayTag                                EventTag                                                   (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FGameplayEventData                          EventData                                                  (Parm, NativeAccessSpecifierPublic)
	 */
	void UGA_PaviseInstall::EventReceived(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GA_PaviseInstall.EventReceived");
		
		UGA_PaviseInstall_EventReceived_Params params {};
		params.EventTag = EventTag;
		params.EventData = EventData;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.GA_PaviseInstall.AbilityActivated
	 * 		Flags  -> (Event, Protected, HasOutParms, BlueprintEvent)
	 * Parameters:
	 * 		struct FGameplayEventData                          TriggerEventData                                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UGA_PaviseInstall::AbilityActivated(const struct FGameplayEventData& TriggerEventData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GA_PaviseInstall.AbilityActivated");
		
		UGA_PaviseInstall_AbilityActivated_Params params {};
		params.TriggerEventData = TriggerEventData;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGA_PaviseInstall.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGA_PaviseInstall::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.GA_PaviseInstall");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGA_Pickpocket.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGA_Pickpocket::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.GA_Pickpocket");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017EA200
	 * 		Name   -> Function DungeonCrawler.GA_PickUp.OnStartSync
	 * 		Flags  -> (Final, Native, Private)
	 */
	void UGA_PickUp::OnStartSync()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GA_PickUp.OnStartSync");
		
		UGA_PickUp_OnStartSync_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017EA050
	 * 		Name   -> Function DungeonCrawler.GA_PickUp.OnPickedUp
	 * 		Flags  -> (Final, Native, Private)
	 * Parameters:
	 * 		class AActor*                                      ItemHolderToPickUp                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bShouldDestroy                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGA_PickUp::OnPickedUp(class AActor* ItemHolderToPickUp, bool bShouldDestroy)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GA_PickUp.OnPickedUp");
		
		UGA_PickUp_OnPickedUp_Params params {};
		params.ItemHolderToPickUp = ItemHolderToPickUp;
		params.bShouldDestroy = bShouldDestroy;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGA_PickUp.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGA_PickUp::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.GA_PickUp");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017EA390
	 * 		Name   -> Function DungeonCrawler.GA_PlayerCharMeleeAttackBase.OtherHandIAStarted
	 * 		Flags  -> (Final, Native, Protected, HasOutParms)
	 * Parameters:
	 * 		struct FInputActionValue                           InputActionValue                                           (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UGA_PlayerCharMeleeAttackBase::OtherHandIAStarted(const struct FInputActionValue& InputActionValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GA_PlayerCharMeleeAttackBase.OtherHandIAStarted");
		
		UGA_PlayerCharMeleeAttackBase_OtherHandIAStarted_Params params {};
		params.InputActionValue = InputActionValue;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017EA2E0
	 * 		Name   -> Function DungeonCrawler.GA_PlayerCharMeleeAttackBase.OtherHandIACompleted
	 * 		Flags  -> (Final, Native, Protected, HasOutParms)
	 * Parameters:
	 * 		struct FInputActionValue                           InputActionValue                                           (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UGA_PlayerCharMeleeAttackBase::OtherHandIACompleted(const struct FInputActionValue& InputActionValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GA_PlayerCharMeleeAttackBase.OtherHandIACompleted");
		
		UGA_PlayerCharMeleeAttackBase_OtherHandIACompleted_Params params {};
		params.InputActionValue = InputActionValue;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017E9130
	 * 		Name   -> Function DungeonCrawler.GA_PlayerCharMeleeAttackBase.ComboIAStarted
	 * 		Flags  -> (Final, Native, Protected, HasOutParms)
	 * Parameters:
	 * 		struct FInputActionValue                           InputActionValue                                           (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UGA_PlayerCharMeleeAttackBase::ComboIAStarted(const struct FInputActionValue& InputActionValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GA_PlayerCharMeleeAttackBase.ComboIAStarted");
		
		UGA_PlayerCharMeleeAttackBase_ComboIAStarted_Params params {};
		params.InputActionValue = InputActionValue;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017E9080
	 * 		Name   -> Function DungeonCrawler.GA_PlayerCharMeleeAttackBase.ComboIACompleted
	 * 		Flags  -> (Final, Native, Protected, HasOutParms)
	 * Parameters:
	 * 		struct FInputActionValue                           InputActionValue                                           (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UGA_PlayerCharMeleeAttackBase::ComboIACompleted(const struct FInputActionValue& InputActionValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GA_PlayerCharMeleeAttackBase.ComboIACompleted");
		
		UGA_PlayerCharMeleeAttackBase_ComboIACompleted_Params params {};
		params.InputActionValue = InputActionValue;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGA_PlayerCharMeleeAttackBase.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGA_PlayerCharMeleeAttackBase::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.GA_PlayerCharMeleeAttackBase");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.GA_PlayerSkillBase.AbilityActivated
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 * Parameters:
	 * 		struct FGameplayEventData                          TriggerEventData                                           (ConstParm, Parm, NativeAccessSpecifierPublic)
	 */
	void UGA_PlayerSkillBase::AbilityActivated(const struct FGameplayEventData& TriggerEventData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GA_PlayerSkillBase.AbilityActivated");
		
		UGA_PlayerSkillBase_AbilityActivated_Params params {};
		params.TriggerEventData = TriggerEventData;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGA_PlayerSkillBase.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGA_PlayerSkillBase::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.GA_PlayerSkillBase");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017E4F30
	 * 		Name   -> Function DungeonCrawler.GA_PlayerSkillCastBase.ReceivedEvent
	 * 		Flags  -> (Native, Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		struct FGameplayTag                                EventTag                                                   (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FGameplayEventData                          EventData                                                  (Parm, NativeAccessSpecifierPublic)
	 */
	void UGA_PlayerSkillCastBase::ReceivedEvent(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GA_PlayerSkillCastBase.ReceivedEvent");
		
		UGA_PlayerSkillCastBase_ReceivedEvent_Params params {};
		params.EventTag = EventTag;
		params.EventData = EventData;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017EA2C0
	 * 		Name   -> Function DungeonCrawler.GA_PlayerSkillCastBase.OnVelocityChange_Channeling
	 * 		Flags  -> (Final, Native, Public)
	 */
	void UGA_PlayerSkillCastBase::OnVelocityChange_Channeling()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GA_PlayerSkillCastBase.OnVelocityChange_Channeling");
		
		UGA_PlayerSkillCastBase_OnVelocityChange_Channeling_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017EA2A0
	 * 		Name   -> Function DungeonCrawler.GA_PlayerSkillCastBase.OnVelocityChange_Casting
	 * 		Flags  -> (Final, Native, Public)
	 */
	void UGA_PlayerSkillCastBase::OnVelocityChange_Casting()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GA_PlayerSkillCastBase.OnVelocityChange_Casting");
		
		UGA_PlayerSkillCastBase_OnVelocityChange_Casting_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.GA_PlayerSkillCastBase.OnSkillActived_Server
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		struct FGameplayTag                                SkillTag                                                   (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FGameplayTag                                CooldownTag                                                (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGA_PlayerSkillCastBase::OnSkillActived_Server(const struct FGameplayTag& SkillTag, const struct FGameplayTag& CooldownTag)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GA_PlayerSkillCastBase.OnSkillActived_Server");
		
		UGA_PlayerSkillCastBase_OnSkillActived_Server_Params params {};
		params.SkillTag = SkillTag;
		params.CooldownTag = CooldownTag;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.GA_PlayerSkillCastBase.OnSkillActived_Client
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		struct FGameplayTag                                SkillTag                                                   (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FGameplayTag                                CooldownTag                                                (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGA_PlayerSkillCastBase::OnSkillActived_Client(const struct FGameplayTag& SkillTag, const struct FGameplayTag& CooldownTag)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GA_PlayerSkillCastBase.OnSkillActived_Client");
		
		UGA_PlayerSkillCastBase_OnSkillActived_Client_Params params {};
		params.SkillTag = SkillTag;
		params.CooldownTag = CooldownTag;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017EA1E0
	 * 		Name   -> Function DungeonCrawler.GA_PlayerSkillCastBase.OnSkillActive
	 * 		Flags  -> (Final, Native, Public)
	 */
	void UGA_PlayerSkillCastBase::OnSkillActive()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GA_PlayerSkillCastBase.OnSkillActive");
		
		UGA_PlayerSkillCastBase_OnSkillActive_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017E2510
	 * 		Name   -> Function DungeonCrawler.GA_PlayerSkillCastBase.OnInterrupted
	 * 		Flags  -> (Native, Public)
	 * Parameters:
	 * 		struct FGameplayTag                                EventTag                                                   (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FGameplayEventData                          EventData                                                  (Parm, NativeAccessSpecifierPublic)
	 */
	void UGA_PlayerSkillCastBase::OnInterrupted(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GA_PlayerSkillCastBase.OnInterrupted");
		
		UGA_PlayerSkillCastBase_OnInterrupted_Params params {};
		params.EventTag = EventTag;
		params.EventData = EventData;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017E3870
	 * 		Name   -> Function DungeonCrawler.GA_PlayerSkillCastBase.OnCompleted
	 * 		Flags  -> (Native, Public)
	 * Parameters:
	 * 		struct FGameplayTag                                EventTag                                                   (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FGameplayEventData                          EventData                                                  (Parm, NativeAccessSpecifierPublic)
	 */
	void UGA_PlayerSkillCastBase::OnCompleted(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GA_PlayerSkillCastBase.OnCompleted");
		
		UGA_PlayerSkillCastBase_OnCompleted_Params params {};
		params.EventTag = EventTag;
		params.EventData = EventData;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.GA_PlayerSkillCastBase.OnChannelingStartTrigger
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 */
	void UGA_PlayerSkillCastBase::OnChannelingStartTrigger()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GA_PlayerSkillCastBase.OnChannelingStartTrigger");
		
		UGA_PlayerSkillCastBase_OnChannelingStartTrigger_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017E9FB0
	 * 		Name   -> Function DungeonCrawler.GA_PlayerSkillCastBase.OnChannelingStartSync
	 * 		Flags  -> (Final, Native, Public)
	 */
	void UGA_PlayerSkillCastBase::OnChannelingStartSync()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GA_PlayerSkillCastBase.OnChannelingStartSync");
		
		UGA_PlayerSkillCastBase_OnChannelingStartSync_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017E9F90
	 * 		Name   -> Function DungeonCrawler.GA_PlayerSkillCastBase.OnChannelingReadySync
	 * 		Flags  -> (Final, Native, Public)
	 */
	void UGA_PlayerSkillCastBase::OnChannelingReadySync()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GA_PlayerSkillCastBase.OnChannelingReadySync");
		
		UGA_PlayerSkillCastBase_OnChannelingReadySync_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017E9F50
	 * 		Name   -> Function DungeonCrawler.GA_PlayerSkillCastBase.OnChannelingFinishSync
	 * 		Flags  -> (Final, Native, Public)
	 */
	void UGA_PlayerSkillCastBase::OnChannelingFinishSync()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GA_PlayerSkillCastBase.OnChannelingFinishSync");
		
		UGA_PlayerSkillCastBase_OnChannelingFinishSync_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017E9F10
	 * 		Name   -> Function DungeonCrawler.GA_PlayerSkillCastBase.OnChannelingFinish
	 * 		Flags  -> (Final, Native, Public)
	 */
	void UGA_PlayerSkillCastBase::OnChannelingFinish()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GA_PlayerSkillCastBase.OnChannelingFinish");
		
		UGA_PlayerSkillCastBase_OnChannelingFinish_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.GA_PlayerSkillCastBase.OnChannelingActivate
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		struct FGameplayEventData                          EventData                                                  (Parm, NativeAccessSpecifierPublic)
	 * 		struct FGameplayCueParameters                      CueParams                                                  (Parm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	void UGA_PlayerSkillCastBase::OnChannelingActivate(const struct FGameplayEventData& EventData, const struct FGameplayCueParameters& CueParams)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GA_PlayerSkillCastBase.OnChannelingActivate");
		
		UGA_PlayerSkillCastBase_OnChannelingActivate_Params params {};
		params.EventData = EventData;
		params.CueParams = CueParams;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017E9DF0
	 * 		Name   -> Function DungeonCrawler.GA_PlayerSkillCastBase.OnChannelingAction
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		int32_t                                            ActionCount                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGA_PlayerSkillCastBase::OnChannelingAction(int32_t ActionCount)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GA_PlayerSkillCastBase.OnChannelingAction");
		
		UGA_PlayerSkillCastBase_OnChannelingAction_Params params {};
		params.ActionCount = ActionCount;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.GA_PlayerSkillCastBase.OnCastingStartTrigger
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 */
	void UGA_PlayerSkillCastBase::OnCastingStartTrigger()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GA_PlayerSkillCastBase.OnCastingStartTrigger");
		
		UGA_PlayerSkillCastBase_OnCastingStartTrigger_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017E9DD0
	 * 		Name   -> Function DungeonCrawler.GA_PlayerSkillCastBase.OnCastingStartSync
	 * 		Flags  -> (Final, Native, Public)
	 */
	void UGA_PlayerSkillCastBase::OnCastingStartSync()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GA_PlayerSkillCastBase.OnCastingStartSync");
		
		UGA_PlayerSkillCastBase_OnCastingStartSync_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017E9DB0
	 * 		Name   -> Function DungeonCrawler.GA_PlayerSkillCastBase.OnCastingFinishSync
	 * 		Flags  -> (Final, Native, Public)
	 */
	void UGA_PlayerSkillCastBase::OnCastingFinishSync()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GA_PlayerSkillCastBase.OnCastingFinishSync");
		
		UGA_PlayerSkillCastBase_OnCastingFinishSync_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017E9D90
	 * 		Name   -> Function DungeonCrawler.GA_PlayerSkillCastBase.OnCastingFinish
	 * 		Flags  -> (Final, Native, Public)
	 */
	void UGA_PlayerSkillCastBase::OnCastingFinish()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GA_PlayerSkillCastBase.OnCastingFinish");
		
		UGA_PlayerSkillCastBase_OnCastingFinish_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017DE8B0
	 * 		Name   -> Function DungeonCrawler.GA_PlayerSkillCastBase.OnCancelled
	 * 		Flags  -> (Native, Public)
	 * Parameters:
	 * 		struct FGameplayTag                                EventTag                                                   (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FGameplayEventData                          EventData                                                  (Parm, NativeAccessSpecifierPublic)
	 */
	void UGA_PlayerSkillCastBase::OnCancelled(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GA_PlayerSkillCastBase.OnCancelled");
		
		UGA_PlayerSkillCastBase_OnCancelled_Params params {};
		params.EventTag = EventTag;
		params.EventData = EventData;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017E3620
	 * 		Name   -> Function DungeonCrawler.GA_PlayerSkillCastBase.OnBlendOut
	 * 		Flags  -> (Native, Public)
	 * Parameters:
	 * 		struct FGameplayTag                                EventTag                                                   (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FGameplayEventData                          EventData                                                  (Parm, NativeAccessSpecifierPublic)
	 */
	void UGA_PlayerSkillCastBase::OnBlendOut(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GA_PlayerSkillCastBase.OnBlendOut");
		
		UGA_PlayerSkillCastBase_OnBlendOut_Params params {};
		params.EventTag = EventTag;
		params.EventData = EventData;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017E9A20
	 * 		Name   -> Function DungeonCrawler.GA_PlayerSkillCastBase.IsVisibleWeapon
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               IsVisible                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGA_PlayerSkillCastBase::IsVisibleWeapon(bool IsVisible)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GA_PlayerSkillCastBase.IsVisibleWeapon");
		
		UGA_PlayerSkillCastBase_IsVisibleWeapon_Params params {};
		params.IsVisible = IsVisible;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017E2E00
	 * 		Name   -> Function DungeonCrawler.GA_PlayerSkillCastBase.EventReceived
	 * 		Flags  -> (Native, Public)
	 * Parameters:
	 * 		struct FGameplayTag                                EventTag                                                   (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FGameplayEventData                          EventData                                                  (Parm, NativeAccessSpecifierPublic)
	 */
	void UGA_PlayerSkillCastBase::EventReceived(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GA_PlayerSkillCastBase.EventReceived");
		
		UGA_PlayerSkillCastBase_EventReceived_Params params {};
		params.EventTag = EventTag;
		params.EventData = EventData;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017E9480
	 * 		Name   -> Function DungeonCrawler.GA_PlayerSkillCastBase.EndAbilityWhenSkillEvent
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void UGA_PlayerSkillCastBase::EndAbilityWhenSkillEvent()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GA_PlayerSkillCastBase.EndAbilityWhenSkillEvent");
		
		UGA_PlayerSkillCastBase_EndAbilityWhenSkillEvent_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017E8CF0
	 * 		Name   -> Function DungeonCrawler.GA_PlayerSkillCastBase.CheckedApplyCooldownTag
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		struct FGameplayEffectSpecHandle                   SpecHandle                                                 (Parm, NativeAccessSpecifierPublic)
	 * 		struct FActiveGameplayEffectHandle                 ActiveHandle                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGA_PlayerSkillCastBase::CheckedApplyCooldownTag(const struct FGameplayEffectSpecHandle& SpecHandle, const struct FActiveGameplayEffectHandle& ActiveHandle)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GA_PlayerSkillCastBase.CheckedApplyCooldownTag");
		
		UGA_PlayerSkillCastBase_CheckedApplyCooldownTag_Params params {};
		params.SpecHandle = SpecHandle;
		params.ActiveHandle = ActiveHandle;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.GA_PlayerSkillCastBase.Activated_CooldownAfter_Client
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		struct FGameplayTag                                SkillTag                                                   (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FGameplayTag                                CooldownTag                                                (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              CooldownDuration                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGA_PlayerSkillCastBase::Activated_CooldownAfter_Client(const struct FGameplayTag& SkillTag, const struct FGameplayTag& CooldownTag, float CooldownDuration)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GA_PlayerSkillCastBase.Activated_CooldownAfter_Client");
		
		UGA_PlayerSkillCastBase_Activated_CooldownAfter_Client_Params params {};
		params.SkillTag = SkillTag;
		params.CooldownTag = CooldownTag;
		params.CooldownDuration = CooldownDuration;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGA_PlayerSkillCastBase.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGA_PlayerSkillCastBase::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.GA_PlayerSkillCastBase");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017EA750
	 * 		Name   -> Function DungeonCrawler.GA_PlayerSkillRouterBase.SendSystemMessage
	 * 		Flags  -> (Final, Native, Protected, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		class FText                                        SystemMessage                                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UGA_PlayerSkillRouterBase::SendSystemMessage(const class FText& SystemMessage)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GA_PlayerSkillRouterBase.SendSystemMessage");
		
		UGA_PlayerSkillRouterBase_SendSystemMessage_Params params {};
		params.SystemMessage = SystemMessage;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.GA_PlayerSkillRouterBase.OnSystemMessage
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 */
	void UGA_PlayerSkillRouterBase::OnSystemMessage()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GA_PlayerSkillRouterBase.OnSystemMessage");
		
		UGA_PlayerSkillRouterBase_OnSystemMessage_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017EA140
	 * 		Name   -> Function DungeonCrawler.GA_PlayerSkillRouterBase.OnRoutedAbilityEnded
	 * 		Flags  -> (Final, Native, Private, HasOutParms)
	 * Parameters:
	 * 		struct FAbilityEndedData                           AbilityEndedData                                           (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UGA_PlayerSkillRouterBase::OnRoutedAbilityEnded(const struct FAbilityEndedData& AbilityEndedData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GA_PlayerSkillRouterBase.OnRoutedAbilityEnded");
		
		UGA_PlayerSkillRouterBase_OnRoutedAbilityEnded_Params params {};
		params.AbilityEndedData = AbilityEndedData;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGA_PlayerSkillRouterBase.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGA_PlayerSkillRouterBase::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.GA_PlayerSkillRouterBase");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.GA_PlayerSpellCastBase.SpellFireEvent
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 */
	void UGA_PlayerSpellCastBase::SpellFireEvent()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GA_PlayerSpellCastBase.SpellFireEvent");
		
		UGA_PlayerSpellCastBase_SpellFireEvent_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017EA820
	 * 		Name   -> Function DungeonCrawler.GA_PlayerSpellCastBase.ServerReceivedTargetData
	 * 		Flags  -> (Final, Native, Protected, HasOutParms)
	 * Parameters:
	 * 		struct FGameplayTag                                InEffectTag                                                (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FGameplayTag                                InChannelTag                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FGameplayAbilityTargetDataHandle            InData                                                     (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UGA_PlayerSpellCastBase::ServerReceivedTargetData(const struct FGameplayTag& InEffectTag, const struct FGameplayTag& InChannelTag, const struct FGameplayAbilityTargetDataHandle& InData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GA_PlayerSpellCastBase.ServerReceivedTargetData");
		
		UGA_PlayerSpellCastBase_ServerReceivedTargetData_Params params {};
		params.InEffectTag = InEffectTag;
		params.InChannelTag = InChannelTag;
		params.InData = InData;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017EA6C0
	 * 		Name   -> Function DungeonCrawler.GA_PlayerSpellCastBase.SendActivateSpellCrossHairNotify
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		bool                                               IsActivate                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGA_PlayerSpellCastBase::SendActivateSpellCrossHairNotify(bool IsActivate)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GA_PlayerSpellCastBase.SendActivateSpellCrossHairNotify");
		
		UGA_PlayerSpellCastBase_SendActivateSpellCrossHairNotify_Params params {};
		params.IsActivate = IsActivate;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017EA440
	 * 		Name   -> Function DungeonCrawler.GA_PlayerSpellCastBase.ReceivedTargetData
	 * 		Flags  -> (Final, Native, Protected, HasOutParms)
	 * Parameters:
	 * 		struct FGameplayAbilityTargetDataHandle            InData                                                     (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UGA_PlayerSpellCastBase::ReceivedTargetData(const struct FGameplayAbilityTargetDataHandle& InData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GA_PlayerSpellCastBase.ReceivedTargetData");
		
		UGA_PlayerSpellCastBase_ReceivedTargetData_Params params {};
		params.InData = InData;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017E4F30
	 * 		Name   -> Function DungeonCrawler.GA_PlayerSpellCastBase.ReceivedEvent
	 * 		Flags  -> (Native, Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		struct FGameplayTag                                EventTag                                                   (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FGameplayEventData                          EventData                                                  (Parm, NativeAccessSpecifierPublic)
	 */
	void UGA_PlayerSpellCastBase::ReceivedEvent(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GA_PlayerSpellCastBase.ReceivedEvent");
		
		UGA_PlayerSpellCastBase_ReceivedEvent_Params params {};
		params.EventTag = EventTag;
		params.EventData = EventData;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017EA280
	 * 		Name   -> Function DungeonCrawler.GA_PlayerSpellCastBase.OnVelocityChange
	 * 		Flags  -> (Final, Native, Public)
	 */
	void UGA_PlayerSpellCastBase::OnVelocityChange()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GA_PlayerSpellCastBase.OnVelocityChange");
		
		UGA_PlayerSpellCastBase_OnVelocityChange_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017EA260
	 * 		Name   -> Function DungeonCrawler.GA_PlayerSpellCastBase.OnStuckFinish
	 * 		Flags  -> (Final, Native, Protected)
	 */
	void UGA_PlayerSpellCastBase::OnStuckFinish()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GA_PlayerSpellCastBase.OnStuckFinish");
		
		UGA_PlayerSpellCastBase_OnStuckFinish_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017EA240
	 * 		Name   -> Function DungeonCrawler.GA_PlayerSpellCastBase.OnStuck
	 * 		Flags  -> (Final, Native, Protected)
	 */
	void UGA_PlayerSpellCastBase::OnStuck()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GA_PlayerSpellCastBase.OnStuck");
		
		UGA_PlayerSpellCastBase_OnStuck_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017EA220
	 * 		Name   -> Function DungeonCrawler.GA_PlayerSpellCastBase.OnStartSync
	 * 		Flags  -> (Final, Native, Public)
	 */
	void UGA_PlayerSpellCastBase::OnStartSync()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GA_PlayerSpellCastBase.OnStartSync");
		
		UGA_PlayerSpellCastBase_OnStartSync_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017EA120
	 * 		Name   -> Function DungeonCrawler.GA_PlayerSpellCastBase.OnRelease
	 * 		Flags  -> (Final, Native, Public)
	 */
	void UGA_PlayerSpellCastBase::OnRelease()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GA_PlayerSpellCastBase.OnRelease");
		
		UGA_PlayerSpellCastBase_OnRelease_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00A2B690
	 * 		Name   -> Function DungeonCrawler.GA_PlayerSpellCastBase.OnInterruptFinish
	 * 		Flags  -> (Final, Native, Protected)
	 */
	void UGA_PlayerSpellCastBase::OnInterruptFinish()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GA_PlayerSpellCastBase.OnInterruptFinish");
		
		UGA_PlayerSpellCastBase_OnInterruptFinish_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017E2510
	 * 		Name   -> Function DungeonCrawler.GA_PlayerSpellCastBase.OnInterrupted
	 * 		Flags  -> (Native, Public)
	 * Parameters:
	 * 		struct FGameplayTag                                EventTag                                                   (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FGameplayEventData                          EventData                                                  (Parm, NativeAccessSpecifierPublic)
	 */
	void UGA_PlayerSpellCastBase::OnInterrupted(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GA_PlayerSpellCastBase.OnInterrupted");
		
		UGA_PlayerSpellCastBase_OnInterrupted_Params params {};
		params.EventTag = EventTag;
		params.EventData = EventData;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017EA030
	 * 		Name   -> Function DungeonCrawler.GA_PlayerSpellCastBase.OnFire
	 * 		Flags  -> (Final, Native, Public)
	 */
	void UGA_PlayerSpellCastBase::OnFire()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GA_PlayerSpellCastBase.OnFire");
		
		UGA_PlayerSpellCastBase_OnFire_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017EA010
	 * 		Name   -> Function DungeonCrawler.GA_PlayerSpellCastBase.OnFinishSync
	 * 		Flags  -> (Final, Native, Public)
	 */
	void UGA_PlayerSpellCastBase::OnFinishSync()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GA_PlayerSpellCastBase.OnFinishSync");
		
		UGA_PlayerSpellCastBase_OnFinishSync_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017E9FF0
	 * 		Name   -> Function DungeonCrawler.GA_PlayerSpellCastBase.OnFinish
	 * 		Flags  -> (Final, Native, Public)
	 */
	void UGA_PlayerSpellCastBase::OnFinish()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GA_PlayerSpellCastBase.OnFinish");
		
		UGA_PlayerSpellCastBase_OnFinish_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017E3870
	 * 		Name   -> Function DungeonCrawler.GA_PlayerSpellCastBase.OnCompleted
	 * 		Flags  -> (Native, Public)
	 * Parameters:
	 * 		struct FGameplayTag                                EventTag                                                   (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FGameplayEventData                          EventData                                                  (Parm, NativeAccessSpecifierPublic)
	 */
	void UGA_PlayerSpellCastBase::OnCompleted(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GA_PlayerSpellCastBase.OnCompleted");
		
		UGA_PlayerSpellCastBase_OnCompleted_Params params {};
		params.EventTag = EventTag;
		params.EventData = EventData;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017E9FD0
	 * 		Name   -> Function DungeonCrawler.GA_PlayerSpellCastBase.OnChannelingTriggerSync
	 * 		Flags  -> (Final, Native, Public)
	 */
	void UGA_PlayerSpellCastBase::OnChannelingTriggerSync()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GA_PlayerSpellCastBase.OnChannelingTriggerSync");
		
		UGA_PlayerSpellCastBase_OnChannelingTriggerSync_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017E9F70
	 * 		Name   -> Function DungeonCrawler.GA_PlayerSpellCastBase.OnChannelingFinishSync
	 * 		Flags  -> (Final, Native, Public)
	 */
	void UGA_PlayerSpellCastBase::OnChannelingFinishSync()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GA_PlayerSpellCastBase.OnChannelingFinishSync");
		
		UGA_PlayerSpellCastBase_OnChannelingFinishSync_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017E9F30
	 * 		Name   -> Function DungeonCrawler.GA_PlayerSpellCastBase.OnChannelingFinish
	 * 		Flags  -> (Final, Native, Public)
	 */
	void UGA_PlayerSpellCastBase::OnChannelingFinish()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GA_PlayerSpellCastBase.OnChannelingFinish");
		
		UGA_PlayerSpellCastBase_OnChannelingFinish_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017E9E80
	 * 		Name   -> Function DungeonCrawler.GA_PlayerSpellCastBase.OnChannelingAction
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		int32_t                                            ActionCounter                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGA_PlayerSpellCastBase::OnChannelingAction(int32_t ActionCounter)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GA_PlayerSpellCastBase.OnChannelingAction");
		
		UGA_PlayerSpellCastBase_OnChannelingAction_Params params {};
		params.ActionCounter = ActionCounter;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017E9D70
	 * 		Name   -> Function DungeonCrawler.GA_PlayerSpellCastBase.OnCastTriggerSync
	 * 		Flags  -> (Final, Native, Public)
	 */
	void UGA_PlayerSpellCastBase::OnCastTriggerSync()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GA_PlayerSpellCastBase.OnCastTriggerSync");
		
		UGA_PlayerSpellCastBase_OnCastTriggerSync_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017DE8B0
	 * 		Name   -> Function DungeonCrawler.GA_PlayerSpellCastBase.OnCancelled
	 * 		Flags  -> (Native, Public)
	 * Parameters:
	 * 		struct FGameplayTag                                EventTag                                                   (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FGameplayEventData                          EventData                                                  (Parm, NativeAccessSpecifierPublic)
	 */
	void UGA_PlayerSpellCastBase::OnCancelled(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GA_PlayerSpellCastBase.OnCancelled");
		
		UGA_PlayerSpellCastBase_OnCancelled_Params params {};
		params.EventTag = EventTag;
		params.EventData = EventData;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017E3620
	 * 		Name   -> Function DungeonCrawler.GA_PlayerSpellCastBase.OnBlendOut
	 * 		Flags  -> (Native, Public)
	 * Parameters:
	 * 		struct FGameplayTag                                EventTag                                                   (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FGameplayEventData                          EventData                                                  (Parm, NativeAccessSpecifierPublic)
	 */
	void UGA_PlayerSpellCastBase::OnBlendOut(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GA_PlayerSpellCastBase.OnBlendOut");
		
		UGA_PlayerSpellCastBase_OnBlendOut_Params params {};
		params.EventTag = EventTag;
		params.EventData = EventData;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017E2E00
	 * 		Name   -> Function DungeonCrawler.GA_PlayerSpellCastBase.EventReceived
	 * 		Flags  -> (Native, Public)
	 * Parameters:
	 * 		struct FGameplayTag                                EventTag                                                   (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FGameplayEventData                          EventData                                                  (Parm, NativeAccessSpecifierPublic)
	 */
	void UGA_PlayerSpellCastBase::EventReceived(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GA_PlayerSpellCastBase.EventReceived");
		
		UGA_PlayerSpellCastBase_EventReceived_Params params {};
		params.EventTag = EventTag;
		params.EventData = EventData;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017E8EC0
	 * 		Name   -> Function DungeonCrawler.GA_PlayerSpellCastBase.ClientReceivedTargetData
	 * 		Flags  -> (Final, Native, Protected, HasOutParms)
	 * Parameters:
	 * 		struct FGameplayTag                                InEffectTag                                                (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FGameplayTag                                InChannelTag                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FGameplayAbilityTargetDataHandle            InData                                                     (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UGA_PlayerSpellCastBase::ClientReceivedTargetData(const struct FGameplayTag& InEffectTag, const struct FGameplayTag& InChannelTag, const struct FGameplayAbilityTargetDataHandle& InData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GA_PlayerSpellCastBase.ClientReceivedTargetData");
		
		UGA_PlayerSpellCastBase_ClientReceivedTargetData_Params params {};
		params.InEffectTag = InEffectTag;
		params.InChannelTag = InChannelTag;
		params.InData = InData;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.GA_PlayerSpellCastBase.CastingFinishEvent
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		struct FDesignDataSpell                            CurentDesignSpellData                                      (Parm, NativeAccessSpecifierPublic)
	 */
	void UGA_PlayerSpellCastBase::CastingFinishEvent(const struct FDesignDataSpell& CurentDesignSpellData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GA_PlayerSpellCastBase.CastingFinishEvent");
		
		UGA_PlayerSpellCastBase_CastingFinishEvent_Params params {};
		params.CurentDesignSpellData = CurentDesignSpellData;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.GA_PlayerSpellCastBase.AbilityActivated
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		struct FGameplayEventData                          TriggerEventData                                           (ConstParm, Parm, NativeAccessSpecifierPublic)
	 */
	void UGA_PlayerSpellCastBase::AbilityActivated(const struct FGameplayEventData& TriggerEventData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GA_PlayerSpellCastBase.AbilityActivated");
		
		UGA_PlayerSpellCastBase_AbilityActivated_Params params {};
		params.TriggerEventData = TriggerEventData;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGA_PlayerSpellCastBase.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGA_PlayerSpellCastBase::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.GA_PlayerSpellCastBase");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017E2510
	 * 		Name   -> Function DungeonCrawler.GA_PlayMontageAndWaitForEvent.ReceivedEvent
	 * 		Flags  -> (Native, Event, Protected, BlueprintEvent)
	 * Parameters:
	 * 		struct FGameplayTag                                EventTag                                                   (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FGameplayEventData                          EventData                                                  (Parm, NativeAccessSpecifierPublic)
	 */
	void UGA_PlayMontageAndWaitForEvent::ReceivedEvent(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GA_PlayMontageAndWaitForEvent.ReceivedEvent");
		
		UGA_PlayMontageAndWaitForEvent_ReceivedEvent_Params params {};
		params.EventTag = EventTag;
		params.EventData = EventData;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017DE4E0
	 * 		Name   -> Function DungeonCrawler.GA_PlayMontageAndWaitForEvent.OnCompleted
	 * 		Flags  -> (Final, Native, Protected)
	 * Parameters:
	 * 		struct FGameplayTag                                EventTag                                                   (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FGameplayEventData                          EventData                                                  (Parm, NativeAccessSpecifierPublic)
	 */
	void UGA_PlayMontageAndWaitForEvent::OnCompleted(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GA_PlayMontageAndWaitForEvent.OnCompleted");
		
		UGA_PlayMontageAndWaitForEvent_OnCompleted_Params params {};
		params.EventTag = EventTag;
		params.EventData = EventData;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017DE290
	 * 		Name   -> Function DungeonCrawler.GA_PlayMontageAndWaitForEvent.OnCancelled
	 * 		Flags  -> (Final, Native, Protected)
	 * Parameters:
	 * 		struct FGameplayTag                                EventTag                                                   (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FGameplayEventData                          EventData                                                  (Parm, NativeAccessSpecifierPublic)
	 */
	void UGA_PlayMontageAndWaitForEvent::OnCancelled(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GA_PlayMontageAndWaitForEvent.OnCancelled");
		
		UGA_PlayMontageAndWaitForEvent_OnCancelled_Params params {};
		params.EventTag = EventTag;
		params.EventData = EventData;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017DE8B0
	 * 		Name   -> Function DungeonCrawler.GA_PlayMontageAndWaitForEvent.EventReceived
	 * 		Flags  -> (Native, Protected)
	 * Parameters:
	 * 		struct FGameplayTag                                EventTag                                                   (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FGameplayEventData                          EventData                                                  (Parm, NativeAccessSpecifierPublic)
	 */
	void UGA_PlayMontageAndWaitForEvent::EventReceived(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GA_PlayMontageAndWaitForEvent.EventReceived");
		
		UGA_PlayMontageAndWaitForEvent_EventReceived_Params params {};
		params.EventTag = EventTag;
		params.EventData = EventData;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.GA_PlayMontageAndWaitForEvent.AbilityActivated
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 * Parameters:
	 * 		struct FGameplayEventData                          TriggerEventData                                           (ConstParm, Parm, NativeAccessSpecifierPublic)
	 */
	void UGA_PlayMontageAndWaitForEvent::AbilityActivated(const struct FGameplayEventData& TriggerEventData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GA_PlayMontageAndWaitForEvent.AbilityActivated");
		
		UGA_PlayMontageAndWaitForEvent_AbilityActivated_Params params {};
		params.TriggerEventData = TriggerEventData;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGA_PlayMontageAndWaitForEvent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGA_PlayMontageAndWaitForEvent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.GA_PlayMontageAndWaitForEvent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017EA9E0
	 * 		Name   -> Function DungeonCrawler.GA_ProjectileCollision.TargetDataReceived
	 * 		Flags  -> (Native, Event, Protected, HasOutParms, BlueprintEvent)
	 * Parameters:
	 * 		struct FHitResult                                  Hit                                                        (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	void UGA_ProjectileCollision::TargetDataReceived(const struct FHitResult& Hit)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GA_ProjectileCollision.TargetDataReceived");
		
		UGA_ProjectileCollision_TargetDataReceived_Params params {};
		params.Hit = Hit;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017EA580
	 * 		Name   -> Function DungeonCrawler.GA_ProjectileCollision.ReceivedTargetData
	 * 		Flags  -> (Final, Native, Protected, HasOutParms)
	 * Parameters:
	 * 		struct FGameplayAbilityTargetDataHandle            Data                                                       (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UGA_ProjectileCollision::ReceivedTargetData(const struct FGameplayAbilityTargetDataHandle& Data)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GA_ProjectileCollision.ReceivedTargetData");
		
		UGA_ProjectileCollision_ReceivedTargetData_Params params {};
		params.Data = Data;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGA_ProjectileCollision.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGA_ProjectileCollision::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.GA_ProjectileCollision");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGA_PropsMeleeAttackBase.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGA_PropsMeleeAttackBase::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.GA_PropsMeleeAttackBase");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017DE8B0
	 * 		Name   -> Function DungeonCrawler.GA_ReloadAmmoBase.ReceivedEvent
	 * 		Flags  -> (Native, Event, Protected, BlueprintEvent)
	 * Parameters:
	 * 		struct FGameplayTag                                EventTag                                                   (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FGameplayEventData                          EventData                                                  (Parm, NativeAccessSpecifierPublic)
	 */
	void UGA_ReloadAmmoBase::ReceivedEvent(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GA_ReloadAmmoBase.ReceivedEvent");
		
		UGA_ReloadAmmoBase_ReceivedEvent_Params params {};
		params.EventTag = EventTag;
		params.EventData = EventData;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.GA_ReloadAmmoBase.OnReloadSucceed
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 */
	void UGA_ReloadAmmoBase::OnReloadSucceed()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GA_ReloadAmmoBase.OnReloadSucceed");
		
		UGA_ReloadAmmoBase_OnReloadSucceed_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017EF830
	 * 		Name   -> Function DungeonCrawler.GA_ReloadAmmoBase.OnReload
	 * 		Flags  -> (Final, Native, Protected)
	 */
	void UGA_ReloadAmmoBase::OnReload()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GA_ReloadAmmoBase.OnReload");
		
		UGA_ReloadAmmoBase_OnReload_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017DE4E0
	 * 		Name   -> Function DungeonCrawler.GA_ReloadAmmoBase.OnCompleted
	 * 		Flags  -> (Final, Native, Protected)
	 * Parameters:
	 * 		struct FGameplayTag                                EventTag                                                   (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FGameplayEventData                          EventData                                                  (Parm, NativeAccessSpecifierPublic)
	 */
	void UGA_ReloadAmmoBase::OnCompleted(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GA_ReloadAmmoBase.OnCompleted");
		
		UGA_ReloadAmmoBase_OnCompleted_Params params {};
		params.EventTag = EventTag;
		params.EventData = EventData;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017DE290
	 * 		Name   -> Function DungeonCrawler.GA_ReloadAmmoBase.OnCancelled
	 * 		Flags  -> (Final, Native, Protected)
	 * Parameters:
	 * 		struct FGameplayTag                                EventTag                                                   (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FGameplayEventData                          EventData                                                  (Parm, NativeAccessSpecifierPublic)
	 */
	void UGA_ReloadAmmoBase::OnCancelled(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GA_ReloadAmmoBase.OnCancelled");
		
		UGA_ReloadAmmoBase_OnCancelled_Params params {};
		params.EventTag = EventTag;
		params.EventData = EventData;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017EE640
	 * 		Name   -> Function DungeonCrawler.GA_ReloadAmmoBase.EventReceived
	 * 		Flags  -> (Final, Native, Protected)
	 * Parameters:
	 * 		struct FGameplayTag                                EventTag                                                   (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FGameplayEventData                          EventData                                                  (Parm, NativeAccessSpecifierPublic)
	 */
	void UGA_ReloadAmmoBase::EventReceived(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GA_ReloadAmmoBase.EventReceived");
		
		UGA_ReloadAmmoBase_EventReceived_Params params {};
		params.EventTag = EventTag;
		params.EventData = EventData;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017EE450
	 * 		Name   -> Function DungeonCrawler.GA_ReloadAmmoBase.CancelReloadByCrossHairAim
	 * 		Flags  -> (Final, Native, Protected)
	 */
	void UGA_ReloadAmmoBase::CancelReloadByCrossHairAim()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GA_ReloadAmmoBase.CancelReloadByCrossHairAim");
		
		UGA_ReloadAmmoBase_CancelReloadByCrossHairAim_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017EE380
	 * 		Name   -> Function DungeonCrawler.GA_ReloadAmmoBase.ActivateCrossHairPullAnimationByCrossbow
	 * 		Flags  -> (Final, Native, Protected)
	 * Parameters:
	 * 		float                                              ActionSpeed                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGA_ReloadAmmoBase::ActivateCrossHairPullAnimationByCrossbow(float ActionSpeed)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GA_ReloadAmmoBase.ActivateCrossHairPullAnimationByCrossbow");
		
		UGA_ReloadAmmoBase_ActivateCrossHairPullAnimationByCrossbow_Params params {};
		params.ActionSpeed = ActionSpeed;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.GA_ReloadAmmoBase.AbilityActivated
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 * Parameters:
	 * 		struct FGameplayEventData                          TriggerEventData                                           (ConstParm, Parm, NativeAccessSpecifierPublic)
	 */
	void UGA_ReloadAmmoBase::AbilityActivated(const struct FGameplayEventData& TriggerEventData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GA_ReloadAmmoBase.AbilityActivated");
		
		UGA_ReloadAmmoBase_AbilityActivated_Params params {};
		params.TriggerEventData = TriggerEventData;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGA_ReloadAmmoBase.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGA_ReloadAmmoBase::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.GA_ReloadAmmoBase");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017DE4E0
	 * 		Name   -> Function DungeonCrawler.GA_ReversibleChangeIdle.OnCompleted
	 * 		Flags  -> (Final, Native, Protected)
	 * Parameters:
	 * 		struct FGameplayTag                                EventTag                                                   (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FGameplayEventData                          EventData                                                  (Parm, NativeAccessSpecifierPublic)
	 */
	void UGA_ReversibleChangeIdle::OnCompleted(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GA_ReversibleChangeIdle.OnCompleted");
		
		UGA_ReversibleChangeIdle_OnCompleted_Params params {};
		params.EventTag = EventTag;
		params.EventData = EventData;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017DE4E0
	 * 		Name   -> Function DungeonCrawler.GA_ReversibleChangeIdle.OnBlendOut
	 * 		Flags  -> (Final, Native, Protected)
	 * Parameters:
	 * 		struct FGameplayTag                                EventTag                                                   (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FGameplayEventData                          EventData                                                  (Parm, NativeAccessSpecifierPublic)
	 */
	void UGA_ReversibleChangeIdle::OnBlendOut(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GA_ReversibleChangeIdle.OnBlendOut");
		
		UGA_ReversibleChangeIdle_OnBlendOut_Params params {};
		params.EventTag = EventTag;
		params.EventData = EventData;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.GA_ReversibleChangeIdle.AbilityActivated
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 * Parameters:
	 * 		struct FGameplayEventData                          TriggerEventData                                           (ConstParm, Parm, NativeAccessSpecifierPublic)
	 */
	void UGA_ReversibleChangeIdle::AbilityActivated(const struct FGameplayEventData& TriggerEventData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GA_ReversibleChangeIdle.AbilityActivated");
		
		UGA_ReversibleChangeIdle_AbilityActivated_Params params {};
		params.TriggerEventData = TriggerEventData;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGA_ReversibleChangeIdle.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGA_ReversibleChangeIdle::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.GA_ReversibleChangeIdle");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017EF590
	 * 		Name   -> Function DungeonCrawler.GA_SpellBase.IsSocketSightBlocked
	 * 		Flags  -> (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
	 */
	bool UGA_SpellBase::IsSocketSightBlocked()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GA_SpellBase.IsSocketSightBlocked");
		
		UGA_SpellBase_IsSocketSightBlocked_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017EEFF0
	 * 		Name   -> Function DungeonCrawler.GA_SpellBase.GetRange
	 * 		Flags  -> (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
	 */
	float UGA_SpellBase::GetRange()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GA_SpellBase.GetRange");
		
		UGA_SpellBase_GetRange_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017EE9F0
	 * 		Name   -> Function DungeonCrawler.GA_SpellBase.GetAimRadius
	 * 		Flags  -> (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
	 */
	float UGA_SpellBase::GetAimRadius()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GA_SpellBase.GetAimRadius");
		
		UGA_SpellBase_GetAimRadius_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017EE890
	 * 		Name   -> Function DungeonCrawler.GA_SpellBase.FireProjectile
	 * 		Flags  -> (Native, Protected, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		struct FHitResult                                  HitResult                                                  (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 * 		class UClass*                                      ProjectileActorClass                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGA_SpellBase::FireProjectile(const struct FHitResult& HitResult, class UClass* ProjectileActorClass)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GA_SpellBase.FireProjectile");
		
		UGA_SpellBase_FireProjectile_Params params {};
		params.HitResult = HitResult;
		params.ProjectileActorClass = ProjectileActorClass;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017EE490
	 * 		Name   -> Function DungeonCrawler.GA_SpellBase.CastToTarget
	 * 		Flags  -> (Native, Protected, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		struct FHitResult                                  HitResult                                                  (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 * 		bool                                               IsEndAbility                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               UseExecuteGameplayCue                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGA_SpellBase::CastToTarget(const struct FHitResult& HitResult, bool IsEndAbility, bool UseExecuteGameplayCue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GA_SpellBase.CastToTarget");
		
		UGA_SpellBase_CastToTarget_Params params {};
		params.HitResult = HitResult;
		params.IsEndAbility = IsEndAbility;
		params.UseExecuteGameplayCue = UseExecuteGameplayCue;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017EE470
	 * 		Name   -> Function DungeonCrawler.GA_SpellBase.CastToSelf
	 * 		Flags  -> (Native, Protected, BlueprintCallable)
	 */
	void UGA_SpellBase::CastToSelf()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GA_SpellBase.CastToSelf");
		
		UGA_SpellBase_CastToSelf_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.GA_SpellBase.CastFinished
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 */
	void UGA_SpellBase::CastFinished()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GA_SpellBase.CastFinished");
		
		UGA_SpellBase_CastFinished_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.GA_SpellBase.AbilityActivated
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		struct FGameplayEventData                          TriggerEventData                                           (ConstParm, Parm, NativeAccessSpecifierPublic)
	 * 		bool                                               bIsSocketSightBlocked                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGA_SpellBase::AbilityActivated(const struct FGameplayEventData& TriggerEventData, bool bIsSocketSightBlocked)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GA_SpellBase.AbilityActivated");
		
		UGA_SpellBase_AbilityActivated_Params params {};
		params.TriggerEventData = TriggerEventData;
		params.bIsSocketSightBlocked = bIsSocketSightBlocked;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGA_SpellBase.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGA_SpellBase::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.GA_SpellBase");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017EF850
	 * 		Name   -> Function DungeonCrawler.GA_WearBase.OnStartSync
	 * 		Flags  -> (Final, Native, Protected)
	 */
	void UGA_WearBase::OnStartSync()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GA_WearBase.OnStartSync");
		
		UGA_WearBase_OnStartSync_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00A2B690
	 * 		Name   -> Function DungeonCrawler.GA_WearBase.OnLootTargetRemoved
	 * 		Flags  -> (Final, Native, Protected)
	 */
	void UGA_WearBase::OnLootTargetRemoved()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GA_WearBase.OnLootTargetRemoved");
		
		UGA_WearBase_OnLootTargetRemoved_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017EF810
	 * 		Name   -> Function DungeonCrawler.GA_WearBase.OnFinish
	 * 		Flags  -> (Final, Native, Protected)
	 */
	void UGA_WearBase::OnFinish()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GA_WearBase.OnFinish");
		
		UGA_WearBase_OnFinish_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017E3D30
	 * 		Name   -> Function DungeonCrawler.GA_WearBase.OnEndSync
	 * 		Flags  -> (Final, Native, Protected)
	 */
	void UGA_WearBase::OnEndSync()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GA_WearBase.OnEndSync");
		
		UGA_WearBase_OnEndSync_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017EF5C0
	 * 		Name   -> Function DungeonCrawler.GA_WearBase.OnChangingMontageCompleted
	 * 		Flags  -> (Final, Native, Protected)
	 * Parameters:
	 * 		struct FGameplayTag                                EventTag                                                   (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FGameplayEventData                          EventData                                                  (Parm, NativeAccessSpecifierPublic)
	 */
	void UGA_WearBase::OnChangingMontageCompleted(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GA_WearBase.OnChangingMontageCompleted");
		
		UGA_WearBase_OnChangingMontageCompleted_Params params {};
		params.EventTag = EventTag;
		params.EventData = EventData;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017DE8B0
	 * 		Name   -> Function DungeonCrawler.GA_WearBase.EventReceived
	 * 		Flags  -> (Native, Protected)
	 * Parameters:
	 * 		struct FGameplayTag                                EventTag                                                   (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FGameplayEventData                          EventData                                                  (Parm, NativeAccessSpecifierPublic)
	 */
	void UGA_WearBase::EventReceived(const struct FGameplayTag& EventTag, const struct FGameplayEventData& EventData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GA_WearBase.EventReceived");
		
		UGA_WearBase_EventReceived_Params params {};
		params.EventTag = EventTag;
		params.EventData = EventData;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGA_WearBase.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGA_WearBase::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.GA_WearBase");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01764730
	 * 		Name   -> Function DungeonCrawler.DCGlitterComponent.UnbindMsgAll
	 * 		Flags  -> (Native, Public)
	 * Parameters:
	 * 		class UObject*                                     InObject                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UDCGlitterComponent::UnbindMsgAll(class UObject* InObject)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCGlitterComponent.UnbindMsgAll");
		
		UDCGlitterComponent_UnbindMsgAll_Params params {};
		params.InObject = InObject;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01764280
	 * 		Name   -> Function DungeonCrawler.DCGlitterComponent.UnbindMsg
	 * 		Flags  -> (Native, Public)
	 * Parameters:
	 * 		class UScriptStruct*                               InMsgType                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UObject*                                     InObject                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UDCGlitterComponent::UnbindMsg(class UScriptStruct* InMsgType, class UObject* InObject)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCGlitterComponent.UnbindMsg");
		
		UDCGlitterComponent_UnbindMsg_Params params {};
		params.InMsgType = InMsgType;
		params.InObject = InObject;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01763EB0
	 * 		Name   -> Function DungeonCrawler.DCGlitterComponent.TerminateBase
	 * 		Flags  -> (Native, Public)
	 */
	void UDCGlitterComponent::TerminateBase()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCGlitterComponent.TerminateBase");
		
		UDCGlitterComponent_TerminateBase_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D3C640
	 * 		Name   -> Function DungeonCrawler.DCGlitterComponent.BroadcastMsgBlueprint
	 * 		Flags  -> (Native, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		int32_t                                            InMsg                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UDCGlitterComponent::BroadcastMsgBlueprint(int32_t InMsg)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCGlitterComponent.BroadcastMsgBlueprint");
		
		UDCGlitterComponent_BroadcastMsgBlueprint_Params params {};
		params.InMsg = InMsg;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDCGlitterComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDCGlitterComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCGlitterComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017EEA20
	 * 		Name   -> Function DungeonCrawler.GlobalData.GetAttackTypeText
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		struct FGameplayTag                                AttackType                                                 (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class FText UGlobalData::GetAttackTypeText(const struct FGameplayTag& AttackType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.GlobalData.GetAttackTypeText");
		
		UGlobalData_GetAttackTypeText_Params params {};
		params.AttackType = AttackType;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGlobalData.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGlobalData::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.GlobalData");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.MonsterSpawnableInterface.Spawn
	 * 		Flags  -> (Event, Protected, BlueprintCallable, BlueprintEvent)
	 * Parameters:
	 * 		class UClass*                                      Monster                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class ADCMonsterBase* UMonsterSpawnableInterface::Spawn(class UClass* Monster)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.MonsterSpawnableInterface.Spawn");
		
		UMonsterSpawnableInterface_Spawn_Params params {};
		params.Monster = Monster;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMonsterSpawnableInterface.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMonsterSpawnableInterface::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.MonsterSpawnableInterface");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01764730
	 * 		Name   -> Function DungeonCrawler.ImpactableComponent.UnbindMsgAll
	 * 		Flags  -> (Native, Public)
	 * Parameters:
	 * 		class UObject*                                     InObject                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UImpactableComponent::UnbindMsgAll(class UObject* InObject)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.ImpactableComponent.UnbindMsgAll");
		
		UImpactableComponent_UnbindMsgAll_Params params {};
		params.InObject = InObject;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01764280
	 * 		Name   -> Function DungeonCrawler.ImpactableComponent.UnbindMsg
	 * 		Flags  -> (Native, Public)
	 * Parameters:
	 * 		class UScriptStruct*                               InMsgType                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UObject*                                     InObject                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UImpactableComponent::UnbindMsg(class UScriptStruct* InMsgType, class UObject* InObject)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.ImpactableComponent.UnbindMsg");
		
		UImpactableComponent_UnbindMsg_Params params {};
		params.InMsgType = InMsgType;
		params.InObject = InObject;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01763EB0
	 * 		Name   -> Function DungeonCrawler.ImpactableComponent.TerminateBase
	 * 		Flags  -> (Native, Public)
	 */
	void UImpactableComponent::TerminateBase()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.ImpactableComponent.TerminateBase");
		
		UImpactableComponent_TerminateBase_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017EF940
	 * 		Name   -> Function DungeonCrawler.ImpactableComponent.SetImpactableQuery
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		TArray<struct FPrimaryAssetId>                     TagQueryDatas                                              (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
	 */
	void UImpactableComponent::SetImpactableQuery(TArray<struct FPrimaryAssetId> TagQueryDatas)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.ImpactableComponent.SetImpactableQuery");
		
		UImpactableComponent_SetImpactableQuery_Params params {};
		params.TagQueryDatas = TagQueryDatas;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017EEC70
	 * 		Name   -> Function DungeonCrawler.ImpactableComponent.GetImpactableTagQueryArray
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	TArray<class UTagQueryData*> UImpactableComponent::GetImpactableTagQueryArray()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.ImpactableComponent.GetImpactableTagQueryArray");
		
		UImpactableComponent_GetImpactableTagQueryArray_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D3C640
	 * 		Name   -> Function DungeonCrawler.ImpactableComponent.BroadcastMsgBlueprint
	 * 		Flags  -> (Native, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		int32_t                                            InMsg                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UImpactableComponent::BroadcastMsgBlueprint(int32_t InMsg)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.ImpactableComponent.BroadcastMsgBlueprint");
		
		UImpactableComponent_BroadcastMsgBlueprint_Params params {};
		params.InMsg = InMsg;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UImpactableComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UImpactableComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.ImpactableComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017EF020
	 * 		Name   -> Function DungeonCrawler.IMUtilBlueprintLibrary.GetServerWorldTimeSeconds
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	float UIMUtilBlueprintLibrary::STATIC_GetServerWorldTimeSeconds(class UObject* WorldContextObject)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.IMUtilBlueprintLibrary.GetServerWorldTimeSeconds");
		
		UIMUtilBlueprintLibrary_GetServerWorldTimeSeconds_Params params {};
		params.WorldContextObject = WorldContextObject;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017EEF50
	 * 		Name   -> Function DungeonCrawler.IMUtilBlueprintLibrary.GetProjectVersion
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class FString                                      OutVersion                                                 (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UIMUtilBlueprintLibrary::STATIC_GetProjectVersion(class FString* OutVersion)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.IMUtilBlueprintLibrary.GetProjectVersion");
		
		UIMUtilBlueprintLibrary_GetProjectVersion_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutVersion != nullptr)
			*OutVersion = params.OutVersion;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UIMUtilBlueprintLibrary.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UIMUtilBlueprintLibrary::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.IMUtilBlueprintLibrary");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UInputTriggerComboAction.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UInputTriggerComboAction::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.InputTriggerComboAction");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017EFC40
	 * 		Name   -> Function DungeonCrawler.InteractableTargetComponent.UnregisterInteracter
	 * 		Flags  -> (Final, Native, Private)
	 * Parameters:
	 * 		class AActor*                                      InteractingActor                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UInteractableTargetComponent::UnregisterInteracter(class AActor* InteractingActor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.InteractableTargetComponent.UnregisterInteracter");
		
		UInteractableTargetComponent_UnregisterInteracter_Params params {};
		params.InteractingActor = InteractingActor;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01764730
	 * 		Name   -> Function DungeonCrawler.InteractableTargetComponent.UnbindMsgAll
	 * 		Flags  -> (Native, Public)
	 * Parameters:
	 * 		class UObject*                                     InObject                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UInteractableTargetComponent::UnbindMsgAll(class UObject* InObject)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.InteractableTargetComponent.UnbindMsgAll");
		
		UInteractableTargetComponent_UnbindMsgAll_Params params {};
		params.InObject = InObject;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01764280
	 * 		Name   -> Function DungeonCrawler.InteractableTargetComponent.UnbindMsg
	 * 		Flags  -> (Native, Public)
	 * Parameters:
	 * 		class UScriptStruct*                               InMsgType                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UObject*                                     InObject                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UInteractableTargetComponent::UnbindMsg(class UScriptStruct* InMsgType, class UObject* InObject)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.InteractableTargetComponent.UnbindMsg");
		
		UInteractableTargetComponent_UnbindMsg_Params params {};
		params.InMsgType = InMsgType;
		params.InObject = InObject;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01763EB0
	 * 		Name   -> Function DungeonCrawler.InteractableTargetComponent.TerminateBase
	 * 		Flags  -> (Native, Public)
	 */
	void UInteractableTargetComponent::TerminateBase()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.InteractableTargetComponent.TerminateBase");
		
		UInteractableTargetComponent_TerminateBase_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017EFBA0
	 * 		Name   -> Function DungeonCrawler.InteractableTargetComponent.ShouldCancelOthersWhenInteractSucceed
	 * 		Flags  -> (Final, Native, Private)
	 * Parameters:
	 * 		struct FGameplayTag                                StateTag                                                   (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UInteractableTargetComponent::ShouldCancelOthersWhenInteractSucceed(const struct FGameplayTag& StateTag)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.InteractableTargetComponent.ShouldCancelOthersWhenInteractSucceed");
		
		UInteractableTargetComponent_ShouldCancelOthersWhenInteractSucceed_Params params {};
		params.StateTag = StateTag;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017EFA30
	 * 		Name   -> Function DungeonCrawler.InteractableTargetComponent.SetInteractionData
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		struct FDesignDataPropsInteract                    InteractionData                                            (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UInteractableTargetComponent::SetInteractionData(const struct FDesignDataPropsInteract& InteractionData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.InteractableTargetComponent.SetInteractionData");
		
		UInteractableTargetComponent_SetInteractionData_Params params {};
		params.InteractionData = InteractionData;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017EF8B0
	 * 		Name   -> Function DungeonCrawler.InteractableTargetComponent.RegisterInteracter
	 * 		Flags  -> (Final, Native, Private)
	 * Parameters:
	 * 		class AActor*                                      InteractingActor                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UInteractableTargetComponent::RegisterInteracter(class AActor* InteractingActor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.InteractableTargetComponent.RegisterInteracter");
		
		UInteractableTargetComponent_RegisterInteracter_Params params {};
		params.InteractingActor = InteractingActor;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017EF4F0
	 * 		Name   -> Function DungeonCrawler.InteractableTargetComponent.IsDetectable
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		class AActor*                                      Interacter                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UInteractableTargetComponent::IsDetectable(class AActor* Interacter)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.InteractableTargetComponent.IsDetectable");
		
		UInteractableTargetComponent_IsDetectable_Params params {};
		params.Interacter = Interacter;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017EF210
	 * 		Name   -> Function DungeonCrawler.InteractableTargetComponent.InteractSucceed
	 * 		Flags  -> (Final, Native, Private)
	 * Parameters:
	 * 		class AActor*                                      InteractingActor                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FGameplayTag                                TriggerTag                                                 (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FGameplayTag                                StateTag                                                   (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FHitResult                                  HitResult                                                  (Parm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	void UInteractableTargetComponent::InteractSucceed(class AActor* InteractingActor, const struct FGameplayTag& TriggerTag, const struct FGameplayTag& StateTag, const struct FHitResult& HitResult)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.InteractableTargetComponent.InteractSucceed");
		
		UInteractableTargetComponent_InteractSucceed_Params params {};
		params.InteractingActor = InteractingActor;
		params.TriggerTag = TriggerTag;
		params.StateTag = StateTag;
		params.HitResult = HitResult;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017EF140
	 * 		Name   -> Function DungeonCrawler.InteractableTargetComponent.InteractFailed
	 * 		Flags  -> (Final, Native, Private)
	 * Parameters:
	 * 		class AActor*                                      InteractingActor                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FGameplayTag                                TriggerTag                                                 (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UInteractableTargetComponent::InteractFailed(class AActor* InteractingActor, const struct FGameplayTag& TriggerTag)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.InteractableTargetComponent.InteractFailed");
		
		UInteractableTargetComponent_InteractFailed_Params params {};
		params.InteractingActor = InteractingActor;
		params.TriggerTag = TriggerTag;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017EF0B0
	 * 		Name   -> Function DungeonCrawler.InteractableTargetComponent.GetStateTag
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		struct FGameplayTag                                TriggerTag                                                 (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FGameplayTag UInteractableTargetComponent::GetStateTag(const struct FGameplayTag& TriggerTag)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.InteractableTargetComponent.GetStateTag");
		
		UInteractableTargetComponent_GetStateTag_Params params {};
		params.TriggerTag = TriggerTag;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017EECF0
	 * 		Name   -> Function DungeonCrawler.InteractableTargetComponent.GetInteractTargetData
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	struct FInteractTargetData UInteractableTargetComponent::GetInteractTargetData()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.InteractableTargetComponent.GetInteractTargetData");
		
		UInteractableTargetComponent_GetInteractTargetData_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017EEE30
	 * 		Name   -> Function DungeonCrawler.InteractableTargetComponent.GetInteractableDataByStateMap
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	TMap<struct FGameplayTag, struct FInteractionData> UInteractableTargetComponent::GetInteractableDataByStateMap()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.InteractableTargetComponent.GetInteractableDataByStateMap");
		
		UInteractableTargetComponent_GetInteractableDataByStateMap_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017EED90
	 * 		Name   -> Function DungeonCrawler.InteractableTargetComponent.GetInteractability
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		class AActor*                                      Interacter                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	EInteractabilityType UInteractableTargetComponent::GetInteractability(class AActor* Interacter)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.InteractableTargetComponent.GetInteractability");
		
		UInteractableTargetComponent_GetInteractability_Params params {};
		params.Interacter = Interacter;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017EEB20
	 * 		Name   -> Function DungeonCrawler.InteractableTargetComponent.GetData
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		struct FGameplayTag                                StateTag                                                   (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FInteractionData UInteractableTargetComponent::GetData(const struct FGameplayTag& StateTag)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.InteractableTargetComponent.GetData");
		
		UInteractableTargetComponent_GetData_Params params {};
		params.StateTag = StateTag;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017EE400
	 * 		Name   -> Function DungeonCrawler.InteractableTargetComponent.CanInteract
	 * 		Flags  -> (Final, Native, Private, BlueprintCallable)
	 */
	bool UInteractableTargetComponent::CanInteract()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.InteractableTargetComponent.CanInteract");
		
		UInteractableTargetComponent_CanInteract_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017EE430
	 * 		Name   -> Function DungeonCrawler.InteractableTargetComponent.CancelAllInteractions
	 * 		Flags  -> (Final, Native, Private, BlueprintCallable)
	 */
	void UInteractableTargetComponent::CancelAllInteractions()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.InteractableTargetComponent.CancelAllInteractions");
		
		UInteractableTargetComponent_CancelAllInteractions_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D3C640
	 * 		Name   -> Function DungeonCrawler.InteractableTargetComponent.BroadcastMsgBlueprint
	 * 		Flags  -> (Native, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		int32_t                                            InMsg                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UInteractableTargetComponent::BroadcastMsgBlueprint(int32_t InMsg)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.InteractableTargetComponent.BroadcastMsgBlueprint");
		
		UInteractableTargetComponent_BroadcastMsgBlueprint_Params params {};
		params.InMsg = InMsg;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UInteractableTargetComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UInteractableTargetComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.InteractableTargetComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UInteractData.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UInteractData::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.InteractData");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017F4800
	 * 		Name   -> Function DungeonCrawler.InventoryLootingWidget.RequestInventoryWidgetVisible
	 * 		Flags  -> (Final, Native, Protected, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bVisible                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UInventoryLootingWidget::RequestInventoryWidgetVisible(bool bVisible)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.InventoryLootingWidget.RequestInventoryWidgetVisible");
		
		UInventoryLootingWidget_RequestInventoryWidgetVisible_Params params {};
		params.bVisible = bVisible;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017F45C0
	 * 		Name   -> Function DungeonCrawler.InventoryLootingWidget.OnLootingTargetCountChanged
	 * 		Flags  -> (Final, Native, Private)
	 * Parameters:
	 * 		int32_t                                            Count                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UInventoryLootingWidget::OnLootingTargetCountChanged(int32_t Count)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.InventoryLootingWidget.OnLootingTargetCountChanged");
		
		UInventoryLootingWidget_OnLootingTargetCountChanged_Params params {};
		params.Count = Count;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017F44F0
	 * 		Name   -> Function DungeonCrawler.InventoryLootingWidget.OnLootingPlayerSet
	 * 		Flags  -> (Final, Native, Private)
	 * Parameters:
	 * 		bool                                               bSetTargetPlayer                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FName                                        TargetPlayerName                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UInventoryLootingWidget::OnLootingPlayerSet(bool bSetTargetPlayer, const class FName& TargetPlayerName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.InventoryLootingWidget.OnLootingPlayerSet");
		
		UInventoryLootingWidget_OnLootingPlayerSet_Params params {};
		params.bSetTargetPlayer = bSetTargetPlayer;
		params.TargetPlayerName = TargetPlayerName;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UInventoryLootingWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UInventoryLootingWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.InventoryLootingWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UInventoryPerkListWidgetBase.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UInventoryPerkListWidgetBase::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.InventoryPerkListWidgetBase");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UInventorySkillListWidgetBase.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UInventorySkillListWidgetBase::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.InventorySkillListWidgetBase");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.InventoryStatusWidget.OnPlayerCharacterName
	 * 		Flags  -> (Event, Protected, HasOutParms, BlueprintEvent)
	 * Parameters:
	 * 		class FText                                        NewValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		class FText                                        OldValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UInventoryStatusWidget::OnPlayerCharacterName(const class FText& NewValue, const class FText& OldValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.InventoryStatusWidget.OnPlayerCharacterName");
		
		UInventoryStatusWidget_OnPlayerCharacterName_Params params {};
		params.NewValue = NewValue;
		params.OldValue = OldValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UInventoryStatusWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UInventoryStatusWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.InventoryStatusWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017F8530
	 * 		Name   -> Function DungeonCrawler.InventoryTabWidgetBase.OnClickedInventoryTab
	 * 		Flags  -> (Final, Native, Protected)
	 */
	void UInventoryTabWidgetBase::OnClickedInventoryTab()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.InventoryTabWidgetBase.OnClickedInventoryTab");
		
		UInventoryTabWidgetBase_OnClickedInventoryTab_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.InventoryTabWidgetBase.OnChangeActiveState
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		bool                                               bActive                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UInventoryTabWidgetBase::OnChangeActiveState(bool bActive)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.InventoryTabWidgetBase.OnChangeActiveState");
		
		UInventoryTabWidgetBase_OnChangeActiveState_Params params {};
		params.bActive = bActive;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UInventoryTabWidgetBase.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UInventoryTabWidgetBase::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.InventoryTabWidgetBase");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01734160
	 * 		Name   -> Function DungeonCrawler.InvitePartyUserSlotWidget.OnRightClicked
	 * 		Flags  -> (Native, Protected)
	 */
	void UInvitePartyUserSlotWidget::OnRightClicked()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.InvitePartyUserSlotWidget.OnRightClicked");
		
		UInvitePartyUserSlotWidget_OnRightClicked_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UInvitePartyUserSlotWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UInvitePartyUserSlotWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.InvitePartyUserSlotWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UInvitePartyMemberSlotWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UInvitePartyMemberSlotWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.InvitePartyMemberSlotWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UInvitePartyUserSlotWidgetData.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UInvitePartyUserSlotWidgetData::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.InvitePartyUserSlotWidgetData");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UInvitePartyUserSlotListWidgetData.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UInvitePartyUserSlotListWidgetData::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.InvitePartyUserSlotListWidgetData");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.InvitePartyWidget.TryRequestInviteParty
	 * 		Flags  -> (Event, Public, BlueprintCallable, BlueprintEvent)
	 * Parameters:
	 * 		class UInvitePartyUserSlotWidgetData*              InInvitePartyUserSlotWidgetData                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UInvitePartyWidget::TryRequestInviteParty(class UInvitePartyUserSlotWidgetData* InInvitePartyUserSlotWidgetData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.InvitePartyWidget.TryRequestInviteParty");
		
		UInvitePartyWidget_TryRequestInviteParty_Params params {};
		params.InInvitePartyUserSlotWidgetData = InInvitePartyUserSlotWidgetData;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017F9070
	 * 		Name   -> Function DungeonCrawler.InvitePartyWidget.OnUserListFindIdClicked
	 * 		Flags  -> (Final, Native, Protected, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		class FText                                        FindId                                                     (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UInvitePartyWidget::OnUserListFindIdClicked(const class FText& FindId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.InvitePartyWidget.OnUserListFindIdClicked");
		
		UInvitePartyWidget_OnUserListFindIdClicked_Params params {};
		params.FindId = FindId;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017F8F90
	 * 		Name   -> Function DungeonCrawler.InvitePartyWidget.OnTextChangedFindUserId
	 * 		Flags  -> (Final, Native, Protected, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		class FText                                        FindId                                                     (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	bool UInvitePartyWidget::OnTextChangedFindUserId(const class FText& FindId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.InvitePartyWidget.OnTextChangedFindUserId");
		
		UInvitePartyWidget_OnTextChangedFindUserId_Params params {};
		params.FindId = FindId;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017F8D00
	 * 		Name   -> Function DungeonCrawler.InvitePartyWidget.OnRightButtonCkicked
	 * 		Flags  -> (Final, Native, Protected, BlueprintCallable)
	 */
	void UInvitePartyWidget::OnRightButtonCkicked()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.InvitePartyWidget.OnRightButtonCkicked");
		
		UInvitePartyWidget_OnRightButtonCkicked_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017F8920
	 * 		Name   -> Function DungeonCrawler.InvitePartyWidget.OnPopupSWidgetPartyInviteResult
	 * 		Flags  -> (Final, Native, Protected, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		EPopupResult                                       PopupResult                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FInvitePartyUserSlot                        TargetUser                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UInvitePartyWidget::OnPopupSWidgetPartyInviteResult(EPopupResult PopupResult, const struct FInvitePartyUserSlot& TargetUser)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.InvitePartyWidget.OnPopupSWidgetPartyInviteResult");
		
		UInvitePartyWidget_OnPopupSWidgetPartyInviteResult_Params params {};
		params.PopupResult = PopupResult;
		params.TargetUser = TargetUser;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017F8900
	 * 		Name   -> Function DungeonCrawler.InvitePartyWidget.OnPartyPrivacyButtonClicked
	 * 		Flags  -> (Final, Native, Protected)
	 */
	void UInvitePartyWidget::OnPartyPrivacyButtonClicked()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.InvitePartyWidget.OnPartyPrivacyButtonClicked");
		
		UInvitePartyWidget_OnPartyPrivacyButtonClicked_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.InvitePartyWidget.OnPageNumber
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 * Parameters:
	 * 		int32_t                                            CurrentPage                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            MaxPage                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UInvitePartyWidget::OnPageNumber(int32_t CurrentPage, int32_t MaxPage)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.InvitePartyWidget.OnPageNumber");
		
		UInvitePartyWidget_OnPageNumber_Params params {};
		params.CurrentPage = CurrentPage;
		params.MaxPage = MaxPage;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.InvitePartyWidget.OnLocateNumber
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 * Parameters:
	 * 		int32_t                                            LobbyCount                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            DungeonCount                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            BlockCount                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UInvitePartyWidget::OnLocateNumber(int32_t LobbyCount, int32_t DungeonCount, int32_t BlockCount)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.InvitePartyWidget.OnLocateNumber");
		
		UInvitePartyWidget_OnLocateNumber_Params params {};
		params.LobbyCount = LobbyCount;
		params.DungeonCount = DungeonCount;
		params.BlockCount = BlockCount;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017F8730
	 * 		Name   -> Function DungeonCrawler.InvitePartyWidget.OnLeftButtonCkicked
	 * 		Flags  -> (Final, Native, Protected, BlueprintCallable)
	 */
	void UInvitePartyWidget::OnLeftButtonCkicked()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.InvitePartyWidget.OnLeftButtonCkicked");
		
		UInvitePartyWidget_OnLeftButtonCkicked_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017F8550
	 * 		Name   -> Function DungeonCrawler.InvitePartyWidget.OnInvitePartyUserSlotData
	 * 		Flags  -> (Native, Event, Protected, HasOutParms, BlueprintEvent)
	 * Parameters:
	 * 		struct FInvitePartyUserSlotData                    NewValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		struct FInvitePartyUserSlotData                    OldValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UInvitePartyWidget::OnInvitePartyUserSlotData(const struct FInvitePartyUserSlotData& NewValue, const struct FInvitePartyUserSlotData& OldValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.InvitePartyWidget.OnInvitePartyUserSlotData");
		
		UInvitePartyWidget_OnInvitePartyUserSlotData_Params params {};
		params.NewValue = NewValue;
		params.OldValue = OldValue;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017F8490
	 * 		Name   -> Function DungeonCrawler.InvitePartyWidget.OnClassIconSelected
	 * 		Flags  -> (Final, Native, Protected, HasOutParms, HasDefaults)
	 * Parameters:
	 * 		struct FPrimaryAssetId                             InCharacterClassId                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UInvitePartyWidget::OnClassIconSelected(const struct FPrimaryAssetId& InCharacterClassId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.InvitePartyWidget.OnClassIconSelected");
		
		UInvitePartyWidget_OnClassIconSelected_Params params {};
		params.InCharacterClassId = InCharacterClassId;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017F8470
	 * 		Name   -> Function DungeonCrawler.InvitePartyWidget.OnButtonShowBlock
	 * 		Flags  -> (Final, Native, Private)
	 */
	void UInvitePartyWidget::OnButtonShowBlock()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.InvitePartyWidget.OnButtonShowBlock");
		
		UInvitePartyWidget_OnButtonShowBlock_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017F8200
	 * 		Name   -> Function DungeonCrawler.InvitePartyWidget.HandleBackButtonClicked
	 * 		Flags  -> (Final, Native, Protected, BlueprintCallable)
	 */
	void UInvitePartyWidget::HandleBackButtonClicked()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.InvitePartyWidget.HandleBackButtonClicked");
		
		UInvitePartyWidget_HandleBackButtonClicked_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UInvitePartyWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UInvitePartyWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.InvitePartyWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UIronShield.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UIronShield::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.IronShield");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01720B30
	 * 		Name   -> Function DungeonCrawler.Item.UnbindMsgAll
	 * 		Flags  -> (Native, Public)
	 * Parameters:
	 * 		class UObject*                                     InObject                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UItem::UnbindMsgAll(class UObject* InObject)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.Item.UnbindMsgAll");
		
		UItem_UnbindMsgAll_Params params {};
		params.InObject = InObject;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01720A60
	 * 		Name   -> Function DungeonCrawler.Item.UnbindMsg
	 * 		Flags  -> (Native, Public)
	 * Parameters:
	 * 		class UScriptStruct*                               InMsgType                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UObject*                                     InObject                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UItem::UnbindMsg(class UScriptStruct* InMsgType, class UObject* InObject)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.Item.UnbindMsg");
		
		UItem_UnbindMsg_Params params {};
		params.InMsgType = InMsgType;
		params.InObject = InObject;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01720A40
	 * 		Name   -> Function DungeonCrawler.Item.TerminateBase
	 * 		Flags  -> (Native, Public)
	 */
	void UItem::TerminateBase()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.Item.TerminateBase");
		
		UItem_TerminateBase_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017F83B0
	 * 		Name   -> Function DungeonCrawler.Item.IsItemWeaponType
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		struct FGameplayTag                                WeaponType                                                 (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UItem::IsItemWeaponType(const struct FGameplayTag& WeaponType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.Item.IsItemWeaponType");
		
		UItem_IsItemWeaponType_Params params {};
		params.WeaponType = WeaponType;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017F8260
	 * 		Name   -> Function DungeonCrawler.Item.Initialize
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		struct FItemData                                   Data                                                       (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UItem::Initialize(const struct FItemData& Data)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.Item.Initialize");
		
		UItem_Initialize_Params params {};
		params.Data = Data;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017F8110
	 * 		Name   -> Function DungeonCrawler.Item.GetItemWeaponTypes
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	TArray<struct FGameplayTag> UItem::GetItemWeaponTypes()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.Item.GetItemWeaponTypes");
		
		UItem_GetItemWeaponTypes_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017F8030
	 * 		Name   -> Function DungeonCrawler.Item.GetItemSlotType
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	struct FGameplayTag UItem::GetItemSlotType()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.Item.GetItemSlotType");
		
		UItem_GetItemSlotType_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017F8000
	 * 		Name   -> Function DungeonCrawler.Item.GetItemIconTexture
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	class UTexture2D* UItem::GetItemIconTexture()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.Item.GetItemIconTexture");
		
		UItem_GetItemIconTexture_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017F7FE0
	 * 		Name   -> Function DungeonCrawler.Item.GetItemHandType
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	struct FGameplayTag UItem::GetItemHandType()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.Item.GetItemHandType");
		
		UItem_GetItemHandType_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017F7F60
	 * 		Name   -> Function DungeonCrawler.Item.GetItemDataWeaponTypeTags
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	TArray<struct FGameplayTag> UItem::GetItemDataWeaponTypeTags()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.Item.GetItemDataWeaponTypeTags");
		
		UItem_GetItemDataWeaponTypeTags_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017F7F20
	 * 		Name   -> Function DungeonCrawler.Item.GetItemDataUtilityTag
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	struct FGameplayTag UItem::GetItemDataUtilityTag()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.Item.GetItemDataUtilityTag");
		
		UItem_GetItemDataUtilityTag_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017F7D50
	 * 		Name   -> Function DungeonCrawler.Item.GetItemData
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	struct FItemData UItem::GetItemData()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.Item.GetItemData");
		
		UItem_GetItemData_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017F7C60
	 * 		Name   -> Function DungeonCrawler.Item.GetItemActorClass
	 * 		Flags  -> (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
	 */
	class UClass* UItem::GetItemActorClass()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.Item.GetItemActorClass");
		
		UItem_GetItemActorClass_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017F7C20
	 * 		Name   -> Function DungeonCrawler.Item.GetItemActor
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	class AItemActor* UItem::GetItemActor()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.Item.GetItemActor");
		
		UItem_GetItemActor_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017F7BF0
	 * 		Name   -> Function DungeonCrawler.Item.GetDesignDataItem
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	struct FDesignDataItem UItem::GetDesignDataItem()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.Item.GetDesignDataItem");
		
		UItem_GetDesignDataItem_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D3C640
	 * 		Name   -> Function DungeonCrawler.Item.BroadcastMsgBlueprint
	 * 		Flags  -> (Native, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		int32_t                                            InMsg                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UItem::BroadcastMsgBlueprint(int32_t InMsg)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.Item.BroadcastMsgBlueprint");
		
		UItem_BroadcastMsgBlueprint_Params params {};
		params.InMsg = InMsg;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UItem.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UItem::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.Item");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017F9140
	 * 		Name   -> Function DungeonCrawler.ItemActor.SetItemData
	 * 		Flags  -> (Final, Native, Public, HasOutParms)
	 * Parameters:
	 * 		struct FItemData                                   InItemData                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void AItemActor::SetItemData(const struct FItemData& InItemData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.ItemActor.SetItemData");
		
		AItemActor_SetItemData_Params params {};
		params.InItemData = InItemData;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.ItemActor.PreReduceAmmoCount
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		int32_t                                            ReduceCount                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AItemActor::PreReduceAmmoCount(int32_t ReduceCount)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.ItemActor.PreReduceAmmoCount");
		
		AItemActor_PreReduceAmmoCount_Params params {};
		params.ReduceCount = ReduceCount;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017F8B10
	 * 		Name   -> Function DungeonCrawler.ItemActor.OnRep_ItemData
	 * 		Flags  -> (Final, Native, Private, HasOutParms)
	 * Parameters:
	 * 		struct FItemData                                   OldItemData                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void AItemActor::OnRep_ItemData(const struct FItemData& OldItemData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.ItemActor.OnRep_ItemData");
		
		AItemActor_OnRep_ItemData_Params params {};
		params.OldItemData = OldItemData;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.ItemActor.OnAttachmentReplication
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 */
	void AItemActor::OnAttachmentReplication()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.ItemActor.OnAttachmentReplication");
		
		AItemActor_OnAttachmentReplication_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.ItemActor.OnAttachedSheathSocket
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 */
	void AItemActor::OnAttachedSheathSocket()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.ItemActor.OnAttachedSheathSocket");
		
		AItemActor_OnAttachedSheathSocket_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.ItemActor.OnAttachedEquipSocket
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 */
	void AItemActor::OnAttachedEquipSocket()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.ItemActor.OnAttachedEquipSocket");
		
		AItemActor_OnAttachedEquipSocket_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.ItemActor.ItemDataUpdated
	 * 		Flags  -> (Event, Protected, HasOutParms, BlueprintEvent)
	 * Parameters:
	 * 		struct FItemData                                   InItemData                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void AItemActor::ItemDataUpdated(const struct FItemData& InItemData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.ItemActor.ItemDataUpdated");
		
		AItemActor_ItemDataUpdated_Params params {};
		params.InItemData = InItemData;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017F81D0
	 * 		Name   -> Function DungeonCrawler.ItemActor.GetSoundData
	 * 		Flags  -> (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
	 */
	class USoundData* AItemActor::GetSoundData()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.ItemActor.GetSoundData");
		
		AItemActor_GetSoundData_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017F80D0
	 * 		Name   -> Function DungeonCrawler.ItemActor.GetItemUtilityTag
	 * 		Flags  -> (Final, Native, Public, Const)
	 */
	struct FGameplayTag AItemActor::GetItemUtilityTag()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.ItemActor.GetItemUtilityTag");
		
		AItemActor_GetItemUtilityTag_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017F8050
	 * 		Name   -> Function DungeonCrawler.ItemActor.GetItemTypeTags
	 * 		Flags  -> (Final, Native, Public, Const)
	 */
	TArray<struct FGameplayTag> AItemActor::GetItemTypeTags()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.ItemActor.GetItemTypeTags");
		
		AItemActor_GetItemTypeTags_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017F7CA0
	 * 		Name   -> Function DungeonCrawler.ItemActor.GetItemData
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	struct FItemData AItemActor::GetItemData()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.ItemActor.GetItemData");
		
		AItemActor_GetItemData_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017F7BA0
	 * 		Name   -> Function DungeonCrawler.ItemActor.GetDesignDataItem
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	struct FDesignDataItem AItemActor::GetDesignDataItem()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.ItemActor.GetDesignDataItem");
		
		AItemActor_GetDesignDataItem_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.ItemActor.GameplayTagUpdated
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 * Parameters:
	 * 		struct FGameplayTag                                InGameplayTag                                              (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            InCount                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AItemActor::GameplayTagUpdated(const struct FGameplayTag& InGameplayTag, int32_t InCount)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.ItemActor.GameplayTagUpdated");
		
		AItemActor_GameplayTagUpdated_Params params {};
		params.InGameplayTag = InGameplayTag;
		params.InCount = InCount;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AItemActor.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AItemActor::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.ItemActor");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01764730
	 * 		Name   -> Function DungeonCrawler.ItemComponentBase.UnbindMsgAll
	 * 		Flags  -> (Native, Public)
	 * Parameters:
	 * 		class UObject*                                     InObject                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UItemComponentBase::UnbindMsgAll(class UObject* InObject)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.ItemComponentBase.UnbindMsgAll");
		
		UItemComponentBase_UnbindMsgAll_Params params {};
		params.InObject = InObject;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01764280
	 * 		Name   -> Function DungeonCrawler.ItemComponentBase.UnbindMsg
	 * 		Flags  -> (Native, Public)
	 * Parameters:
	 * 		class UScriptStruct*                               InMsgType                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UObject*                                     InObject                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UItemComponentBase::UnbindMsg(class UScriptStruct* InMsgType, class UObject* InObject)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.ItemComponentBase.UnbindMsg");
		
		UItemComponentBase_UnbindMsg_Params params {};
		params.InMsgType = InMsgType;
		params.InObject = InObject;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01763EB0
	 * 		Name   -> Function DungeonCrawler.ItemComponentBase.TerminateBase
	 * 		Flags  -> (Native, Public)
	 */
	void UItemComponentBase::TerminateBase()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.ItemComponentBase.TerminateBase");
		
		UItemComponentBase_TerminateBase_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D3C640
	 * 		Name   -> Function DungeonCrawler.ItemComponentBase.BroadcastMsgBlueprint
	 * 		Flags  -> (Native, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		int32_t                                            InMsg                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UItemComponentBase::BroadcastMsgBlueprint(int32_t InMsg)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.ItemComponentBase.BroadcastMsgBlueprint");
		
		UItemComponentBase_BroadcastMsgBlueprint_Params params {};
		params.InMsg = InMsg;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UItemComponentBase.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UItemComponentBase::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.ItemComponentBase");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UItemCountSelectWidgetData.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UItemCountSelectWidgetData::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.ItemCountSelectWidgetData");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017F8EC0
	 * 		Name   -> Function DungeonCrawler.ItemCountSelectWidget.OnTextBlockValueChanged
	 * 		Flags  -> (Final, Native, Private, HasOutParms)
	 * Parameters:
	 * 		class FText                                        Text                                                       (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UItemCountSelectWidget::OnTextBlockValueChanged(const class FText& Text)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.ItemCountSelectWidget.OnTextBlockValueChanged");
		
		UItemCountSelectWidget_OnTextBlockValueChanged_Params params {};
		params.Text = Text;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017F8DA0
	 * 		Name   -> Function DungeonCrawler.ItemCountSelectWidget.OnTextBlockCommitted
	 * 		Flags  -> (Final, Native, Private, HasOutParms)
	 * Parameters:
	 * 		class FText                                        Text                                                       (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		ETextCommit                                        CommitMethod                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UItemCountSelectWidget::OnTextBlockCommitted(const class FText& Text, ETextCommit CommitMethod)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.ItemCountSelectWidget.OnTextBlockCommitted");
		
		UItemCountSelectWidget_OnTextBlockCommitted_Params params {};
		params.Text = Text;
		params.CommitMethod = CommitMethod;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017F8D20
	 * 		Name   -> Function DungeonCrawler.ItemCountSelectWidget.OnSliderValueChanged
	 * 		Flags  -> (Final, Native, Private)
	 * Parameters:
	 * 		float                                              Value                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UItemCountSelectWidget::OnSliderValueChanged(float Value)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.ItemCountSelectWidget.OnSliderValueChanged");
		
		UItemCountSelectWidget_OnSliderValueChanged_Params params {};
		params.Value = Value;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.ItemCountSelectWidget.OnRemovePopup
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 */
	void UItemCountSelectWidget::OnRemovePopup()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.ItemCountSelectWidget.OnRemovePopup");
		
		UItemCountSelectWidget_OnRemovePopup_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.ItemCountSelectWidget.OnCreatePopup
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 */
	void UItemCountSelectWidget::OnCreatePopup()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.ItemCountSelectWidget.OnCreatePopup");
		
		UItemCountSelectWidget_OnCreatePopup_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017F8240
	 * 		Name   -> Function DungeonCrawler.ItemCountSelectWidget.HandleRightButtonClicked
	 * 		Flags  -> (Final, Native, Protected)
	 */
	void UItemCountSelectWidget::HandleRightButtonClicked()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.ItemCountSelectWidget.HandleRightButtonClicked");
		
		UItemCountSelectWidget_HandleRightButtonClicked_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017F8220
	 * 		Name   -> Function DungeonCrawler.ItemCountSelectWidget.HandleLeftButtonClicked
	 * 		Flags  -> (Final, Native, Protected)
	 */
	void UItemCountSelectWidget::HandleLeftButtonClicked()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.ItemCountSelectWidget.HandleLeftButtonClicked");
		
		UItemCountSelectWidget_HandleLeftButtonClicked_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UItemCountSelectWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UItemCountSelectWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.ItemCountSelectWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017F8870
	 * 		Name   -> Function DungeonCrawler.DCItemDataComponent.OnLoadData_Sound
	 * 		Flags  -> (Final, Native, Private)
	 * Parameters:
	 * 		class UObject*                                     InLoadedObject                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UDCItemDataComponent::OnLoadData_Sound(class UObject* InLoadedObject)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCItemDataComponent.OnLoadData_Sound");
		
		UDCItemDataComponent_OnLoadData_Sound_Params params {};
		params.InLoadedObject = InLoadedObject;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017F87E0
	 * 		Name   -> Function DungeonCrawler.DCItemDataComponent.OnLoadData_Bundle
	 * 		Flags  -> (Final, Native, Private)
	 * Parameters:
	 * 		class UObject*                                     InLoadedObject                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UDCItemDataComponent::OnLoadData_Bundle(class UObject* InLoadedObject)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCItemDataComponent.OnLoadData_Bundle");
		
		UDCItemDataComponent_OnLoadData_Bundle_Params params {};
		params.InLoadedObject = InLoadedObject;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017F8750
	 * 		Name   -> Function DungeonCrawler.DCItemDataComponent.OnLoadData_Art
	 * 		Flags  -> (Final, Native, Private)
	 * Parameters:
	 * 		class UObject*                                     InLoadedObject                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UDCItemDataComponent::OnLoadData_Art(class UObject* InLoadedObject)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.DCItemDataComponent.OnLoadData_Art");
		
		UDCItemDataComponent_OnLoadData_Art_Params params {};
		params.InLoadedObject = InLoadedObject;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDCItemDataComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDCItemDataComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCItemDataComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017F9290
	 * 		Name   -> Function DungeonCrawler.ItemHolderActorBase.SetItemObject
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UItem*                                       Item                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AItemHolderActorBase::SetItemObject(class UItem* Item)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.ItemHolderActorBase.SetItemObject");
		
		AItemHolderActorBase_SetItemObject_Params params {};
		params.Item = Item;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017F8C60
	 * 		Name   -> Function DungeonCrawler.ItemHolderActorBase.OnRep_ItemId
	 * 		Flags  -> (Native, Protected, HasDefaults)
	 * Parameters:
	 * 		struct FPrimaryAssetId                             OldItemId                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AItemHolderActorBase::OnRep_ItemId(const struct FPrimaryAssetId& OldItemId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.ItemHolderActorBase.OnRep_ItemId");
		
		AItemHolderActorBase_OnRep_ItemId_Params params {};
		params.OldItemId = OldItemId;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017F8A80
	 * 		Name   -> Function DungeonCrawler.ItemHolderActorBase.OnRep_ArtDataItem
	 * 		Flags  -> (Native, Protected)
	 * Parameters:
	 * 		class UArtDataItem*                                OldArtDataItem                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AItemHolderActorBase::OnRep_ArtDataItem(class UArtDataItem* OldArtDataItem)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.ItemHolderActorBase.OnRep_ArtDataItem");
		
		AItemHolderActorBase_OnRep_ArtDataItem_Params params {};
		params.OldArtDataItem = OldArtDataItem;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AItemHolderActorBase.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AItemHolderActorBase::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.ItemHolderActorBase");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017FE230
	 * 		Name   -> Function DungeonCrawler.ItemMoveValidatorComponent.ServerMoveItem
	 * 		Flags  -> (Final, Net, NetReliable, Native, Event, Private, NetServer)
	 * Parameters:
	 * 		struct FItemData                                   OldItemData                                                (ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		TArray<struct FItemData>                           NewItemDataArray                                           (ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      OldOwner                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      NewOwner                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bHasDelay                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UItemMoveValidatorComponent::ServerMoveItem(const struct FItemData& OldItemData, TArray<struct FItemData> NewItemDataArray, class AActor* OldOwner, class AActor* NewOwner, bool bHasDelay)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.ItemMoveValidatorComponent.ServerMoveItem");
		
		UItemMoveValidatorComponent_ServerMoveItem_Params params {};
		params.OldItemData = OldItemData;
		params.NewItemDataArray = NewItemDataArray;
		params.OldOwner = OldOwner;
		params.NewOwner = NewOwner;
		params.bHasDelay = bHasDelay;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017FE020
	 * 		Name   -> Function DungeonCrawler.ItemMoveValidatorComponent.ClientShowMessage
	 * 		Flags  -> (Final, Net, Native, Event, Private, NetClient)
	 * Parameters:
	 * 		class FText                                        OutPutMessage                                              (ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UItemMoveValidatorComponent::ClientShowMessage(const class FText& OutPutMessage)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.ItemMoveValidatorComponent.ClientShowMessage");
		
		UItemMoveValidatorComponent_ClientShowMessage_Params params {};
		params.OutPutMessage = OutPutMessage;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017FDEB0
	 * 		Name   -> Function DungeonCrawler.ItemMoveValidatorComponent.ClientMoveItemEnd
	 * 		Flags  -> (Final, Net, NetReliable, Native, Event, Private, NetClient)
	 * Parameters:
	 * 		bool                                               bMoveSucceed                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		TArray<struct FItemData>                           MovedItemDataArray                                         (ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UItemMoveValidatorComponent::ClientMoveItemEnd(bool bMoveSucceed, TArray<struct FItemData> MovedItemDataArray)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.ItemMoveValidatorComponent.ClientMoveItemEnd");
		
		UItemMoveValidatorComponent_ClientMoveItemEnd_Params params {};
		params.bMoveSucceed = bMoveSucceed;
		params.MovedItemDataArray = MovedItemDataArray;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017FDBE0
	 * 		Name   -> Function DungeonCrawler.ItemMoveValidatorComponent.CheckEnableMoveItem
	 * 		Flags  -> (Final, Native, Private, HasOutParms)
	 * Parameters:
	 * 		struct FItemData                                   OldItemData                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		TArray<struct FItemData>                           NewItemDataArray                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      OldOwner                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      NewOwner                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UItemMoveValidatorComponent::CheckEnableMoveItem(const struct FItemData& OldItemData, TArray<struct FItemData> NewItemDataArray, class AActor* OldOwner, class AActor* NewOwner)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.ItemMoveValidatorComponent.CheckEnableMoveItem");
		
		UItemMoveValidatorComponent_CheckEnableMoveItem_Params params {};
		params.OldItemData = OldItemData;
		params.NewItemDataArray = NewItemDataArray;
		params.OldOwner = OldOwner;
		params.NewOwner = NewOwner;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UItemMoveValidatorComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UItemMoveValidatorComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.ItemMoveValidatorComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01764730
	 * 		Name   -> Function DungeonCrawler.ItemRandomGenerateComponent.UnbindMsgAll
	 * 		Flags  -> (Native, Public)
	 * Parameters:
	 * 		class UObject*                                     InObject                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UItemRandomGenerateComponent::UnbindMsgAll(class UObject* InObject)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.ItemRandomGenerateComponent.UnbindMsgAll");
		
		UItemRandomGenerateComponent_UnbindMsgAll_Params params {};
		params.InObject = InObject;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01764280
	 * 		Name   -> Function DungeonCrawler.ItemRandomGenerateComponent.UnbindMsg
	 * 		Flags  -> (Native, Public)
	 * Parameters:
	 * 		class UScriptStruct*                               InMsgType                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UObject*                                     InObject                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UItemRandomGenerateComponent::UnbindMsg(class UScriptStruct* InMsgType, class UObject* InObject)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.ItemRandomGenerateComponent.UnbindMsg");
		
		UItemRandomGenerateComponent_UnbindMsg_Params params {};
		params.InMsgType = InMsgType;
		params.InObject = InObject;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01763EB0
	 * 		Name   -> Function DungeonCrawler.ItemRandomGenerateComponent.TerminateBase
	 * 		Flags  -> (Native, Public)
	 */
	void UItemRandomGenerateComponent::TerminateBase()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.ItemRandomGenerateComponent.TerminateBase");
		
		UItemRandomGenerateComponent_TerminateBase_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017FE1D0
	 * 		Name   -> Function DungeonCrawler.ItemRandomGenerateComponent.GenerateItems
	 * 		Flags  -> (Final, Native, Private, BlueprintCallable)
	 */
	void UItemRandomGenerateComponent::GenerateItems()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.ItemRandomGenerateComponent.GenerateItems");
		
		UItemRandomGenerateComponent_GenerateItems_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017FE100
	 * 		Name   -> Function DungeonCrawler.ItemRandomGenerateComponent.DropItem
	 * 		Flags  -> (Final, Native, Private, BlueprintCallable)
	 * Parameters:
	 * 		int64_t                                            ItemUniqueId                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      Owner                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UItemRandomGenerateComponent::DropItem(int64_t ItemUniqueId, class AActor* Owner)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.ItemRandomGenerateComponent.DropItem");
		
		UItemRandomGenerateComponent_DropItem_Params params {};
		params.ItemUniqueId = ItemUniqueId;
		params.Owner = Owner;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017FE0E0
	 * 		Name   -> Function DungeonCrawler.ItemRandomGenerateComponent.DropAllItems
	 * 		Flags  -> (Final, Native, Private, BlueprintCallable)
	 */
	void UItemRandomGenerateComponent::DropAllItems()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.ItemRandomGenerateComponent.DropAllItems");
		
		UItemRandomGenerateComponent_DropAllItems_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017FDE90
	 * 		Name   -> Function DungeonCrawler.ItemRandomGenerateComponent.ClearAllItems
	 * 		Flags  -> (Final, Native, Private, BlueprintCallable)
	 */
	void UItemRandomGenerateComponent::ClearAllItems()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.ItemRandomGenerateComponent.ClearAllItems");
		
		UItemRandomGenerateComponent_ClearAllItems_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D3C640
	 * 		Name   -> Function DungeonCrawler.ItemRandomGenerateComponent.BroadcastMsgBlueprint
	 * 		Flags  -> (Native, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		int32_t                                            InMsg                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UItemRandomGenerateComponent::BroadcastMsgBlueprint(int32_t InMsg)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.ItemRandomGenerateComponent.BroadcastMsgBlueprint");
		
		UItemRandomGenerateComponent_BroadcastMsgBlueprint_Params params {};
		params.InMsg = InMsg;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UItemRandomGenerateComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UItemRandomGenerateComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.ItemRandomGenerateComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.ItemRichTextBlockDecorator.GetItemTextBlockStyle
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		struct FGameplayTag                                InRarityType                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FTextBlockStyle UItemRichTextBlockDecorator::GetItemTextBlockStyle(const struct FGameplayTag& InRarityType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.ItemRichTextBlockDecorator.GetItemTextBlockStyle");
		
		UItemRichTextBlockDecorator_GetItemTextBlockStyle_Params params {};
		params.InRarityType = InRarityType;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UItemRichTextBlockDecorator.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UItemRichTextBlockDecorator::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.ItemRichTextBlockDecorator");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UItemTooltipRequirementListEntryWidgetData.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UItemTooltipRequirementListEntryWidgetData::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.ItemTooltipRequirementListEntryWidgetData");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UItemTooltipRequirementListWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UItemTooltipRequirementListWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.ItemTooltipRequirementListWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.ItemTooltipRequirementWidget.OnChangedRequirementStatus
	 * 		Flags  -> (Event, Protected, BlueprintCallable, BlueprintEvent)
	 * Parameters:
	 * 		bool                                               bFulfilled                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UItemTooltipRequirementWidget::OnChangedRequirementStatus(bool bFulfilled)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.ItemTooltipRequirementWidget.OnChangedRequirementStatus");
		
		UItemTooltipRequirementWidget_OnChangedRequirementStatus_Params params {};
		params.bFulfilled = bFulfilled;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UItemTooltipRequirementWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UItemTooltipRequirementWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.ItemTooltipRequirementWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UItemTooltipStatWidgetData.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UItemTooltipStatWidgetData::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.ItemTooltipStatWidgetData");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UItemTooltipStatWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UItemTooltipStatWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.ItemTooltipStatWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017FE500
	 * 		Name   -> Function DungeonCrawler.ItemTooltipWidget.SetItemData
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		struct FItemData                                   NewItemData                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UItemTooltipWidget::SetItemData(const struct FItemData& NewItemData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.ItemTooltipWidget.SetItemData");
		
		UItemTooltipWidget_SetItemData_Params params {};
		params.NewItemData = NewItemData;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.ItemTooltipWidget.OnRefreshItemName
	 * 		Flags  -> (Event, Protected, BlueprintCallable, BlueprintEvent)
	 */
	void UItemTooltipWidget::OnRefreshItemName()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.ItemTooltipWidget.OnRefreshItemName");
		
		UItemTooltipWidget_OnRefreshItemName_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.ItemTooltipWidget.OnItemData
	 * 		Flags  -> (Event, Protected, HasOutParms, BlueprintEvent)
	 * Parameters:
	 * 		struct FItemData                                   NewItemData                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		struct FItemData                                   OldItemData                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UItemTooltipWidget::OnItemData(const struct FItemData& NewItemData, const struct FItemData& OldItemData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.ItemTooltipWidget.OnItemData");
		
		UItemTooltipWidget_OnItemData_Params params {};
		params.NewItemData = NewItemData;
		params.OldItemData = OldItemData;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UItemTooltipWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UItemTooltipWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.ItemTooltipWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.ItemWeaponAnimInstanceBase.OnItemDataUpdated
	 * 		Flags  -> (Event, Protected, HasOutParms, BlueprintEvent)
	 * Parameters:
	 * 		struct FItemData                                   ItemData                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UItemWeaponAnimInstanceBase::OnItemDataUpdated(const struct FItemData& ItemData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.ItemWeaponAnimInstanceBase.OnItemDataUpdated");
		
		UItemWeaponAnimInstanceBase_OnItemDataUpdated_Params params {};
		params.ItemData = ItemData;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UItemWeaponAnimInstanceBase.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UItemWeaponAnimInstanceBase::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.ItemWeaponAnimInstanceBase");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ULeaderBoardClassIconWidgetData.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ULeaderBoardClassIconWidgetData::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.LeaderBoardClassIconWidgetData");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017FE210
	 * 		Name   -> Function DungeonCrawler.LeaderBoardClassIconWidget.OnClickedClassIconButton
	 * 		Flags  -> (Final, Native, Protected, BlueprintCallable)
	 */
	void ULeaderBoardClassIconWidget::OnClickedClassIconButton()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.LeaderBoardClassIconWidget.OnClickedClassIconButton");
		
		ULeaderBoardClassIconWidget_OnClickedClassIconButton_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ULeaderBoardClassIconWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ULeaderBoardClassIconWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.LeaderBoardClassIconWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ULeaderBoardRankRecordListWidgetData.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ULeaderBoardRankRecordListWidgetData::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.LeaderBoardRankRecordListWidgetData");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.LeaderBoardRankRecordListWidget.OnRankData
	 * 		Flags  -> (Event, Protected, HasOutParms, BlueprintEvent)
	 * Parameters:
	 * 		struct FRankData                                   NewValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		struct FRankData                                   OldValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void ULeaderBoardRankRecordListWidget::OnRankData(const struct FRankData& NewValue, const struct FRankData& OldValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.LeaderBoardRankRecordListWidget.OnRankData");
		
		ULeaderBoardRankRecordListWidget_OnRankData_Params params {};
		params.NewValue = NewValue;
		params.OldValue = OldValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ULeaderBoardRankRecordListWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ULeaderBoardRankRecordListWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.LeaderBoardRankRecordListWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ULeaderBoardRankRecordMineWidgetData.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ULeaderBoardRankRecordMineWidgetData::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.LeaderBoardRankRecordMineWidgetData");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.LeaderBoardRankRecordMineWidget.OnRankRecordMineData
	 * 		Flags  -> (Event, Protected, HasOutParms, BlueprintEvent)
	 * Parameters:
	 * 		struct FRankRecord                                 NewValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		struct FRankRecord                                 OldValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void ULeaderBoardRankRecordMineWidget::OnRankRecordMineData(const struct FRankRecord& NewValue, const struct FRankRecord& OldValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.LeaderBoardRankRecordMineWidget.OnRankRecordMineData");
		
		ULeaderBoardRankRecordMineWidget_OnRankRecordMineData_Params params {};
		params.NewValue = NewValue;
		params.OldValue = OldValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.LeaderBoardRankRecordMineWidget.OnFMsgWidgetStreamingModeNotifyBlueprint
	 * 		Flags  -> (Event, Protected, HasOutParms, BlueprintEvent)
	 * Parameters:
	 * 		struct FMsgWidgetStreamingModeNotify               InMsg                                                      (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void ULeaderBoardRankRecordMineWidget::OnFMsgWidgetStreamingModeNotifyBlueprint(const struct FMsgWidgetStreamingModeNotify& InMsg)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.LeaderBoardRankRecordMineWidget.OnFMsgWidgetStreamingModeNotifyBlueprint");
		
		ULeaderBoardRankRecordMineWidget_OnFMsgWidgetStreamingModeNotifyBlueprint_Params params {};
		params.InMsg = InMsg;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ULeaderBoardRankRecordMineWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ULeaderBoardRankRecordMineWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.LeaderBoardRankRecordMineWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ULeaderBoardRankRecordWidgetData.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ULeaderBoardRankRecordWidgetData::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.LeaderBoardRankRecordWidgetData");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.LeaderBoardRankRecordWidget.OnRankRecordData
	 * 		Flags  -> (Event, Protected, HasOutParms, BlueprintEvent)
	 * Parameters:
	 * 		struct FRankRecord                                 NewValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		struct FRankRecord                                 OldValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void ULeaderBoardRankRecordWidget::OnRankRecordData(const struct FRankRecord& NewValue, const struct FRankRecord& OldValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.LeaderBoardRankRecordWidget.OnRankRecordData");
		
		ULeaderBoardRankRecordWidget_OnRankRecordData_Params params {};
		params.NewValue = NewValue;
		params.OldValue = OldValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.LeaderBoardRankRecordWidget.OnMineRankRecordData
	 * 		Flags  -> (Event, Protected, HasOutParms, BlueprintEvent)
	 * Parameters:
	 * 		struct FRankRecord                                 MineValue                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		bool                                               IsMine                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ULeaderBoardRankRecordWidget::OnMineRankRecordData(const struct FRankRecord& MineValue, bool IsMine)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.LeaderBoardRankRecordWidget.OnMineRankRecordData");
		
		ULeaderBoardRankRecordWidget_OnMineRankRecordData_Params params {};
		params.MineValue = MineValue;
		params.IsMine = IsMine;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.LeaderBoardRankRecordWidget.OnFMsgWidgetStreamingModeNotifyBlueprint
	 * 		Flags  -> (Event, Protected, HasOutParms, BlueprintEvent)
	 * Parameters:
	 * 		struct FMsgWidgetStreamingModeNotify               InMsg                                                      (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void ULeaderBoardRankRecordWidget::OnFMsgWidgetStreamingModeNotifyBlueprint(const struct FMsgWidgetStreamingModeNotify& InMsg)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.LeaderBoardRankRecordWidget.OnFMsgWidgetStreamingModeNotifyBlueprint");
		
		ULeaderBoardRankRecordWidget_OnFMsgWidgetStreamingModeNotifyBlueprint_Params params {};
		params.InMsg = InMsg;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ULeaderBoardRankRecordWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ULeaderBoardRankRecordWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.LeaderBoardRankRecordWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ULeaderBoardWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ULeaderBoardWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.LeaderBoardWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ULoadoutItemWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ULoadoutItemWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.LoadoutItemWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ULoadoutWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ULoadoutWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.LoadoutWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x018039D0
	 * 		Name   -> Function DungeonCrawler.LobbyGroupMerchantWidget.OnBackButtonClicked
	 * 		Flags  -> (Final, Native, Private)
	 */
	void ULobbyGroupMerchantWidget::OnBackButtonClicked()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.LobbyGroupMerchantWidget.OnBackButtonClicked");
		
		ULobbyGroupMerchantWidget_OnBackButtonClicked_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ULobbyGroupMerchantWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ULobbyGroupMerchantWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.LobbyGroupMerchantWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01803C70
	 * 		Name   -> Function DungeonCrawler.LobbyGroupTradeChannelWidget.OnReadRulesButtonClicked
	 * 		Flags  -> (Final, Native, Private)
	 */
	void ULobbyGroupTradeChannelWidget::OnReadRulesButtonClicked()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.LobbyGroupTradeChannelWidget.OnReadRulesButtonClicked");
		
		ULobbyGroupTradeChannelWidget_OnReadRulesButtonClicked_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01803A10
	 * 		Name   -> Function DungeonCrawler.LobbyGroupTradeChannelWidget.OnLeaveChannelButtonClicked
	 * 		Flags  -> (Final, Native, Protected, BlueprintCallable)
	 */
	void ULobbyGroupTradeChannelWidget::OnLeaveChannelButtonClicked()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.LobbyGroupTradeChannelWidget.OnLeaveChannelButtonClicked");
		
		ULobbyGroupTradeChannelWidget_OnLeaveChannelButtonClicked_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ULobbyGroupTradeChannelWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ULobbyGroupTradeChannelWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.LobbyGroupTradeChannelWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01803C70
	 * 		Name   -> Function DungeonCrawler.LobbyGroupTradingWidget.OnReadRulesButtonClicked
	 * 		Flags  -> (Final, Native, Private)
	 */
	void ULobbyGroupTradingWidget::OnReadRulesButtonClicked()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.LobbyGroupTradingWidget.OnReadRulesButtonClicked");
		
		ULobbyGroupTradingWidget_OnReadRulesButtonClicked_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x017C21F0
	 * 		Name   -> Function DungeonCrawler.LobbyGroupTradingWidget.OnLeaveChannelButtonClicked
	 * 		Flags  -> (Final, Native, Protected, BlueprintCallable)
	 */
	void ULobbyGroupTradingWidget::OnLeaveChannelButtonClicked()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.LobbyGroupTradingWidget.OnLeaveChannelButtonClicked");
		
		ULobbyGroupTradingWidget_OnLeaveChannelButtonClicked_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ULobbyGroupTradingWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ULobbyGroupTradingWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.LobbyGroupTradingWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.LobbyTopMenuWidget.OnPlayPartyReadyStateChanged
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 * Parameters:
	 * 		bool                                               bMine                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bLeader                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bReady                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ULobbyTopMenuWidget::OnPlayPartyReadyStateChanged(bool bMine, bool bLeader, bool bReady)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.LobbyTopMenuWidget.OnPlayPartyReadyStateChanged");
		
		ULobbyTopMenuWidget_OnPlayPartyReadyStateChanged_Params params {};
		params.bMine = bMine;
		params.bLeader = bLeader;
		params.bReady = bReady;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.LobbyTopMenuWidget.OnMatchingStateChanged
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 * Parameters:
	 * 		bool                                               bMatching                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ULobbyTopMenuWidget::OnMatchingStateChanged(bool bMatching)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.LobbyTopMenuWidget.OnMatchingStateChanged");
		
		ULobbyTopMenuWidget_OnMatchingStateChanged_Params params {};
		params.bMatching = bMatching;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ULobbyTopMenuWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ULobbyTopMenuWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.LobbyTopMenuWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ULobbyUserSlotBase.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ULobbyUserSlotBase::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.LobbyUserSlotBase");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01803B90
	 * 		Name   -> Function DungeonCrawler.LobbyWidget.OnPopupSWidgetInvitePartyAnswerResponse
	 * 		Flags  -> (Final, Native, Protected)
	 * Parameters:
	 * 		EPopupResult                                       PopupResult                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FString                                      ReturnAccountId                                            (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ULobbyWidget::OnPopupSWidgetInvitePartyAnswerResponse(EPopupResult PopupResult, const class FString& ReturnAccountId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.LobbyWidget.OnPopupSWidgetInvitePartyAnswerResponse");
		
		ULobbyWidget_OnPopupSWidgetInvitePartyAnswerResponse_Params params {};
		params.PopupResult = PopupResult;
		params.ReturnAccountId = ReturnAccountId;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01803A50
	 * 		Name   -> Function DungeonCrawler.LobbyWidget.OnPopupSWidgetInvitePartyAnswerRequest
	 * 		Flags  -> (Final, Native, Protected, HasOutParms)
	 * Parameters:
	 * 		class UPopupDataBase*                              PopupData                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FClientMsgInvitePartyNotifyBody             InvitePartyBody                                            (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void ULobbyWidget::OnPopupSWidgetInvitePartyAnswerRequest(class UPopupDataBase* PopupData, const struct FClientMsgInvitePartyNotifyBody& InvitePartyBody)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.LobbyWidget.OnPopupSWidgetInvitePartyAnswerRequest");
		
		ULobbyWidget_OnPopupSWidgetInvitePartyAnswerRequest_Params params {};
		params.PopupData = PopupData;
		params.InvitePartyBody = InvitePartyBody;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.LobbyWidget.OnLobbySystemMessage
	 * 		Flags  -> (Event, Protected, HasOutParms, BlueprintEvent)
	 * Parameters:
	 * 		class FText                                        AnnounceText                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void ULobbyWidget::OnLobbySystemMessage(const class FText& AnnounceText)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.LobbyWidget.OnLobbySystemMessage");
		
		ULobbyWidget_OnLobbySystemMessage_Params params {};
		params.AnnounceText = AnnounceText;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ULobbyWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ULobbyWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.LobbyWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01803F20
	 * 		Name   -> Function DungeonCrawler.LoginWidget.OnTextChangedPassWord
	 * 		Flags  -> (Final, Native, Private, HasOutParms)
	 * Parameters:
	 * 		class FText                                        InPassWord                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void ULoginWidget::OnTextChangedPassWord(const class FText& InPassWord)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.LoginWidget.OnTextChangedPassWord");
		
		ULoginWidget_OnTextChangedPassWord_Params params {};
		params.InPassWord = InPassWord;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01803E50
	 * 		Name   -> Function DungeonCrawler.LoginWidget.OnTextChangedLoginId
	 * 		Flags  -> (Final, Native, Private, HasOutParms)
	 * Parameters:
	 * 		class FText                                        InLoginId                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void ULoginWidget::OnTextChangedLoginId(const class FText& InLoginId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.LoginWidget.OnTextChangedLoginId");
		
		ULoginWidget_OnTextChangedLoginId_Params params {};
		params.InLoginId = InLoginId;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01803D20
	 * 		Name   -> Function DungeonCrawler.LoginWidget.OnSelectionChanged
	 * 		Flags  -> (Final, Native, Private)
	 * Parameters:
	 * 		class FString                                      SelectedItem                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		ESelectInfo                                        SelectionType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ULoginWidget::OnSelectionChanged(const class FString& SelectedItem, ESelectInfo SelectionType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.LoginWidget.OnSelectionChanged");
		
		ULoginWidget_OnSelectionChanged_Params params {};
		params.SelectedItem = SelectedItem;
		params.SelectionType = SelectionType;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01803A30
	 * 		Name   -> Function DungeonCrawler.LoginWidget.OnLoginButtonClicked
	 * 		Flags  -> (Final, Native, Protected, BlueprintCallable)
	 */
	void ULoginWidget::OnLoginButtonClicked()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.LoginWidget.OnLoginButtonClicked");
		
		ULoginWidget_OnLoginButtonClicked_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.LoginWidget.OnLogin
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 */
	void ULoginWidget::OnLogin()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.LoginWidget.OnLogin");
		
		ULoginWidget_OnLogin_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ULoginWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ULoginWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.LoginWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01804010
	 * 		Name   -> Function DungeonCrawler.LootComponent.ServerRemoveLootTarget
	 * 		Flags  -> (Final, Net, NetReliable, Native, Event, Private, NetServer)
	 * Parameters:
	 * 		class UInventoryComponent*                         InventoryComponent                                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		TArray<struct FItemData>                           InContainingItems                                          (ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void ULootComponent::ServerRemoveLootTarget(class UInventoryComponent* InventoryComponent, TArray<struct FItemData> InContainingItems)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.LootComponent.ServerRemoveLootTarget");
		
		ULootComponent_ServerRemoveLootTarget_Params params {};
		params.InventoryComponent = InventoryComponent;
		params.InContainingItems = InContainingItems;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01803FF0
	 * 		Name   -> Function DungeonCrawler.LootComponent.ServerClearLootingTargetContainingItems
	 * 		Flags  -> (Final, Net, NetReliable, Native, Event, Private, NetServer)
	 */
	void ULootComponent::ServerClearLootingTargetContainingItems()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.LootComponent.ServerClearLootingTargetContainingItems");
		
		ULootComponent_ServerClearLootingTargetContainingItems_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01803C90
	 * 		Name   -> Function DungeonCrawler.LootComponent.OnRep_LootTargetActor
	 * 		Flags  -> (Final, Native, Private)
	 * Parameters:
	 * 		class AActor*                                      OldLootTargetActor                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ULootComponent::OnRep_LootTargetActor(class AActor* OldLootTargetActor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.LootComponent.OnRep_LootTargetActor");
		
		ULootComponent_OnRep_LootTargetActor_Params params {};
		params.OldLootTargetActor = OldLootTargetActor;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00F4FBD0
	 * 		Name   -> Function DungeonCrawler.LootComponent.IsLootTargetPlayer
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	bool ULootComponent::IsLootTargetPlayer()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.LootComponent.IsLootTargetPlayer");
		
		ULootComponent_IsLootTargetPlayer_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x018039B0
	 * 		Name   -> Function DungeonCrawler.LootComponent.GetLootTargetActor
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	class AActor* ULootComponent::GetLootTargetActor()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.LootComponent.GetLootTargetActor");
		
		ULootComponent_GetLootTargetActor_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ULootComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ULootComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.LootComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ULootingPlayerInventoryWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ULootingPlayerInventoryWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.LootingPlayerInventoryWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AMerchantActorBase.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AMerchantActorBase::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.MerchantActorBase");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01804170
	 * 		Name   -> Function DungeonCrawler.MerchantDealTableWidget.UpdateMerchantRemainTime
	 * 		Flags  -> (Final, Native, Private)
	 */
	void UMerchantDealTableWidget::UpdateMerchantRemainTime()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.MerchantDealTableWidget.UpdateMerchantRemainTime");
		
		UMerchantDealTableWidget_UpdateMerchantRemainTime_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.MerchantDealTableWidget.OnSetMerchantScript
	 * 		Flags  -> (Event, Protected, HasOutParms, BlueprintEvent)
	 * Parameters:
	 * 		class FText                                        InScript                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UMerchantDealTableWidget::OnSetMerchantScript(const class FText& InScript)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.MerchantDealTableWidget.OnSetMerchantScript");
		
		UMerchantDealTableWidget_OnSetMerchantScript_Params params {};
		params.InScript = InScript;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.MerchantDealTableWidget.OnSetMerchantRemainTime
	 * 		Flags  -> (Event, Protected, HasDefaults, BlueprintEvent)
	 * Parameters:
	 * 		struct FTimespan                                   RemainTime                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UMerchantDealTableWidget::OnSetMerchantRemainTime(const struct FTimespan& RemainTime)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.MerchantDealTableWidget.OnSetMerchantRemainTime");
		
		UMerchantDealTableWidget_OnSetMerchantRemainTime_Params params {};
		params.RemainTime = RemainTime;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.MerchantDealTableWidget.OnSetMerchantPortrait
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 * Parameters:
	 * 		class UTexture2D*                                  Portrait                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UMerchantDealTableWidget::OnSetMerchantPortrait(class UTexture2D* Portrait)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.MerchantDealTableWidget.OnSetMerchantPortrait");
		
		UMerchantDealTableWidget_OnSetMerchantPortrait_Params params {};
		params.Portrait = Portrait;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.MerchantDealTableWidget.OnSetMerchantName
	 * 		Flags  -> (Event, Protected, HasOutParms, BlueprintEvent)
	 * Parameters:
	 * 		class FText                                        Name                                                       (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UMerchantDealTableWidget::OnSetMerchantName(const class FText& Name)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.MerchantDealTableWidget.OnSetMerchantName");
		
		UMerchantDealTableWidget_OnSetMerchantName_Params params {};
		params.Name = Name;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.MerchantDealTableWidget.OnSetMerchantFaction
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 * Parameters:
	 * 		int32_t                                            InFaction                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UMerchantDealTableWidget::OnSetMerchantFaction(int32_t InFaction)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.MerchantDealTableWidget.OnSetMerchantFaction");
		
		UMerchantDealTableWidget_OnSetMerchantFaction_Params params {};
		params.InFaction = InFaction;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.MerchantDealTableWidget.OnMerchantServiceActiveNotify
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 * Parameters:
	 * 		EWidgetMerchantServiceType                         ActiveService                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UMerchantDealTableWidget::OnMerchantServiceActiveNotify(EWidgetMerchantServiceType ActiveService)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.MerchantDealTableWidget.OnMerchantServiceActiveNotify");
		
		UMerchantDealTableWidget_OnMerchantServiceActiveNotify_Params params {};
		params.ActiveService = ActiveService;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMerchantDealTableWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMerchantDealTableWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.MerchantDealTableWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMerchantInventoryWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMerchantInventoryWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.MerchantInventoryWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.MerchantItemWidget.SetActivateStockSellBackInfo
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 * Parameters:
	 * 		bool                                               bSellTabOpen                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UMerchantItemWidget::SetActivateStockSellBackInfo(bool bSellTabOpen)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.MerchantItemWidget.SetActivateStockSellBackInfo");
		
		UMerchantItemWidget_SetActivateStockSellBackInfo_Params params {};
		params.bSellTabOpen = bSellTabOpen;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.MerchantItemWidget.OnStockSellBackDataSet
	 * 		Flags  -> (Event, Protected, HasOutParms, BlueprintEvent)
	 * Parameters:
	 * 		struct FStockSellBackData                          InStockSellBackData                                        (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UMerchantItemWidget::OnStockSellBackDataSet(const struct FStockSellBackData& InStockSellBackData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.MerchantItemWidget.OnStockSellBackDataSet");
		
		UMerchantItemWidget_OnStockSellBackDataSet_Params params {};
		params.InStockSellBackData = InStockSellBackData;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.MerchantItemWidget.OnStockCraftDataSet
	 * 		Flags  -> (Event, Protected, HasOutParms, BlueprintEvent)
	 * Parameters:
	 * 		struct FStockCraftData                             InStockCraftData                                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UMerchantItemWidget::OnStockCraftDataSet(const struct FStockCraftData& InStockCraftData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.MerchantItemWidget.OnStockCraftDataSet");
		
		UMerchantItemWidget_OnStockCraftDataSet_Params params {};
		params.InStockCraftData = InStockCraftData;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.MerchantItemWidget.OnStockBuyDataSet
	 * 		Flags  -> (Event, Protected, HasOutParms, BlueprintEvent)
	 * Parameters:
	 * 		struct FStockBuyData                               InStockBuyData                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UMerchantItemWidget::OnStockBuyDataSet(const struct FStockBuyData& InStockBuyData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.MerchantItemWidget.OnStockBuyDataSet");
		
		UMerchantItemWidget_OnStockBuyDataSet_Params params {};
		params.InStockBuyData = InStockBuyData;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.MerchantItemWidget.OnSelected
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 * Parameters:
	 * 		bool                                               bSelected                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UMerchantItemWidget::OnSelected(bool bSelected)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.MerchantItemWidget.OnSelected");
		
		UMerchantItemWidget_OnSelected_Params params {};
		params.bSelected = bSelected;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMerchantItemWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMerchantItemWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.MerchantItemWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01804190
	 * 		Name   -> Function DungeonCrawler.MerchantListSlotWidget.UpdateMerchantRemainTime
	 * 		Flags  -> (Final, Native, Private)
	 */
	void UMerchantListSlotWidget::UpdateMerchantRemainTime()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.MerchantListSlotWidget.UpdateMerchantRemainTime");
		
		UMerchantListSlotWidget_UpdateMerchantRemainTime_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.MerchantListSlotWidget.OnSetMerchantRemainTime
	 * 		Flags  -> (Event, Public, HasDefaults, BlueprintEvent)
	 * Parameters:
	 * 		struct FTimespan                                   RemainTime                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UMerchantListSlotWidget::OnSetMerchantRemainTime(const struct FTimespan& RemainTime)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.MerchantListSlotWidget.OnSetMerchantRemainTime");
		
		UMerchantListSlotWidget_OnSetMerchantRemainTime_Params params {};
		params.RemainTime = RemainTime;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.MerchantListSlotWidget.OnSetMerchantPortrait
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 * Parameters:
	 * 		class UTexture2D*                                  Portrait                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UMerchantListSlotWidget::OnSetMerchantPortrait(class UTexture2D* Portrait)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.MerchantListSlotWidget.OnSetMerchantPortrait");
		
		UMerchantListSlotWidget_OnSetMerchantPortrait_Params params {};
		params.Portrait = Portrait;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.MerchantListSlotWidget.OnSetMerchantName
	 * 		Flags  -> (Event, Protected, HasOutParms, BlueprintEvent)
	 * Parameters:
	 * 		class FText                                        Name                                                       (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UMerchantListSlotWidget::OnSetMerchantName(const class FText& Name)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.MerchantListSlotWidget.OnSetMerchantName");
		
		UMerchantListSlotWidget_OnSetMerchantName_Params params {};
		params.Name = Name;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.MerchantListSlotWidget.OnSetMerchantFaction
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 * Parameters:
	 * 		int32_t                                            InFaction                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UMerchantListSlotWidget::OnSetMerchantFaction(int32_t InFaction)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.MerchantListSlotWidget.OnSetMerchantFaction");
		
		UMerchantListSlotWidget_OnSetMerchantFaction_Params params {};
		params.InFaction = InFaction;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x018039F0
	 * 		Name   -> Function DungeonCrawler.MerchantListSlotWidget.OnClickedDeal
	 * 		Flags  -> (Final, Native, Private)
	 */
	void UMerchantListSlotWidget::OnClickedDeal()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.MerchantListSlotWidget.OnClickedDeal");
		
		UMerchantListSlotWidget_OnClickedDeal_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMerchantListSlotWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMerchantListSlotWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.MerchantListSlotWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.MerchantListWidget.OnRemoveAllMerchantListSlotWidget
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 */
	void UMerchantListWidget::OnRemoveAllMerchantListSlotWidget()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.MerchantListWidget.OnRemoveAllMerchantListSlotWidget");
		
		UMerchantListWidget_OnRemoveAllMerchantListSlotWidget_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.MerchantListWidget.OnAddMerchantListSlotWidget
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 * Parameters:
	 * 		class UUserWidget*                                 AddedSlotWidget                                            (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UMerchantListWidget::OnAddMerchantListSlotWidget(class UUserWidget* AddedSlotWidget)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.MerchantListWidget.OnAddMerchantListSlotWidget");
		
		UMerchantListWidget_OnAddMerchantListSlotWidget_Params params {};
		params.AddedSlotWidget = AddedSlotWidget;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMerchantListWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMerchantListWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.MerchantListWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01808E90
	 * 		Name   -> Function DungeonCrawler.MerchantServiceTabWidget.OnClickedServiceTab
	 * 		Flags  -> (Final, Native, Protected)
	 */
	void UMerchantServiceTabWidget::OnClickedServiceTab()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.MerchantServiceTabWidget.OnClickedServiceTab");
		
		UMerchantServiceTabWidget_OnClickedServiceTab_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.MerchantServiceTabWidget.OnChangeActiveState
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 * Parameters:
	 * 		bool                                               bActive                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UMerchantServiceTabWidget::OnChangeActiveState(bool bActive)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.MerchantServiceTabWidget.OnChangeActiveState");
		
		UMerchantServiceTabWidget_OnChangeActiveState_Params params {};
		params.bActive = bActive;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMerchantServiceTabWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMerchantServiceTabWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.MerchantServiceTabWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMerchantServiceGroupTabWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMerchantServiceGroupTabWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.MerchantServiceGroupTabWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.MerchantServiceWidget.OnMerchantServiceActiveNotify
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 * Parameters:
	 * 		EWidgetMerchantServiceType                         ActiveService                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UMerchantServiceWidget::OnMerchantServiceActiveNotify(EWidgetMerchantServiceType ActiveService)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.MerchantServiceWidget.OnMerchantServiceActiveNotify");
		
		UMerchantServiceWidget_OnMerchantServiceActiveNotify_Params params {};
		params.ActiveService = ActiveService;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMerchantServiceWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMerchantServiceWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.MerchantServiceWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMetaClassComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMetaClassComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.MetaClassComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMetaDealTableInventoryComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMetaDealTableInventoryComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.MetaDealTableInventoryComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMetaFriendComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMetaFriendComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.MetaFriendComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01808EB0
	 * 		Name   -> Function DungeonCrawler.MetaInventoryComponent.OnLobbyCharacterInfoUupdated
	 * 		Flags  -> (Final, Native, Protected)
	 */
	void UMetaInventoryComponent::OnLobbyCharacterInfoUupdated()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.MetaInventoryComponent.OnLobbyCharacterInfoUupdated");
		
		UMetaInventoryComponent_OnLobbyCharacterInfoUupdated_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMetaInventoryComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMetaInventoryComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.MetaInventoryComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMetaItemComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMetaItemComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.MetaItemComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMetaLeaderBoardComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMetaLeaderBoardComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.MetaLeaderBoardComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01808EF0
	 * 		Name   -> Function DungeonCrawler.MetaMerchantActor.OnSetMerchantInfoArray
	 * 		Flags  -> (Final, Native, Private)
	 */
	void AMetaMerchantActor::OnSetMerchantInfoArray()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.MetaMerchantActor.OnSetMerchantInfoArray");
		
		AMetaMerchantActor_OnSetMerchantInfoArray_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AMetaMerchantActor.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AMetaMerchantActor::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.MetaMerchantActor");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMetaPartyInterface.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMetaPartyInterface::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.MetaPartyInterface");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMetaPlayComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMetaPlayComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.MetaPlayComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x018185E0
	 * 		Name   -> Function DungeonCrawler.StockBuyInventoryComponent.SetStockBuyDataArray
	 * 		Flags  -> (Native, Protected)
	 * Parameters:
	 * 		struct FMerchantInfo                               InMerchantInfo                                             (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UStockBuyInventoryComponent::SetStockBuyDataArray(const struct FMerchantInfo& InMerchantInfo)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.StockBuyInventoryComponent.SetStockBuyDataArray");
		
		UStockBuyInventoryComponent_SetStockBuyDataArray_Params params {};
		params.InMerchantInfo = InMerchantInfo;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01818130
	 * 		Name   -> Function DungeonCrawler.StockBuyInventoryComponent.RequestStockBuy
	 * 		Flags  -> (Native, Protected, HasOutParms)
	 * Parameters:
	 * 		struct FStockBuyData                               InStockBuyData                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UStockBuyInventoryComponent::RequestStockBuy(const struct FStockBuyData& InStockBuyData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.StockBuyInventoryComponent.RequestStockBuy");
		
		UStockBuyInventoryComponent_RequestStockBuy_Params params {};
		params.InStockBuyData = InStockBuyData;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UStockBuyInventoryComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UStockBuyInventoryComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.StockBuyInventoryComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMetaStockBuyInventoryComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMetaStockBuyInventoryComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.MetaStockBuyInventoryComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x018185E0
	 * 		Name   -> Function DungeonCrawler.StockCraftInventoryComponent.SetStockCraftDataArray
	 * 		Flags  -> (Native, Protected)
	 * Parameters:
	 * 		struct FMerchantInfo                               InMerchantInfo                                             (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UStockCraftInventoryComponent::SetStockCraftDataArray(const struct FMerchantInfo& InMerchantInfo)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.StockCraftInventoryComponent.SetStockCraftDataArray");
		
		UStockCraftInventoryComponent_SetStockCraftDataArray_Params params {};
		params.InMerchantInfo = InMerchantInfo;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01818130
	 * 		Name   -> Function DungeonCrawler.StockCraftInventoryComponent.RequestStockCraft
	 * 		Flags  -> (Native, Protected, HasOutParms)
	 * Parameters:
	 * 		struct FStockCraftData                             InStockCraftData                                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UStockCraftInventoryComponent::RequestStockCraft(const struct FStockCraftData& InStockCraftData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.StockCraftInventoryComponent.RequestStockCraft");
		
		UStockCraftInventoryComponent_RequestStockCraft_Params params {};
		params.InStockCraftData = InStockCraftData;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UStockCraftInventoryComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UStockCraftInventoryComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.StockCraftInventoryComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMetaStockCraftInventoryComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMetaStockCraftInventoryComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.MetaStockCraftInventoryComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x018185E0
	 * 		Name   -> Function DungeonCrawler.StockSellBackInventoryComponent.SetStockSellBackItemArray
	 * 		Flags  -> (Native, Protected)
	 * Parameters:
	 * 		struct FMerchantInfo                               InMerchantInfo                                             (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UStockSellBackInventoryComponent::SetStockSellBackItemArray(const struct FMerchantInfo& InMerchantInfo)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.StockSellBackInventoryComponent.SetStockSellBackItemArray");
		
		UStockSellBackInventoryComponent_SetStockSellBackItemArray_Params params {};
		params.InMerchantInfo = InMerchantInfo;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UStockSellBackInventoryComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UStockSellBackInventoryComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.StockSellBackInventoryComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMetaStockSellInventoryComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMetaStockSellInventoryComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.MetaStockSellInventoryComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01808ED0
	 * 		Name   -> Function DungeonCrawler.MetaStorageComponent.OnLobbyCharacterInfoUupdated
	 * 		Flags  -> (Final, Native, Protected)
	 */
	void UMetaStorageComponent::OnLobbyCharacterInfoUupdated()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.MetaStorageComponent.OnLobbyCharacterInfoUupdated");
		
		UMetaStorageComponent_OnLobbyCharacterInfoUupdated_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMetaStorageComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMetaStorageComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.MetaStorageComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMiniMapData.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMiniMapData::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.MiniMapData");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01808F10
	 * 		Name   -> Function DungeonCrawler.NickNameWidgetBase.SetNickName
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		struct FNickname                                   InNickName                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UNickNameWidgetBase::SetNickName(const struct FNickname& InNickName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.NickNameWidgetBase.SetNickName");
		
		UNickNameWidgetBase_SetNickName_Params params {};
		params.InNickName = InNickName;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.NickNameWidgetBase.OnNickNameStr
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 * Parameters:
	 * 		class FString                                      NewValue                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FString                                      OldValue                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UNickNameWidgetBase::OnNickNameStr(const class FString& NewValue, const class FString& OldValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.NickNameWidgetBase.OnNickNameStr");
		
		UNickNameWidgetBase_OnNickNameStr_Params params {};
		params.NewValue = NewValue;
		params.OldValue = OldValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UNickNameWidgetBase.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UNickNameWidgetBase::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.NickNameWidgetBase");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01751E50
	 * 		Name   -> Function DungeonCrawler.OnlineSystemSteam.UnbindMsgAll
	 * 		Flags  -> (Native, Public)
	 * Parameters:
	 * 		class UObject*                                     InObject                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UOnlineSystemSteam::UnbindMsgAll(class UObject* InObject)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.OnlineSystemSteam.UnbindMsgAll");
		
		UOnlineSystemSteam_UnbindMsgAll_Params params {};
		params.InObject = InObject;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01751D80
	 * 		Name   -> Function DungeonCrawler.OnlineSystemSteam.UnbindMsg
	 * 		Flags  -> (Native, Public)
	 * Parameters:
	 * 		class UScriptStruct*                               InMsgType                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UObject*                                     InObject                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UOnlineSystemSteam::UnbindMsg(class UScriptStruct* InMsgType, class UObject* InObject)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.OnlineSystemSteam.UnbindMsg");
		
		UOnlineSystemSteam_UnbindMsg_Params params {};
		params.InMsgType = InMsgType;
		params.InObject = InObject;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01751D60
	 * 		Name   -> Function DungeonCrawler.OnlineSystemSteam.TerminateBase
	 * 		Flags  -> (Native, Public)
	 */
	void UOnlineSystemSteam::TerminateBase()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.OnlineSystemSteam.TerminateBase");
		
		UOnlineSystemSteam_TerminateBase_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D3C640
	 * 		Name   -> Function DungeonCrawler.OnlineSystemSteam.BroadcastMsgBlueprint
	 * 		Flags  -> (Native, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		int32_t                                            InMsg                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UOnlineSystemSteam::BroadcastMsgBlueprint(int32_t InMsg)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.OnlineSystemSteam.BroadcastMsgBlueprint");
		
		UOnlineSystemSteam_BroadcastMsgBlueprint_Params params {};
		params.InMsg = InMsg;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UOnlineSystemSteam.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UOnlineSystemSteam::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.OnlineSystemSteam");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.PartyChatWidget.OnChatAccountData
	 * 		Flags  -> (Event, Protected, HasOutParms, BlueprintEvent)
	 * Parameters:
	 * 		struct FChatAccountData                            NewItemData                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		struct FChatAccountData                            OldItemData                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UPartyChatWidget::OnChatAccountData(const struct FChatAccountData& NewItemData, const struct FChatAccountData& OldItemData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.PartyChatWidget.OnChatAccountData");
		
		UPartyChatWidget_OnChatAccountData_Params params {};
		params.NewItemData = NewItemData;
		params.OldItemData = OldItemData;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UPartyChatWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UPartyChatWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.PartyChatWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01720B30
	 * 		Name   -> Function DungeonCrawler.PartySession.UnbindMsgAll
	 * 		Flags  -> (Native, Public)
	 * Parameters:
	 * 		class UObject*                                     InObject                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UPartySession::UnbindMsgAll(class UObject* InObject)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.PartySession.UnbindMsgAll");
		
		UPartySession_UnbindMsgAll_Params params {};
		params.InObject = InObject;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01720A60
	 * 		Name   -> Function DungeonCrawler.PartySession.UnbindMsg
	 * 		Flags  -> (Native, Public)
	 * Parameters:
	 * 		class UScriptStruct*                               InMsgType                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UObject*                                     InObject                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UPartySession::UnbindMsg(class UScriptStruct* InMsgType, class UObject* InObject)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.PartySession.UnbindMsg");
		
		UPartySession_UnbindMsg_Params params {};
		params.InMsgType = InMsgType;
		params.InObject = InObject;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01720A40
	 * 		Name   -> Function DungeonCrawler.PartySession.TerminateBase
	 * 		Flags  -> (Native, Public)
	 */
	void UPartySession::TerminateBase()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.PartySession.TerminateBase");
		
		UPartySession_TerminateBase_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D3C640
	 * 		Name   -> Function DungeonCrawler.PartySession.BroadcastMsgBlueprint
	 * 		Flags  -> (Native, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		int32_t                                            InMsg                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UPartySession::BroadcastMsgBlueprint(int32_t InMsg)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.PartySession.BroadcastMsgBlueprint");
		
		UPartySession_BroadcastMsgBlueprint_Params params {};
		params.InMsg = InMsg;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UPartySession.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UPartySession::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.PartySession");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0180E9A0
	 * 		Name   -> Function DungeonCrawler.PerkWidget.SetPerkData
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		class FText                                        PerkName                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		class FText                                        PerkDesc                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UPerkWidget::SetPerkData(const class FText& PerkName, const class FText& PerkDesc)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.PerkWidget.SetPerkData");
		
		UPerkWidget_SetPerkData_Params params {};
		params.PerkName = PerkName;
		params.PerkDesc = PerkDesc;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.PerkWidget.OnSetPerkData
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 */
	void UPerkWidget::OnSetPerkData()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.PerkWidget.OnSetPerkData");
		
		UPerkWidget_OnSetPerkData_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0180DF50
	 * 		Name   -> Function DungeonCrawler.PerkWidget.InitializePerkWidget
	 * 		Flags  -> (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FPrimaryAssetId                             InPerkId                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UPerkWidget::InitializePerkWidget(const struct FPrimaryAssetId& InPerkId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.PerkWidget.InitializePerkWidget");
		
		UPerkWidget_InitializePerkWidget_Params params {};
		params.InPerkId = InPerkId;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UPerkWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UPerkWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.PerkWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0180EB10
	 * 		Name   -> Function DungeonCrawler.PlayerCharacterCaptureActor.SetStartRotateLocation
	 * 		Flags  -> (Final, Native, Protected, BlueprintCallable)
	 * Parameters:
	 * 		float                                              InStartPosition                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void APlayerCharacterCaptureActor::SetStartRotateLocation(float InStartPosition)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.PlayerCharacterCaptureActor.SetStartRotateLocation");
		
		APlayerCharacterCaptureActor_SetStartRotateLocation_Params params {};
		params.InStartPosition = InStartPosition;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0180E920
	 * 		Name   -> Function DungeonCrawler.PlayerCharacterCaptureActor.SetMeshRotation
	 * 		Flags  -> (Final, Native, Protected, BlueprintCallable)
	 * Parameters:
	 * 		float                                              InYaw                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void APlayerCharacterCaptureActor::SetMeshRotation(float InYaw)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.PlayerCharacterCaptureActor.SetMeshRotation");
		
		APlayerCharacterCaptureActor_SetMeshRotation_Params params {};
		params.InYaw = InYaw;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0180E5D0
	 * 		Name   -> Function DungeonCrawler.PlayerCharacterCaptureActor.ResetMeshRotation
	 * 		Flags  -> (Final, Native, Protected, BlueprintCallable)
	 */
	void APlayerCharacterCaptureActor::ResetMeshRotation()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.PlayerCharacterCaptureActor.ResetMeshRotation");
		
		APlayerCharacterCaptureActor_ResetMeshRotation_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.PlayerCharacterCaptureActor.OnItemEquipped
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 * Parameters:
	 * 		class UAnimationAsset*                             ItemStandIdle                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FGameplayTag                                ItemHandType                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FGameplayTag                                ItemSlotType                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void APlayerCharacterCaptureActor::OnItemEquipped(class UAnimationAsset* ItemStandIdle, const struct FGameplayTag& ItemHandType, const struct FGameplayTag& ItemSlotType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.PlayerCharacterCaptureActor.OnItemEquipped");
		
		APlayerCharacterCaptureActor_OnItemEquipped_Params params {};
		params.ItemStandIdle = ItemStandIdle;
		params.ItemHandType = ItemHandType;
		params.ItemSlotType = ItemSlotType;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0180DD40
	 * 		Name   -> Function DungeonCrawler.PlayerCharacterCaptureActor.GetCharacterMeshAnimInstance
	 * 		Flags  -> (Final, Native, Protected, BlueprintCallable, BlueprintPure)
	 */
	class UAnimInstance* APlayerCharacterCaptureActor::GetCharacterMeshAnimInstance()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.PlayerCharacterCaptureActor.GetCharacterMeshAnimInstance");
		
		APlayerCharacterCaptureActor_GetCharacterMeshAnimInstance_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction APlayerCharacterCaptureActor.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* APlayerCharacterCaptureActor::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.PlayerCharacterCaptureActor");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.PlayWidget.OnUpdateLobbyCharacterData
	 * 		Flags  -> (Event, Protected, HasOutParms, BlueprintEvent)
	 * Parameters:
	 * 		struct FLobbyCharacterInfo                         LobbyInfo                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UPlayWidget::OnUpdateLobbyCharacterData(const struct FLobbyCharacterInfo& LobbyInfo)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.PlayWidget.OnUpdateLobbyCharacterData");
		
		UPlayWidget_OnUpdateLobbyCharacterData_Params params {};
		params.LobbyInfo = LobbyInfo;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.PlayWidget.OnUpdateDungeonSelectBtn
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 * Parameters:
	 * 		EGameDifficultyType                                GameDifficultyType                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bLeader                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UPlayWidget::OnUpdateDungeonSelectBtn(EGameDifficultyType GameDifficultyType, bool bLeader)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.PlayWidget.OnUpdateDungeonSelectBtn");
		
		UPlayWidget_OnUpdateDungeonSelectBtn_Params params {};
		params.GameDifficultyType = GameDifficultyType;
		params.bLeader = bLeader;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0180E490
	 * 		Name   -> Function DungeonCrawler.PlayWidget.OnStartButtonClicked
	 * 		Flags  -> (Final, Native, Protected, BlueprintCallable)
	 */
	void UPlayWidget::OnStartButtonClicked()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.PlayWidget.OnStartButtonClicked");
		
		UPlayWidget_OnStartButtonClicked_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0180E400
	 * 		Name   -> Function DungeonCrawler.PlayWidget.OnSoloRegionUpdate
	 * 		Flags  -> (Final, Native, Protected, BlueprintCallable)
	 * Parameters:
	 * 		int32_t                                            RegionIndex                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UPlayWidget::OnSoloRegionUpdate(int32_t RegionIndex)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.PlayWidget.OnSoloRegionUpdate");
		
		UPlayWidget_OnSoloRegionUpdate_Params params {};
		params.RegionIndex = RegionIndex;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0180E2F0
	 * 		Name   -> Function DungeonCrawler.PlayWidget.OnRegionSelected
	 * 		Flags  -> (Final, Native, Protected, BlueprintCallable)
	 * Parameters:
	 * 		int32_t                                            RegionIndex                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UPlayWidget::OnRegionSelected(int32_t RegionIndex)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.PlayWidget.OnRegionSelected");
		
		UPlayWidget_OnRegionSelected_Params params {};
		params.RegionIndex = RegionIndex;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.PlayWidget.OnRegionDataSet
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 * Parameters:
	 * 		int32_t                                            RegionIndex                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               IsPartyLeader                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UPlayWidget::OnRegionDataSet(int32_t RegionIndex, bool IsPartyLeader)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.PlayWidget.OnRegionDataSet");
		
		UPlayWidget_OnRegionDataSet_Params params {};
		params.RegionIndex = RegionIndex;
		params.IsPartyLeader = IsPartyLeader;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0180E210
	 * 		Name   -> Function DungeonCrawler.PlayWidget.OnPopupSWidgetInvitePartyResponse
	 * 		Flags  -> (Final, Native, Protected, BlueprintCallable)
	 * Parameters:
	 * 		EPopupResult                                       PopupResult                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FString                                      ReturnAccountId                                            (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UPlayWidget::OnPopupSWidgetInvitePartyResponse(EPopupResult PopupResult, const class FString& ReturnAccountId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.PlayWidget.OnPopupSWidgetInvitePartyResponse");
		
		UPlayWidget_OnPopupSWidgetInvitePartyResponse_Params params {};
		params.PopupResult = PopupResult;
		params.ReturnAccountId = ReturnAccountId;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.PlayWidget.OnPopupSWidgetInvitePartyRequest
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 * Parameters:
	 * 		class UPopupDataBase*                              PopupData                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FString                                      ReturnAccountId                                            (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UPlayWidget::OnPopupSWidgetInvitePartyRequest(class UPopupDataBase* PopupData, const class FString& ReturnAccountId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.PlayWidget.OnPopupSWidgetInvitePartyRequest");
		
		UPlayWidget_OnPopupSWidgetInvitePartyRequest_Params params {};
		params.PopupData = PopupData;
		params.ReturnAccountId = ReturnAccountId;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.PlayWidget.OnPlayPartyUserInfoData
	 * 		Flags  -> (Event, Protected, HasOutParms, BlueprintEvent)
	 * Parameters:
	 * 		struct FPlayPartyUserInfoData                      NewValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		struct FPlayPartyUserInfoData                      OldValue                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UPlayWidget::OnPlayPartyUserInfoData(const struct FPlayPartyUserInfoData& NewValue, const struct FPlayPartyUserInfoData& OldValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.PlayWidget.OnPlayPartyUserInfoData");
		
		UPlayWidget_OnPlayPartyUserInfoData_Params params {};
		params.NewValue = NewValue;
		params.OldValue = OldValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.PlayWidget.OnPlayPartyUserInfo
	 * 		Flags  -> (Event, Protected, HasOutParms, BlueprintEvent)
	 * Parameters:
	 * 		struct FPlayPartyUserInfo                          PlayPartyUserInfo                                          (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UPlayWidget::OnPlayPartyUserInfo(const struct FPlayPartyUserInfo& PlayPartyUserInfo)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.PlayWidget.OnPlayPartyUserInfo");
		
		UPlayWidget_OnPlayPartyUserInfo_Params params {};
		params.PlayPartyUserInfo = PlayPartyUserInfo;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.PlayWidget.OnPlayPartyReadyStateChanged
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 * Parameters:
	 * 		bool                                               bMine                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bLeader                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bReady                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UPlayWidget::OnPlayPartyReadyStateChanged(bool bMine, bool bLeader, bool bReady)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.PlayWidget.OnPlayPartyReadyStateChanged");
		
		UPlayWidget_OnPlayPartyReadyStateChanged_Params params {};
		params.bMine = bMine;
		params.bLeader = bLeader;
		params.bReady = bReady;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0180E180
	 * 		Name   -> Function DungeonCrawler.PlayWidget.OnPartyReadyButtonClicked
	 * 		Flags  -> (Final, Native, Protected)
	 * Parameters:
	 * 		bool                                               IsReady                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UPlayWidget::OnPartyReadyButtonClicked(bool IsReady)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.PlayWidget.OnPartyReadyButtonClicked");
		
		UPlayWidget_OnPartyReadyButtonClicked_Params params {};
		params.IsReady = IsReady;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.PlayWidget.OnPartyLocationSet
	 * 		Flags  -> (Event, Protected, HasOutParms, BlueprintEvent)
	 * Parameters:
	 * 		struct FPlayPartyUserInfo                          PartyUser                                                  (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            MetaLocationIndex                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               IsReady                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UPlayWidget::OnPartyLocationSet(const struct FPlayPartyUserInfo& PartyUser, int32_t MetaLocationIndex, bool IsReady)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.PlayWidget.OnPartyLocationSet");
		
		UPlayWidget_OnPartyLocationSet_Params params {};
		params.PartyUser = PartyUser;
		params.MetaLocationIndex = MetaLocationIndex;
		params.IsReady = IsReady;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0180E160
	 * 		Name   -> Function DungeonCrawler.PlayWidget.OnPartyExitButtonClicked
	 * 		Flags  -> (Final, Native, Protected, BlueprintCallable)
	 */
	void UPlayWidget::OnPartyExitButtonClicked()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.PlayWidget.OnPartyExitButtonClicked");
		
		UPlayWidget_OnPartyExitButtonClicked_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.PlayWidget.OnPartyCheckAndRegionButtonUpdate
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 * Parameters:
	 * 		int32_t                                            RegionIndex                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UPlayWidget::OnPartyCheckAndRegionButtonUpdate(int32_t RegionIndex)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.PlayWidget.OnPartyCheckAndRegionButtonUpdate");
		
		UPlayWidget_OnPartyCheckAndRegionButtonUpdate_Params params {};
		params.RegionIndex = RegionIndex;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.PlayWidget.OnMatchStart
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 * Parameters:
	 * 		bool                                               InbCanCancel                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              InMatchCancelDelayTimeSec                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UPlayWidget::OnMatchStart(bool InbCanCancel, float InMatchCancelDelayTimeSec)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.PlayWidget.OnMatchStart");
		
		UPlayWidget_OnMatchStart_Params params {};
		params.InbCanCancel = InbCanCancel;
		params.InMatchCancelDelayTimeSec = InMatchCancelDelayTimeSec;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.PlayWidget.OnMatchCancel
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 */
	void UPlayWidget::OnMatchCancel()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.PlayWidget.OnMatchCancel");
		
		UPlayWidget_OnMatchCancel_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0180E0B0
	 * 		Name   -> Function DungeonCrawler.PlayWidget.OnInvitePartyButtonClicked
	 * 		Flags  -> (Final, Native, Protected, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		EWidgetPartyUserLocate                             UserLocate                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UPlayWidget::OnInvitePartyButtonClicked(EWidgetPartyUserLocate UserLocate)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.PlayWidget.OnInvitePartyButtonClicked");
		
		UPlayWidget_OnInvitePartyButtonClicked_Params params {};
		params.UserLocate = UserLocate;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.PlayWidget.OnDungeonSelectListPopupOpen
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 * Parameters:
	 * 		EGameDifficultyType                                GameDifficultyType                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            EntranceFeeGold                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UPlayWidget::OnDungeonSelectListPopupOpen(EGameDifficultyType GameDifficultyType, int32_t EntranceFeeGold)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.PlayWidget.OnDungeonSelectListPopupOpen");
		
		UPlayWidget_OnDungeonSelectListPopupOpen_Params params {};
		params.GameDifficultyType = GameDifficultyType;
		params.EntranceFeeGold = EntranceFeeGold;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0180E030
	 * 		Name   -> Function DungeonCrawler.PlayWidget.OnDungeonSelect
	 * 		Flags  -> (Final, Native, Protected, BlueprintCallable)
	 * Parameters:
	 * 		EGameDifficultyType                                GameDifficultyType                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UPlayWidget::OnDungeonSelect(EGameDifficultyType GameDifficultyType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.PlayWidget.OnDungeonSelect");
		
		UPlayWidget_OnDungeonSelect_Params params {};
		params.GameDifficultyType = GameDifficultyType;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0180E010
	 * 		Name   -> Function DungeonCrawler.PlayWidget.OnClickedDungeonSelect
	 * 		Flags  -> (Final, Native, Protected, BlueprintCallable)
	 */
	void UPlayWidget::OnClickedDungeonSelect()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.PlayWidget.OnClickedDungeonSelect");
		
		UPlayWidget_OnClickedDungeonSelect_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.PlayWidget.OnChangedMatchingState
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 * Parameters:
	 * 		bool                                               IsInMatching                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UPlayWidget::OnChangedMatchingState(bool IsInMatching)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.PlayWidget.OnChangedMatchingState");
		
		UPlayWidget_OnChangedMatchingState_Params params {};
		params.IsInMatching = IsInMatching;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0180DFF0
	 * 		Name   -> Function DungeonCrawler.PlayWidget.OnCancelButtonClicked
	 * 		Flags  -> (Final, Native, Protected, BlueprintCallable)
	 */
	void UPlayWidget::OnCancelButtonClicked()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.PlayWidget.OnCancelButtonClicked");
		
		UPlayWidget_OnCancelButtonClicked_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0180DB30
	 * 		Name   -> Function DungeonCrawler.PlayWidget.AutoTeamRegisterSingle
	 * 		Flags  -> (Final, Native, Protected, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               IsRegister                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UPlayWidget::AutoTeamRegisterSingle(bool IsRegister)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.PlayWidget.AutoTeamRegisterSingle");
		
		UPlayWidget_AutoTeamRegisterSingle_Params params {};
		params.IsRegister = IsRegister;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UPlayWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UPlayWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.PlayWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0180EB90
	 * 		Name   -> Function DungeonCrawler.ProjectileActor.StopPierce
	 * 		Flags  -> (Final, Native, Protected, BlueprintCallable)
	 */
	void AProjectileActor::StopPierce()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.ProjectileActor.StopPierce");
		
		AProjectileActor_StopPierce_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0180E890
	 * 		Name   -> Function DungeonCrawler.ProjectileActor.SetHomingTargetComponent
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class USceneComponent*                             InHomingTargetComponent                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AProjectileActor::SetHomingTargetComponent(class USceneComponent* InHomingTargetComponent)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.ProjectileActor.SetHomingTargetComponent");
		
		AProjectileActor_SetHomingTargetComponent_Params params {};
		params.InHomingTargetComponent = InHomingTargetComponent;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0180E810
	 * 		Name   -> Function DungeonCrawler.ProjectileActor.SetHomingMagnitude
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		float                                              InHomingMagnitude                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AProjectileActor::SetHomingMagnitude(float InHomingMagnitude)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.ProjectileActor.SetHomingMagnitude");
		
		AProjectileActor_SetHomingMagnitude_Params params {};
		params.InHomingMagnitude = InHomingMagnitude;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0180E700
	 * 		Name   -> Function DungeonCrawler.ProjectileActor.SetAddEffectToTargetHit
	 * 		Flags  -> (Final, Native, Protected, BlueprintCallable)
	 * Parameters:
	 * 		TArray<struct FPrimaryAssetId>                     AddEffectList                                              (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
	 */
	void AProjectileActor::SetAddEffectToTargetHit(TArray<struct FPrimaryAssetId> AddEffectList)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.ProjectileActor.SetAddEffectToTargetHit");
		
		AProjectileActor_SetAddEffectToTargetHit_Params params {};
		params.AddEffectList = AddEffectList;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0180E5F0
	 * 		Name   -> Function DungeonCrawler.ProjectileActor.SetAddEffectToGroundtHit
	 * 		Flags  -> (Final, Native, Protected, BlueprintCallable)
	 * Parameters:
	 * 		TArray<struct FPrimaryAssetId>                     AddEffectList                                              (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
	 */
	void AProjectileActor::SetAddEffectToGroundtHit(TArray<struct FPrimaryAssetId> AddEffectList)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.ProjectileActor.SetAddEffectToGroundtHit");
		
		AProjectileActor_SetAddEffectToGroundtHit_Params params {};
		params.AddEffectList = AddEffectList;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.ProjectileActor.ProjectileHit
	 * 		Flags  -> (Event, Protected, HasOutParms, HasDefaults, BlueprintEvent)
	 * Parameters:
	 * 		struct FHitResult                                  Hit                                                        (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 * 		bool                                               bIsAttached                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FTransform                                  ActorPrevTickTransform                                     (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void AProjectileActor::ProjectileHit(const struct FHitResult& Hit, bool bIsAttached, const struct FTransform& ActorPrevTickTransform)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.ProjectileActor.ProjectileHit");
		
		AProjectileActor_ProjectileHit_Params params {};
		params.Hit = Hit;
		params.bIsAttached = bIsAttached;
		params.ActorPrevTickTransform = ActorPrevTickTransform;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0180E4B0
	 * 		Name   -> Function DungeonCrawler.ProjectileActor.PlayPierce
	 * 		Flags  -> (Final, Native, Protected, BlueprintCallable)
	 * Parameters:
	 * 		float                                              SetPierceCount                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               SetObstaclePierce                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              SetObstaclePierceDecrease                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AProjectileActor::PlayPierce(float SetPierceCount, bool SetObstaclePierce, float SetObstaclePierceDecrease)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.ProjectileActor.PlayPierce");
		
		AProjectileActor_PlayPierce_Params params {};
		params.SetPierceCount = SetPierceCount;
		params.SetObstaclePierce = SetObstaclePierce;
		params.SetObstaclePierceDecrease = SetObstaclePierceDecrease;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0180E3E0
	 * 		Name   -> Function DungeonCrawler.ProjectileActor.OnRep_ProjectileMovementComponentLocalVelocity
	 * 		Flags  -> (Final, Native, Public)
	 */
	void AProjectileActor::OnRep_ProjectileMovementComponentLocalVelocity()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.ProjectileActor.OnRep_ProjectileMovementComponentLocalVelocity");
		
		AProjectileActor_OnRep_ProjectileMovementComponentLocalVelocity_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0180E3C0
	 * 		Name   -> Function DungeonCrawler.ProjectileActor.OnRep_IsHomingProjectile
	 * 		Flags  -> (Final, Native, Public)
	 */
	void AProjectileActor::OnRep_IsHomingProjectile()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.ProjectileActor.OnRep_IsHomingProjectile");
		
		AProjectileActor_OnRep_IsHomingProjectile_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0180E3A0
	 * 		Name   -> Function DungeonCrawler.ProjectileActor.OnRep_HomingTargetComponent
	 * 		Flags  -> (Final, Native, Public)
	 */
	void AProjectileActor::OnRep_HomingTargetComponent()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.ProjectileActor.OnRep_HomingTargetComponent");
		
		AProjectileActor_OnRep_HomingTargetComponent_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0180E380
	 * 		Name   -> Function DungeonCrawler.ProjectileActor.OnRep_HomingMagnitude
	 * 		Flags  -> (Final, Native, Public)
	 */
	void AProjectileActor::OnRep_HomingMagnitude()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.ProjectileActor.OnRep_HomingMagnitude");
		
		AProjectileActor_OnRep_HomingMagnitude_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0180E140
	 * 		Name   -> Function DungeonCrawler.ProjectileActor.OnLifeTimeExpired
	 * 		Flags  -> (Final, Native, Protected)
	 */
	void AProjectileActor::OnLifeTimeExpired()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.ProjectileActor.OnLifeTimeExpired");
		
		AProjectileActor_OnLifeTimeExpired_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.ProjectileActor.LifeTimeExpired
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 */
	void AProjectileActor::LifeTimeExpired()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.ProjectileActor.LifeTimeExpired");
		
		AProjectileActor_LifeTimeExpired_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0180DEA0
	 * 		Name   -> Function DungeonCrawler.ProjectileActor.InitVelocity
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		float                                              FirePower                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AProjectileActor::InitVelocity(float FirePower)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.ProjectileActor.InitVelocity");
		
		AProjectileActor_InitVelocity_Params params {};
		params.FirePower = FirePower;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0180DF20
	 * 		Name   -> Function DungeonCrawler.ProjectileActor.InitialSpeed
	 * 		Flags  -> (Final, Native, Public)
	 */
	float AProjectileActor::InitialSpeed()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.ProjectileActor.InitialSpeed");
		
		AProjectileActor_InitialSpeed_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0180DE10
	 * 		Name   -> Function DungeonCrawler.ProjectileActor.InitArrivalVelocity
	 * 		Flags  -> (Final, Native, Public, HasDefaults)
	 * Parameters:
	 * 		struct FVector                                     Velocity                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AProjectileActor::InitArrivalVelocity(const struct FVector& Velocity)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.ProjectileActor.InitArrivalVelocity");
		
		AProjectileActor_InitArrivalVelocity_Params params {};
		params.Velocity = Velocity;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0180DD90
	 * 		Name   -> Function DungeonCrawler.ProjectileActor.HandleTimelineUpdate
	 * 		Flags  -> (Final, Native, Protected)
	 * Parameters:
	 * 		float                                              Value                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AProjectileActor::HandleTimelineUpdate(float Value)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.ProjectileActor.HandleTimelineUpdate");
		
		AProjectileActor_HandleTimelineUpdate_Params params {};
		params.Value = Value;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0180DD70
	 * 		Name   -> Function DungeonCrawler.ProjectileActor.HandleTimelineFinished
	 * 		Flags  -> (Final, Native, Protected)
	 */
	void AProjectileActor::HandleTimelineFinished()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.ProjectileActor.HandleTimelineFinished");
		
		AProjectileActor_HandleTimelineFinished_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0180DC80
	 * 		Name   -> Function DungeonCrawler.ProjectileActor.GetAddEffectToTargetHit
	 * 		Flags  -> (Final, Native, Protected, BlueprintCallable)
	 */
	TArray<struct FPrimaryAssetId> AProjectileActor::GetAddEffectToTargetHit()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.ProjectileActor.GetAddEffectToTargetHit");
		
		AProjectileActor_GetAddEffectToTargetHit_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0180DBC0
	 * 		Name   -> Function DungeonCrawler.ProjectileActor.GetAddEffectToGroundHit
	 * 		Flags  -> (Final, Native, Protected, BlueprintCallable)
	 */
	TArray<struct FPrimaryAssetId> AProjectileActor::GetAddEffectToGroundHit()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.ProjectileActor.GetAddEffectToGroundHit");
		
		AProjectileActor_GetAddEffectToGroundHit_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.ProjectileActor.GameplayTagUpdated
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 * Parameters:
	 * 		struct FGameplayTag                                InGameplayTag                                              (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            InCount                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AProjectileActor::GameplayTagUpdated(const struct FGameplayTag& InGameplayTag, int32_t InCount)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.ProjectileActor.GameplayTagUpdated");
		
		AProjectileActor_GameplayTagUpdated_Params params {};
		params.InGameplayTag = InGameplayTag;
		params.InCount = InCount;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AProjectileActor.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AProjectileActor::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.ProjectileActor");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDCPropDataComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDCPropDataComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.DCPropDataComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01720B30
	 * 		Name   -> Function DungeonCrawler.SampleSubObject.UnbindMsgAll
	 * 		Flags  -> (Native, Public)
	 * Parameters:
	 * 		class UObject*                                     InObject                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void USampleSubObject::UnbindMsgAll(class UObject* InObject)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.SampleSubObject.UnbindMsgAll");
		
		USampleSubObject_UnbindMsgAll_Params params {};
		params.InObject = InObject;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01720A60
	 * 		Name   -> Function DungeonCrawler.SampleSubObject.UnbindMsg
	 * 		Flags  -> (Native, Public)
	 * Parameters:
	 * 		class UScriptStruct*                               InMsgType                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UObject*                                     InObject                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void USampleSubObject::UnbindMsg(class UScriptStruct* InMsgType, class UObject* InObject)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.SampleSubObject.UnbindMsg");
		
		USampleSubObject_UnbindMsg_Params params {};
		params.InMsgType = InMsgType;
		params.InObject = InObject;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01720A40
	 * 		Name   -> Function DungeonCrawler.SampleSubObject.TerminateBase
	 * 		Flags  -> (Native, Public)
	 */
	void USampleSubObject::TerminateBase()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.SampleSubObject.TerminateBase");
		
		USampleSubObject_TerminateBase_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x018133C0
	 * 		Name   -> Function DungeonCrawler.SampleSubObject.InitializeSampleSubObject
	 * 		Flags  -> (Native, Event, Public, BlueprintEvent)
	 */
	void USampleSubObject::InitializeSampleSubObject()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.SampleSubObject.InitializeSampleSubObject");
		
		USampleSubObject_InitializeSampleSubObject_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D3C640
	 * 		Name   -> Function DungeonCrawler.SampleSubObject.BroadcastMsgBlueprint
	 * 		Flags  -> (Native, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		int32_t                                            InMsg                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void USampleSubObject::BroadcastMsgBlueprint(int32_t InMsg)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.SampleSubObject.BroadcastMsgBlueprint");
		
		USampleSubObject_BroadcastMsgBlueprint_Params params {};
		params.InMsg = InMsg;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01812750
	 * 		Name   -> Function DungeonCrawler.SampleSubObject.BeginSampleSubObject
	 * 		Flags  -> (Native, Event, Public, BlueprintEvent)
	 */
	void USampleSubObject::BeginSampleSubObject()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.SampleSubObject.BeginSampleSubObject");
		
		USampleSubObject_BeginSampleSubObject_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction USampleSubObject.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* USampleSubObject::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.SampleSubObject");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01720B30
	 * 		Name   -> Function DungeonCrawler.SampleObject.UnbindMsgAll
	 * 		Flags  -> (Native, Public)
	 * Parameters:
	 * 		class UObject*                                     InObject                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void USampleObject::UnbindMsgAll(class UObject* InObject)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.SampleObject.UnbindMsgAll");
		
		USampleObject_UnbindMsgAll_Params params {};
		params.InObject = InObject;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01720A60
	 * 		Name   -> Function DungeonCrawler.SampleObject.UnbindMsg
	 * 		Flags  -> (Native, Public)
	 * Parameters:
	 * 		class UScriptStruct*                               InMsgType                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UObject*                                     InObject                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void USampleObject::UnbindMsg(class UScriptStruct* InMsgType, class UObject* InObject)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.SampleObject.UnbindMsg");
		
		USampleObject_UnbindMsg_Params params {};
		params.InMsgType = InMsgType;
		params.InObject = InObject;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01720A40
	 * 		Name   -> Function DungeonCrawler.SampleObject.TerminateBase
	 * 		Flags  -> (Native, Public)
	 */
	void USampleObject::TerminateBase()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.SampleObject.TerminateBase");
		
		USampleObject_TerminateBase_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x018133C0
	 * 		Name   -> Function DungeonCrawler.SampleObject.InitializeSampleObject
	 * 		Flags  -> (Native, Event, Public, BlueprintCallable, BlueprintEvent)
	 */
	void USampleObject::InitializeSampleObject()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.SampleObject.InitializeSampleObject");
		
		USampleObject_InitializeSampleObject_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D3C640
	 * 		Name   -> Function DungeonCrawler.SampleObject.BroadcastMsgBlueprint
	 * 		Flags  -> (Native, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		int32_t                                            InMsg                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void USampleObject::BroadcastMsgBlueprint(int32_t InMsg)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.SampleObject.BroadcastMsgBlueprint");
		
		USampleObject_BroadcastMsgBlueprint_Params params {};
		params.InMsg = InMsg;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01812750
	 * 		Name   -> Function DungeonCrawler.SampleObject.BeginSampleObject
	 * 		Flags  -> (Native, Event, Public, BlueprintEvent)
	 */
	void USampleObject::BeginSampleObject()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.SampleObject.BeginSampleObject");
		
		USampleObject_BeginSampleObject_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction USampleObject.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* USampleObject::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.SampleObject");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01751E50
	 * 		Name   -> Function DungeonCrawler.ServerAccountSubsystem.UnbindMsgAll
	 * 		Flags  -> (Native, Public)
	 * Parameters:
	 * 		class UObject*                                     InObject                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UServerAccountSubsystem::UnbindMsgAll(class UObject* InObject)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.ServerAccountSubsystem.UnbindMsgAll");
		
		UServerAccountSubsystem_UnbindMsgAll_Params params {};
		params.InObject = InObject;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01751D80
	 * 		Name   -> Function DungeonCrawler.ServerAccountSubsystem.UnbindMsg
	 * 		Flags  -> (Native, Public)
	 * Parameters:
	 * 		class UScriptStruct*                               InMsgType                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UObject*                                     InObject                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UServerAccountSubsystem::UnbindMsg(class UScriptStruct* InMsgType, class UObject* InObject)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.ServerAccountSubsystem.UnbindMsg");
		
		UServerAccountSubsystem_UnbindMsg_Params params {};
		params.InMsgType = InMsgType;
		params.InObject = InObject;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01751D60
	 * 		Name   -> Function DungeonCrawler.ServerAccountSubsystem.TerminateBase
	 * 		Flags  -> (Native, Public)
	 */
	void UServerAccountSubsystem::TerminateBase()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.ServerAccountSubsystem.TerminateBase");
		
		UServerAccountSubsystem_TerminateBase_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D3C640
	 * 		Name   -> Function DungeonCrawler.ServerAccountSubsystem.BroadcastMsgBlueprint
	 * 		Flags  -> (Native, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		int32_t                                            InMsg                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UServerAccountSubsystem::BroadcastMsgBlueprint(int32_t InMsg)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.ServerAccountSubsystem.BroadcastMsgBlueprint");
		
		UServerAccountSubsystem_BroadcastMsgBlueprint_Params params {};
		params.InMsg = InMsg;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UServerAccountSubsystem.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UServerAccountSubsystem::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.ServerAccountSubsystem");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ASkeletalMeshItemHolderActor.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ASkeletalMeshItemHolderActor::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.SkeletalMeshItemHolderActor");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x018137C0
	 * 		Name   -> Function DungeonCrawler.SkillActor.SetSkillData
	 * 		Flags  -> (Final, Native, Public, HasOutParms)
	 * Parameters:
	 * 		struct FSkillData                                  NewSkillData                                               (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void ASkillActor::SetSkillData(const struct FSkillData& NewSkillData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.SkillActor.SetSkillData");
		
		ASkillActor_SetSkillData_Params params {};
		params.NewSkillData = NewSkillData;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01813690
	 * 		Name   -> Function DungeonCrawler.SkillActor.RechargeSkill
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		int32_t                                            ChargeAmount                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASkillActor::RechargeSkill(int32_t ChargeAmount)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.SkillActor.RechargeSkill");
		
		ASkillActor_RechargeSkill_Params params {};
		params.ChargeAmount = ChargeAmount;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01813530
	 * 		Name   -> Function DungeonCrawler.SkillActor.OnRep_SkillData
	 * 		Flags  -> (Final, Native, Private, HasOutParms)
	 * Parameters:
	 * 		struct FSkillData                                  OldSkillData                                               (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void ASkillActor::OnRep_SkillData(const struct FSkillData& OldSkillData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.SkillActor.OnRep_SkillData");
		
		ASkillActor_OnRep_SkillData_Params params {};
		params.OldSkillData = OldSkillData;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x018132E0
	 * 		Name   -> Function DungeonCrawler.SkillActor.GetSoundDataSkill
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	class USoundData* ASkillActor::GetSoundDataSkill()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.SkillActor.GetSoundDataSkill");
		
		ASkillActor_GetSoundDataSkill_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x018130F0
	 * 		Name   -> Function DungeonCrawler.SkillActor.GetSkillData
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	struct FSkillData ASkillActor::GetSkillData()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.SkillActor.GetSkillData");
		
		ASkillActor_GetSkillData_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01812BB0
	 * 		Name   -> Function DungeonCrawler.SkillActor.GetDesignDataSkill
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	struct FDesignDataSkill ASkillActor::GetDesignDataSkill()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.SkillActor.GetDesignDataSkill");
		
		ASkillActor_GetDesignDataSkill_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01812AC0
	 * 		Name   -> Function DungeonCrawler.SkillActor.GetArtDataSkill
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	class UArtDataSkill* ASkillActor::GetArtDataSkill()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.SkillActor.GetArtDataSkill");
		
		ASkillActor_GetArtDataSkill_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ASkillActor.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ASkillActor::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.SkillActor");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x018139E0
	 * 		Name   -> Function DungeonCrawler.SkillComponent.UpdateSkillCount
	 * 		Flags  -> (Final, Native, Private)
	 * Parameters:
	 * 		struct FGameplayTag                                SkillTag                                                   (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            Count                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool USkillComponent::UpdateSkillCount(const struct FGameplayTag& SkillTag, int32_t Count)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.SkillComponent.UpdateSkillCount");
		
		USkillComponent_UpdateSkillCount_Params params {};
		params.SkillTag = SkillTag;
		params.Count = Count;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01764730
	 * 		Name   -> Function DungeonCrawler.SkillComponent.UnbindMsgAll
	 * 		Flags  -> (Native, Public)
	 * Parameters:
	 * 		class UObject*                                     InObject                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void USkillComponent::UnbindMsgAll(class UObject* InObject)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.SkillComponent.UnbindMsgAll");
		
		USkillComponent_UnbindMsgAll_Params params {};
		params.InObject = InObject;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01764280
	 * 		Name   -> Function DungeonCrawler.SkillComponent.UnbindMsg
	 * 		Flags  -> (Native, Public)
	 * Parameters:
	 * 		class UScriptStruct*                               InMsgType                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UObject*                                     InObject                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void USkillComponent::UnbindMsg(class UScriptStruct* InMsgType, class UObject* InObject)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.SkillComponent.UnbindMsg");
		
		USkillComponent_UnbindMsg_Params params {};
		params.InMsgType = InMsgType;
		params.InObject = InObject;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01763EB0
	 * 		Name   -> Function DungeonCrawler.SkillComponent.TerminateBase
	 * 		Flags  -> (Native, Public)
	 */
	void USkillComponent::TerminateBase()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.SkillComponent.TerminateBase");
		
		USkillComponent_TerminateBase_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x018135E0
	 * 		Name   -> Function DungeonCrawler.SkillComponent.OnRep_SkillDataList
	 * 		Flags  -> (Final, Native, Private, HasOutParms)
	 * Parameters:
	 * 		TArray<struct FSkillDataInfo>                      OldSkillDataList                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void USkillComponent::OnRep_SkillDataList(TArray<struct FSkillDataInfo> OldSkillDataList)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.SkillComponent.OnRep_SkillDataList");
		
		USkillComponent_OnRep_SkillDataList_Params params {};
		params.OldSkillDataList = OldSkillDataList;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01813480
	 * 		Name   -> Function DungeonCrawler.SkillComponent.OnRep_SkillActorList
	 * 		Flags  -> (Final, Native, Private, HasOutParms)
	 * Parameters:
	 * 		TArray<class ASkillActor*>                         OldSkillActors                                             (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	 */
	void USkillComponent::OnRep_SkillActorList(TArray<class ASkillActor*>* OldSkillActors)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.SkillComponent.OnRep_SkillActorList");
		
		USkillComponent_OnRep_SkillActorList_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OldSkillActors != nullptr)
			*OldSkillActors = params.OldSkillActors;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x018133A0
	 * 		Name   -> Function DungeonCrawler.SkillComponent.InitSkillData
	 * 		Flags  -> (Final, Native, Private)
	 */
	void USkillComponent::InitSkillData()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.SkillComponent.InitSkillData");
		
		USkillComponent_InitSkillData_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01813310
	 * 		Name   -> Function DungeonCrawler.SkillComponent.HandleSkillInput
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		struct FGameplayTag                                InputTag                                                   (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void USkillComponent::HandleSkillInput(const struct FGameplayTag& InputTag)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.SkillComponent.HandleSkillInput");
		
		USkillComponent_HandleSkillInput_Params params {};
		params.InputTag = InputTag;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01813210
	 * 		Name   -> Function DungeonCrawler.SkillComponent.GetSkillDataByTriggerTag
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		struct FGameplayTag                                TriggerTag                                                 (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FSkillData USkillComponent::GetSkillDataByTriggerTag(const struct FGameplayTag& TriggerTag)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.SkillComponent.GetSkillDataByTriggerTag");
		
		USkillComponent_GetSkillDataByTriggerTag_Params params {};
		params.TriggerTag = TriggerTag;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01813150
	 * 		Name   -> Function DungeonCrawler.SkillComponent.GetSkillDataByIndex
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		ESkillIndex                                        SkillIndex                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FSkillData USkillComponent::GetSkillDataByIndex(ESkillIndex SkillIndex)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.SkillComponent.GetSkillDataByIndex");
		
		USkillComponent_GetSkillDataByIndex_Params params {};
		params.SkillIndex = SkillIndex;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01812F70
	 * 		Name   -> Function DungeonCrawler.SkillComponent.GetSkillAllCurrentSkillData
	 * 		Flags  -> (Final, Native, Public, HasOutParms)
	 * Parameters:
	 * 		TArray<struct FSkillData>                          SkillDataList                                              (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	 * 		TArray<float>                                      MaxDurationList                                            (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	 * 		TArray<float>                                      RemainDurationList                                         (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	 */
	void USkillComponent::GetSkillAllCurrentSkillData(TArray<struct FSkillData>* SkillDataList, TArray<float>* MaxDurationList, TArray<float>* RemainDurationList)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.SkillComponent.GetSkillAllCurrentSkillData");
		
		USkillComponent_GetSkillAllCurrentSkillData_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (SkillDataList != nullptr)
			*SkillDataList = params.SkillDataList;
		if (MaxDurationList != nullptr)
			*MaxDurationList = params.MaxDurationList;
		if (RemainDurationList != nullptr)
			*RemainDurationList = params.RemainDurationList;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01812ED0
	 * 		Name   -> Function DungeonCrawler.SkillComponent.GetSkillActor
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		struct FGameplayTag                                SkillTag                                                   (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class ASkillActor* USkillComponent::GetSkillActor(const struct FGameplayTag& SkillTag)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.SkillComponent.GetSkillActor");
		
		USkillComponent_GetSkillActor_Params params {};
		params.SkillTag = SkillTag;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01812E30
	 * 		Name   -> Function DungeonCrawler.SkillComponent.GetSkillActivatabilityByTriggerTag
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		struct FGameplayTag                                TriggerTag                                                 (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	ESkillActivatableType USkillComponent::GetSkillActivatabilityByTriggerTag(const struct FGameplayTag& TriggerTag)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.SkillComponent.GetSkillActivatabilityByTriggerTag");
		
		USkillComponent_GetSkillActivatabilityByTriggerTag_Params params {};
		params.TriggerTag = TriggerTag;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01812960
	 * 		Name   -> Function DungeonCrawler.SkillComponent.GameplayEffectStackChanged
	 * 		Flags  -> (Final, Native, Private)
	 * Parameters:
	 * 		struct FGameplayTag                                EffectGameplayTag                                          (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FActiveGameplayEffectHandle                 EffectHandle                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            NewStackCount                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            PreviousStackCount                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void USkillComponent::GameplayEffectStackChanged(const struct FGameplayTag& EffectGameplayTag, const struct FActiveGameplayEffectHandle& EffectHandle, int32_t NewStackCount, int32_t PreviousStackCount)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.SkillComponent.GameplayEffectStackChanged");
		
		USkillComponent_GameplayEffectStackChanged_Params params {};
		params.EffectGameplayTag = EffectGameplayTag;
		params.EffectHandle = EffectHandle;
		params.NewStackCount = NewStackCount;
		params.PreviousStackCount = PreviousStackCount;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01812890
	 * 		Name   -> Function DungeonCrawler.SkillComponent.CheckSkillReduceCount
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		struct FGameplayTag                                SkillTag                                                   (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              ReduceCount                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool USkillComponent::CheckSkillReduceCount(const struct FGameplayTag& SkillTag, float ReduceCount)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.SkillComponent.CheckSkillReduceCount");
		
		USkillComponent_CheckSkillReduceCount_Params params {};
		params.SkillTag = SkillTag;
		params.ReduceCount = ReduceCount;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01812770
	 * 		Name   -> Function DungeonCrawler.SkillComponent.CalSkillCooldownRemainTime
	 * 		Flags  -> (Final, Native, Private)
	 * Parameters:
	 * 		float                                              StartTime                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              RemainDuration                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              MaxDuration                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	float USkillComponent::CalSkillCooldownRemainTime(float StartTime, float RemainDuration, float MaxDuration)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.SkillComponent.CalSkillCooldownRemainTime");
		
		USkillComponent_CalSkillCooldownRemainTime_Params params {};
		params.StartTime = StartTime;
		params.RemainDuration = RemainDuration;
		params.MaxDuration = MaxDuration;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D3C640
	 * 		Name   -> Function DungeonCrawler.SkillComponent.BroadcastMsgBlueprint
	 * 		Flags  -> (Native, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		int32_t                                            InMsg                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void USkillComponent::BroadcastMsgBlueprint(int32_t InMsg)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.SkillComponent.BroadcastMsgBlueprint");
		
		USkillComponent_BroadcastMsgBlueprint_Params params {};
		params.InMsg = InMsg;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction USkillComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* USkillComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.SkillComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01813870
	 * 		Name   -> Function DungeonCrawler.SkillWidget.SetSkillData
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		class FText                                        SkillName                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		class FText                                        SkillDesc                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void USkillWidget::SetSkillData(const class FText& SkillName, const class FText& SkillDesc)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.SkillWidget.SetSkillData");
		
		USkillWidget_SetSkillData_Params params {};
		params.SkillName = SkillName;
		params.SkillDesc = SkillDesc;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.SkillWidget.OnSetSkillData
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 */
	void USkillWidget::OnSetSkillData()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.SkillWidget.OnSetSkillData");
		
		USkillWidget_OnSetSkillData_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x018133E0
	 * 		Name   -> Function DungeonCrawler.SkillWidget.InitializeSkillWidget
	 * 		Flags  -> (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FPrimaryAssetId                             InSkillId                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void USkillWidget::InitializeSkillWidget(const struct FPrimaryAssetId& InSkillId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.SkillWidget.InitializeSkillWidget");
		
		USkillWidget_InitializeSkillWidget_Params params {};
		params.InSkillId = InSkillId;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction USkillWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* USkillWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.SkillWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01817F90
	 * 		Name   -> Function DungeonCrawler.SoundBlueprintLibrary.PlaySoundWithTag
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		class UObject*                                     InSoundPlayer                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UObject*                                     InSoundProvider                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FGameplayTag                                Tag                                                        (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool USoundBlueprintLibrary::STATIC_PlaySoundWithTag(class UObject* InSoundPlayer, class UObject* InSoundProvider, const struct FGameplayTag& Tag)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.SoundBlueprintLibrary.PlaySoundWithTag");
		
		USoundBlueprintLibrary_PlaySoundWithTag_Params params {};
		params.InSoundPlayer = InSoundPlayer;
		params.InSoundProvider = InSoundProvider;
		params.Tag = Tag;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01817D50
	 * 		Name   -> Function DungeonCrawler.SoundBlueprintLibrary.PlaySoundWithSwitch
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		class UObject*                                     InSoundPlayer                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UAkAudioEvent*                               AkEvent                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UObject*                                     InSoundProvider                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FGameplayTag                                Tag                                                        (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EPhysicalSurface                                   Surface                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FString                                      SwitchGroup                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FString                                      SwitchState                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool USoundBlueprintLibrary::STATIC_PlaySoundWithSwitch(class UObject* InSoundPlayer, class UAkAudioEvent* AkEvent, class UObject* InSoundProvider, const struct FGameplayTag& Tag, EPhysicalSurface Surface, const class FString& SwitchGroup, const class FString& SwitchState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.SoundBlueprintLibrary.PlaySoundWithSwitch");
		
		USoundBlueprintLibrary_PlaySoundWithSwitch_Params params {};
		params.InSoundPlayer = InSoundPlayer;
		params.AkEvent = AkEvent;
		params.InSoundProvider = InSoundProvider;
		params.Tag = Tag;
		params.Surface = Surface;
		params.SwitchGroup = SwitchGroup;
		params.SwitchState = SwitchState;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01817C80
	 * 		Name   -> Function DungeonCrawler.SoundBlueprintLibrary.PlaySoundOnPlayerController
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UAkAudioEvent*                               AkEvent                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool USoundBlueprintLibrary::STATIC_PlaySoundOnPlayerController(class UObject* WorldContextObject, class UAkAudioEvent* AkEvent)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.SoundBlueprintLibrary.PlaySoundOnPlayerController");
		
		USoundBlueprintLibrary_PlaySoundOnPlayerController_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.AkEvent = AkEvent;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01817BB0
	 * 		Name   -> Function DungeonCrawler.SoundBlueprintLibrary.PlaySound
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UObject*                                     InSoundPlayer                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UAkAudioEvent*                               AkEvent                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool USoundBlueprintLibrary::STATIC_PlaySound(class UObject* InSoundPlayer, class UAkAudioEvent* AkEvent)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.SoundBlueprintLibrary.PlaySound");
		
		USoundBlueprintLibrary_PlaySound_Params params {};
		params.InSoundPlayer = InSoundPlayer;
		params.AkEvent = AkEvent;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01817940
	 * 		Name   -> Function DungeonCrawler.SoundBlueprintLibrary.IsSoundPlayable
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class UObject*                                     InSoundPlayer                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UObject*                                     InSoundProvider                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FGameplayTag                                InSoundEventTag                                            (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool USoundBlueprintLibrary::STATIC_IsSoundPlayable(class UObject* InSoundPlayer, class UObject* InSoundProvider, const struct FGameplayTag& InSoundEventTag)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.SoundBlueprintLibrary.IsSoundPlayable");
		
		USoundBlueprintLibrary_IsSoundPlayable_Params params {};
		params.InSoundPlayer = InSoundPlayer;
		params.InSoundProvider = InSoundProvider;
		params.InSoundEventTag = InSoundEventTag;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction USoundBlueprintLibrary.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* USoundBlueprintLibrary::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.SoundBlueprintLibrary");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction USoundData.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* USoundData::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.SoundData");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01817700
	 * 		Name   -> Function DungeonCrawler.SoundProvider.GetTagQuery
	 * 		Flags  -> (Native, Public, HasOutParms, Const)
	 * Parameters:
	 * 		struct FGameplayTag                                Tag                                                        (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FGameplayTagQuery USoundProvider::GetTagQuery(const struct FGameplayTag& Tag)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.SoundProvider.GetTagQuery");
		
		USoundProvider_GetTagQuery_Params params {};
		params.Tag = Tag;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01817610
	 * 		Name   -> Function DungeonCrawler.SoundProvider.GetTagQueries
	 * 		Flags  -> (Native, Public, Const)
	 */
	TMap<struct FGameplayTag, struct FGameplayTagQuery> USoundProvider::GetTagQueries()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.SoundProvider.GetTagQueries");
		
		USoundProvider_GetTagQueries_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01817520
	 * 		Name   -> Function DungeonCrawler.SoundProvider.GetSwitches
	 * 		Flags  -> (Native, Public, Const)
	 */
	TMap<struct FGameplayTag, struct FDCSoundDataContainer> USoundProvider::GetSwitches()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.SoundProvider.GetSwitches");
		
		USoundProvider_GetSwitches_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01817430
	 * 		Name   -> Function DungeonCrawler.SoundProvider.GetSwitch
	 * 		Flags  -> (Native, Public, HasOutParms, Const)
	 * Parameters:
	 * 		struct FGameplayTag                                Tag                                                        (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EPhysicalSurface                                   Surface                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UAkSwitchValue* USoundProvider::GetSwitch(const struct FGameplayTag& Tag, EPhysicalSurface Surface)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.SoundProvider.GetSwitch");
		
		USoundProvider_GetSwitch_Params params {};
		params.Tag = Tag;
		params.Surface = Surface;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x018172D0
	 * 		Name   -> Function DungeonCrawler.SoundProvider.GetLastPrimaryAssetId
	 * 		Flags  -> (Native, Public, HasDefaults, Const)
	 */
	struct FPrimaryAssetId USoundProvider::GetLastPrimaryAssetId()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.SoundProvider.GetLastPrimaryAssetId");
		
		USoundProvider_GetLastPrimaryAssetId_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01817200
	 * 		Name   -> Function DungeonCrawler.SoundProvider.GetEvents
	 * 		Flags  -> (Native, Public, Const)
	 */
	TMap<struct FGameplayTag, class UAkAudioEvent*> USoundProvider::GetEvents()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.SoundProvider.GetEvents");
		
		USoundProvider_GetEvents_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01817150
	 * 		Name   -> Function DungeonCrawler.SoundProvider.GetEvent
	 * 		Flags  -> (Native, Public, HasOutParms, Const)
	 * Parameters:
	 * 		struct FGameplayTag                                Tag                                                        (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UAkAudioEvent* USoundProvider::GetEvent(const struct FGameplayTag& Tag)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.SoundProvider.GetEvent");
		
		USoundProvider_GetEvent_Params params {};
		params.Tag = Tag;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction USoundProvider.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* USoundProvider::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.SoundProvider");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01818730
	 * 		Name   -> Function DungeonCrawler.SpellActor.UpdateSpellCount
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		int32_t                                            Count                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool ASpellActor::UpdateSpellCount(int32_t Count)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.SpellActor.UpdateSpellCount");
		
		ASpellActor_UpdateSpellCount_Params params {};
		params.Count = Count;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01818350
	 * 		Name   -> Function DungeonCrawler.SpellActor.SetSpellData
	 * 		Flags  -> (Final, Native, Public, HasOutParms)
	 * Parameters:
	 * 		struct FSpellData                                  NewSpellData                                               (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void ASpellActor::SetSpellData(const struct FSpellData& NewSpellData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.SpellActor.SetSpellData");
		
		ASpellActor_SetSpellData_Params params {};
		params.NewSpellData = NewSpellData;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x018180A0
	 * 		Name   -> Function DungeonCrawler.SpellActor.RechargeSpell
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		int32_t                                            ChargeAmount                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASpellActor::RechargeSpell(int32_t ChargeAmount)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.SpellActor.RechargeSpell");
		
		ASpellActor_RechargeSpell_Params params {};
		params.ChargeAmount = ChargeAmount;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01817AF0
	 * 		Name   -> Function DungeonCrawler.SpellActor.OnRep_SpellData
	 * 		Flags  -> (Final, Native, Private, HasOutParms)
	 * Parameters:
	 * 		struct FSpellData                                  OldSpellData                                               (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void ASpellActor::OnRep_SpellData(const struct FSpellData& OldSpellData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.SpellActor.OnRep_SpellData");
		
		ASpellActor_OnRep_SpellData_Params params {};
		params.OldSpellData = OldSpellData;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01817340
	 * 		Name   -> Function DungeonCrawler.SpellActor.GetSpellData
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	struct FSpellData ASpellActor::GetSpellData()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.SpellActor.GetSpellData");
		
		ASpellActor_GetSpellData_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01817310
	 * 		Name   -> Function DungeonCrawler.SpellActor.GetSoundDataSpell
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	class USoundData* ASpellActor::GetSoundDataSpell()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.SpellActor.GetSoundDataSpell");
		
		ASpellActor_GetSoundDataSpell_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01816F30
	 * 		Name   -> Function DungeonCrawler.SpellActor.GetDesignDataSpell
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	struct FDesignDataSpell ASpellActor::GetDesignDataSpell()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.SpellActor.GetDesignDataSpell");
		
		ASpellActor_GetDesignDataSpell_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01816EA0
	 * 		Name   -> Function DungeonCrawler.SpellActor.GetArtDataSpell
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	class UArtDataSpell* ASpellActor::GetArtDataSpell()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.SpellActor.GetArtDataSpell");
		
		ASpellActor_GetArtDataSpell_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ASpellActor.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ASpellActor::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.SpellActor");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x018187D0
	 * 		Name   -> Function DungeonCrawler.SpellMemorizeComponent.UpdateSpellCount
	 * 		Flags  -> (Final, Native, Private)
	 * Parameters:
	 * 		struct FGameplayTag                                SpellTag                                                   (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            Count                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool USpellMemorizeComponent::UpdateSpellCount(const struct FGameplayTag& SpellTag, int32_t Count)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.SpellMemorizeComponent.UpdateSpellCount");
		
		USpellMemorizeComponent_UpdateSpellCount_Params params {};
		params.SpellTag = SpellTag;
		params.Count = Count;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01764730
	 * 		Name   -> Function DungeonCrawler.SpellMemorizeComponent.UnbindMsgAll
	 * 		Flags  -> (Native, Public)
	 * Parameters:
	 * 		class UObject*                                     InObject                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void USpellMemorizeComponent::UnbindMsgAll(class UObject* InObject)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.SpellMemorizeComponent.UnbindMsgAll");
		
		USpellMemorizeComponent_UnbindMsgAll_Params params {};
		params.InObject = InObject;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01764280
	 * 		Name   -> Function DungeonCrawler.SpellMemorizeComponent.UnbindMsg
	 * 		Flags  -> (Native, Public)
	 * Parameters:
	 * 		class UScriptStruct*                               InMsgType                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UObject*                                     InObject                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void USpellMemorizeComponent::UnbindMsg(class UScriptStruct* InMsgType, class UObject* InObject)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.SpellMemorizeComponent.UnbindMsg");
		
		USpellMemorizeComponent_UnbindMsg_Params params {};
		params.InMsgType = InMsgType;
		params.InObject = InObject;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01818690
	 * 		Name   -> Function DungeonCrawler.SpellMemorizeComponent.TryUseSpell
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		struct FGameplayTag                                SpellTriggerTag                                            (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool USpellMemorizeComponent::TryUseSpell(const struct FGameplayTag& SpellTriggerTag)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.SpellMemorizeComponent.TryUseSpell");
		
		USpellMemorizeComponent_TryUseSpell_Params params {};
		params.SpellTriggerTag = SpellTriggerTag;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01763EB0
	 * 		Name   -> Function DungeonCrawler.SpellMemorizeComponent.TerminateBase
	 * 		Flags  -> (Native, Public)
	 */
	void USpellMemorizeComponent::TerminateBase()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.SpellMemorizeComponent.TerminateBase");
		
		USpellMemorizeComponent_TerminateBase_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x018182C0
	 * 		Name   -> Function DungeonCrawler.SpellMemorizeComponent.ServerSetCurrentSpell
	 * 		Flags  -> (Final, Net, NetReliable, Native, Event, Private, NetServer)
	 * Parameters:
	 * 		struct FGameplayTag                                SpellTag                                                   (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void USpellMemorizeComponent::ServerSetCurrentSpell(const struct FGameplayTag& SpellTag)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.SpellMemorizeComponent.ServerSetCurrentSpell");
		
		USpellMemorizeComponent_ServerSetCurrentSpell_Params params {};
		params.SpellTag = SpellTag;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01817A40
	 * 		Name   -> Function DungeonCrawler.SpellMemorizeComponent.OnRep_SpellActors
	 * 		Flags  -> (Final, Native, Protected, HasOutParms)
	 * Parameters:
	 * 		TArray<class ASpellActor*>                         OldASpellActors                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void USpellMemorizeComponent::OnRep_SpellActors(TArray<class ASpellActor*> OldASpellActors)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.SpellMemorizeComponent.OnRep_SpellActors");
		
		USpellMemorizeComponent_OnRep_SpellActors_Params params {};
		params.OldASpellActors = OldASpellActors;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x018177F0
	 * 		Name   -> Function DungeonCrawler.SpellMemorizeComponent.InitSpellData
	 * 		Flags  -> (Final, Native, Private, HasOutParms)
	 * Parameters:
	 * 		struct FAccountData                                InAccountData                                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void USpellMemorizeComponent::InitSpellData(const struct FAccountData& InAccountData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.SpellMemorizeComponent.InitSpellData");
		
		USpellMemorizeComponent_InitSpellData_Params params {};
		params.InAccountData = InAccountData;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x018173B0
	 * 		Name   -> Function DungeonCrawler.SpellMemorizeComponent.GetSpellDatas
	 * 		Flags  -> (Final, Native, Public, Const)
	 */
	TArray<struct FSpellData> USpellMemorizeComponent::GetSpellDatas()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.SpellMemorizeComponent.GetSpellDatas");
		
		USpellMemorizeComponent_GetSpellDatas_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01816F00
	 * 		Name   -> Function DungeonCrawler.SpellMemorizeComponent.GetCurrentSpellCastability
	 * 		Flags  -> (Final, Native, Public)
	 */
	ESpellCastabilityType USpellMemorizeComponent::GetCurrentSpellCastability()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.SpellMemorizeComponent.GetCurrentSpellCastability");
		
		USpellMemorizeComponent_GetCurrentSpellCastability_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01816ED0
	 * 		Name   -> Function DungeonCrawler.SpellMemorizeComponent.GetCurrentSpellActor
	 * 		Flags  -> (Final, Native, Public)
	 */
	class ASpellActor* USpellMemorizeComponent::GetCurrentSpellActor()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.SpellMemorizeComponent.GetCurrentSpellActor");
		
		USpellMemorizeComponent_GetCurrentSpellActor_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00D3C640
	 * 		Name   -> Function DungeonCrawler.SpellMemorizeComponent.BroadcastMsgBlueprint
	 * 		Flags  -> (Native, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		int32_t                                            InMsg                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void USpellMemorizeComponent::BroadcastMsgBlueprint(int32_t InMsg)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.SpellMemorizeComponent.BroadcastMsgBlueprint");
		
		USpellMemorizeComponent_BroadcastMsgBlueprint_Params params {};
		params.InMsg = InMsg;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction USpellMemorizeComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* USpellMemorizeComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.SpellMemorizeComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AStaticMeshItemHolderActor.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AStaticMeshItemHolderActor::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.StaticMeshItemHolderActor");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ABP_StaticMeshItemHolder_C.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ABP_StaticMeshItemHolder_C::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("BlueprintGeneratedClass BP_StaticMeshItemHolder.BP_StaticMeshItemHolder_C");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UStorageWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UStorageWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.StorageWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UTagQueryData.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UTagQueryData::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.TagQueryData");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UTopTitleWidgetBase.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UTopTitleWidgetBase::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.TopTitleWidgetBase");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UTotalGoldCountWidgetBase.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UTotalGoldCountWidgetBase::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.TotalGoldCountWidgetBase");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01822660
	 * 		Name   -> Function DungeonCrawler.TradeChannelButtonBase.OnChannelButtonClicked
	 * 		Flags  -> (Final, Native, Private)
	 */
	void UTradeChannelButtonBase::OnChannelButtonClicked()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.TradeChannelButtonBase.OnChannelButtonClicked");
		
		UTradeChannelButtonBase_OnChannelButtonClicked_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UTradeChannelButtonBase.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UTradeChannelButtonBase::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.TradeChannelButtonBase");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.TradeChannelChatWidget.OnChatType
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 * Parameters:
	 * 		EChatType                                          NewItemData                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EChatType                                          OldItemData                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UTradeChannelChatWidget::OnChatType(EChatType NewItemData, EChatType OldItemData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.TradeChannelChatWidget.OnChatType");
		
		UTradeChannelChatWidget_OnChatType_Params params {};
		params.NewItemData = NewItemData;
		params.OldItemData = OldItemData;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.TradeChannelChatWidget.OnChatAccountData
	 * 		Flags  -> (Event, Protected, HasOutParms, BlueprintEvent)
	 * Parameters:
	 * 		struct FChatAccountData                            NewItemData                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		struct FChatAccountData                            OldItemData                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UTradeChannelChatWidget::OnChatAccountData(const struct FChatAccountData& NewItemData, const struct FChatAccountData& OldItemData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.TradeChannelChatWidget.OnChatAccountData");
		
		UTradeChannelChatWidget_OnChatAccountData_Params params {};
		params.NewItemData = NewItemData;
		params.OldItemData = OldItemData;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UTradeChannelChatWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UTradeChannelChatWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.TradeChannelChatWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UTradeChannelListWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UTradeChannelListWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.TradeChannelListWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2D860
	 * 		Name   -> Function DungeonCrawler.TradeChatWidget.OnChatAccountData
	 * 		Flags  -> (Event, Protected, HasOutParms, BlueprintEvent)
	 * Parameters:
	 * 		struct FChatAccountData                            NewItemData                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		struct FChatAccountData                            OldItemData                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UTradeChatWidget::OnChatAccountData(const struct FChatAccountData& NewItemData, const struct FChatAccountData& OldItemData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.TradeChatWidget.OnChatAccountData");
		
		UTradeChatWidget_OnChatAccountData_Params params {};
		params.NewItemData = NewItemData;
		params.OldItemData = OldItemData;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UTradeChatWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UTradeChatWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.TradeChatWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01803C70
	 * 		Name   -> Function DungeonCrawler.TradeMasterWidget.SendTradeSubscriptionWidgetBeginNotify
	 * 		Flags  -> (Final, Native, Private)
	 */
	void UTradeMasterWidget::SendTradeSubscriptionWidgetBeginNotify()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.TradeMasterWidget.SendTradeSubscriptionWidgetBeginNotify");
		
		UTradeMasterWidget_SendTradeSubscriptionWidgetBeginNotify_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UTradeMasterWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UTradeMasterWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.TradeMasterWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01822930
	 * 		Name   -> Function DungeonCrawler.TradeSubscriptionWidget.SendMsgWidgetTradeSubscriptionButtonClicked
	 * 		Flags  -> (Final, Native, Private)
	 */
	void UTradeSubscriptionWidget::SendMsgWidgetTradeSubscriptionButtonClicked()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.TradeSubscriptionWidget.SendMsgWidgetTradeSubscriptionButtonClicked");
		
		UTradeSubscriptionWidget_SendMsgWidgetTradeSubscriptionButtonClicked_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01822680
	 * 		Name   -> Function DungeonCrawler.TradeSubscriptionWidget.OnClikedButtonDone
	 * 		Flags  -> (Final, Native, Private)
	 */
	void UTradeSubscriptionWidget::OnClikedButtonDone()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.TradeSubscriptionWidget.OnClikedButtonDone");
		
		UTradeSubscriptionWidget_OnClikedButtonDone_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01822620
	 * 		Name   -> Function DungeonCrawler.TradeSubscriptionWidget.CloseSelf
	 * 		Flags  -> (Final, Native, Private)
	 */
	void UTradeSubscriptionWidget::CloseSelf()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.TradeSubscriptionWidget.CloseSelf");
		
		UTradeSubscriptionWidget_CloseSelf_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UTradeSubscriptionWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UTradeSubscriptionWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.TradeSubscriptionWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UTradeUserListEntryWidgetData.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UTradeUserListEntryWidgetData::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.TradeUserListEntryWidgetData");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01822830
	 * 		Name   -> Function DungeonCrawler.TradeUserListEntryWidget.OnRightClicked
	 * 		Flags  -> (Native, Protected)
	 */
	void UTradeUserListEntryWidget::OnRightClicked()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.TradeUserListEntryWidget.OnRightClicked");
		
		UTradeUserListEntryWidget_OnRightClicked_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UTradeUserListEntryWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UTradeUserListEntryWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.TradeUserListEntryWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01822860
	 * 		Name   -> Function DungeonCrawler.TradeUserListWidget.OnTextChanged
	 * 		Flags  -> (Final, Native, Private, HasOutParms)
	 * Parameters:
	 * 		class FText                                        FindId                                                     (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UTradeUserListWidget::OnTextChanged(const class FText& FindId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.TradeUserListWidget.OnTextChanged");
		
		UTradeUserListWidget_OnTextChanged_Params params {};
		params.FindId = FindId;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01822640
	 * 		Name   -> Function DungeonCrawler.TradeUserListWidget.OnBlockUpdated
	 * 		Flags  -> (Final, Native, Private)
	 */
	void UTradeUserListWidget::OnBlockUpdated()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function DungeonCrawler.TradeUserListWidget.OnBlockUpdated");
		
		UTradeUserListWidget_OnBlockUpdated_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UTradeUserListWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UTradeUserListWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class DungeonCrawler.TradeUserListWidget");
		return ptr;
	}

}


