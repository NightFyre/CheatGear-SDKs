/**
 * Name: Borderlands_3
 * Version: 4.20.3
 */

#include "../SDK.h"

namespace CG
{
	// --------------------------------------------------
	// # Structs Functions
	// --------------------------------------------------
	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UStanceDataProvider.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UStanceDataProvider::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.StanceDataProvider");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UStanceData.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UStanceData::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.StanceData");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02162B60
	 * 		Name   -> Function GbxGameSystemCore.GbxAnimTable.Autofill
	 * 		Flags  -> (Native, Protected)
	 */
	void UGbxAnimTable::Autofill()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxAnimTable.Autofill");
		
		UGbxAnimTable_Autofill_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGbxAnimTable.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGbxAnimTable::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.GbxAnimTable");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0178F8F0
	 * 		Name   -> Function GbxGameSystemCore.GbxAction.OnServerEnd
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		EGbxActionEndState                                 ActionEndState                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      Actor                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGbxAction::OnServerEnd(EGbxActionEndState ActionEndState, class AActor* Actor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxAction.OnServerEnd");
		
		UGbxAction_OnServerEnd_Params params {};
		params.ActionEndState = ActionEndState;
		params.Actor = Actor;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0178F8F0
	 * 		Name   -> Function GbxGameSystemCore.GbxAction.OnServerBegin
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		class AActor*                                      Actor                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGbxAction::OnServerBegin(class AActor* Actor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxAction.OnServerBegin");
		
		UGbxAction_OnServerBegin_Params params {};
		params.Actor = Actor;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0178F8F0
	 * 		Name   -> Function GbxGameSystemCore.GbxAction.OnEnd
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		EGbxActionEndState                                 ActionEndState                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      Actor                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGbxAction::OnEnd(EGbxActionEndState ActionEndState, class AActor* Actor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxAction.OnEnd");
		
		UGbxAction_OnEnd_Params params {};
		params.ActionEndState = ActionEndState;
		params.Actor = Actor;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0178F8F0
	 * 		Name   -> Function GbxGameSystemCore.GbxAction.OnBegin
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		class AActor*                                      Actor                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGbxAction::OnBegin(class AActor* Actor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxAction.OnBegin");
		
		UGbxAction_OnBegin_Params params {};
		params.Actor = Actor;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E1E700
	 * 		Name   -> Function GbxGameSystemCore.GbxAction.K2_GetVectorRegisterValue
	 * 		Flags  -> (Final, Native, Private, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		class FName                                        InName                                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     OutVector                                                  (Parm, OutParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UGbxAction::K2_GetVectorRegisterValue(const class FName& InName, struct FVector* OutVector)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxAction.K2_GetVectorRegisterValue");
		
		UGbxAction_K2_GetVectorRegisterValue_Params params {};
		params.InName = InName;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutVector != nullptr)
			*OutVector = params.OutVector;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E1E6D0
	 * 		Name   -> Function GbxGameSystemCore.GbxAction.K2_GetTimeRemaining
	 * 		Flags  -> (Final, Native, Private, BlueprintCallable, BlueprintPure, Const)
	 */
	float UGbxAction::K2_GetTimeRemaining()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxAction.K2_GetTimeRemaining");
		
		UGbxAction_K2_GetTimeRemaining_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E1E600
	 * 		Name   -> Function GbxGameSystemCore.GbxAction.K2_GetObjectRegisterValue
	 * 		Flags  -> (Final, Native, Private, HasOutParms, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		class FName                                        InName                                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UObject*                                     OutObject                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UGbxAction::K2_GetObjectRegisterValue(const class FName& InName, class UObject** OutObject)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxAction.K2_GetObjectRegisterValue");
		
		UGbxAction_K2_GetObjectRegisterValue_Params params {};
		params.InName = InName;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutObject != nullptr)
			*OutObject = params.OutObject;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E1E530
	 * 		Name   -> Function GbxGameSystemCore.GbxAction.K2_GetNameRegisterValue
	 * 		Flags  -> (Final, Native, Private, HasOutParms, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		class FName                                        InName                                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FName                                        OutName                                                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UGbxAction::K2_GetNameRegisterValue(const class FName& InName, class FName* OutName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxAction.K2_GetNameRegisterValue");
		
		UGbxAction_K2_GetNameRegisterValue_Params params {};
		params.InName = InName;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutName != nullptr)
			*OutName = params.OutName;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E1E500
	 * 		Name   -> Function GbxGameSystemCore.GbxAction.K2_GetMaxCurrentTime
	 * 		Flags  -> (Final, Native, Private, BlueprintCallable, BlueprintPure, Const)
	 */
	float UGbxAction::K2_GetMaxCurrentTime()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxAction.K2_GetMaxCurrentTime");
		
		UGbxAction_K2_GetMaxCurrentTime_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E1E430
	 * 		Name   -> Function GbxGameSystemCore.GbxAction.K2_GetIntRegisterValue
	 * 		Flags  -> (Final, Native, Private, HasOutParms, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		class FName                                        InName                                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            OutInt                                                     (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UGbxAction::K2_GetIntRegisterValue(const class FName& InName, int32_t* OutInt)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxAction.K2_GetIntRegisterValue");
		
		UGbxAction_K2_GetIntRegisterValue_Params params {};
		params.InName = InName;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutInt != nullptr)
			*OutInt = params.OutInt;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E1E350
	 * 		Name   -> Function GbxGameSystemCore.GbxAction.K2_GetFloatRegisterValue
	 * 		Flags  -> (Final, Native, Private, HasOutParms, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		class FName                                        InName                                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              OutFloat                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UGbxAction::K2_GetFloatRegisterValue(const class FName& InName, float* OutFloat)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxAction.K2_GetFloatRegisterValue");
		
		UGbxAction_K2_GetFloatRegisterValue_Params params {};
		params.InName = InName;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutFloat != nullptr)
			*OutFloat = params.OutFloat;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E1E320
	 * 		Name   -> Function GbxGameSystemCore.GbxAction.K2_GetCurrentTime
	 * 		Flags  -> (Final, Native, Private, BlueprintCallable, BlueprintPure, Const)
	 */
	float UGbxAction::K2_GetCurrentTime()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxAction.K2_GetCurrentTime");
		
		UGbxAction_K2_GetCurrentTime_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E1E2F0
	 * 		Name   -> Function GbxGameSystemCore.GbxAction.K2_GetCurrentNormalizedTime
	 * 		Flags  -> (Final, Native, Private, BlueprintCallable, BlueprintPure, Const)
	 */
	float UGbxAction::K2_GetCurrentNormalizedTime()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxAction.K2_GetCurrentNormalizedTime");
		
		UGbxAction_K2_GetCurrentNormalizedTime_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E1E2C0
	 * 		Name   -> Function GbxGameSystemCore.GbxAction.K2_GetActor
	 * 		Flags  -> (Final, Native, Private, BlueprintCallable, BlueprintPure, Const)
	 */
	class AActor* UGbxAction::K2_GetActor()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxAction.K2_GetActor");
		
		UGbxAction_K2_GetActor_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGbxAction.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGbxAction::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.GbxAction");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0178F8F0
	 * 		Name   -> Function GbxGameSystemCore.GbxAction_SimpleAnim.OnAnimEnd
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 * Parameters:
	 * 		class AActor*                                      Actor                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGbxAction_SimpleAnim::OnAnimEnd(class AActor* Actor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxAction_SimpleAnim.OnAnimEnd");
		
		UGbxAction_SimpleAnim_OnAnimEnd_Params params {};
		params.Actor = Actor;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E22C60
	 * 		Name   -> Function GbxGameSystemCore.GbxAction_SimpleAnim.K2_SetTickAndRefreshBones
	 * 		Flags  -> (Final, Native, Private, BlueprintCallable, Const)
	 * Parameters:
	 * 		bool                                               bLockResource                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGbxAction_SimpleAnim::K2_SetTickAndRefreshBones(bool bLockResource)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxAction_SimpleAnim.K2_SetTickAndRefreshBones");
		
		UGbxAction_SimpleAnim_K2_SetTickAndRefreshBones_Params params {};
		params.bLockResource = bLockResource;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E22BD0
	 * 		Name   -> Function GbxGameSystemCore.GbxAction_SimpleAnim.K2_SetPhysNoneWithRootMotion
	 * 		Flags  -> (Final, Native, Private, BlueprintCallable, Const)
	 * Parameters:
	 * 		bool                                               bEnable                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGbxAction_SimpleAnim::K2_SetPhysNoneWithRootMotion(bool bEnable)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxAction_SimpleAnim.K2_SetPhysNoneWithRootMotion");
		
		UGbxAction_SimpleAnim_K2_SetPhysNoneWithRootMotion_Params params {};
		params.bEnable = bEnable;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E22B40
	 * 		Name   -> Function GbxGameSystemCore.GbxAction_SimpleAnim.K2_SetMovement
	 * 		Flags  -> (Final, Native, Private, BlueprintCallable, Const)
	 * Parameters:
	 * 		bool                                               bDisable                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGbxAction_SimpleAnim::K2_SetMovement(bool bDisable)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxAction_SimpleAnim.K2_SetMovement");
		
		UGbxAction_SimpleAnim_K2_SetMovement_Params params {};
		params.bDisable = bDisable;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E22AB0
	 * 		Name   -> Function GbxGameSystemCore.GbxAction_SimpleAnim.K2_SetLook
	 * 		Flags  -> (Final, Native, Private, BlueprintCallable, Const)
	 * Parameters:
	 * 		bool                                               bDisable                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGbxAction_SimpleAnim::K2_SetLook(bool bDisable)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxAction_SimpleAnim.K2_SetLook");
		
		UGbxAction_SimpleAnim_K2_SetLook_Params params {};
		params.bDisable = bDisable;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E22A20
	 * 		Name   -> Function GbxGameSystemCore.GbxAction_SimpleAnim.K2_SetHitReactions
	 * 		Flags  -> (Final, Native, Private, BlueprintCallable, Const)
	 * Parameters:
	 * 		bool                                               bDisable                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGbxAction_SimpleAnim::K2_SetHitReactions(bool bDisable)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxAction_SimpleAnim.K2_SetHitReactions");
		
		UGbxAction_SimpleAnim_K2_SetHitReactions_Params params {};
		params.bDisable = bDisable;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E22990
	 * 		Name   -> Function GbxGameSystemCore.GbxAction_SimpleAnim.K2_SetHeadLookLocked
	 * 		Flags  -> (Final, Native, Private, BlueprintCallable, Const)
	 * Parameters:
	 * 		bool                                               bLock                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGbxAction_SimpleAnim::K2_SetHeadLookLocked(bool bLock)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxAction_SimpleAnim.K2_SetHeadLookLocked");
		
		UGbxAction_SimpleAnim_K2_SetHeadLookLocked_Params params {};
		params.bLock = bLock;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E22900
	 * 		Name   -> Function GbxGameSystemCore.GbxAction_SimpleAnim.K2_SetHeadLook
	 * 		Flags  -> (Final, Native, Private, BlueprintCallable, Const)
	 * Parameters:
	 * 		bool                                               bDisable                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGbxAction_SimpleAnim::K2_SetHeadLook(bool bDisable)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxAction_SimpleAnim.K2_SetHeadLook");
		
		UGbxAction_SimpleAnim_K2_SetHeadLook_Params params {};
		params.bDisable = bDisable;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E22870
	 * 		Name   -> Function GbxGameSystemCore.GbxAction_SimpleAnim.K2_SetCollision
	 * 		Flags  -> (Final, Native, Private, BlueprintCallable, Const)
	 * Parameters:
	 * 		bool                                               bEnable                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGbxAction_SimpleAnim::K2_SetCollision(bool bEnable)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxAction_SimpleAnim.K2_SetCollision");
		
		UGbxAction_SimpleAnim_K2_SetCollision_Params params {};
		params.bEnable = bEnable;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E227E0
	 * 		Name   -> Function GbxGameSystemCore.GbxAction_SimpleAnim.K2_SetAvoidance
	 * 		Flags  -> (Final, Native, Private, BlueprintCallable, Const)
	 * Parameters:
	 * 		bool                                               bDisable                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGbxAction_SimpleAnim::K2_SetAvoidance(bool bDisable)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxAction_SimpleAnim.K2_SetAvoidance");
		
		UGbxAction_SimpleAnim_K2_SetAvoidance_Params params {};
		params.bDisable = bDisable;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E226C0
	 * 		Name   -> Function GbxGameSystemCore.GbxAction_SimpleAnim.K2_SetAIThinking
	 * 		Flags  -> (Final, Native, Private, BlueprintCallable, Const)
	 * Parameters:
	 * 		bool                                               bDisable                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGbxAction_SimpleAnim::K2_SetAIThinking(bool bDisable)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxAction_SimpleAnim.K2_SetAIThinking");
		
		UGbxAction_SimpleAnim_K2_SetAIThinking_Params params {};
		params.bDisable = bDisable;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E22750
	 * 		Name   -> Function GbxGameSystemCore.GbxAction_SimpleAnim.K2_SetAimRotation
	 * 		Flags  -> (Final, Native, Private, BlueprintCallable, Const)
	 * Parameters:
	 * 		bool                                               bDisable                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGbxAction_SimpleAnim::K2_SetAimRotation(bool bDisable)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxAction_SimpleAnim.K2_SetAimRotation");
		
		UGbxAction_SimpleAnim_K2_SetAimRotation_Params params {};
		params.bDisable = bDisable;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGbxAction_SimpleAnim.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGbxAction_SimpleAnim::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.GbxAction_SimpleAnim");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGbxAISystemBase.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGbxAISystemBase::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.GbxAISystemBase");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E6C760
	 * 		Name   -> Function GbxGameSystemCore.PreviewComponent.OnBlueprintCompiled
	 * 		Flags  -> (Final, Native, Protected)
	 * Parameters:
	 * 		class UBlueprint*                                  BP                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UPreviewComponent::OnBlueprintCompiled(class UBlueprint* BP)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.PreviewComponent.OnBlueprintCompiled");
		
		UPreviewComponent_OnBlueprintCompiled_Params params {};
		params.BP = BP;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UPreviewComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UPreviewComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.PreviewComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E1EAE0
	 * 		Name   -> Function GbxGameSystemCore.GbxAction_Anim.K2_SetMantlingBlocked
	 * 		Flags  -> (Final, Native, Private, BlueprintCallable, Const)
	 * Parameters:
	 * 		bool                                               bBlocked                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGbxAction_Anim::K2_SetMantlingBlocked(bool bBlocked)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxAction_Anim.K2_SetMantlingBlocked");
		
		UGbxAction_Anim_K2_SetMantlingBlocked_Params params {};
		params.bBlocked = bBlocked;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E1EA50
	 * 		Name   -> Function GbxGameSystemCore.GbxAction_Anim.K2_SetGodMode
	 * 		Flags  -> (Final, Native, Private, BlueprintCallable, Const)
	 * Parameters:
	 * 		bool                                               bEnable                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGbxAction_Anim::K2_SetGodMode(bool bEnable)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxAction_Anim.K2_SetGodMode");
		
		UGbxAction_Anim_K2_SetGodMode_Params params {};
		params.bEnable = bEnable;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E1E9C0
	 * 		Name   -> Function GbxGameSystemCore.GbxAction_Anim.K2_SetFootIK
	 * 		Flags  -> (Final, Native, Private, BlueprintCallable, Const)
	 * Parameters:
	 * 		bool                                               bDisable                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGbxAction_Anim::K2_SetFootIK(bool bDisable)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxAction_Anim.K2_SetFootIK");
		
		UGbxAction_Anim_K2_SetFootIK_Params params {};
		params.bDisable = bDisable;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E1E930
	 * 		Name   -> Function GbxGameSystemCore.GbxAction_Anim.K2_SetDemigodMode
	 * 		Flags  -> (Final, Native, Private, BlueprintCallable, Const)
	 * Parameters:
	 * 		bool                                               bEnable                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGbxAction_Anim::K2_SetDemigodMode(bool bEnable)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxAction_Anim.K2_SetDemigodMode");
		
		UGbxAction_Anim_K2_SetDemigodMode_Params params {};
		params.bEnable = bEnable;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E1E8A0
	 * 		Name   -> Function GbxGameSystemCore.GbxAction_Anim.K2_SetCrouchBlocked
	 * 		Flags  -> (Final, Native, Private, BlueprintCallable, Const)
	 * Parameters:
	 * 		bool                                               bBlocked                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGbxAction_Anim::K2_SetCrouchBlocked(bool bBlocked)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxAction_Anim.K2_SetCrouchBlocked");
		
		UGbxAction_Anim_K2_SetCrouchBlocked_Params params {};
		params.bBlocked = bBlocked;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E1E880
	 * 		Name   -> Function GbxGameSystemCore.GbxAction_Anim.K2_Resume
	 * 		Flags  -> (Final, Native, Private, BlueprintCallable, Const)
	 */
	void UGbxAction_Anim::K2_Resume()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxAction_Anim.K2_Resume");
		
		UGbxAction_Anim_K2_Resume_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E1E860
	 * 		Name   -> Function GbxGameSystemCore.GbxAction_Anim.K2_RepProceedToNextSection
	 * 		Flags  -> (Final, Native, Private, BlueprintCallable, Const)
	 */
	void UGbxAction_Anim::K2_RepProceedToNextSection()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxAction_Anim.K2_RepProceedToNextSection");
		
		UGbxAction_Anim_K2_RepProceedToNextSection_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E1E840
	 * 		Name   -> Function GbxGameSystemCore.GbxAction_Anim.K2_RepJumpToNextSection
	 * 		Flags  -> (Final, Native, Private, BlueprintCallable, Const)
	 */
	void UGbxAction_Anim::K2_RepJumpToNextSection()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxAction_Anim.K2_RepJumpToNextSection");
		
		UGbxAction_Anim_K2_RepJumpToNextSection_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E1E820
	 * 		Name   -> Function GbxGameSystemCore.GbxAction_Anim.K2_ProceedToNextSection
	 * 		Flags  -> (Final, Native, Private, BlueprintCallable, Const)
	 */
	void UGbxAction_Anim::K2_ProceedToNextSection()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxAction_Anim.K2_ProceedToNextSection");
		
		UGbxAction_Anim_K2_ProceedToNextSection_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E1E800
	 * 		Name   -> Function GbxGameSystemCore.GbxAction_Anim.K2_Pause
	 * 		Flags  -> (Final, Native, Private, BlueprintCallable, Const)
	 */
	void UGbxAction_Anim::K2_Pause()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxAction_Anim.K2_Pause");
		
		UGbxAction_Anim_K2_Pause_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E1E7E0
	 * 		Name   -> Function GbxGameSystemCore.GbxAction_Anim.K2_JumpToNextSection
	 * 		Flags  -> (Final, Native, Private, BlueprintCallable, Const)
	 */
	void UGbxAction_Anim::K2_JumpToNextSection()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxAction_Anim.K2_JumpToNextSection");
		
		UGbxAction_Anim_K2_JumpToNextSection_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGbxAction_Anim.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGbxAction_Anim::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.GbxAction_Anim");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E7F1C0
	 * 		Name   -> Function GbxGameSystemCore.TeamComponent.SetTeamToDefault
	 * 		Flags  -> (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
	 */
	void UTeamComponent::SetTeamToDefault()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.TeamComponent.SetTeamToDefault");
		
		UTeamComponent_SetTeamToDefault_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E7F130
	 * 		Name   -> Function GbxGameSystemCore.TeamComponent.SetTeamCollision
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bOn                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UTeamComponent::SetTeamCollision(bool bOn)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.TeamComponent.SetTeamCollision");
		
		UTeamComponent_SetTeamCollision_Params params {};
		params.bOn = bOn;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E7F0B0
	 * 		Name   -> Function GbxGameSystemCore.TeamComponent.SetTeam
	 * 		Flags  -> (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UTeam*                                       NewTeam                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UTeamComponent::SetTeam(class UTeam* NewTeam)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.TeamComponent.SetTeam");
		
		UTeamComponent_SetTeam_Params params {};
		params.NewTeam = NewTeam;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E7F030
	 * 		Name   -> Function GbxGameSystemCore.TeamComponent.SetSourceTeamComponent
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UTeamComponent*                              NewSourceTeamComponent                                     (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UTeamComponent::SetSourceTeamComponent(class UTeamComponent* NewSourceTeamComponent)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.TeamComponent.SetSourceTeamComponent");
		
		UTeamComponent_SetSourceTeamComponent_Params params {};
		params.NewSourceTeamComponent = NewSourceTeamComponent;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E7EE10
	 * 		Name   -> Function GbxGameSystemCore.TeamComponent.SetCollidesWithTeam
	 * 		Flags  -> (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bCollidesWithTeam                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UTeamComponent::SetCollidesWithTeam(bool bCollidesWithTeam)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.TeamComponent.SetCollidesWithTeam");
		
		UTeamComponent_SetCollidesWithTeam_Params params {};
		params.bCollidesWithTeam = bCollidesWithTeam;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x014D2C00
	 * 		Name   -> Function GbxGameSystemCore.TeamComponent.OnRep_Team
	 * 		Flags  -> (Final, Native, Private)
	 * Parameters:
	 * 		class UTeam*                                       OldTeam                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UTeamComponent::OnRep_Team(class UTeam* OldTeam)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.TeamComponent.OnRep_Team");
		
		UTeamComponent_OnRep_Team_Params params {};
		params.OldTeam = OldTeam;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x014B3930
	 * 		Name   -> Function GbxGameSystemCore.TeamComponent.OnRep_bIgnoreCollisionWithTeam
	 * 		Flags  -> (Final, Native, Private)
	 */
	void UTeamComponent::OnRep_bIgnoreCollisionWithTeam()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.TeamComponent.OnRep_bIgnoreCollisionWithTeam");
		
		UTeamComponent_OnRep_bIgnoreCollisionWithTeam_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E7E760
	 * 		Name   -> Function GbxGameSystemCore.TeamComponent.IsNeutral
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		class AActor*                                      Actor                                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UTeamComponent::IsNeutral(class AActor* Actor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.TeamComponent.IsNeutral");
		
		UTeamComponent_IsNeutral_Params params {};
		params.Actor = Actor;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E7E6D0
	 * 		Name   -> Function GbxGameSystemCore.TeamComponent.IsHostile
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		class AActor*                                      Actor                                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UTeamComponent::IsHostile(class AActor* Actor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.TeamComponent.IsHostile");
		
		UTeamComponent_IsHostile_Params params {};
		params.Actor = Actor;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E7E640
	 * 		Name   -> Function GbxGameSystemCore.TeamComponent.IsFriendly
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		class AActor*                                      Actor                                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UTeamComponent::IsFriendly(class AActor* Actor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.TeamComponent.IsFriendly");
		
		UTeamComponent_IsFriendly_Params params {};
		params.Actor = Actor;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E7E5C0
	 * 		Name   -> Function GbxGameSystemCore.TeamComponent.InitializeTeam
	 * 		Flags  -> (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UTeam*                                       NewTeam                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UTeamComponent::InitializeTeam(class UTeam* NewTeam)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.TeamComponent.InitializeTeam");
		
		UTeamComponent_InitializeTeam_Params params {};
		params.NewTeam = NewTeam;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E7E590
	 * 		Name   -> Function GbxGameSystemCore.TeamComponent.GetTeamCollisionChannel
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	ETeamCollisionChannel UTeamComponent::GetTeamCollisionChannel()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.TeamComponent.GetTeamCollisionChannel");
		
		UTeamComponent_GetTeamCollisionChannel_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E7E500
	 * 		Name   -> Function GbxGameSystemCore.TeamComponent.GetTeamAttitudeTowardsTeam
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		class UTeam*                                       OtherTeam                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	ETeamAttitude UTeamComponent::GetTeamAttitudeTowardsTeam(class UTeam* OtherTeam)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.TeamComponent.GetTeamAttitudeTowardsTeam");
		
		UTeamComponent_GetTeamAttitudeTowardsTeam_Params params {};
		params.OtherTeam = OtherTeam;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E7E470
	 * 		Name   -> Function GbxGameSystemCore.TeamComponent.GetTeamAttitudeTowardsActor
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		class AActor*                                      Actor                                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	ETeamAttitude UTeamComponent::GetTeamAttitudeTowardsActor(class AActor* Actor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.TeamComponent.GetTeamAttitudeTowardsActor");
		
		UTeamComponent_GetTeamAttitudeTowardsActor_Params params {};
		params.Actor = Actor;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UTeamComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UTeamComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.TeamComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E340D0
	 * 		Name   -> Function GbxGameSystemCore.GbxCharacter.SetTeam
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, Const)
	 * Parameters:
	 * 		class UTeam*                                       Team                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AGbxCharacter::SetTeam(class UTeam* Team)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxCharacter.SetTeam");
		
		AGbxCharacter_SetTeam_Params params {};
		params.Team = Team;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E34050
	 * 		Name   -> Function GbxGameSystemCore.GbxCharacter.SetPlayerMaster
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class AGbxCharacter*                               NewPlayerMaster                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AGbxCharacter::SetPlayerMaster(class AGbxCharacter* NewPlayerMaster)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxCharacter.SetPlayerMaster");
		
		AGbxCharacter_SetPlayerMaster_Params params {};
		params.NewPlayerMaster = NewPlayerMaster;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E33FD0
	 * 		Name   -> Function GbxGameSystemCore.GbxCharacter.SetCharacterUIName
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UGbxUIName*                                  NewCharacterUIName                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AGbxCharacter::SetCharacterUIName(class UGbxUIName* NewCharacterUIName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxCharacter.SetCharacterUIName");
		
		AGbxCharacter_SetCharacterUIName_Params params {};
		params.NewCharacterUIName = NewCharacterUIName;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E33F30
	 * 		Name   -> Function GbxGameSystemCore.GbxCharacter.SetCharacterNameFromString
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class FString                                      NewCharacterName                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AGbxCharacter::SetCharacterNameFromString(const class FString& NewCharacterName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxCharacter.SetCharacterNameFromString");
		
		AGbxCharacter_SetCharacterNameFromString_Params params {};
		params.NewCharacterName = NewCharacterName;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E33E60
	 * 		Name   -> Function GbxGameSystemCore.GbxCharacter.SetCharacterName
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		class FText                                        NewCharacterName                                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void AGbxCharacter::SetCharacterName(const class FText& NewCharacterName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxCharacter.SetCharacterName");
		
		AGbxCharacter_SetCharacterName_Params params {};
		params.NewCharacterName = NewCharacterName;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E33D50
	 * 		Name   -> Function GbxGameSystemCore.GbxCharacter.RotateCharacterTo
	 * 		Flags  -> (Final, BlueprintAuthorityOnly, Native, Public, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FRotator                                    TargetRotation                                             (Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		float                                              Duration                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EEasingFunc                                        Easing                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AGbxCharacter::RotateCharacterTo(const struct FRotator& TargetRotation, float Duration, EEasingFunc Easing)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxCharacter.RotateCharacterTo");
		
		AGbxCharacter_RotateCharacterTo_Params params {};
		params.TargetRotation = TargetRotation;
		params.Duration = Duration;
		params.Easing = Easing;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E33CC0
	 * 		Name   -> Function GbxGameSystemCore.GbxCharacter.ReceiveOwnerPlayerControllerChanged
	 * 		Flags  -> (Native, Event, Protected, BlueprintEvent)
	 * Parameters:
	 * 		class AGbxPlayerController*                        NewPlayerControllerOwner                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AGbxCharacter::ReceiveOwnerPlayerControllerChanged(class AGbxPlayerController* NewPlayerControllerOwner)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxCharacter.ReceiveOwnerPlayerControllerChanged");
		
		AGbxCharacter_ReceiveOwnerPlayerControllerChanged_Params params {};
		params.NewPlayerControllerOwner = NewPlayerControllerOwner;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E33CA0
	 * 		Name   -> Function GbxGameSystemCore.GbxCharacter.OnRep_ReplicatedPawnAttachState
	 * 		Flags  -> (Final, Native, Protected)
	 */
	void AGbxCharacter::OnRep_ReplicatedPawnAttachState()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxCharacter.OnRep_ReplicatedPawnAttachState");
		
		AGbxCharacter_OnRep_ReplicatedPawnAttachState_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0178F8F0
	 * 		Name   -> Function GbxGameSystemCore.GbxCharacter.OnLandingDataTriggered
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		struct FLandingInfo                                LandingInfo                                                (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 * 		int32_t                                            Index                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AGbxCharacter::OnLandingDataTriggered(const struct FLandingInfo& LandingInfo, int32_t Index)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxCharacter.OnLandingDataTriggered");
		
		AGbxCharacter_OnLandingDataTriggered_Params params {};
		params.LandingInfo = LandingInfo;
		params.Index = Index;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E33C10
	 * 		Name   -> Function GbxGameSystemCore.GbxCharacter.NetMulticast_TriggerHitReactionSound
	 * 		Flags  -> (Net, Native, Event, NetMulticast, Public)
	 * Parameters:
	 * 		class UCharacterSoundTag*                          Tag                                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AGbxCharacter::NetMulticast_TriggerHitReactionSound(class UCharacterSoundTag* Tag)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxCharacter.NetMulticast_TriggerHitReactionSound");
		
		AGbxCharacter_NetMulticast_TriggerHitReactionSound_Params params {};
		params.Tag = Tag;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E33A70
	 * 		Name   -> Function GbxGameSystemCore.GbxCharacter.NetMulticast_PlayLanded
	 * 		Flags  -> (Net, Native, Event, NetMulticast, Public)
	 * Parameters:
	 * 		struct FHitResult                                  Hit                                                        (ConstParm, Parm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 * 		float                                              ImpactSpeed                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bLandFromJump                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class ULandingData*                                LandingDataOverride                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AGbxCharacter::NetMulticast_PlayLanded(const struct FHitResult& Hit, float ImpactSpeed, bool bLandFromJump, class ULandingData* LandingDataOverride)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxCharacter.NetMulticast_PlayLanded");
		
		AGbxCharacter_NetMulticast_PlayLanded_Params params {};
		params.Hit = Hit;
		params.ImpactSpeed = ImpactSpeed;
		params.bLandFromJump = bLandFromJump;
		params.LandingDataOverride = LandingDataOverride;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E33A50
	 * 		Name   -> Function GbxGameSystemCore.GbxCharacter.NetMulticast_PlayJumped
	 * 		Flags  -> (Net, Native, Event, NetMulticast, Public)
	 */
	void AGbxCharacter::NetMulticast_PlayJumped()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxCharacter.NetMulticast_PlayJumped");
		
		AGbxCharacter_NetMulticast_PlayJumped_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E33A20
	 * 		Name   -> Function GbxGameSystemCore.GbxCharacter.IsZoomed
	 * 		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AGbxCharacter::IsZoomed()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxCharacter.IsZoomed");
		
		AGbxCharacter_IsZoomed_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E32D30
	 * 		Name   -> Function GbxGameSystemCore.GbxCharacter.GetTeamComponent
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	class UTeamComponent* AGbxCharacter::GetTeamComponent()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxCharacter.GetTeamComponent");
		
		AGbxCharacter_GetTeamComponent_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E32D70
	 * 		Name   -> Function GbxGameSystemCore.GbxCharacter.GetTeam
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	class UTeam* AGbxCharacter::GetTeam()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxCharacter.GetTeam");
		
		AGbxCharacter_GetTeam_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E32D50
	 * 		Name   -> Function GbxGameSystemCore.GbxCharacter.GetTargetingComponent
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	class UTargetingComponent* AGbxCharacter::GetTargetingComponent()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxCharacter.GetTargetingComponent");
		
		AGbxCharacter_GetTargetingComponent_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E32D30
	 * 		Name   -> Function GbxGameSystemCore.GbxCharacter.GetTargetableComponent
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	class UTargetableComponent* AGbxCharacter::GetTargetableComponent()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxCharacter.GetTargetableComponent");
		
		AGbxCharacter_GetTargetableComponent_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E32B70
	 * 		Name   -> Function GbxGameSystemCore.GbxCharacter.GetPerceptionComponent
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	class UGbxPerceptionComponent* AGbxCharacter::GetPerceptionComponent()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxCharacter.GetPerceptionComponent");
		
		AGbxCharacter_GetPerceptionComponent_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E32B50
	 * 		Name   -> Function GbxGameSystemCore.GbxCharacter.GetPawnAttachStatus
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	EPawnAttachStatus AGbxCharacter::GetPawnAttachStatus()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxCharacter.GetPawnAttachStatus");
		
		AGbxCharacter_GetPawnAttachStatus_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E32B20
	 * 		Name   -> Function GbxGameSystemCore.GbxCharacter.GetPawnAttachComponent
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	class UPawnAttachSlotComponent* AGbxCharacter::GetPawnAttachComponent()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxCharacter.GetPawnAttachComponent");
		
		AGbxCharacter_GetPawnAttachComponent_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E32AF0
	 * 		Name   -> Function GbxGameSystemCore.GbxCharacter.GetPawnAttachActor
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	class AActor* AGbxCharacter::GetPawnAttachActor()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxCharacter.GetPawnAttachActor");
		
		AGbxCharacter_GetPawnAttachActor_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E32A30
	 * 		Name   -> Function GbxGameSystemCore.GbxCharacter.GetLookAtLocation
	 * 		Flags  -> (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		float                                              OutWeight                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FVector AGbxCharacter::GetLookAtLocation(float* OutWeight)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxCharacter.GetLookAtLocation");
		
		AGbxCharacter_GetLookAtLocation_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutWeight != nullptr)
			*OutWeight = params.OutWeight;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E328E0
	 * 		Name   -> Function GbxGameSystemCore.GbxCharacter.GetLookAt
	 * 		Flags  -> (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		struct FVector                                     HeadLocation                                               (Parm, OutParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     EyeLocation                                                (Parm, OutParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              HeadWeight                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	float AGbxCharacter::GetLookAt(struct FVector* HeadLocation, struct FVector* EyeLocation, float* HeadWeight)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxCharacter.GetLookAt");
		
		AGbxCharacter_GetLookAt_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (HeadLocation != nullptr)
			*HeadLocation = params.HeadLocation;
		if (EyeLocation != nullptr)
			*EyeLocation = params.EyeLocation;
		if (HeadWeight != nullptr)
			*HeadWeight = params.HeadWeight;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E328B0
	 * 		Name   -> Function GbxGameSystemCore.GbxCharacter.GetFirstPersonMesh
	 * 		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	class USkeletalMeshComponent* AGbxCharacter::GetFirstPersonMesh()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxCharacter.GetFirstPersonMesh");
		
		AGbxCharacter_GetFirstPersonMesh_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E32880
	 * 		Name   -> Function GbxGameSystemCore.GbxCharacter.GetFirstPersonComponent
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	class UFirstPersonComponent* AGbxCharacter::GetFirstPersonComponent()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxCharacter.GetFirstPersonComponent");
		
		AGbxCharacter_GetFirstPersonComponent_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E32850
	 * 		Name   -> Function GbxGameSystemCore.GbxCharacter.GetBlackboardComponent
	 * 		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	class UBlackboardComponent* AGbxCharacter::GetBlackboardComponent()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxCharacter.GetBlackboardComponent");
		
		AGbxCharacter_GetBlackboardComponent_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E32820
	 * 		Name   -> Function GbxGameSystemCore.GbxCharacter.GetBlackboardAsset
	 * 		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	class UBlackboardData* AGbxCharacter::GetBlackboardAsset()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxCharacter.GetBlackboardAsset");
		
		AGbxCharacter_GetBlackboardAsset_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E32770
	 * 		Name   -> Function GbxGameSystemCore.GbxCharacter.GetAvailableSocketNames
	 * 		Flags  -> (Final, Native, Public, HasOutParms, Const)
	 * Parameters:
	 * 		TArray<class FName>                                Array                                                      (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	 */
	void AGbxCharacter::GetAvailableSocketNames(TArray<class FName>* Array)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxCharacter.GetAvailableSocketNames");
		
		AGbxCharacter_GetAvailableSocketNames_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (Array != nullptr)
			*Array = params.Array;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E32730
	 * 		Name   -> Function GbxGameSystemCore.GbxCharacter.GetAimVectorStartLocation
	 * 		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
	 */
	struct FVector AGbxCharacter::GetAimVectorStartLocation()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxCharacter.GetAimVectorStartLocation");
		
		AGbxCharacter_GetAimVectorStartLocation_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E326F0
	 * 		Name   -> Function GbxGameSystemCore.GbxCharacter.GetAimOffset
	 * 		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
	 */
	struct FRotator AGbxCharacter::GetAimOffset()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxCharacter.GetAimOffset");
		
		AGbxCharacter_GetAimOffset_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E326C0
	 * 		Name   -> Function GbxGameSystemCore.GbxCharacter.FindFirstPersonComponent
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	class UFirstPersonComponent* AGbxCharacter::FindFirstPersonComponent()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxCharacter.FindFirstPersonComponent");
		
		AGbxCharacter_FindFirstPersonComponent_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E32640
	 * 		Name   -> Function GbxGameSystemCore.GbxCharacter.DetachCharacter
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		EDetachmentRule                                    LocationRule                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AGbxCharacter::DetachCharacter(EDetachmentRule LocationRule)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxCharacter.DetachCharacter");
		
		AGbxCharacter_DetachCharacter_Params params {};
		params.LocationRule = LocationRule;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E32530
	 * 		Name   -> Function GbxGameSystemCore.GbxCharacter.ClientRotateCharacterTo
	 * 		Flags  -> (Final, Net, NetReliable, Native, Event, Private, HasDefaults, NetClient)
	 * Parameters:
	 * 		struct FRotator                                    TargetRotation                                             (Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		float                                              Duration                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EEasingFunc                                        Easing                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AGbxCharacter::ClientRotateCharacterTo(const struct FRotator& TargetRotation, float Duration, EEasingFunc Easing)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxCharacter.ClientRotateCharacterTo");
		
		AGbxCharacter_ClientRotateCharacterTo_Params params {};
		params.TargetRotation = TargetRotation;
		params.Duration = Duration;
		params.Easing = Easing;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E32430
	 * 		Name   -> Function GbxGameSystemCore.GbxCharacter.CauseEveryoneToForgetMe
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void AGbxCharacter::CauseEveryoneToForgetMe()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxCharacter.CauseEveryoneToForgetMe");
		
		AGbxCharacter_CauseEveryoneToForgetMe_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E32270
	 * 		Name   -> Function GbxGameSystemCore.GbxCharacter.AttachCharacterToComponent
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class USceneComponent*                             Parent                                                     (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FName                                        SocketName                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EAttachmentRule                                    LocationRule                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EAttachmentRule                                    RotationRule                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EAttachmentRule                                    ScaleRule                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bWeldSimulatedBodies                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AGbxCharacter::AttachCharacterToComponent(class USceneComponent* Parent, const class FName& SocketName, EAttachmentRule LocationRule, EAttachmentRule RotationRule, EAttachmentRule ScaleRule, bool bWeldSimulatedBodies)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxCharacter.AttachCharacterToComponent");
		
		AGbxCharacter_AttachCharacterToComponent_Params params {};
		params.Parent = Parent;
		params.SocketName = SocketName;
		params.LocationRule = LocationRule;
		params.RotationRule = RotationRule;
		params.ScaleRule = ScaleRule;
		params.bWeldSimulatedBodies = bWeldSimulatedBodies;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E320B0
	 * 		Name   -> Function GbxGameSystemCore.GbxCharacter.AttachCharacterToActor
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class AActor*                                      ParentActor                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FName                                        SocketName                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EAttachmentRule                                    LocationRule                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EAttachmentRule                                    RotationRule                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EAttachmentRule                                    ScaleRule                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bWeldSimulatedBodies                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AGbxCharacter::AttachCharacterToActor(class AActor* ParentActor, const class FName& SocketName, EAttachmentRule LocationRule, EAttachmentRule RotationRule, EAttachmentRule ScaleRule, bool bWeldSimulatedBodies)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxCharacter.AttachCharacterToActor");
		
		AGbxCharacter_AttachCharacterToActor_Params params {};
		params.ParentActor = ParentActor;
		params.SocketName = SocketName;
		params.LocationRule = LocationRule;
		params.RotationRule = RotationRule;
		params.ScaleRule = ScaleRule;
		params.bWeldSimulatedBodies = bWeldSimulatedBodies;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AGbxCharacter.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AGbxCharacter::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.GbxCharacter");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02DFCB90
	 * 		Name   -> Function GbxGameSystemCore.BalanceStateComponent.SetGameStage
	 * 		Flags  -> (Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		int32_t                                            NewGameStage                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UBalanceStateComponent::SetGameStage(int32_t NewGameStage)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.BalanceStateComponent.SetGameStage");
		
		UBalanceStateComponent_SetGameStage_Params params {};
		params.NewGameStage = NewGameStage;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02DFCB10
	 * 		Name   -> Function GbxGameSystemCore.BalanceStateComponent.SetExperienceLevel
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		int32_t                                            NewExperienceLevel                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UBalanceStateComponent::SetExperienceLevel(int32_t NewExperienceLevel)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.BalanceStateComponent.SetExperienceLevel");
		
		UBalanceStateComponent_SetExperienceLevel_Params params {};
		params.NewExperienceLevel = NewExperienceLevel;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02DFAEE0
	 * 		Name   -> Function GbxGameSystemCore.BalanceStateComponent.OnRep_ExperienceLevel
	 * 		Flags  -> (Final, Native, Protected)
	 * Parameters:
	 * 		int32_t                                            OldExperienceLevel                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UBalanceStateComponent::OnRep_ExperienceLevel(int32_t OldExperienceLevel)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.BalanceStateComponent.OnRep_ExperienceLevel");
		
		UBalanceStateComponent_OnRep_ExperienceLevel_Params params {};
		params.OldExperienceLevel = OldExperienceLevel;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02DFADE0
	 * 		Name   -> Function GbxGameSystemCore.BalanceStateComponent.OnInheritedBalanceSourceLevelChanged
	 * 		Flags  -> (Native, Protected)
	 * Parameters:
	 * 		class UBalanceStateComponent*                      InheritedBalanceStateSource                                (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            OldExperienceLevel                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            NewExperienceLevel                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UBalanceStateComponent::OnInheritedBalanceSourceLevelChanged(class UBalanceStateComponent* InheritedBalanceStateSource, int32_t OldExperienceLevel, int32_t NewExperienceLevel)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.BalanceStateComponent.OnInheritedBalanceSourceLevelChanged");
		
		UBalanceStateComponent_OnInheritedBalanceSourceLevelChanged_Params params {};
		params.InheritedBalanceStateSource = InheritedBalanceStateSource;
		params.OldExperienceLevel = OldExperienceLevel;
		params.NewExperienceLevel = NewExperienceLevel;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02DFAC00
	 * 		Name   -> Function GbxGameSystemCore.BalanceStateComponent.GetGameStage
	 * 		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	int32_t UBalanceStateComponent::GetGameStage()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.BalanceStateComponent.GetGameStage");
		
		UBalanceStateComponent_GetGameStage_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02DFABD0
	 * 		Name   -> Function GbxGameSystemCore.BalanceStateComponent.GetExperienceLevel
	 * 		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	int32_t UBalanceStateComponent::GetExperienceLevel()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.BalanceStateComponent.GetExperienceLevel");
		
		UBalanceStateComponent_GetExperienceLevel_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02DFA870
	 * 		Name   -> Function GbxGameSystemCore.BalanceStateComponent.GetBalanceTableRow
	 * 		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	struct FDataTableRowHandle UBalanceStateComponent::GetBalanceTableRow()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.BalanceStateComponent.GetBalanceTableRow");
		
		UBalanceStateComponent_GetBalanceTableRow_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UBalanceStateComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UBalanceStateComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.BalanceStateComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E40A10
	 * 		Name   -> Function GbxGameSystemCore.GbxChildActorComponent.SpawnChildActor
	 * 		Flags  -> (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
	 */
	void UGbxChildActorComponent::SpawnChildActor()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxChildActorComponent.SpawnChildActor");
		
		UGbxChildActorComponent_SpawnChildActor_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E3FFA0
	 * 		Name   -> Function GbxGameSystemCore.GbxChildActorComponent.DespawnChildActor
	 * 		Flags  -> (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
	 */
	void UGbxChildActorComponent::DespawnChildActor()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxChildActorComponent.DespawnChildActor");
		
		UGbxChildActorComponent_DespawnChildActor_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGbxChildActorComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGbxChildActorComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.GbxChildActorComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UAnimNotify_PawnAttachSlotTransition.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UAnimNotify_PawnAttachSlotTransition::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.AnimNotify_PawnAttachSlotTransition");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UAttributeEffectMutatorData.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UAttributeEffectMutatorData::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.AttributeEffectMutatorData");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E2E930
	 * 		Name   -> Function GbxGameSystemCore.GbxAnimInstance.GetAnimTableSequence
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		class UGbxAnimTable*                               AnimTable                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UAnimSequence* UGbxAnimInstance::GetAnimTableSequence(class UGbxAnimTable* AnimTable)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxAnimInstance.GetAnimTableSequence");
		
		UGbxAnimInstance_GetAnimTableSequence_Params params {};
		params.AnimTable = AnimTable;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E2DDC0
	 * 		Name   -> Function GbxGameSystemCore.GbxAnimInstance.CanUseAnimTable
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		class UGbxAnimTable*                               AnimTable                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UGbxAnimInstance::CanUseAnimTable(class UGbxAnimTable* AnimTable)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxAnimInstance.CanUseAnimTable");
		
		UGbxAnimInstance_CanUseAnimTable_Params params {};
		params.AnimTable = AnimTable;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGbxAnimInstance.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGbxAnimInstance::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.GbxAnimInstance");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E479C0
	 * 		Name   -> Function GbxGameSystemCore.GbxCustomizationData.RemoveCustomizationFromActor
	 * 		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		class AActor*                                      TargetActor                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UGbxCustomizationData::RemoveCustomizationFromActor(class AActor* TargetActor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxCustomizationData.RemoveCustomizationFromActor");
		
		UGbxCustomizationData_RemoveCustomizationFromActor_Params params {};
		params.TargetActor = TargetActor;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E474D0
	 * 		Name   -> Function GbxGameSystemCore.GbxCustomizationData.OnCustomizationAssetLoaded
	 * 		Flags  -> (Final, Native, Private)
	 */
	void UGbxCustomizationData::OnCustomizationAssetLoaded()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxCustomizationData.OnCustomizationAssetLoaded");
		
		UGbxCustomizationData_OnCustomizationAssetLoaded_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E473B0
	 * 		Name   -> Function GbxGameSystemCore.GbxCustomizationData.K2_PlayAction
	 * 		Flags  -> (Final, Native, Private, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		class AActor*                                      TargetActor                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FActionState_Base                           ActionData                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	class UGbxAction* UGbxCustomizationData::K2_PlayAction(class AActor* TargetActor, const struct FActionState_Base& ActionData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxCustomizationData.K2_PlayAction");
		
		UGbxCustomizationData_K2_PlayAction_Params params {};
		params.TargetActor = TargetActor;
		params.ActionData = ActionData;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E47380
	 * 		Name   -> Function GbxGameSystemCore.GbxCustomizationData.IsLoading
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	bool UGbxCustomizationData::IsLoading()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxCustomizationData.IsLoading");
		
		UGbxCustomizationData_IsLoading_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E472E0
	 * 		Name   -> Function GbxGameSystemCore.GbxCustomizationData.IsLoaded
	 * 		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		int32_t                                            OptionalCustomizationId                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UGbxCustomizationData::IsLoaded(int32_t OptionalCustomizationId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxCustomizationData.IsLoaded");
		
		UGbxCustomizationData_IsLoaded_Params params {};
		params.OptionalCustomizationId = OptionalCustomizationId;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E45FC0
	 * 		Name   -> Function GbxGameSystemCore.GbxCustomizationData.AsyncLoadCustomizationAssets
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		class FScriptDelegate                              LoadedDelegate                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UGbxCustomizationData::AsyncLoadCustomizationAssets(const class FScriptDelegate& LoadedDelegate)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxCustomizationData.AsyncLoadCustomizationAssets");
		
		UGbxCustomizationData_AsyncLoadCustomizationAssets_Params params {};
		params.LoadedDelegate = LoadedDelegate;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E45EF0
	 * 		Name   -> Function GbxGameSystemCore.GbxCustomizationData.ApplyCustomizationToActor
	 * 		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		class AActor*                                      TargetActor                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            OptionalCustomizationId                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UGbxCustomizationData::ApplyCustomizationToActor(class AActor* TargetActor, int32_t OptionalCustomizationId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxCustomizationData.ApplyCustomizationToActor");
		
		UGbxCustomizationData_ApplyCustomizationToActor_Params params {};
		params.TargetActor = TargetActor;
		params.OptionalCustomizationId = OptionalCustomizationId;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGbxCustomizationData.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGbxCustomizationData::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.GbxCustomizationData");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UActorPartSelectionData.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UActorPartSelectionData::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.ActorPartSelectionData");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0178F8F0
	 * 		Name   -> Function GbxGameSystemCore.AttributeValueResolver.SetValueForAttribute
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 * Parameters:
	 * 		class UGbxAttributeData*                           Attribute                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UObject*                                     Context                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Value                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UAttributeValueResolver::SetValueForAttribute(class UGbxAttributeData* Attribute, class UObject* Context, float Value)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.AttributeValueResolver.SetValueForAttribute");
		
		UAttributeValueResolver_SetValueForAttribute_Params params {};
		params.Attribute = Attribute;
		params.Context = Context;
		params.Value = Value;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0178F8F0
	 * 		Name   -> Function GbxGameSystemCore.AttributeValueResolver.GetValueForAttribute
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 * Parameters:
	 * 		class UGbxAttributeData*                           Attribute                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UObject*                                     Context                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	float UAttributeValueResolver::GetValueForAttribute(class UGbxAttributeData* Attribute, class UObject* Context)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.AttributeValueResolver.GetValueForAttribute");
		
		UAttributeValueResolver_GetValueForAttribute_Params params {};
		params.Attribute = Attribute;
		params.Context = Context;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UAttributeValueResolver.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UAttributeValueResolver::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.AttributeValueResolver");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x014F27C0
	 * 		Name   -> Function GbxGameSystemCore.GbxAreaComponent.AreaTest
	 * 		Flags  -> (Native, Public)
	 */
	void UGbxAreaComponent::AreaTest()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxAreaComponent.AreaTest");
		
		UGbxAreaComponent_AreaTest_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGbxAreaComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGbxAreaComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.GbxAreaComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E0F800
	 * 		Name   -> Function GbxGameSystemCore.EffectCollectionData.StaticGetWwiseEvent
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, Const)
	 * Parameters:
	 * 		class UClass*                                      Collection                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UObject*                                     ContextObject                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UWwiseEvent* UEffectCollectionData::STATIC_StaticGetWwiseEvent(class UClass* Collection, class UObject* ContextObject)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.EffectCollectionData.StaticGetWwiseEvent");
		
		UEffectCollectionData_StaticGetWwiseEvent_Params params {};
		params.Collection = Collection;
		params.ContextObject = ContextObject;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E0F6A0
	 * 		Name   -> Function GbxGameSystemCore.EffectCollectionData.StaticGetParticleEffectAndWwiseEvent
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, Const)
	 * Parameters:
	 * 		class UClass*                                      Collection                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UObject*                                     ContextObject                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UParticleSystem*                             ParticleEffect                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UWwiseEvent*                                 WwiseEvent                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UEffectCollectionData::STATIC_StaticGetParticleEffectAndWwiseEvent(class UClass* Collection, class UObject* ContextObject, class UParticleSystem** ParticleEffect, class UWwiseEvent** WwiseEvent)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.EffectCollectionData.StaticGetParticleEffectAndWwiseEvent");
		
		UEffectCollectionData_StaticGetParticleEffectAndWwiseEvent_Params params {};
		params.Collection = Collection;
		params.ContextObject = ContextObject;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (ParticleEffect != nullptr)
			*ParticleEffect = params.ParticleEffect;
		if (WwiseEvent != nullptr)
			*WwiseEvent = params.WwiseEvent;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E0F5E0
	 * 		Name   -> Function GbxGameSystemCore.EffectCollectionData.StaticGetParticleEffect
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, Const)
	 * Parameters:
	 * 		class UClass*                                      Collection                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UObject*                                     ContextObject                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UParticleSystem* UEffectCollectionData::STATIC_StaticGetParticleEffect(class UClass* Collection, class UObject* ContextObject)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.EffectCollectionData.StaticGetParticleEffect");
		
		UEffectCollectionData_StaticGetParticleEffect_Params params {};
		params.Collection = Collection;
		params.ContextObject = ContextObject;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E0E5C0
	 * 		Name   -> Function GbxGameSystemCore.EffectCollectionData.GetWwiseEvent
	 * 		Flags  -> (Native, Event, Public, BlueprintEvent, Const)
	 * Parameters:
	 * 		class UObject*                                     ContextObject                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UWwiseEvent* UEffectCollectionData::GetWwiseEvent(class UObject* ContextObject)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.EffectCollectionData.GetWwiseEvent");
		
		UEffectCollectionData_GetWwiseEvent_Params params {};
		params.ContextObject = ContextObject;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E0E460
	 * 		Name   -> Function GbxGameSystemCore.EffectCollectionData.GetParticleEffectAndWwiseEvent
	 * 		Flags  -> (Native, Event, Public, HasOutParms, BlueprintEvent, Const)
	 * Parameters:
	 * 		class UObject*                                     ContextObject                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UParticleSystem*                             ParticleEffect                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UWwiseEvent*                                 WwiseEvent                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UEffectCollectionData::GetParticleEffectAndWwiseEvent(class UObject* ContextObject, class UParticleSystem** ParticleEffect, class UWwiseEvent** WwiseEvent)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.EffectCollectionData.GetParticleEffectAndWwiseEvent");
		
		UEffectCollectionData_GetParticleEffectAndWwiseEvent_Params params {};
		params.ContextObject = ContextObject;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (ParticleEffect != nullptr)
			*ParticleEffect = params.ParticleEffect;
		if (WwiseEvent != nullptr)
			*WwiseEvent = params.WwiseEvent;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E0E3C0
	 * 		Name   -> Function GbxGameSystemCore.EffectCollectionData.GetParticleEffect
	 * 		Flags  -> (Native, Event, Public, BlueprintEvent, Const)
	 * Parameters:
	 * 		class UObject*                                     ContextObject                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UParticleSystem* UEffectCollectionData::GetParticleEffect(class UObject* ContextObject)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.EffectCollectionData.GetParticleEffect");
		
		UEffectCollectionData_GetParticleEffect_Params params {};
		params.ContextObject = ContextObject;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UEffectCollectionData.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UEffectCollectionData::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.EffectCollectionData");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UEnvQueryGenerator_TargetableActors.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UEnvQueryGenerator_TargetableActors::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.EnvQueryGenerator_TargetableActors");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E7F1E0
	 * 		Name   -> Function GbxGameSystemCore.UsableComponent.SetUsableLocked
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bLocked                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FName                                        Reason                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UUsableComponent::SetUsableLocked(bool bLocked, const class FName& Reason)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.UsableComponent.SetUsableLocked");
		
		UUsableComponent_SetUsableLocked_Params params {};
		params.bLocked = bLocked;
		params.Reason = Reason;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E7EF60
	 * 		Name   -> Function GbxGameSystemCore.UsableComponent.SetInteractionHeader
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		class FText                                        NewHeaderName                                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UUsableComponent::SetInteractionHeader(const class FText& NewHeaderName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.UsableComponent.SetInteractionHeader");
		
		UUsableComponent_SetInteractionHeader_Params params {};
		params.NewHeaderName = NewHeaderName;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E7EDF0
	 * 		Name   -> Function GbxGameSystemCore.UsableComponent.ResetUseCount
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void UUsableComponent::ResetUseCount()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.UsableComponent.ResetUseCount");
		
		UUsableComponent_ResetUseCount_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E7EA90
	 * 		Name   -> Function GbxGameSystemCore.UsableComponent.K2_GetOptionalErrorText
	 * 		Flags  -> (Native, Event, Public, BlueprintEvent, Const)
	 */
	class FText UUsableComponent::K2_GetOptionalErrorText()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.UsableComponent.K2_GetOptionalErrorText");
		
		UUsableComponent_K2_GetOptionalErrorText_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E7E7F0
	 * 		Name   -> Function GbxGameSystemCore.UsableComponent.K2_CanBeUsed
	 * 		Flags  -> (Native, Event, Public, HasOutParms, BlueprintEvent, Const)
	 * Parameters:
	 * 		struct FUsabilityQuery                             Query                                                      (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	bool UUsableComponent::K2_CanBeUsed(const struct FUsabilityQuery& Query)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.UsableComponent.K2_CanBeUsed");
		
		UUsableComponent_K2_CanBeUsed_Params params {};
		params.Query = Query;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007A5960
	 * 		Name   -> Function GbxGameSystemCore.UsableComponent.GetValidPrimitiveComponentNames
	 * 		Flags  -> (Final, Native, Private, HasOutParms, Const)
	 * Parameters:
	 * 		TArray<class FName>                                ComponentNames                                             (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	 */
	void UUsableComponent::GetValidPrimitiveComponentNames(TArray<class FName>* ComponentNames)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.UsableComponent.GetValidPrimitiveComponentNames");
		
		UUsableComponent_GetValidPrimitiveComponentNames_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (ComponentNames != nullptr)
			*ComponentNames = params.ComponentNames;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E7E440
	 * 		Name   -> Function GbxGameSystemCore.UsableComponent.GetInteractionHeader
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	class FText UUsableComponent::GetInteractionHeader()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.UsableComponent.GetInteractionHeader");
		
		UUsableComponent_GetInteractionHeader_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UUsableComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UUsableComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.UsableComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGbxGameplayGlobals.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGbxGameplayGlobals::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.GbxGameplayGlobals");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AGbxGameMode.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AGbxGameMode::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.GbxGameMode");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E4F420
	 * 		Name   -> Function GbxGameSystemCore.GbxGameState.SpawnEmitterAtLocationMulticastImpl
	 * 		Flags  -> (Net, NetReliable, Native, Event, NetMulticast, Public, HasDefaults, BlueprintCallable, Const)
	 * Parameters:
	 * 		class UParticleSystem*                             EmitterTemplate                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     Location                                                   (Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FRotator                                    Rotation                                                   (Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     Scale                                                      (Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bAutoDestroy                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UObject*                                     ParameterEvaluationContext                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AGbxGameState::SpawnEmitterAtLocationMulticastImpl(class UParticleSystem* EmitterTemplate, const struct FVector& Location, const struct FRotator& Rotation, const struct FVector& Scale, bool bAutoDestroy, class UObject* ParameterEvaluationContext)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxGameState.SpawnEmitterAtLocationMulticastImpl");
		
		AGbxGameState_SpawnEmitterAtLocationMulticastImpl_Params params {};
		params.EmitterTemplate = EmitterTemplate;
		params.Location = Location;
		params.Rotation = Rotation;
		params.Scale = Scale;
		params.bAutoDestroy = bAutoDestroy;
		params.ParameterEvaluationContext = ParameterEvaluationContext;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E4F200
	 * 		Name   -> Function GbxGameSystemCore.GbxGameState.SpawnEmitterAtLocationMulticast
	 * 		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UParticleSystem*                             EmitterTemplate                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     Location                                                   (Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FRotator                                    Rotation                                                   (Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     Scale                                                      (Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bAutoDestroy                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UObject*                                     ParameterEvaluationContext                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AGbxGameState::STATIC_SpawnEmitterAtLocationMulticast(class UObject* WorldContextObject, class UParticleSystem* EmitterTemplate, const struct FVector& Location, const struct FRotator& Rotation, const struct FVector& Scale, bool bAutoDestroy, class UObject* ParameterEvaluationContext)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxGameState.SpawnEmitterAtLocationMulticast");
		
		AGbxGameState_SpawnEmitterAtLocationMulticast_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.EmitterTemplate = EmitterTemplate;
		params.Location = Location;
		params.Rotation = Rotation;
		params.Scale = Scale;
		params.bAutoDestroy = bAutoDestroy;
		params.ParameterEvaluationContext = ParameterEvaluationContext;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E4F050
	 * 		Name   -> Function GbxGameSystemCore.GbxGameState.SpawnEmitterAtComponentSocketMulticast
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UParticleSystem*                             EmitterTemplate                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class USceneComponent*                             Component                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FName                                        Socket                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bAutoDestroy                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UObject*                                     ParameterEvaluationContext                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AGbxGameState::STATIC_SpawnEmitterAtComponentSocketMulticast(class UObject* WorldContextObject, class UParticleSystem* EmitterTemplate, class USceneComponent* Component, const class FName& Socket, bool bAutoDestroy, class UObject* ParameterEvaluationContext)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxGameState.SpawnEmitterAtComponentSocketMulticast");
		
		AGbxGameState_SpawnEmitterAtComponentSocketMulticast_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.EmitterTemplate = EmitterTemplate;
		params.Component = Component;
		params.Socket = Socket;
		params.bAutoDestroy = bAutoDestroy;
		params.ParameterEvaluationContext = ParameterEvaluationContext;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E4EEA0
	 * 		Name   -> Function GbxGameSystemCore.GbxGameState.SpawnEmitterAtActorSocketMulticast
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UParticleSystem*                             EmitterTemplate                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      Actor                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FName                                        Socket                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bAutoDestroy                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UObject*                                     ParameterEvaluationContext                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AGbxGameState::STATIC_SpawnEmitterAtActorSocketMulticast(class UObject* WorldContextObject, class UParticleSystem* EmitterTemplate, class AActor* Actor, const class FName& Socket, bool bAutoDestroy, class UObject* ParameterEvaluationContext)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxGameState.SpawnEmitterAtActorSocketMulticast");
		
		AGbxGameState_SpawnEmitterAtActorSocketMulticast_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.EmitterTemplate = EmitterTemplate;
		params.Actor = Actor;
		params.Socket = Socket;
		params.bAutoDestroy = bAutoDestroy;
		params.ParameterEvaluationContext = ParameterEvaluationContext;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E4C630
	 * 		Name   -> Function GbxGameSystemCore.GbxGameState.PlayImpactMulticast
	 * 		Flags  -> (Net, Native, Event, NetMulticast, Public)
	 * Parameters:
	 * 		class UImpactData*                                 ImpactData                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      ImpactInstigator                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FReplicatedImpactHitResult                  HitResult                                                  (ConstParm, Parm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 * 		struct FImpactResponseParams                       ResponseParams                                             (ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void AGbxGameState::PlayImpactMulticast(class UImpactData* ImpactData, class AActor* ImpactInstigator, const struct FReplicatedImpactHitResult& HitResult, const struct FImpactResponseParams& ResponseParams)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxGameState.PlayImpactMulticast");
		
		AGbxGameState_PlayImpactMulticast_Params params {};
		params.ImpactData = ImpactData;
		params.ImpactInstigator = ImpactInstigator;
		params.HitResult = HitResult;
		params.ResponseParams = ResponseParams;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E4C4E0
	 * 		Name   -> Function GbxGameSystemCore.GbxGameState.PlayHitRegionImpactMulticast
	 * 		Flags  -> (Net, Native, Event, NetMulticast, Public)
	 * Parameters:
	 * 		class UHitRegionData*                              HitRegion                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      ImpactInstigator                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FReplicatedImpactHitResult                  HitResult                                                  (ConstParm, Parm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	void AGbxGameState::PlayHitRegionImpactMulticast(class UHitRegionData* HitRegion, class AActor* ImpactInstigator, const struct FReplicatedImpactHitResult& HitResult)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxGameState.PlayHitRegionImpactMulticast");
		
		AGbxGameState_PlayHitRegionImpactMulticast_Params params {};
		params.HitRegion = HitRegion;
		params.ImpactInstigator = ImpactInstigator;
		params.HitResult = HitResult;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E4C4C0
	 * 		Name   -> Function GbxGameSystemCore.GbxGameState.OnRep_StatsManager
	 * 		Flags  -> (Native, Public)
	 */
	void AGbxGameState::OnRep_StatsManager()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxGameState.OnRep_StatsManager");
		
		AGbxGameState_OnRep_StatsManager_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0291E400
	 * 		Name   -> Function GbxGameSystemCore.GbxGameState.OnRep_HostPlayerState
	 * 		Flags  -> (Native, Public)
	 */
	void AGbxGameState::OnRep_HostPlayerState()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxGameState.OnRep_HostPlayerState");
		
		AGbxGameState_OnRep_HostPlayerState_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E4C4A0
	 * 		Name   -> Function GbxGameSystemCore.GbxGameState.OnRep_GameInstanceTime
	 * 		Flags  -> (Final, Native, Private)
	 */
	void AGbxGameState::OnRep_GameInstanceTime()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxGameState.OnRep_GameInstanceTime");
		
		AGbxGameState_OnRep_GameInstanceTime_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E4C480
	 * 		Name   -> Function GbxGameSystemCore.GbxGameState.OnRep_GameInstanceId
	 * 		Flags  -> (Final, Native, Private)
	 */
	void AGbxGameState::OnRep_GameInstanceId()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxGameState.OnRep_GameInstanceId");
		
		AGbxGameState_OnRep_GameInstanceId_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x005D70B0
	 * 		Name   -> Function GbxGameSystemCore.GbxGameState.OnRep_bPlayersOnly
	 * 		Flags  -> (Final, Native, Private)
	 */
	void AGbxGameState::OnRep_bPlayersOnly()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxGameState.OnRep_bPlayersOnly");
		
		AGbxGameState_OnRep_bPlayersOnly_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AGbxGameState.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AGbxGameState::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.GbxGameState");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E3BC90
	 * 		Name   -> Function GbxGameSystemCore.GbxCharacterAnimInstance.SetDesiredFacialEmoteWeight
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		float                                              Weight                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              BlendTime                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGbxCharacterAnimInstance::SetDesiredFacialEmoteWeight(float Weight, float BlendTime)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxCharacterAnimInstance.SetDesiredFacialEmoteWeight");
		
		UGbxCharacterAnimInstance_SetDesiredFacialEmoteWeight_Params params {};
		params.Weight = Weight;
		params.BlendTime = BlendTime;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0178F8F0
	 * 		Name   -> Function GbxGameSystemCore.GbxCharacterAnimInstance.OnStanceChanged
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 */
	void UGbxCharacterAnimInstance::OnStanceChanged()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxCharacterAnimInstance.OnStanceChanged");
		
		UGbxCharacterAnimInstance_OnStanceChanged_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGbxCharacterAnimInstance.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGbxCharacterAnimInstance::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.GbxCharacterAnimInstance");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0178F8F0
	 * 		Name   -> Function GbxGameSystemCore.DamageData.OnKilledEnemy
	 * 		Flags  -> (Event, Protected, HasOutParms, BlueprintEvent, Const)
	 * Parameters:
	 * 		class AActor*                                      DamageInstigator                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      DamageCauser                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      DamageTarget                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FDamageDataEventDetails                     Details                                                    (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UDamageData::OnKilledEnemy(class AActor* DamageInstigator, class AActor* DamageCauser, class AActor* DamageTarget, const struct FDamageDataEventDetails& Details)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.DamageData.OnKilledEnemy");
		
		UDamageData_OnKilledEnemy_Params params {};
		params.DamageInstigator = DamageInstigator;
		params.DamageCauser = DamageCauser;
		params.DamageTarget = DamageTarget;
		params.Details = Details;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0178F8F0
	 * 		Name   -> Function GbxGameSystemCore.DamageData.OnHitFriendly
	 * 		Flags  -> (Event, Protected, HasOutParms, BlueprintEvent, Const)
	 * Parameters:
	 * 		class AActor*                                      DamageInstigator                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      DamageCauser                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      DamageTarget                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FDamageDataEventDetails                     Details                                                    (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UDamageData::OnHitFriendly(class AActor* DamageInstigator, class AActor* DamageCauser, class AActor* DamageTarget, const struct FDamageDataEventDetails& Details)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.DamageData.OnHitFriendly");
		
		UDamageData_OnHitFriendly_Params params {};
		params.DamageInstigator = DamageInstigator;
		params.DamageCauser = DamageCauser;
		params.DamageTarget = DamageTarget;
		params.Details = Details;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0178F8F0
	 * 		Name   -> Function GbxGameSystemCore.DamageData.OnHitEnemy
	 * 		Flags  -> (Event, Protected, HasOutParms, BlueprintEvent, Const)
	 * Parameters:
	 * 		class AActor*                                      DamageInstigator                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      DamageCauser                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      DamageTarget                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FDamageDataEventDetails                     Details                                                    (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UDamageData::OnHitEnemy(class AActor* DamageInstigator, class AActor* DamageCauser, class AActor* DamageTarget, const struct FDamageDataEventDetails& Details)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.DamageData.OnHitEnemy");
		
		UDamageData_OnHitEnemy_Params params {};
		params.DamageInstigator = DamageInstigator;
		params.DamageCauser = DamageCauser;
		params.DamageTarget = DamageTarget;
		params.Details = Details;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0178F8F0
	 * 		Name   -> Function GbxGameSystemCore.DamageData.OnHitAnyAttitude
	 * 		Flags  -> (Event, Protected, HasOutParms, BlueprintEvent, Const)
	 * Parameters:
	 * 		class AActor*                                      DamageInstigator                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      DamageCauser                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      DamageTarget                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FDamageDataEventDetails                     Details                                                    (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UDamageData::OnHitAnyAttitude(class AActor* DamageInstigator, class AActor* DamageCauser, class AActor* DamageTarget, const struct FDamageDataEventDetails& Details)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.DamageData.OnHitAnyAttitude");
		
		UDamageData_OnHitAnyAttitude_Params params {};
		params.DamageInstigator = DamageInstigator;
		params.DamageCauser = DamageCauser;
		params.DamageTarget = DamageTarget;
		params.Details = Details;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDamageData.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDamageData::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.DamageData");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E6CA30
	 * 		Name   -> Function GbxGameSystemCore.ProjectileHomingComponent.ToggleHoming
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void UProjectileHomingComponent::ToggleHoming()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.ProjectileHomingComponent.ToggleHoming");
		
		UProjectileHomingComponent_ToggleHoming_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E6C920
	 * 		Name   -> Function GbxGameSystemCore.ProjectileHomingComponent.SetHomeIn
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bEnabled                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UProjectileHomingComponent::SetHomeIn(bool bEnabled)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.ProjectileHomingComponent.SetHomeIn");
		
		UProjectileHomingComponent_SetHomeIn_Params params {};
		params.bEnabled = bEnabled;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E6C8A0
	 * 		Name   -> Function GbxGameSystemCore.ProjectileHomingComponent.SetAssociatedProjectileMovement
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UProjectileMovementComponent*                ProjectileMovementComponent                                (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UProjectileHomingComponent::SetAssociatedProjectileMovement(class UProjectileMovementComponent* ProjectileMovementComponent)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.ProjectileHomingComponent.SetAssociatedProjectileMovement");
		
		UProjectileHomingComponent_SetAssociatedProjectileMovement_Params params {};
		params.ProjectileMovementComponent = ProjectileMovementComponent;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E6C2B0
	 * 		Name   -> Function GbxGameSystemCore.ProjectileHomingComponent.GetHomingLocation
	 * 		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable)
	 */
	struct FVector UProjectileHomingComponent::GetHomingLocation()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.ProjectileHomingComponent.GetHomingLocation");
		
		UProjectileHomingComponent_GetHomingLocation_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UProjectileHomingComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UProjectileHomingComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.ProjectileHomingComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UHitReactionLayer.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UHitReactionLayer::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.HitReactionLayer");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0178F8F0
	 * 		Name   -> Function GbxGameSystemCore.AttributeContextResolver.GetContextForAttribute
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 * Parameters:
	 * 		class UGbxAttributeData*                           Attribute                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UObject*                                     ContextSource                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	TArray<class UObject*> UAttributeContextResolver::GetContextForAttribute(class UGbxAttributeData* Attribute, class UObject* ContextSource)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.AttributeContextResolver.GetContextForAttribute");
		
		UAttributeContextResolver_GetContextForAttribute_Params params {};
		params.Attribute = Attribute;
		params.ContextSource = ContextSource;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UAttributeContextResolver.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UAttributeContextResolver::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.AttributeContextResolver");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E6F610
	 * 		Name   -> Function GbxGameSystemCore.SpawnPatternData.CalculateSpawnPoint
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		struct FSpawnPatternInputs                         Inputs                                                     (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 * 		struct FSpawnPatternResult                         Result                                                     (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void USpawnPatternData::CalculateSpawnPoint(const struct FSpawnPatternInputs& Inputs, struct FSpawnPatternResult* Result)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.SpawnPatternData.CalculateSpawnPoint");
		
		USpawnPatternData_CalculateSpawnPoint_Params params {};
		params.Inputs = Inputs;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (Result != nullptr)
			*Result = params.Result;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction USpawnPatternData.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* USpawnPatternData::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.SpawnPatternData");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UPhysicsSpawnPatternData.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UPhysicsSpawnPatternData::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.PhysicsSpawnPatternData");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AGbxPlayerCameraManager.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AGbxPlayerCameraManager::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.GbxPlayerCameraManager");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UStatusEffectData.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UStatusEffectData::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.StatusEffectData");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UCharacterAttributeContextResolver.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UCharacterAttributeContextResolver::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.CharacterAttributeContextResolver");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UAttributePropertyValueResolver.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UAttributePropertyValueResolver::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.AttributePropertyValueResolver");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E7ED50
	 * 		Name   -> Function GbxGameSystemCore.UIStatData.K2_ShouldDisplayStat
	 * 		Flags  -> (Native, Event, Protected, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
	 * Parameters:
	 * 		class UObject*                                     Context                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UUIStatData::K2_ShouldDisplayStat(class UObject* Context)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.UIStatData.K2_ShouldDisplayStat");
		
		UUIStatData_K2_ShouldDisplayStat_Params params {};
		params.Context = Context;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E7EB10
	 * 		Name   -> Function GbxGameSystemCore.UIStatData.K2_GetValueText
	 * 		Flags  -> (Native, Event, Protected, HasOutParms, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
	 * Parameters:
	 * 		class UObject*                                     Context                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FUIStatCollector                            Collector                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	class FText UUIStatData::K2_GetValueText(class UObject* Context, const struct FUIStatCollector& Collector)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.UIStatData.K2_GetValueText");
		
		UUIStatData_K2_GetValueText_Params params {};
		params.Context = Context;
		params.Collector = Collector;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E7E8A0
	 * 		Name   -> Function GbxGameSystemCore.UIStatData.K2_GetComparisonValue
	 * 		Flags  -> (Native, Event, Protected, HasOutParms, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
	 * Parameters:
	 * 		class UObject*                                     Context                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FUIStatCollector                            Collector                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	float UUIStatData::K2_GetComparisonValue(class UObject* Context, const struct FUIStatCollector& Collector)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.UIStatData.K2_GetComparisonValue");
		
		UUIStatData_K2_GetComparisonValue_Params params {};
		params.Context = Context;
		params.Collector = Collector;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E7E300
	 * 		Name   -> Function GbxGameSystemCore.UIStatData.EnumerateSectionNames
	 * 		Flags  -> (Final, Native, Private, HasOutParms, Const)
	 * Parameters:
	 * 		TArray<class FName>                                OutSectionNameList                                         (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	 */
	void UUIStatData::EnumerateSectionNames(TArray<class FName>* OutSectionNameList)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.UIStatData.EnumerateSectionNames");
		
		UUIStatData_EnumerateSectionNames_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutSectionNameList != nullptr)
			*OutSectionNameList = params.OutSectionNameList;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E7E0C0
	 * 		Name   -> Function GbxGameSystemCore.UIStatData.ComputeAttributeModification
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		class UGbxAttributeData*                           Attribute                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bScale                                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FUIStatCollector                            Collector                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	float UUIStatData::ComputeAttributeModification(class UGbxAttributeData* Attribute, bool bScale, const struct FUIStatCollector& Collector)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.UIStatData.ComputeAttributeModification");
		
		UUIStatData_ComputeAttributeModification_Params params {};
		params.Attribute = Attribute;
		params.bScale = bScale;
		params.Collector = Collector;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UUIStatData.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UUIStatData::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.UIStatData");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UUIStatData_Numeric.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UUIStatData_Numeric::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.UIStatData_Numeric");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UAchievementUtility.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UAchievementUtility::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.AchievementUtility");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E1EE40
	 * 		Name   -> Function GbxGameSystemCore.GbxAction_CoordinatedEffect.SetConstantMaterialVectorParamValue
	 * 		Flags  -> (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		class FName                                        ParamName                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FLinearColor                                Color                                                      (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGbxAction_CoordinatedEffect::SetConstantMaterialVectorParamValue(const class FName& ParamName, const struct FLinearColor& Color)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxAction_CoordinatedEffect.SetConstantMaterialVectorParamValue");
		
		UGbxAction_CoordinatedEffect_SetConstantMaterialVectorParamValue_Params params {};
		params.ParamName = ParamName;
		params.Color = Color;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGbxAction_CoordinatedEffect.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGbxAction_CoordinatedEffect::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.GbxAction_CoordinatedEffect");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGbxAction_Gib.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGbxAction_Gib::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.GbxAction_Gib");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E1ED20
	 * 		Name   -> Function GbxGameSystemCore.GbxAction_Loop.OnStop
	 * 		Flags  -> (Native, Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		class AActor*                                      Actor                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGbxAction_Loop::OnStop(class AActor* Actor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxAction_Loop.OnStop");
		
		UGbxAction_Loop_OnStop_Params params {};
		params.Actor = Actor;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E1EC90
	 * 		Name   -> Function GbxGameSystemCore.GbxAction_Loop.OnLoop
	 * 		Flags  -> (Native, Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		class AActor*                                      Actor                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGbxAction_Loop::OnLoop(class AActor* Actor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxAction_Loop.OnLoop");
		
		UGbxAction_Loop_OnLoop_Params params {};
		params.Actor = Actor;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E22CF0
	 * 		Name   -> Function GbxGameSystemCore.GbxAction_Loop.K2_StopLooping
	 * 		Flags  -> (Final, Native, Private, BlueprintCallable, Const)
	 */
	void UGbxAction_Loop::K2_StopLooping()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxAction_Loop.K2_StopLooping");
		
		UGbxAction_Loop_K2_StopLooping_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGbxAction_Loop.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGbxAction_Loop::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.GbxAction_Loop");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E22630
	 * 		Name   -> Function GbxGameSystemCore.GbxAction_PhysicalAnim.K2_GetDynamicBodyState
	 * 		Flags  -> (Final, Native, Private, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		float                                              AngularThreshold                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	EGbxPhysicalActionDynamicBodyState UGbxAction_PhysicalAnim::K2_GetDynamicBodyState(float AngularThreshold)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxAction_PhysicalAnim.K2_GetDynamicBodyState");
		
		UGbxAction_PhysicalAnim_K2_GetDynamicBodyState_Params params {};
		params.AngularThreshold = AngularThreshold;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E225B0
	 * 		Name   -> Function GbxGameSystemCore.GbxAction_PhysicalAnim.K2_FixupDynamicToKinematicIssues
	 * 		Flags  -> (Final, Native, Private, BlueprintCallable, Const)
	 * Parameters:
	 * 		float                                              AngularThreshold                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGbxAction_PhysicalAnim::K2_FixupDynamicToKinematicIssues(float AngularThreshold)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxAction_PhysicalAnim.K2_FixupDynamicToKinematicIssues");
		
		UGbxAction_PhysicalAnim_K2_FixupDynamicToKinematicIssues_Params params {};
		params.AngularThreshold = AngularThreshold;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGbxAction_PhysicalAnim.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGbxAction_PhysicalAnim::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.GbxAction_PhysicalAnim");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGbxAction_PhysicalDeath.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGbxAction_PhysicalDeath::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.GbxAction_PhysicalDeath");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UAimAssistParameters.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UAimAssistParameters::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.AimAssistParameters");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E55A90
	 * 		Name   -> Function GbxGameSystemCore.GbxPlayerController.SetTeam
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, Const)
	 * Parameters:
	 * 		class UTeam*                                       Team                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AGbxPlayerController::SetTeam(class UTeam* Team)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxPlayerController.SetTeam");
		
		AGbxPlayerController_SetTeam_Params params {};
		params.Team = Team;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E55900
	 * 		Name   -> Function GbxGameSystemCore.GbxPlayerController.ServerRequestPawnSlotDetach
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
	 * Parameters:
	 * 		class APawn*                                       Occupant                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AGbxPlayerController::ServerRequestPawnSlotDetach(class APawn* Occupant)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxPlayerController.ServerRequestPawnSlotDetach");
		
		AGbxPlayerController_ServerRequestPawnSlotDetach_Params params {};
		params.Occupant = Occupant;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E55840
	 * 		Name   -> Function GbxGameSystemCore.GbxPlayerController.ServerCanSplitscreenJoin
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
	 * Parameters:
	 * 		int32_t                                            ControllerId                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AGbxPlayerController::ServerCanSplitscreenJoin(int32_t ControllerId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxPlayerController.ServerCanSplitscreenJoin");
		
		AGbxPlayerController_ServerCanSplitscreenJoin_Params params {};
		params.ControllerId = ControllerId;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E557C0
	 * 		Name   -> Function GbxGameSystemCore.GbxPlayerController.PushCinematicMode
	 * 		Flags  -> (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UCinematicModeData*                          InCinematicMode                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AGbxPlayerController::PushCinematicMode(class UCinematicModeData* InCinematicMode)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxPlayerController.PushCinematicMode");
		
		AGbxPlayerController_PushCinematicMode_Params params {};
		params.InCinematicMode = InCinematicMode;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E55740
	 * 		Name   -> Function GbxGameSystemCore.GbxPlayerController.PopCinematicMode
	 * 		Flags  -> (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UCinematicModeData*                          InCinematicMode                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AGbxPlayerController::PopCinematicMode(class UCinematicModeData* InCinematicMode)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxPlayerController.PopCinematicMode");
		
		AGbxPlayerController_PopCinematicMode_Params params {};
		params.InCinematicMode = InCinematicMode;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E55720
	 * 		Name   -> Function GbxGameSystemCore.GbxPlayerController.OnRep_PrimaryCharacter
	 * 		Flags  -> (Final, Native, Protected)
	 */
	void AGbxPlayerController::OnRep_PrimaryCharacter()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxPlayerController.OnRep_PrimaryCharacter");
		
		AGbxPlayerController_OnRep_PrimaryCharacter_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E55700
	 * 		Name   -> Function GbxGameSystemCore.GbxPlayerController.OnRep_CinematicMode
	 * 		Flags  -> (Final, Native, Protected)
	 */
	void AGbxPlayerController::OnRep_CinematicMode()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxPlayerController.OnRep_CinematicMode");
		
		AGbxPlayerController_OnRep_CinematicMode_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0178F8F0
	 * 		Name   -> DelegateFunction GbxGameSystemCore.GbxPlayerController.OnPrimaryCharacterChanged__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 * Parameters:
	 * 		class AGbxCharacter*                               NewCharacter                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AGbxPlayerController::OnPrimaryCharacterChanged__DelegateSignature(class AGbxCharacter* NewCharacter)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction GbxGameSystemCore.GbxPlayerController.OnPrimaryCharacterChanged__DelegateSignature");
		
		AGbxPlayerController_OnPrimaryCharacterChanged__DelegateSignature_Params params {};
		params.NewCharacter = NewCharacter;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0178F8F0
	 * 		Name   -> DelegateFunction GbxGameSystemCore.GbxPlayerController.OnPausedChangedDelegate__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 * Parameters:
	 * 		bool                                               bPaused                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AGbxPlayerController::OnPausedChangedDelegate__DelegateSignature(bool bPaused)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction GbxGameSystemCore.GbxPlayerController.OnPausedChangedDelegate__DelegateSignature");
		
		AGbxPlayerController_OnPausedChangedDelegate__DelegateSignature_Params params {};
		params.bPaused = bPaused;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E55480
	 * 		Name   -> Function GbxGameSystemCore.GbxPlayerController.IsUsingGamepad
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AGbxPlayerController::IsUsingGamepad()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxPlayerController.IsUsingGamepad");
		
		AGbxPlayerController_IsUsingGamepad_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E55460
	 * 		Name   -> Function GbxGameSystemCore.GbxPlayerController.GetTeamComponent
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	class UTeamComponent* AGbxPlayerController::GetTeamComponent()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxPlayerController.GetTeamComponent");
		
		AGbxPlayerController_GetTeamComponent_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E55420
	 * 		Name   -> Function GbxGameSystemCore.GbxPlayerController.GetTeam
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	class UTeam* AGbxPlayerController::GetTeam()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxPlayerController.GetTeam");
		
		AGbxPlayerController_GetTeam_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E55400
	 * 		Name   -> Function GbxGameSystemCore.GbxPlayerController.GetTargetingComponent
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	class UTargetingComponent* AGbxPlayerController::GetTargetingComponent()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxPlayerController.GetTargetingComponent");
		
		AGbxPlayerController_GetTargetingComponent_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E553E0
	 * 		Name   -> Function GbxGameSystemCore.GbxPlayerController.GetTargetableComponent
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	class UTargetableComponent* AGbxPlayerController::GetTargetableComponent()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxPlayerController.GetTargetableComponent");
		
		AGbxPlayerController_GetTargetableComponent_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E553C0
	 * 		Name   -> Function GbxGameSystemCore.GbxPlayerController.GetPrimaryCharacter
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	class AGbxCharacter* AGbxPlayerController::GetPrimaryCharacter()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxPlayerController.GetPrimaryCharacter");
		
		AGbxPlayerController_GetPrimaryCharacter_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E552E0
	 * 		Name   -> Function GbxGameSystemCore.GbxPlayerController.GetPlayerViewportSize
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		int32_t                                            SizeX                                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            SizeY                                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AGbxPlayerController::GetPlayerViewportSize(int32_t* SizeX, int32_t* SizeY)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxPlayerController.GetPlayerViewportSize");
		
		AGbxPlayerController_GetPlayerViewportSize_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (SizeX != nullptr)
			*SizeX = params.SizeX;
		if (SizeY != nullptr)
			*SizeY = params.SizeY;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E55200
	 * 		Name   -> Function GbxGameSystemCore.GbxPlayerController.GetPlayerViewportOffset
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		int32_t                                            OffsetX                                                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            OffsetY                                                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AGbxPlayerController::GetPlayerViewportOffset(int32_t* OffsetX, int32_t* OffsetY)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxPlayerController.GetPlayerViewportOffset");
		
		AGbxPlayerController_GetPlayerViewportOffset_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OffsetX != nullptr)
			*OffsetX = params.OffsetX;
		if (OffsetY != nullptr)
			*OffsetY = params.OffsetY;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E551D0
	 * 		Name   -> Function GbxGameSystemCore.GbxPlayerController.GetPlayerProfile
	 * 		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	class UGbxProfile* AGbxPlayerController::GetPlayerProfile()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxPlayerController.GetPlayerProfile");
		
		AGbxPlayerController_GetPlayerProfile_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E54CB0
	 * 		Name   -> Function GbxGameSystemCore.GbxPlayerController.GetGbxPerceptionComponent
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	class UGbxPerceptionComponent* AGbxPlayerController::GetGbxPerceptionComponent()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxPlayerController.GetGbxPerceptionComponent");
		
		AGbxPlayerController_GetGbxPerceptionComponent_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E546E0
	 * 		Name   -> Function GbxGameSystemCore.GbxPlayerController.DeprojectViewportPositionToWorld
	 * 		Flags  -> (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		float                                              ViewportX                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              ViewportY                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     WorldLocation                                              (Parm, OutParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     WorldDirection                                             (Parm, OutParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bUseForegroundProjection                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool AGbxPlayerController::DeprojectViewportPositionToWorld(float ViewportX, float ViewportY, struct FVector* WorldLocation, struct FVector* WorldDirection, bool bUseForegroundProjection)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxPlayerController.DeprojectViewportPositionToWorld");
		
		AGbxPlayerController_DeprojectViewportPositionToWorld_Params params {};
		params.ViewportX = ViewportX;
		params.ViewportY = ViewportY;
		params.bUseForegroundProjection = bUseForegroundProjection;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (WorldLocation != nullptr)
			*WorldLocation = params.WorldLocation;
		if (WorldDirection != nullptr)
			*WorldDirection = params.WorldDirection;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00672610
	 * 		Name   -> Function GbxGameSystemCore.GbxPlayerController.DebugCategory
	 * 		Flags  -> (Final, Exec, Native, Public)
	 * Parameters:
	 * 		class FName                                        CategoryName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AGbxPlayerController::DebugCategory(const class FName& CategoryName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxPlayerController.DebugCategory");
		
		AGbxPlayerController_DebugCategory_Params params {};
		params.CategoryName = CategoryName;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E54310
	 * 		Name   -> Function GbxGameSystemCore.GbxPlayerController.ClientStopFeedback
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetClient)
	 * Parameters:
	 * 		class UFeedbackData*                               Data                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AGbxPlayerController::ClientStopFeedback(class UFeedbackData* Data)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxPlayerController.ClientStopFeedback");
		
		AGbxPlayerController_ClientStopFeedback_Params params {};
		params.Data = Data;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E54280
	 * 		Name   -> Function GbxGameSystemCore.GbxPlayerController.ClientPlayWwiseEvent
	 * 		Flags  -> (Net, Native, Event, Public, NetClient)
	 * Parameters:
	 * 		class UWwiseEvent*                                 Event                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AGbxPlayerController::ClientPlayWwiseEvent(class UWwiseEvent* Event)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxPlayerController.ClientPlayWwiseEvent");
		
		AGbxPlayerController_ClientPlayWwiseEvent_Params params {};
		params.Event = Event;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E54130
	 * 		Name   -> Function GbxGameSystemCore.GbxPlayerController.ClientPlayFeedback
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetClient)
	 * Parameters:
	 * 		class UFeedbackData*                               Data                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Scale                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bLoop                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UObject*                                     SourceContext                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AGbxPlayerController::ClientPlayFeedback(class UFeedbackData* Data, float Scale, bool bLoop, class UObject* SourceContext)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxPlayerController.ClientPlayFeedback");
		
		AGbxPlayerController_ClientPlayFeedback_Params params {};
		params.Data = Data;
		params.Scale = Scale;
		params.bLoop = bLoop;
		params.SourceContext = SourceContext;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E53F90
	 * 		Name   -> Function GbxGameSystemCore.GbxPlayerController.ClientPerformFeedbackAtLocation
	 * 		Flags  -> (Net, Native, Event, Public, HasDefaults, NetClient)
	 * Parameters:
	 * 		class UFeedbackData*                               FeedbackData                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     SourceLocation                                             (Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bLoop                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UObject*                                     SourceContext                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FRangedDistanceOverrides                    RangedOverrides                                            (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void AGbxPlayerController::ClientPerformFeedbackAtLocation(class UFeedbackData* FeedbackData, const struct FVector& SourceLocation, bool bLoop, class UObject* SourceContext, const struct FRangedDistanceOverrides& RangedOverrides)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxPlayerController.ClientPerformFeedbackAtLocation");
		
		AGbxPlayerController_ClientPerformFeedbackAtLocation_Params params {};
		params.FeedbackData = FeedbackData;
		params.SourceLocation = SourceLocation;
		params.bLoop = bLoop;
		params.SourceContext = SourceContext;
		params.RangedOverrides = RangedOverrides;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E53EC0
	 * 		Name   -> Function GbxGameSystemCore.GbxPlayerController.ClientPerformFeedback
	 * 		Flags  -> (Net, Native, Event, Public, NetClient)
	 * Parameters:
	 * 		class UFeedbackData*                               FeedbackData                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UObject*                                     SourceContext                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AGbxPlayerController::ClientPerformFeedback(class UFeedbackData* FeedbackData, class UObject* SourceContext)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxPlayerController.ClientPerformFeedback");
		
		AGbxPlayerController_ClientPerformFeedback_Params params {};
		params.FeedbackData = FeedbackData;
		params.SourceContext = SourceContext;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x029234E0
	 * 		Name   -> Function GbxGameSystemCore.GbxPlayerController.ClientNotifyActivateCheckpoint
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetClient, BlueprintCallable)
	 */
	void AGbxPlayerController::ClientNotifyActivateCheckpoint()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxPlayerController.ClientNotifyActivateCheckpoint");
		
		AGbxPlayerController_ClientNotifyActivateCheckpoint_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E53DC0
	 * 		Name   -> Function GbxGameSystemCore.GbxPlayerController.ClientCanSplitscreenJoin
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetClient, NetValidate)
	 * Parameters:
	 * 		int32_t                                            ControllerId                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bCanJoin                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AGbxPlayerController::ClientCanSplitscreenJoin(int32_t ControllerId, bool bCanJoin)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxPlayerController.ClientCanSplitscreenJoin");
		
		AGbxPlayerController_ClientCanSplitscreenJoin_Params params {};
		params.ControllerId = ControllerId;
		params.bCanJoin = bCanJoin;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E53CF0
	 * 		Name   -> Function GbxGameSystemCore.GbxPlayerController.ClientApplyDamageDataPresentation
	 * 		Flags  -> (Net, Native, Event, Public, NetClient)
	 * Parameters:
	 * 		class UDamageData*                                 DamageData                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FPlayerDamageDataPresentation               PlayerPresentation                                         (ConstParm, Parm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void AGbxPlayerController::ClientApplyDamageDataPresentation(class UDamageData* DamageData, const struct FPlayerDamageDataPresentation& PlayerPresentation)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxPlayerController.ClientApplyDamageDataPresentation");
		
		AGbxPlayerController_ClientApplyDamageDataPresentation_Params params {};
		params.DamageData = DamageData;
		params.PlayerPresentation = PlayerPresentation;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E54610
	 * 		Name   -> Function GbxGameSystemCore.GbxPlayerController.Client_StopGbxFeedback
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetClient)
	 * Parameters:
	 * 		class UGbxFeedbackData*                            Data                                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UObject*                                     SourceContext                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AGbxPlayerController::Client_StopGbxFeedback(class UGbxFeedbackData* Data, class UObject* SourceContext)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxPlayerController.Client_StopGbxFeedback");
		
		AGbxPlayerController_Client_StopGbxFeedback_Params params {};
		params.Data = Data;
		params.SourceContext = SourceContext;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E543A0
	 * 		Name   -> Function GbxGameSystemCore.GbxPlayerController.Client_PlayGbxFeedback
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, HasDefaults, NetClient)
	 * Parameters:
	 * 		class UGbxFeedbackData*                            Data                                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bIs3D                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bLoop                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Scale                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UObject*                                     SourceContext                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     SourceLocation                                             (Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              EffectFalloffMinDistance                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              EffectFalloffMaxDistance                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AGbxPlayerController::Client_PlayGbxFeedback(class UGbxFeedbackData* Data, bool bIs3D, bool bLoop, float Scale, class UObject* SourceContext, const struct FVector& SourceLocation, float EffectFalloffMinDistance, float EffectFalloffMaxDistance)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxPlayerController.Client_PlayGbxFeedback");
		
		AGbxPlayerController_Client_PlayGbxFeedback_Params params {};
		params.Data = Data;
		params.bIs3D = bIs3D;
		params.bLoop = bLoop;
		params.Scale = Scale;
		params.SourceContext = SourceContext;
		params.SourceLocation = SourceLocation;
		params.EffectFalloffMinDistance = EffectFalloffMinDistance;
		params.EffectFalloffMaxDistance = EffectFalloffMaxDistance;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E53CD0
	 * 		Name   -> Function GbxGameSystemCore.GbxPlayerController.ClearCinematicMode
	 * 		Flags  -> (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
	 */
	void AGbxPlayerController::ClearCinematicMode()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxPlayerController.ClearCinematicMode");
		
		AGbxPlayerController_ClearCinematicMode_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E53C50
	 * 		Name   -> Function GbxGameSystemCore.GbxPlayerController.ClearAndSetCinematicMode
	 * 		Flags  -> (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UCinematicModeData*                          InCinematicMode                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AGbxPlayerController::ClearAndSetCinematicMode(class UCinematicModeData* InCinematicMode)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxPlayerController.ClearAndSetCinematicMode");
		
		AGbxPlayerController_ClearAndSetCinematicMode_Params params {};
		params.InCinematicMode = InCinematicMode;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AGbxPlayerController.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AGbxPlayerController::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.GbxPlayerController");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UAimAssistStrategy.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UAimAssistStrategy::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.AimAssistStrategy");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGbxAssetManager.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGbxAssetManager::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.GbxAssetManager");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UAssetMappingData.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UAssetMappingData::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.AssetMappingData");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02DFCC20
	 * 		Name   -> Function GbxGameSystemCore.Challenge.TestForCompleted
	 * 		Flags  -> (Final, BlueprintAuthorityOnly, Native, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		class AGbxPlayerController*                        PlayerToTest                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UObject*                                     OtherObject                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		TArray<class FString>                              EnumTag                                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	bool UChallenge::TestForCompleted(class AGbxPlayerController* PlayerToTest, class UObject* OtherObject, TArray<class FString> EnumTag)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.Challenge.TestForCompleted");
		
		UChallenge_TestForCompleted_Params params {};
		params.PlayerToTest = PlayerToTest;
		params.OtherObject = OtherObject;
		params.EnumTag = EnumTag;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02DFCA90
	 * 		Name   -> Function GbxGameSystemCore.Challenge.SetChallengeProgress
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, Const)
	 * Parameters:
	 * 		int32_t                                            NewProgress                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UChallenge::SetChallengeProgress(int32_t NewProgress)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.Challenge.SetChallengeProgress");
		
		UChallenge_SetChallengeProgress_Params params {};
		params.NewProgress = NewProgress;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0178F8F0
	 * 		Name   -> Function GbxGameSystemCore.Challenge.PlayerExitChallengeArea
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		class UChallengeLevelActorComponent*               LevelActorComponent                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UChallenge::PlayerExitChallengeArea(class UChallengeLevelActorComponent* LevelActorComponent)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.Challenge.PlayerExitChallengeArea");
		
		UChallenge_PlayerExitChallengeArea_Params params {};
		params.LevelActorComponent = LevelActorComponent;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0178F8F0
	 * 		Name   -> Function GbxGameSystemCore.Challenge.PlayerEnterChallengeArea
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		class UChallengeLevelActorComponent*               LevelActorComponent                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UChallenge::PlayerEnterChallengeArea(class UChallengeLevelActorComponent* LevelActorComponent)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.Challenge.PlayerEnterChallengeArea");
		
		UChallenge_PlayerEnterChallengeArea_Params params {};
		params.LevelActorComponent = LevelActorComponent;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0178F8F0
	 * 		Name   -> Function GbxGameSystemCore.Challenge.OnLevelActorRegistered
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		class UChallengeLevelActorComponent*               RegisteredLevelActor                                       (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UChallenge::OnLevelActorRegistered(class UChallengeLevelActorComponent* RegisteredLevelActor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.Challenge.OnLevelActorRegistered");
		
		UChallenge_OnLevelActorRegistered_Params params {};
		params.RegisteredLevelActor = RegisteredLevelActor;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0178F8F0
	 * 		Name   -> Function GbxGameSystemCore.Challenge.OnInitChallengeInstance
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		class UChallengesComponent*                        OwningChallenges                                           (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AGbxCharacter*                               AssociatedCharacter                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UChallenge::OnInitChallengeInstance(class UChallengesComponent* OwningChallenges, class AGbxCharacter* AssociatedCharacter)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.Challenge.OnInitChallengeInstance");
		
		UChallenge_OnInitChallengeInstance_Params params {};
		params.OwningChallenges = OwningChallenges;
		params.AssociatedCharacter = AssociatedCharacter;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0178F8F0
	 * 		Name   -> Function GbxGameSystemCore.Challenge.OnChallengeActivated
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 */
	void UChallenge::OnChallengeActivated()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.Challenge.OnChallengeActivated");
		
		UChallenge_OnChallengeActivated_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02DFADB0
	 * 		Name   -> Function GbxGameSystemCore.Challenge.IsChallengeComplete
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool UChallenge::IsChallengeComplete()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.Challenge.IsChallengeComplete");
		
		UChallenge_IsChallengeComplete_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02DFAD80
	 * 		Name   -> Function GbxGameSystemCore.Challenge.IsChallengeActive
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool UChallenge::IsChallengeActive()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.Challenge.IsChallengeActive");
		
		UChallenge_IsChallengeActive_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02DFAD00
	 * 		Name   -> Function GbxGameSystemCore.Challenge.IncrementChallengeProgressByValue
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		int32_t                                            Value                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UChallenge::IncrementChallengeProgressByValue(int32_t Value)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.Challenge.IncrementChallengeProgressByValue");
		
		UChallenge_IncrementChallengeProgressByValue_Params params {};
		params.Value = Value;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02DFACE0
	 * 		Name   -> Function GbxGameSystemCore.Challenge.IncrementChallengeProgress
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, Const)
	 */
	void UChallenge::IncrementChallengeProgress()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.Challenge.IncrementChallengeProgress");
		
		UChallenge_IncrementChallengeProgress_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02DFAC30
	 * 		Name   -> Function GbxGameSystemCore.Challenge.GetLevelActorComponents
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		TArray<class UChallengeLevelActorComponent*>       LevelActorList                                             (Parm, OutParm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	void UChallenge::GetLevelActorComponents(TArray<class UChallengeLevelActorComponent*>* LevelActorList)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.Challenge.GetLevelActorComponents");
		
		UChallenge_GetLevelActorComponents_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (LevelActorList != nullptr)
			*LevelActorList = params.LevelActorList;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02DFABA0
	 * 		Name   -> Function GbxGameSystemCore.Challenge.GetChallengeProgressGoalValue
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	int32_t UChallenge::GetChallengeProgressGoalValue()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.Challenge.GetChallengeProgressGoalValue");
		
		UChallenge_GetChallengeProgressGoalValue_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02DFAB70
	 * 		Name   -> Function GbxGameSystemCore.Challenge.GetChallengeProgress
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	int32_t UChallenge::GetChallengeProgress()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.Challenge.GetChallengeProgress");
		
		UChallenge_GetChallengeProgress_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02DFAA90
	 * 		Name   -> Function GbxGameSystemCore.Challenge.GetChallengeCompleteInfo
	 * 		Flags  -> (Native, Public, HasOutParms, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		int32_t                                            NumCompleted                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            NumChallenges                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UChallenge::GetChallengeCompleteInfo(int32_t* NumCompleted, int32_t* NumChallenges)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.Challenge.GetChallengeCompleteInfo");
		
		UChallenge_GetChallengeCompleteInfo_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (NumCompleted != nullptr)
			*NumCompleted = params.NumCompleted;
		if (NumChallenges != nullptr)
			*NumChallenges = params.NumChallenges;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x008AFD90
	 * 		Name   -> Function GbxGameSystemCore.Challenge.CompletedConditional
	 * 		Flags  -> (BlueprintAuthorityOnly, Native, Event, Public, BlueprintEvent)
	 */
	bool UChallenge::CompletedConditional()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.Challenge.CompletedConditional");
		
		UChallenge_CompletedConditional_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0178F8F0
	 * 		Name   -> Function GbxGameSystemCore.Challenge.CompletedChallenge
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		class AGbxPlayerController*                        CompletedPlayer                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UChallenge::CompletedChallenge(class AGbxPlayerController* CompletedPlayer)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.Challenge.CompletedChallenge");
		
		UChallenge_CompletedChallenge_Params params {};
		params.CompletedPlayer = CompletedPlayer;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x022037B0
	 * 		Name   -> Function GbxGameSystemCore.Challenge.CompleteChallenge
	 * 		Flags  -> (Native, Public, BlueprintCallable, Const)
	 */
	void UChallenge::CompleteChallenge()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.Challenge.CompleteChallenge");
		
		UChallenge_CompleteChallenge_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02DFA330
	 * 		Name   -> Function GbxGameSystemCore.Challenge.ActivateChallenge
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void UChallenge::ActivateChallenge()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.Challenge.ActivateChallenge");
		
		UChallenge_ActivateChallenge_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UChallenge.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UChallenge::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.Challenge");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UChallengeCategoryData.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UChallengeCategoryData::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.ChallengeCategoryData");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UChallengeList.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UChallengeList::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.ChallengeList");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E00B80
	 * 		Name   -> Function GbxGameSystemCore.ChallengeManager.OnStatIncrement
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		class AActor*                                      StatContext                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UGameStatData*                               StatId                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            Amount                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AChallengeManager::OnStatIncrement(class AActor* StatContext, class UGameStatData* StatId, int32_t Amount)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.ChallengeManager.OnStatIncrement");
		
		AChallengeManager_OnStatIncrement_Params params {};
		params.StatContext = StatContext;
		params.StatId = StatId;
		params.Amount = Amount;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AChallengeManager.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AChallengeManager::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.ChallengeManager");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UCustomChallengePersistentState.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UCustomChallengePersistentState::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.CustomChallengePersistentState");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E01190
	 * 		Name   -> Function GbxGameSystemCore.ChallengesComponent.UnregisterInActivePlayerChallenges
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void UChallengesComponent::UnregisterInActivePlayerChallenges()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.ChallengesComponent.UnregisterInActivePlayerChallenges");
		
		UChallengesComponent_UnregisterInActivePlayerChallenges_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E00FB0
	 * 		Name   -> Function GbxGameSystemCore.ChallengesComponent.SetChallengeProgress
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UClass*                                      ChalClass                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            NewProgress                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UChallengesComponent::SetChallengeProgress(class UClass* ChalClass, int32_t NewProgress)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.ChallengesComponent.SetChallengeProgress");
		
		UChallengesComponent_SetChallengeProgress_Params params {};
		params.ChalClass = ChalClass;
		params.NewProgress = NewProgress;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E00EE0
	 * 		Name   -> Function GbxGameSystemCore.ChallengesComponent.SetChallengeActive
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UClass*                                      ChalClass                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bInIsActive                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UChallengesComponent::SetChallengeActive(class UClass* ChalClass, bool bInIsActive)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.ChallengesComponent.SetChallengeActive");
		
		UChallengesComponent_SetChallengeActive_Params params {};
		params.ChalClass = ChalClass;
		params.bInIsActive = bInIsActive;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E009B0
	 * 		Name   -> Function GbxGameSystemCore.ChallengesComponent.IsChallengeComplete
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UClass*                                      ChalClass                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UChallengesComponent::IsChallengeComplete(class UClass* ChalClass)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.ChallengesComponent.IsChallengeComplete");
		
		UChallengesComponent_IsChallengeComplete_Params params {};
		params.ChalClass = ChalClass;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E00920
	 * 		Name   -> Function GbxGameSystemCore.ChallengesComponent.IsChallengeActive
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UClass*                                      ChalClass                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UChallengesComponent::IsChallengeActive(class UClass* ChalClass)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.ChallengesComponent.IsChallengeActive");
		
		UChallengesComponent_IsChallengeActive_Params params {};
		params.ChalClass = ChalClass;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E008A0
	 * 		Name   -> Function GbxGameSystemCore.ChallengesComponent.IncrementChallengeProgress
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UClass*                                      ChalClass                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UChallengesComponent::IncrementChallengeProgress(class UClass* ChalClass)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.ChallengesComponent.IncrementChallengeProgress");
		
		UChallengesComponent_IncrementChallengeProgress_Params params {};
		params.ChalClass = ChalClass;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E007F0
	 * 		Name   -> Function GbxGameSystemCore.ChallengesComponent.GetMaxChallengeTiers
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UClass*                                      ChalClass                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	int32_t UChallengesComponent::GetMaxChallengeTiers(class UClass* ChalClass)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.ChallengesComponent.GetMaxChallengeTiers");
		
		UChallengesComponent_GetMaxChallengeTiers_Params params {};
		params.ChalClass = ChalClass;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E00710
	 * 		Name   -> Function GbxGameSystemCore.ChallengesComponent.GetLocalChallenges
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	TArray<struct FChallengeInstanceData> UChallengesComponent::GetLocalChallenges()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.ChallengesComponent.GetLocalChallenges");
		
		UChallengesComponent_GetLocalChallenges_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E00680
	 * 		Name   -> Function GbxGameSystemCore.ChallengesComponent.GetCompletedChallengeTiers
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UClass*                                      ChalClass                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	int32_t UChallengesComponent::GetCompletedChallengeTiers(class UClass* ChalClass)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.ChallengesComponent.GetCompletedChallengeTiers");
		
		UChallengesComponent_GetCompletedChallengeTiers_Params params {};
		params.ChalClass = ChalClass;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E005C0
	 * 		Name   -> Function GbxGameSystemCore.ChallengesComponent.GetChallengeStatValue
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UClass*                                      ChalClass                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UGameStatData*                               StatId                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	int32_t UChallengesComponent::GetChallengeStatValue(class UClass* ChalClass, class UGameStatData* StatId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.ChallengesComponent.GetChallengeStatValue");
		
		UChallengesComponent_GetChallengeStatValue_Params params {};
		params.ChalClass = ChalClass;
		params.StatId = StatId;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E00500
	 * 		Name   -> Function GbxGameSystemCore.ChallengesComponent.GetChallengeStatGoalValue
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UClass*                                      ChalClass                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UGameStatData*                               StatId                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	int32_t UChallengesComponent::GetChallengeStatGoalValue(class UClass* ChalClass, class UGameStatData* StatId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.ChallengesComponent.GetChallengeStatGoalValue");
		
		UChallengesComponent_GetChallengeStatGoalValue_Params params {};
		params.ChalClass = ChalClass;
		params.StatId = StatId;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E00470
	 * 		Name   -> Function GbxGameSystemCore.ChallengesComponent.GetChallengeProgressGoalValue
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UClass*                                      ChalClass                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	int32_t UChallengesComponent::GetChallengeProgressGoalValue(class UClass* ChalClass)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.ChallengesComponent.GetChallengeProgressGoalValue");
		
		UChallengesComponent_GetChallengeProgressGoalValue_Params params {};
		params.ChalClass = ChalClass;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E003E0
	 * 		Name   -> Function GbxGameSystemCore.ChallengesComponent.GetChallengeProgress
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UClass*                                      ChalClass                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	int32_t UChallengesComponent::GetChallengeProgress(class UClass* ChalClass)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.ChallengesComponent.GetChallengeProgress");
		
		UChallengesComponent_GetChallengeProgress_Params params {};
		params.ChalClass = ChalClass;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E001E0
	 * 		Name   -> Function GbxGameSystemCore.ChallengesComponent.GetChallengeCompleteInfoForLevels
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		TArray<class FName>                                LevelsForChallenges                                        (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
	 * 		class UChallengeCategoryData*                      Category                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            NumCompleted                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            NumActive                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bIgnoreHidden                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UChallengesComponent::GetChallengeCompleteInfoForLevels(TArray<class FName> LevelsForChallenges, class UChallengeCategoryData* Category, int32_t* NumCompleted, int32_t* NumActive, bool bIgnoreHidden)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.ChallengesComponent.GetChallengeCompleteInfoForLevels");
		
		UChallengesComponent_GetChallengeCompleteInfoForLevels_Params params {};
		params.LevelsForChallenges = LevelsForChallenges;
		params.Category = Category;
		params.bIgnoreHidden = bIgnoreHidden;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (NumCompleted != nullptr)
			*NumCompleted = params.NumCompleted;
		if (NumActive != nullptr)
			*NumActive = params.NumActive;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E000C0
	 * 		Name   -> Function GbxGameSystemCore.ChallengesComponent.GetChallengeCompleteInfo
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		class UClass*                                      ChalClass                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            NumCompleted                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            NumChallenges                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UChallengesComponent::GetChallengeCompleteInfo(class UClass* ChalClass, int32_t* NumCompleted, int32_t* NumChallenges)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.ChallengesComponent.GetChallengeCompleteInfo");
		
		UChallengesComponent_GetChallengeCompleteInfo_Params params {};
		params.ChalClass = ChalClass;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (NumCompleted != nullptr)
			*NumCompleted = params.NumCompleted;
		if (NumChallenges != nullptr)
			*NumChallenges = params.NumChallenges;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E00010
	 * 		Name   -> Function GbxGameSystemCore.ChallengesComponent.CompleteChallengeIfConditionsMet
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UClass*                                      ChalClass                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UChallengesComponent::CompleteChallengeIfConditionsMet(class UClass* ChalClass)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.ChallengesComponent.CompleteChallengeIfConditionsMet");
		
		UChallengesComponent_CompleteChallengeIfConditionsMet_Params params {};
		params.ChalClass = ChalClass;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02DFFF40
	 * 		Name   -> Function GbxGameSystemCore.ChallengesComponent.CompleteChallenge
	 * 		Flags  -> (Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UClass*                                      ChalClass                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bForceActive                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UChallengesComponent::CompleteChallenge(class UClass* ChalClass, bool bForceActive)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.ChallengesComponent.CompleteChallenge");
		
		UChallengesComponent_CompleteChallenge_Params params {};
		params.ChalClass = ChalClass;
		params.bForceActive = bForceActive;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02DFFE70
	 * 		Name   -> Function GbxGameSystemCore.ChallengesComponent.ClientChallengeUpdateProgress
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetClient)
	 * Parameters:
	 * 		class UClass*                                      ChalClass                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            NewProgress                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UChallengesComponent::ClientChallengeUpdateProgress(class UClass* ChalClass, int32_t NewProgress)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.ChallengesComponent.ClientChallengeUpdateProgress");
		
		UChallengesComponent_ClientChallengeUpdateProgress_Params params {};
		params.ChalClass = ChalClass;
		params.NewProgress = NewProgress;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02DFFD70
	 * 		Name   -> Function GbxGameSystemCore.ChallengesComponent.ClientChallengeCompleted
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetClient)
	 * Parameters:
	 * 		class UClass*                                      ChalClass                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            NumTiersComplete                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bForceActive                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UChallengesComponent::ClientChallengeCompleted(class UClass* ChalClass, int32_t NumTiersComplete, bool bForceActive)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.ChallengesComponent.ClientChallengeCompleted");
		
		UChallengesComponent_ClientChallengeCompleted_Params params {};
		params.ChalClass = ChalClass;
		params.NumTiersComplete = NumTiersComplete;
		params.bForceActive = bForceActive;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01302DD0
	 * 		Name   -> Function GbxGameSystemCore.ChallengesComponent.ClientActivateChallenge
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetClient)
	 * Parameters:
	 * 		class UClass*                                      ChalClass                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UChallengesComponent::ClientActivateChallenge(class UClass* ChalClass)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.ChallengesComponent.ClientActivateChallenge");
		
		UChallengesComponent_ClientActivateChallenge_Params params {};
		params.ChalClass = ChalClass;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02DFFC10
	 * 		Name   -> Function GbxGameSystemCore.ChallengesComponent.AreGlobalChallengesRegistered
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	bool UChallengesComponent::AreGlobalChallengesRegistered()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.ChallengesComponent.AreGlobalChallengesRegistered");
		
		UChallengesComponent_AreGlobalChallengesRegistered_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02DFFA80
	 * 		Name   -> Function GbxGameSystemCore.ChallengesComponent.ActivateChallenge
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UClass*                                      ChalClass                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UChallengesComponent::ActivateChallenge(class UClass* ChalClass)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.ChallengesComponent.ActivateChallenge");
		
		UChallengesComponent_ActivateChallenge_Params params {};
		params.ChalClass = ChalClass;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UChallengesComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UChallengesComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.ChallengesComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E3C570
	 * 		Name   -> Function GbxGameSystemCore.GbxCharacterMovementComponent.StopRotateTo
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void UGbxCharacterMovementComponent::StopRotateTo()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxCharacterMovementComponent.StopRotateTo");
		
		UGbxCharacterMovementComponent_StopRotateTo_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E3C4A0
	 * 		Name   -> Function GbxGameSystemCore.GbxCharacterMovementComponent.StopMoveTo
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bForce                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bReplicateStop                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGbxCharacterMovementComponent::StopMoveTo(bool bForce, bool bReplicateStop)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxCharacterMovementComponent.StopMoveTo");
		
		UGbxCharacterMovementComponent_StopMoveTo_Params params {};
		params.bForce = bForce;
		params.bReplicateStop = bReplicateStop;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E3C390
	 * 		Name   -> Function GbxGameSystemCore.GbxCharacterMovementComponent.StopControlledMove
	 * 		Flags  -> (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UClass*                                      ControlledMove                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bZeroVelocity                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bInterrupted                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGbxCharacterMovementComponent::StopControlledMove(class UClass* ControlledMove, bool bZeroVelocity, bool bInterrupted)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxCharacterMovementComponent.StopControlledMove");
		
		UGbxCharacterMovementComponent_StopControlledMove_Params params {};
		params.ControlledMove = ControlledMove;
		params.bZeroVelocity = bZeroVelocity;
		params.bInterrupted = bInterrupted;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E3C260
	 * 		Name   -> Function GbxGameSystemCore.GbxCharacterMovementComponent.StartRotateTo
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		struct FCharacterRotateToCommand                   RotateToCommand                                            (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UGbxCharacterMovementComponent::StartRotateTo(const struct FCharacterRotateToCommand& RotateToCommand)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxCharacterMovementComponent.StartRotateTo");
		
		UGbxCharacterMovementComponent_StartRotateTo_Params params {};
		params.RotateToCommand = RotateToCommand;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E3C1C0
	 * 		Name   -> Function GbxGameSystemCore.GbxCharacterMovementComponent.StartMoveTo
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		struct FCharacterMoveToCommand                     MoveToCommand                                              (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UGbxCharacterMovementComponent::StartMoveTo(const struct FCharacterMoveToCommand& MoveToCommand)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxCharacterMovementComponent.StartMoveTo");
		
		UGbxCharacterMovementComponent_StartMoveTo_Params params {};
		params.MoveToCommand = MoveToCommand;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E3BFB0
	 * 		Name   -> Function GbxGameSystemCore.GbxCharacterMovementComponent.StartControlledMove
	 * 		Flags  -> (Final, BlueprintAuthorityOnly, Native, Public, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		class UClass*                                      ControlledMove                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      Instigator                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              SpeedOverride                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              DurationOverride                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              LaunchAngleOverride                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      TargetActor                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     TargetLocation                                             (Parm, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UGbxCharacterMovementComponent::StartControlledMove(class UClass* ControlledMove, class AActor* Instigator, float SpeedOverride, float DurationOverride, float LaunchAngleOverride, class AActor* TargetActor, const struct FVector& TargetLocation)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxCharacterMovementComponent.StartControlledMove");
		
		UGbxCharacterMovementComponent_StartControlledMove_Params params {};
		params.ControlledMove = ControlledMove;
		params.Instigator = Instigator;
		params.SpeedOverride = SpeedOverride;
		params.DurationOverride = DurationOverride;
		params.LaunchAngleOverride = LaunchAngleOverride;
		params.TargetActor = TargetActor;
		params.TargetLocation = TargetLocation;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E3BF30
	 * 		Name   -> Function GbxGameSystemCore.GbxCharacterMovementComponent.SetPendingRawInputVector
	 * 		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FVector                                     NewInputVector                                             (Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGbxCharacterMovementComponent::SetPendingRawInputVector(const struct FVector& NewInputVector)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxCharacterMovementComponent.SetPendingRawInputVector");
		
		UGbxCharacterMovementComponent_SetPendingRawInputVector_Params params {};
		params.NewInputVector = NewInputVector;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E3BE70
	 * 		Name   -> Function GbxGameSystemCore.GbxCharacterMovementComponent.SetNoneWithRootMotionMode
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bAnimationWalking                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FName                                        Reason                                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGbxCharacterMovementComponent::SetNoneWithRootMotionMode(bool bAnimationWalking, const class FName& Reason)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxCharacterMovementComponent.SetNoneWithRootMotionMode");
		
		UGbxCharacterMovementComponent_SetNoneWithRootMotionMode_Params params {};
		params.bAnimationWalking = bAnimationWalking;
		params.Reason = Reason;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E3BD50
	 * 		Name   -> Function GbxGameSystemCore.GbxCharacterMovementComponent.SetFacingTarget
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		struct FFacingInfo                                 FacingTarget                                               (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EFacingChannel                                     Channel                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGbxCharacterMovementComponent::SetFacingTarget(const struct FFacingInfo& FacingTarget, EFacingChannel Channel)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxCharacterMovementComponent.SetFacingTarget");
		
		UGbxCharacterMovementComponent_SetFacingTarget_Params params {};
		params.FacingTarget = FacingTarget;
		params.Channel = Channel;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01E186C0
	 * 		Name   -> Function GbxGameSystemCore.GbxCharacterMovementComponent.SetAnimationBasedTurning
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bEnable                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGbxCharacterMovementComponent::SetAnimationBasedTurning(bool bEnable)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxCharacterMovementComponent.SetAnimationBasedTurning");
		
		UGbxCharacterMovementComponent_SetAnimationBasedTurning_Params params {};
		params.bEnable = bEnable;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E3BC40
	 * 		Name   -> Function GbxGameSystemCore.GbxCharacterMovementComponent.ServerStopMoveTo
	 * 		Flags  -> (Final, Net, NetReliable, Native, Event, Private, NetServer, NetValidate)
	 */
	void UGbxCharacterMovementComponent::ServerStopMoveTo()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxCharacterMovementComponent.ServerStopMoveTo");
		
		UGbxCharacterMovementComponent_ServerStopMoveTo_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E3BB90
	 * 		Name   -> Function GbxGameSystemCore.GbxCharacterMovementComponent.ServerStartMoveTo
	 * 		Flags  -> (Final, Net, NetReliable, Native, Event, Private, NetServer, NetValidate)
	 * Parameters:
	 * 		struct FCharacterMoveToCommand                     MoveToCommand                                              (ConstParm, Parm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UGbxCharacterMovementComponent::ServerStartMoveTo(const struct FCharacterMoveToCommand& MoveToCommand)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxCharacterMovementComponent.ServerStartMoveTo");
		
		UGbxCharacterMovementComponent_ServerStartMoveTo_Params params {};
		params.MoveToCommand = MoveToCommand;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E3BA70
	 * 		Name   -> Function GbxGameSystemCore.GbxCharacterMovementComponent.ServerAttemptMantle
	 * 		Flags  -> (Net, NetReliable, Native, Event, Protected, NetServer, NetValidate)
	 * Parameters:
	 * 		struct FMantleAttemptInfo                          ClientData                                                 (ConstParm, Parm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 * 		float                                              Timestamp                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGbxCharacterMovementComponent::ServerAttemptMantle(const struct FMantleAttemptInfo& ClientData, float Timestamp)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxCharacterMovementComponent.ServerAttemptMantle");
		
		UGbxCharacterMovementComponent_ServerAttemptMantle_Params params {};
		params.ClientData = ClientData;
		params.Timestamp = Timestamp;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E3B9D0
	 * 		Name   -> Function GbxGameSystemCore.GbxCharacterMovementComponent.OnStanceChanged
	 * 		Flags  -> (Native, Public)
	 * Parameters:
	 * 		struct FStanceChangedEventArgs                     Args                                                       (Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UGbxCharacterMovementComponent::OnStanceChanged(const struct FStanceChangedEventArgs& Args)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxCharacterMovementComponent.OnStanceChanged");
		
		UGbxCharacterMovementComponent_OnStanceChanged_Params params {};
		params.Args = Args;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E3B9B0
	 * 		Name   -> Function GbxGameSystemCore.GbxCharacterMovementComponent.OnRep_ControlledMove
	 * 		Flags  -> (Final, Native, Protected)
	 */
	void UGbxCharacterMovementComponent::OnRep_ControlledMove()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxCharacterMovementComponent.OnRep_ControlledMove");
		
		UGbxCharacterMovementComponent_OnRep_ControlledMove_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x013D56B0
	 * 		Name   -> Function GbxGameSystemCore.GbxCharacterMovementComponent.OnNotifyTurnExit
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void UGbxCharacterMovementComponent::OnNotifyTurnExit()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxCharacterMovementComponent.OnNotifyTurnExit");
		
		UGbxCharacterMovementComponent_OnNotifyTurnExit_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x013D56B0
	 * 		Name   -> Function GbxGameSystemCore.GbxCharacterMovementComponent.OnNotifyTurnEnter
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void UGbxCharacterMovementComponent::OnNotifyTurnEnter()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxCharacterMovementComponent.OnNotifyTurnEnter");
		
		UGbxCharacterMovementComponent_OnNotifyTurnEnter_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E3B870
	 * 		Name   -> Function GbxGameSystemCore.GbxCharacterMovementComponent.OnCapsuleEndOverlap
	 * 		Flags  -> (Native, Public)
	 * Parameters:
	 * 		class UPrimitiveComponent*                         OverlappedComp                                             (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      OtherActor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UPrimitiveComponent*                         OtherComp                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            OtherBodyIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGbxCharacterMovementComponent::OnCapsuleEndOverlap(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32_t OtherBodyIndex)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxCharacterMovementComponent.OnCapsuleEndOverlap");
		
		UGbxCharacterMovementComponent_OnCapsuleEndOverlap_Params params {};
		params.OverlappedComp = OverlappedComp;
		params.OtherActor = OtherActor;
		params.OtherComp = OtherComp;
		params.OtherBodyIndex = OtherBodyIndex;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E3B680
	 * 		Name   -> Function GbxGameSystemCore.GbxCharacterMovementComponent.OnCapsuleBeginOverlap
	 * 		Flags  -> (Native, Public, HasOutParms)
	 * Parameters:
	 * 		class UPrimitiveComponent*                         OverlappedComp                                             (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      OtherActor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UPrimitiveComponent*                         OtherComp                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            OtherBodyIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bFromSweep                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FHitResult                                  SweepResult                                                (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	void UGbxCharacterMovementComponent::OnCapsuleBeginOverlap(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32_t OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxCharacterMovementComponent.OnCapsuleBeginOverlap");
		
		UGbxCharacterMovementComponent_OnCapsuleBeginOverlap_Params params {};
		params.OverlappedComp = OverlappedComp;
		params.OtherActor = OtherActor;
		params.OtherComp = OtherComp;
		params.OtherBodyIndex = OtherBodyIndex;
		params.bFromSweep = bFromSweep;
		params.SweepResult = SweepResult;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E3B5B0
	 * 		Name   -> Function GbxGameSystemCore.GbxCharacterMovementComponent.MakeFacingInfoRotation
	 * 		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FRotator                                    Rotation                                                   (Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	struct FFacingInfo UGbxCharacterMovementComponent::STATIC_MakeFacingInfoRotation(const struct FRotator& Rotation)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxCharacterMovementComponent.MakeFacingInfoRotation");
		
		UGbxCharacterMovementComponent_MakeFacingInfoRotation_Params params {};
		params.Rotation = Rotation;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E3B520
	 * 		Name   -> Function GbxGameSystemCore.GbxCharacterMovementComponent.MakeFacingInfoNone
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 */
	struct FFacingInfo UGbxCharacterMovementComponent::STATIC_MakeFacingInfoNone()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxCharacterMovementComponent.MakeFacingInfoNone");
		
		UGbxCharacterMovementComponent_MakeFacingInfoNone_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E3B450
	 * 		Name   -> Function GbxGameSystemCore.GbxCharacterMovementComponent.MakeFacingInfoLocation
	 * 		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FVector                                     Location                                                   (Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FFacingInfo UGbxCharacterMovementComponent::STATIC_MakeFacingInfoLocation(const struct FVector& Location)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxCharacterMovementComponent.MakeFacingInfoLocation");
		
		UGbxCharacterMovementComponent_MakeFacingInfoLocation_Params params {};
		params.Location = Location;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E3B380
	 * 		Name   -> Function GbxGameSystemCore.GbxCharacterMovementComponent.MakeFacingInfoDirection
	 * 		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FVector                                     Direction                                                  (Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FFacingInfo UGbxCharacterMovementComponent::STATIC_MakeFacingInfoDirection(const struct FVector& Direction)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxCharacterMovementComponent.MakeFacingInfoDirection");
		
		UGbxCharacterMovementComponent_MakeFacingInfoDirection_Params params {};
		params.Direction = Direction;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E3B270
	 * 		Name   -> Function GbxGameSystemCore.GbxCharacterMovementComponent.MakeFacingInfoComponent
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class USceneComponent*                             Component                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FFacingInfo UGbxCharacterMovementComponent::STATIC_MakeFacingInfoComponent(class USceneComponent* Component)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxCharacterMovementComponent.MakeFacingInfoComponent");
		
		UGbxCharacterMovementComponent_MakeFacingInfoComponent_Params params {};
		params.Component = Component;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E3B150
	 * 		Name   -> Function GbxGameSystemCore.GbxCharacterMovementComponent.MakeFacingInfoActorEyes
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class AActor*                                      Actor                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FFacingInfo UGbxCharacterMovementComponent::STATIC_MakeFacingInfoActorEyes(class AActor* Actor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxCharacterMovementComponent.MakeFacingInfoActorEyes");
		
		UGbxCharacterMovementComponent_MakeFacingInfoActorEyes_Params params {};
		params.Actor = Actor;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E3B050
	 * 		Name   -> Function GbxGameSystemCore.GbxCharacterMovementComponent.MakeFacingInfoActor
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class AActor*                                      Actor                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FFacingInfo UGbxCharacterMovementComponent::STATIC_MakeFacingInfoActor(class AActor* Actor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxCharacterMovementComponent.MakeFacingInfoActor");
		
		UGbxCharacterMovementComponent_MakeFacingInfoActor_Params params {};
		params.Actor = Actor;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E3AFC0
	 * 		Name   -> Function GbxGameSystemCore.GbxCharacterMovementComponent.LeaveNoneWithRootMotionMode
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bApplyDefault                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGbxCharacterMovementComponent::LeaveNoneWithRootMotionMode(bool bApplyDefault)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxCharacterMovementComponent.LeaveNoneWithRootMotionMode");
		
		UGbxCharacterMovementComponent_LeaveNoneWithRootMotionMode_Params params {};
		params.bApplyDefault = bApplyDefault;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E3AEC0
	 * 		Name   -> Function GbxGameSystemCore.GbxCharacterMovementComponent.IsPerformingSpecificControlledMove
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		class UClass*                                      ControlledMove                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UGbxCharacterMovementComponent::IsPerformingSpecificControlledMove(class UClass* ControlledMove)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxCharacterMovementComponent.IsPerformingSpecificControlledMove");
		
		UGbxCharacterMovementComponent_IsPerformingSpecificControlledMove_Params params {};
		params.ControlledMove = ControlledMove;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E3AE80
	 * 		Name   -> Function GbxGameSystemCore.GbxCharacterMovementComponent.IsPerformingControlledMove
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool UGbxCharacterMovementComponent::IsPerformingControlledMove()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxCharacterMovementComponent.IsPerformingControlledMove");
		
		UGbxCharacterMovementComponent_IsPerformingControlledMove_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E3AE40
	 * 		Name   -> Function GbxGameSystemCore.GbxCharacterMovementComponent.IsMovingOnLadder
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool UGbxCharacterMovementComponent::IsMovingOnLadder()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxCharacterMovementComponent.IsMovingOnLadder");
		
		UGbxCharacterMovementComponent_IsMovingOnLadder_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E3AE10
	 * 		Name   -> Function GbxGameSystemCore.GbxCharacterMovementComponent.IsMantlingAllowed
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool UGbxCharacterMovementComponent::IsMantlingAllowed()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxCharacterMovementComponent.IsMantlingAllowed");
		
		UGbxCharacterMovementComponent_IsMantlingAllowed_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E3ADE0
	 * 		Name   -> Function GbxGameSystemCore.GbxCharacterMovementComponent.IsMantling
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool UGbxCharacterMovementComponent::IsMantling()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxCharacterMovementComponent.IsMantling");
		
		UGbxCharacterMovementComponent_IsMantling_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E3ADB0
	 * 		Name   -> Function GbxGameSystemCore.GbxCharacterMovementComponent.IsInNoneWithRootMotionMode
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool UGbxCharacterMovementComponent::IsInNoneWithRootMotionMode()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxCharacterMovementComponent.IsInNoneWithRootMotionMode");
		
		UGbxCharacterMovementComponent_IsInNoneWithRootMotionMode_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E3AD80
	 * 		Name   -> Function GbxGameSystemCore.GbxCharacterMovementComponent.IsHandIkEnabled
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool UGbxCharacterMovementComponent::IsHandIkEnabled()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxCharacterMovementComponent.IsHandIkEnabled");
		
		UGbxCharacterMovementComponent_IsHandIkEnabled_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E3AD50
	 * 		Name   -> Function GbxGameSystemCore.GbxCharacterMovementComponent.IsFootIkTracingEnabled
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool UGbxCharacterMovementComponent::IsFootIkTracingEnabled()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxCharacterMovementComponent.IsFootIkTracingEnabled");
		
		UGbxCharacterMovementComponent_IsFootIkTracingEnabled_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E3AD20
	 * 		Name   -> Function GbxGameSystemCore.GbxCharacterMovementComponent.IsFootIkEnabled
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool UGbxCharacterMovementComponent::IsFootIkEnabled()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxCharacterMovementComponent.IsFootIkEnabled");
		
		UGbxCharacterMovementComponent_IsFootIkEnabled_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E3AC50
	 * 		Name   -> Function GbxGameSystemCore.GbxCharacterMovementComponent.IsFacingTargetBP
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		float                                              ThresholdDegrees                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EFacingChannel                                     Channel                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UGbxCharacterMovementComponent::IsFacingTargetBP(float ThresholdDegrees, EFacingChannel Channel)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxCharacterMovementComponent.IsFacingTargetBP");
		
		UGbxCharacterMovementComponent_IsFacingTargetBP_Params params {};
		params.ThresholdDegrees = ThresholdDegrees;
		params.Channel = Channel;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E3AC10
	 * 		Name   -> Function GbxGameSystemCore.GbxCharacterMovementComponent.GetMaxAllowedAimOffset
	 * 		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	float UGbxCharacterMovementComponent::GetMaxAllowedAimOffset()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxCharacterMovementComponent.GetMaxAllowedAimOffset");
		
		UGbxCharacterMovementComponent_GetMaxAllowedAimOffset_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E3ABF0
	 * 		Name   -> Function GbxGameSystemCore.GbxCharacterMovementComponent.GetMantleData
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	class UMantleData* UGbxCharacterMovementComponent::GetMantleData()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxCharacterMovementComponent.GetMantleData");
		
		UGbxCharacterMovementComponent_GetMantleData_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E3AB30
	 * 		Name   -> Function GbxGameSystemCore.GbxCharacterMovementComponent.GetDesiredFacingRotation
	 * 		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		EFacingChannel                                     Channel                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FRotator UGbxCharacterMovementComponent::GetDesiredFacingRotation(EFacingChannel Channel)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxCharacterMovementComponent.GetDesiredFacingRotation");
		
		UGbxCharacterMovementComponent_GetDesiredFacingRotation_Params params {};
		params.Channel = Channel;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E3AA70
	 * 		Name   -> Function GbxGameSystemCore.GbxCharacterMovementComponent.GetDesiredFacingLocation
	 * 		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		EFacingChannel                                     Channel                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FVector UGbxCharacterMovementComponent::GetDesiredFacingLocation(EFacingChannel Channel)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxCharacterMovementComponent.GetDesiredFacingLocation");
		
		UGbxCharacterMovementComponent_GetDesiredFacingLocation_Params params {};
		params.Channel = Channel;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E3A9D0
	 * 		Name   -> Function GbxGameSystemCore.GbxCharacterMovementComponent.GetCurrentFacingRotation
	 * 		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		EFacingChannel                                     Channel                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FRotator UGbxCharacterMovementComponent::GetCurrentFacingRotation(EFacingChannel Channel)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxCharacterMovementComponent.GetCurrentFacingRotation");
		
		UGbxCharacterMovementComponent_GetCurrentFacingRotation_Params params {};
		params.Channel = Channel;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E3A930
	 * 		Name   -> Function GbxGameSystemCore.GbxCharacterMovementComponent.GetCurrentFacingOrigin
	 * 		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		EFacingChannel                                     Channel                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FVector UGbxCharacterMovementComponent::GetCurrentFacingOrigin(EFacingChannel Channel)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxCharacterMovementComponent.GetCurrentFacingOrigin");
		
		UGbxCharacterMovementComponent_GetCurrentFacingOrigin_Params params {};
		params.Channel = Channel;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E3A890
	 * 		Name   -> Function GbxGameSystemCore.GbxCharacterMovementComponent.GetCurrentFacingLocation
	 * 		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		EFacingChannel                                     Channel                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FVector UGbxCharacterMovementComponent::GetCurrentFacingLocation(EFacingChannel Channel)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxCharacterMovementComponent.GetCurrentFacingLocation");
		
		UGbxCharacterMovementComponent_GetCurrentFacingLocation_Params params {};
		params.Channel = Channel;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E3A7D0
	 * 		Name   -> Function GbxGameSystemCore.GbxCharacterMovementComponent.GbxSetAnimInstanceClass
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class USkeletalMeshComponent*                      SkelMeshComponent                                          (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UClass*                                      NewClass                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGbxCharacterMovementComponent::GbxSetAnimInstanceClass(class USkeletalMeshComponent* SkelMeshComponent, class UClass* NewClass)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxCharacterMovementComponent.GbxSetAnimInstanceClass");
		
		UGbxCharacterMovementComponent_GbxSetAnimInstanceClass_Params params {};
		params.SkelMeshComponent = SkelMeshComponent;
		params.NewClass = NewClass;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0178F8F0
	 * 		Name   -> DelegateFunction GbxGameSystemCore.GbxCharacterMovementComponent.GbxCharacterMovementEvent__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 */
	void UGbxCharacterMovementComponent::GbxCharacterMovementEvent__DelegateSignature()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction GbxGameSystemCore.GbxCharacterMovementComponent.GbxCharacterMovementEvent__DelegateSignature");
		
		UGbxCharacterMovementComponent_GbxCharacterMovementEvent__DelegateSignature_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E3A630
	 * 		Name   -> Function GbxGameSystemCore.GbxCharacterMovementComponent.ControlledServerMoveOld
	 * 		Flags  -> (Final, Net, Native, Event, Private, NetServer, NetValidate)
	 * Parameters:
	 * 		float                                              OldTimeStamp                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector_NetQuantize10                       OldAccel                                                   (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		unsigned char                                      OldMoveFlags                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		uint32_t                                           CMDir                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGbxCharacterMovementComponent::ControlledServerMoveOld(float OldTimeStamp, const struct FVector_NetQuantize10& OldAccel, unsigned char OldMoveFlags, uint32_t CMDir)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxCharacterMovementComponent.ControlledServerMoveOld");
		
		UGbxCharacterMovementComponent_ControlledServerMoveOld_Params params {};
		params.OldTimeStamp = OldTimeStamp;
		params.OldAccel = OldAccel;
		params.OldMoveFlags = OldMoveFlags;
		params.CMDir = CMDir;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E3A100
	 * 		Name   -> Function GbxGameSystemCore.GbxCharacterMovementComponent.ControlledServerMoveDual
	 * 		Flags  -> (Final, Net, Native, Event, Private, NetServer, NetValidate)
	 * Parameters:
	 * 		float                                              TimeStamp0                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector_NetQuantize10                       InAccel0                                                   (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		unsigned char                                      PendingFlags                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		uint32_t                                           View0                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		uint32_t                                           CMDir0                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Timestamp                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector_NetQuantize10                       InAccel                                                    (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector_NetQuantize100                      ClientLoc                                                  (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		unsigned char                                      NewFlags                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		unsigned char                                      ClientRoll                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		uint32_t                                           View                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UPrimitiveComponent*                         ClientMovementBase                                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FName                                        ClientBaseBoneName                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		unsigned char                                      ClientMovementMode                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		uint32_t                                           CMDir                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		uint16_t                                           ClientBodyYaw                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGbxCharacterMovementComponent::ControlledServerMoveDual(float TimeStamp0, const struct FVector_NetQuantize10& InAccel0, unsigned char PendingFlags, uint32_t View0, uint32_t CMDir0, float Timestamp, const struct FVector_NetQuantize10& InAccel, const struct FVector_NetQuantize100& ClientLoc, unsigned char NewFlags, unsigned char ClientRoll, uint32_t View, class UPrimitiveComponent* ClientMovementBase, const class FName& ClientBaseBoneName, unsigned char ClientMovementMode, uint32_t CMDir, uint16_t ClientBodyYaw)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxCharacterMovementComponent.ControlledServerMoveDual");
		
		UGbxCharacterMovementComponent_ControlledServerMoveDual_Params params {};
		params.TimeStamp0 = TimeStamp0;
		params.InAccel0 = InAccel0;
		params.PendingFlags = PendingFlags;
		params.View0 = View0;
		params.CMDir0 = CMDir0;
		params.Timestamp = Timestamp;
		params.InAccel = InAccel;
		params.ClientLoc = ClientLoc;
		params.NewFlags = NewFlags;
		params.ClientRoll = ClientRoll;
		params.View = View;
		params.ClientMovementBase = ClientMovementBase;
		params.ClientBaseBoneName = ClientBaseBoneName;
		params.ClientMovementMode = ClientMovementMode;
		params.CMDir = CMDir;
		params.ClientBodyYaw = ClientBodyYaw;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E39D50
	 * 		Name   -> Function GbxGameSystemCore.GbxCharacterMovementComponent.ControlledServerMove
	 * 		Flags  -> (Final, Net, Native, Event, Private, NetServer, NetValidate)
	 * Parameters:
	 * 		float                                              Timestamp                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector_NetQuantize10                       InAccel                                                    (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector_NetQuantize100                      ClientLoc                                                  (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		unsigned char                                      CompressedMoveFlags                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		unsigned char                                      ClientRoll                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		uint32_t                                           View                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UPrimitiveComponent*                         ClientMovementBase                                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FName                                        ClientBaseBoneName                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		unsigned char                                      ClientMovementMode                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		uint32_t                                           CMDir                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		uint16_t                                           ClientBodyYaw                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGbxCharacterMovementComponent::ControlledServerMove(float Timestamp, const struct FVector_NetQuantize10& InAccel, const struct FVector_NetQuantize100& ClientLoc, unsigned char CompressedMoveFlags, unsigned char ClientRoll, uint32_t View, class UPrimitiveComponent* ClientMovementBase, const class FName& ClientBaseBoneName, unsigned char ClientMovementMode, uint32_t CMDir, uint16_t ClientBodyYaw)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxCharacterMovementComponent.ControlledServerMove");
		
		UGbxCharacterMovementComponent_ControlledServerMove_Params params {};
		params.Timestamp = Timestamp;
		params.InAccel = InAccel;
		params.ClientLoc = ClientLoc;
		params.CompressedMoveFlags = CompressedMoveFlags;
		params.ClientRoll = ClientRoll;
		params.View = View;
		params.ClientMovementBase = ClientMovementBase;
		params.ClientBaseBoneName = ClientBaseBoneName;
		params.ClientMovementMode = ClientMovementMode;
		params.CMDir = CMDir;
		params.ClientBodyYaw = ClientBodyYaw;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E39A90
	 * 		Name   -> Function GbxGameSystemCore.GbxCharacterMovementComponent.ClientAdjustControlledMovePosition
	 * 		Flags  -> (Final, Net, Native, Event, Private, HasDefaults, NetClient)
	 * Parameters:
	 * 		float                                              Timestamp                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FControlledMoveNetCorrection                ServerCMData                                               (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     NewLoc                                                     (Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     NewVel                                                     (Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UPrimitiveComponent*                         NewBase                                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FName                                        NewBaseBoneName                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bHasBase                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bBaseRelativePosition                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		unsigned char                                      ServerMovementMode                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGbxCharacterMovementComponent::ClientAdjustControlledMovePosition(float Timestamp, const struct FControlledMoveNetCorrection& ServerCMData, const struct FVector& NewLoc, const struct FVector& NewVel, class UPrimitiveComponent* NewBase, const class FName& NewBaseBoneName, bool bHasBase, bool bBaseRelativePosition, unsigned char ServerMovementMode)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxCharacterMovementComponent.ClientAdjustControlledMovePosition");
		
		UGbxCharacterMovementComponent_ClientAdjustControlledMovePosition_Params params {};
		params.Timestamp = Timestamp;
		params.ServerCMData = ServerCMData;
		params.NewLoc = NewLoc;
		params.NewVel = NewVel;
		params.NewBase = NewBase;
		params.NewBaseBoneName = NewBaseBoneName;
		params.bHasBase = bHasBase;
		params.bBaseRelativePosition = bBaseRelativePosition;
		params.ServerMovementMode = ServerMovementMode;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E39A50
	 * 		Name   -> Function GbxGameSystemCore.GbxCharacterMovementComponent.CanStartPassiveMantle
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool UGbxCharacterMovementComponent::CanStartPassiveMantle()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxCharacterMovementComponent.CanStartPassiveMantle");
		
		UGbxCharacterMovementComponent_CanStartPassiveMantle_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E39A10
	 * 		Name   -> Function GbxGameSystemCore.GbxCharacterMovementComponent.CanStartMantle
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool UGbxCharacterMovementComponent::CanStartMantle()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxCharacterMovementComponent.CanStartMantle");
		
		UGbxCharacterMovementComponent_CanStartMantle_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGbxCharacterMovementComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGbxCharacterMovementComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.GbxCharacterMovementComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E40A30
	 * 		Name   -> Function GbxGameSystemCore.GbxCheatManager.TestGameStage
	 * 		Flags  -> (Exec, Native, Public)
	 * Parameters:
	 * 		int32_t                                            GameStageOverride                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGbxCheatManager::TestGameStage(int32_t GameStageOverride)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxCheatManager.TestGameStage");
		
		UGbxCheatManager_TestGameStage_Params params {};
		params.GameStageOverride = GameStageOverride;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x005D70B0
	 * 		Name   -> Function GbxGameSystemCore.GbxCheatManager.StartPlayerInit
	 * 		Flags  -> (Final, Exec, Native, Public)
	 */
	void UGbxCheatManager::StartPlayerInit()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxCheatManager.StartPlayerInit");
		
		UGbxCheatManager_StartPlayerInit_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E40950
	 * 		Name   -> Function GbxGameSystemCore.GbxCheatManager.ShowProjectileImpacts
	 * 		Flags  -> (Final, Exec, Native, Public)
	 * Parameters:
	 * 		float                                              Size                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              LifeTime                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGbxCheatManager::ShowProjectileImpacts(float Size, float LifeTime)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxCheatManager.ShowProjectileImpacts");
		
		UGbxCheatManager_ShowProjectileImpacts_Params params {};
		params.Size = Size;
		params.LifeTime = LifeTime;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x014077D0
	 * 		Name   -> Function GbxGameSystemCore.GbxCheatManager.SetDebugActorByName
	 * 		Flags  -> (Final, Exec, Native, Public)
	 * Parameters:
	 * 		class FString                                      ActorName                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGbxCheatManager::SetDebugActorByName(const class FString& ActorName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxCheatManager.SetDebugActorByName");
		
		UGbxCheatManager_SetDebugActorByName_Params params {};
		params.ActorName = ActorName;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E408A0
	 * 		Name   -> Function GbxGameSystemCore.GbxCheatManager.SetDebugActor
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class AActor*                                      Actor                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            ControllerIndex                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGbxCheatManager::STATIC_SetDebugActor(class AActor* Actor, int32_t ControllerIndex)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxCheatManager.SetDebugActor");
		
		UGbxCheatManager_SetDebugActor_Params params {};
		params.Actor = Actor;
		params.ControllerIndex = ControllerIndex;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E40850
	 * 		Name   -> Function GbxGameSystemCore.GbxCheatManager.Server_TogglePlayersOnly
	 * 		Flags  -> (Final, Net, NetReliable, Native, Event, Private, NetServer, NetValidate)
	 */
	void UGbxCheatManager::Server_TogglePlayersOnly()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxCheatManager.Server_TogglePlayersOnly");
		
		UGbxCheatManager_Server_TogglePlayersOnly_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E407A0
	 * 		Name   -> Function GbxGameSystemCore.GbxCheatManager.Server_DamageTarget
	 * 		Flags  -> (Final, Net, NetReliable, Native, Event, Private, NetServer, NetValidate)
	 * Parameters:
	 * 		float                                              DamageAmount                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGbxCheatManager::Server_DamageTarget(float DamageAmount)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxCheatManager.Server_DamageTarget");
		
		UGbxCheatManager_Server_DamageTarget_Params params {};
		params.DamageAmount = DamageAmount;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x014077D0
	 * 		Name   -> Function GbxGameSystemCore.GbxCheatManager.PlayFeedbackRangedFromThere
	 * 		Flags  -> (Final, Exec, Native, Public)
	 * Parameters:
	 * 		class FString                                      FeedbackData                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGbxCheatManager::PlayFeedbackRangedFromThere(const class FString& FeedbackData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxCheatManager.PlayFeedbackRangedFromThere");
		
		UGbxCheatManager_PlayFeedbackRangedFromThere_Params params {};
		params.FeedbackData = FeedbackData;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01409530
	 * 		Name   -> Function GbxGameSystemCore.GbxCheatManager.PlayFeedbackDirectional
	 * 		Flags  -> (Final, Exec, Native, Public)
	 * Parameters:
	 * 		class FString                                      FeedbackData                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              DirectionAngle                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGbxCheatManager::PlayFeedbackDirectional(const class FString& FeedbackData, float DirectionAngle)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxCheatManager.PlayFeedbackDirectional");
		
		UGbxCheatManager_PlayFeedbackDirectional_Params params {};
		params.FeedbackData = FeedbackData;
		params.DirectionAngle = DirectionAngle;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01409530
	 * 		Name   -> Function GbxGameSystemCore.GbxCheatManager.PlayFeedback
	 * 		Flags  -> (Final, Exec, Native, Public)
	 * Parameters:
	 * 		class FString                                      FeedbackData                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Scale                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGbxCheatManager::PlayFeedback(const class FString& FeedbackData, float Scale)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxCheatManager.PlayFeedback");
		
		UGbxCheatManager_PlayFeedback_Params params {};
		params.FeedbackData = FeedbackData;
		params.Scale = Scale;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x005D70B0
	 * 		Name   -> Function GbxGameSystemCore.GbxCheatManager.LogQatalystInfo
	 * 		Flags  -> (Final, Exec, Native, Public, Const)
	 */
	void UGbxCheatManager::LogQatalystInfo()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxCheatManager.LogQatalystInfo");
		
		UGbxCheatManager_LogQatalystInfo_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x005D70B0
	 * 		Name   -> Function GbxGameSystemCore.GbxCheatManager.DebugNextAI
	 * 		Flags  -> (Final, Exec, Native, Public)
	 */
	void UGbxCheatManager::DebugNextAI()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxCheatManager.DebugNextAI");
		
		UGbxCheatManager_DebugNextAI_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x005D70B0
	 * 		Name   -> Function GbxGameSystemCore.GbxCheatManager.DamageAreaDebug
	 * 		Flags  -> (Final, Exec, Native, Public, Const)
	 */
	void UGbxCheatManager::DamageAreaDebug()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxCheatManager.DamageAreaDebug");
		
		UGbxCheatManager_DamageAreaDebug_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x005D70B0
	 * 		Name   -> Function GbxGameSystemCore.GbxCheatManager.ClearPlayerInit
	 * 		Flags  -> (Final, Exec, Native, Public)
	 */
	void UGbxCheatManager::ClearPlayerInit()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxCheatManager.ClearPlayerInit");
		
		UGbxCheatManager_ClearPlayerInit_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGbxCheatManager.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGbxCheatManager::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.GbxCheatManager");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UCinematicModeData.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UCinematicModeData::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.CinematicModeData");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E04200
	 * 		Name   -> Function GbxGameSystemCore.ControlledMove.OnTeleported
	 * 		Flags  -> (Native, Event, Public, HasOutParms, HasDefaults, BlueprintEvent)
	 * Parameters:
	 * 		float                                              MoveDuration                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     PreTeleportLocation                                        (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UControlledMove::OnTeleported(float MoveDuration, const struct FVector& PreTeleportLocation)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.ControlledMove.OnTeleported");
		
		UControlledMove_OnTeleported_Params params {};
		params.MoveDuration = MoveDuration;
		params.PreTeleportLocation = PreTeleportLocation;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E04170
	 * 		Name   -> Function GbxGameSystemCore.ControlledMove.OnTargetLocationChanged
	 * 		Flags  -> (Native, Event, Public, HasOutParms, HasDefaults, BlueprintEvent)
	 * Parameters:
	 * 		struct FVector                                     NewTargetLocation                                          (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UControlledMove::OnTargetLocationChanged(const struct FVector& NewTargetLocation)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.ControlledMove.OnTargetLocationChanged");
		
		UControlledMove_OnTargetLocationChanged_Params params {};
		params.NewTargetLocation = NewTargetLocation;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x028E5090
	 * 		Name   -> Function GbxGameSystemCore.ControlledMove.OnStop
	 * 		Flags  -> (Native, Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		bool                                               bInterrupted                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UControlledMove::OnStop(bool bInterrupted)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.ControlledMove.OnStop");
		
		UControlledMove_OnStop_Params params {};
		params.bInterrupted = bInterrupted;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E040A0
	 * 		Name   -> Function GbxGameSystemCore.ControlledMove.OnStart
	 * 		Flags  -> (Native, Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		float                                              MoveDuration                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      TargetActor                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UControlledMove::OnStart(float MoveDuration, class AActor* TargetActor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.ControlledMove.OnStart");
		
		UControlledMove_OnStart_Params params {};
		params.MoveDuration = MoveDuration;
		params.TargetActor = TargetActor;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02094BF0
	 * 		Name   -> Function GbxGameSystemCore.ControlledMove.OnServerStop
	 * 		Flags  -> (Native, Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		bool                                               bInterrupted                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UControlledMove::OnServerStop(bool bInterrupted)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.ControlledMove.OnServerStop");
		
		UControlledMove_OnServerStop_Params params {};
		params.bInterrupted = bInterrupted;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E03FA0
	 * 		Name   -> Function GbxGameSystemCore.ControlledMove.OnServerStart
	 * 		Flags  -> (Native, Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		float                                              MoveDuration                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      TargetActor                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      Instigator                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UControlledMove::OnServerStart(float MoveDuration, class AActor* TargetActor, class AActor* Instigator)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.ControlledMove.OnServerStart");
		
		UControlledMove_OnServerStart_Params params {};
		params.MoveDuration = MoveDuration;
		params.TargetActor = TargetActor;
		params.Instigator = Instigator;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E03ED0
	 * 		Name   -> Function GbxGameSystemCore.ControlledMove.OnHitWorld
	 * 		Flags  -> (Native, Event, Public, HasOutParms, HasDefaults, BlueprintEvent)
	 * Parameters:
	 * 		class AActor*                                      HitActor                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     HitNormal                                                  (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UControlledMove::OnHitWorld(class AActor* HitActor, const struct FVector& HitNormal)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.ControlledMove.OnHitWorld");
		
		UControlledMove_OnHitWorld_Params params {};
		params.HitActor = HitActor;
		params.HitNormal = HitNormal;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E03E00
	 * 		Name   -> Function GbxGameSystemCore.ControlledMove.OnHitTargetable
	 * 		Flags  -> (Native, Event, Public, HasOutParms, HasDefaults, BlueprintEvent)
	 * Parameters:
	 * 		class AActor*                                      HitActor                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     HitNormal                                                  (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UControlledMove::OnHitTargetable(class AActor* HitActor, const struct FVector& HitNormal)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.ControlledMove.OnHitTargetable");
		
		UControlledMove_OnHitTargetable_Params params {};
		params.HitActor = HitActor;
		params.HitNormal = HitNormal;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UControlledMove.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UControlledMove::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.ControlledMove");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E406A0
	 * 		Name   -> Function GbxGameSystemCore.GbxCustomizationComponent.ServerApplyCustomizationData
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetServer, BlueprintCallable, NetValidate)
	 * Parameters:
	 * 		class UGbxCustomizationData*                       CustomizationToApply                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            OptionalCustomizationId                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGbxCustomizationComponent::ServerApplyCustomizationData(class UGbxCustomizationData* CustomizationToApply, int32_t OptionalCustomizationId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxCustomizationComponent.ServerApplyCustomizationData");
		
		UGbxCustomizationComponent_ServerApplyCustomizationData_Params params {};
		params.CustomizationToApply = CustomizationToApply;
		params.OptionalCustomizationId = OptionalCustomizationId;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E404B0
	 * 		Name   -> Function GbxGameSystemCore.GbxCustomizationComponent.ServerApplyCustomColor
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetServer, HasDefaults, BlueprintCallable, NetValidate)
	 * Parameters:
	 * 		int32_t                                            CustomColorIndex                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     InAppliedColor                                             (Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     InSplitColor                                               (Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               InUseDefaultColor                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               InUseDefaultSplitColor                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGbxCustomizationComponent::ServerApplyCustomColor(int32_t CustomColorIndex, const struct FVector& InAppliedColor, const struct FVector& InSplitColor, bool InUseDefaultColor, bool InUseDefaultSplitColor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxCustomizationComponent.ServerApplyCustomColor");
		
		UGbxCustomizationComponent_ServerApplyCustomColor_Params params {};
		params.CustomColorIndex = CustomColorIndex;
		params.InAppliedColor = InAppliedColor;
		params.InSplitColor = InSplitColor;
		params.InUseDefaultColor = InUseDefaultColor;
		params.InUseDefaultSplitColor = InUseDefaultSplitColor;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E40420
	 * 		Name   -> Function GbxGameSystemCore.GbxCustomizationComponent.RemoveCustomization
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UGbxCustomizationData*                       Customization                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UGbxCustomizationComponent::RemoveCustomization(class UGbxCustomizationData* Customization)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxCustomizationComponent.RemoveCustomization");
		
		UGbxCustomizationComponent_RemoveCustomization_Params params {};
		params.Customization = Customization;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E40400
	 * 		Name   -> Function GbxGameSystemCore.GbxCustomizationComponent.OnRep_CustomColorSelections
	 * 		Flags  -> (Final, Native, Public)
	 */
	void UGbxCustomizationComponent::OnRep_CustomColorSelections()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxCustomizationComponent.OnRep_CustomColorSelections");
		
		UGbxCustomizationComponent_OnRep_CustomColorSelections_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E40280
	 * 		Name   -> Function GbxGameSystemCore.GbxCustomizationComponent.LinkToCustomization
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UGbxCustomizationComponent*                  SourceComponent                                            (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGbxCustomizationComponent::LinkToCustomization(class UGbxCustomizationComponent* SourceComponent)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxCustomizationComponent.LinkToCustomization");
		
		UGbxCustomizationComponent_LinkToCustomization_Params params {};
		params.SourceComponent = SourceComponent;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E40380
	 * 		Name   -> Function GbxGameSystemCore.GbxCustomizationComponent.LinkedCustomizationRemoved
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		class UGbxCustomizationData*                       Customization                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGbxCustomizationComponent::LinkedCustomizationRemoved(class UGbxCustomizationData* Customization)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxCustomizationComponent.LinkedCustomizationRemoved");
		
		UGbxCustomizationComponent_LinkedCustomizationRemoved_Params params {};
		params.Customization = Customization;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E40300
	 * 		Name   -> Function GbxGameSystemCore.GbxCustomizationComponent.LinkedCustomizationApplied
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		class UGbxCustomizationData*                       Customization                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGbxCustomizationComponent::LinkedCustomizationApplied(class UGbxCustomizationData* Customization)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxCustomizationComponent.LinkedCustomizationApplied");
		
		UGbxCustomizationComponent_LinkedCustomizationApplied_Params params {};
		params.Customization = Customization;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E40170
	 * 		Name   -> Function GbxGameSystemCore.GbxCustomizationComponent.GetDefaultCustomSplitColor
	 * 		Flags  -> (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		int32_t                                            SelectionIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FLinearColor                                DefaultSplitColor                                          (Parm, OutParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UGbxCustomizationComponent::GetDefaultCustomSplitColor(int32_t SelectionIndex, struct FLinearColor* DefaultSplitColor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxCustomizationComponent.GetDefaultCustomSplitColor");
		
		UGbxCustomizationComponent_GetDefaultCustomSplitColor_Params params {};
		params.SelectionIndex = SelectionIndex;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (DefaultSplitColor != nullptr)
			*DefaultSplitColor = params.DefaultSplitColor;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E40090
	 * 		Name   -> Function GbxGameSystemCore.GbxCustomizationComponent.GetDefaultCustomColor
	 * 		Flags  -> (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		int32_t                                            SelectionIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FLinearColor                                DefaultColor                                               (Parm, OutParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UGbxCustomizationComponent::GetDefaultCustomColor(int32_t SelectionIndex, struct FLinearColor* DefaultColor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxCustomizationComponent.GetDefaultCustomColor");
		
		UGbxCustomizationComponent_GetDefaultCustomColor_Params params {};
		params.SelectionIndex = SelectionIndex;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (DefaultColor != nullptr)
			*DefaultColor = params.DefaultColor;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E3FF20
	 * 		Name   -> Function GbxGameSystemCore.GbxCustomizationComponent.CopyFromCustomization
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UGbxCustomizationComponent*                  SourceComponent                                            (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGbxCustomizationComponent::CopyFromCustomization(class UGbxCustomizationComponent* SourceComponent)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxCustomizationComponent.CopyFromCustomization");
		
		UGbxCustomizationComponent_CopyFromCustomization_Params params {};
		params.SourceComponent = SourceComponent;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGbxCustomizationComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGbxCustomizationComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.GbxCustomizationComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E474B0
	 * 		Name   -> Function GbxGameSystemCore.GbxCustomizationManager.OnCustomizationAssetLoaded
	 * 		Flags  -> (Final, Native, Public)
	 */
	void AGbxCustomizationManager::OnCustomizationAssetLoaded()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxCustomizationManager.OnCustomizationAssetLoaded");
		
		AGbxCustomizationManager_OnCustomizationAssetLoaded_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AGbxCustomizationManager.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AGbxCustomizationManager::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.GbxCustomizationManager");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDamageBaseComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDamageBaseComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.DamageBaseComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E07740
	 * 		Name   -> Function GbxGameSystemCore.DamageCauserComponent.UnregisterConditionalDamageModifier
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UConditionalDamageModifier*                  Modifier                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UDamageCauserComponent::UnregisterConditionalDamageModifier(class UConditionalDamageModifier* Modifier)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.DamageCauserComponent.UnregisterConditionalDamageModifier");
		
		UDamageCauserComponent_UnregisterConditionalDamageModifier_Params params {};
		params.Modifier = Modifier;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E07410
	 * 		Name   -> Function GbxGameSystemCore.DamageCauserComponent.RegisterConditionalDamageModifier
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UConditionalDamageModifier*                  Modifier                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UDamageCauserComponent::RegisterConditionalDamageModifier(class UConditionalDamageModifier* Modifier)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.DamageCauserComponent.RegisterConditionalDamageModifier");
		
		UDamageCauserComponent_RegisterConditionalDamageModifier_Params params {};
		params.Modifier = Modifier;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDamageCauserComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDamageCauserComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.DamageCauserComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E07740
	 * 		Name   -> Function GbxGameSystemCore.DamageComponent.UnregisterConditionalDamageModifier
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UConditionalDamageModifier*                  Modifier                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UDamageComponent::UnregisterConditionalDamageModifier(class UConditionalDamageModifier* Modifier)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.DamageComponent.UnregisterConditionalDamageModifier");
		
		UDamageComponent_UnregisterConditionalDamageModifier_Params params {};
		params.Modifier = Modifier;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E076B0
	 * 		Name   -> Function GbxGameSystemCore.DamageComponent.SetSelfReflectedDamageType
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		class UClass*                                      DamageType                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UDamageComponent::SetSelfReflectedDamageType(class UClass* DamageType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.DamageComponent.SetSelfReflectedDamageType");
		
		UDamageComponent_SetSelfReflectedDamageType_Params params {};
		params.DamageType = DamageType;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E07620
	 * 		Name   -> Function GbxGameSystemCore.DamageComponent.SetGodMode
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bInGodMode                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UDamageComponent::SetGodMode(bool bInGodMode)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.DamageComponent.SetGodMode");
		
		UDamageComponent_SetGodMode_Params params {};
		params.bInGodMode = bInGodMode;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E07590
	 * 		Name   -> Function GbxGameSystemCore.DamageComponent.SetDemiGodMode
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bInDemiGodMode                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UDamageComponent::SetDemiGodMode(bool bInDemiGodMode)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.DamageComponent.SetDemiGodMode");
		
		UDamageComponent_SetDemiGodMode_Params params {};
		params.bInDemiGodMode = bInDemiGodMode;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E07510
	 * 		Name   -> Function GbxGameSystemCore.DamageComponent.SetCurrentShield
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		float                                              NewCurrentShield                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UDamageComponent::SetCurrentShield(float NewCurrentShield)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.DamageComponent.SetCurrentShield");
		
		UDamageComponent_SetCurrentShield_Params params {};
		params.NewCurrentShield = NewCurrentShield;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E07490
	 * 		Name   -> Function GbxGameSystemCore.DamageComponent.SetCurrentHealth
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		float                                              NewCurrentHealth                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UDamageComponent::SetCurrentHealth(float NewCurrentHealth)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.DamageComponent.SetCurrentHealth");
		
		UDamageComponent_SetCurrentHealth_Params params {};
		params.NewCurrentHealth = NewCurrentHealth;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E07410
	 * 		Name   -> Function GbxGameSystemCore.DamageComponent.RegisterConditionalDamageModifier
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UConditionalDamageModifier*                  Modifier                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UDamageComponent::RegisterConditionalDamageModifier(class UConditionalDamageModifier* Modifier)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.DamageComponent.RegisterConditionalDamageModifier");
		
		UDamageComponent_RegisterConditionalDamageModifier_Params params {};
		params.Modifier = Modifier;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0178F8F0
	 * 		Name   -> Function GbxGameSystemCore.DamageComponent.ReceiveHealthDepleted
	 * 		Flags  -> (BlueprintAuthorityOnly, Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		class UDamageCauserComponent*                      DamageCauser                                               (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UDamageComponent::ReceiveHealthDepleted(class UDamageCauserComponent* DamageCauser)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.DamageComponent.ReceiveHealthDepleted");
		
		UDamageComponent_ReceiveHealthDepleted_Params params {};
		params.DamageCauser = DamageCauser;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0178F8F0
	 * 		Name   -> Function GbxGameSystemCore.DamageComponent.ReceiveAnyHealing
	 * 		Flags  -> (BlueprintAuthorityOnly, Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		float                                              Healing                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      HealInstigator                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UDamageComponent::ReceiveAnyHealing(float Healing, class AActor* HealInstigator)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.DamageComponent.ReceiveAnyHealing");
		
		UDamageComponent_ReceiveAnyHealing_Params params {};
		params.Healing = Healing;
		params.HealInstigator = HealInstigator;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0178F8F0
	 * 		Name   -> Function GbxGameSystemCore.DamageComponent.ReceiveAnyDamage
	 * 		Flags  -> (BlueprintAuthorityOnly, Event, Public, HasOutParms, BlueprintEvent)
	 * Parameters:
	 * 		float                                              Damage                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UGbxDamageType*                              DamageType                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UDamageSource*                               DamageSource                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AController*                                 InstigatedBy                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UDamageCauserComponent*                      DamageCauser                                               (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FReceivedDamageDetails                      Details                                                    (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	void UDamageComponent::ReceiveAnyDamage(float Damage, class UGbxDamageType* DamageType, class UDamageSource* DamageSource, class AController* InstigatedBy, class UDamageCauserComponent* DamageCauser, const struct FReceivedDamageDetails& Details)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.DamageComponent.ReceiveAnyDamage");
		
		UDamageComponent_ReceiveAnyDamage_Params params {};
		params.Damage = Damage;
		params.DamageType = DamageType;
		params.DamageSource = DamageSource;
		params.InstigatedBy = InstigatedBy;
		params.DamageCauser = DamageCauser;
		params.Details = Details;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E073D0
	 * 		Name   -> Function GbxGameSystemCore.DamageComponent.OnRep_HealthInformation
	 * 		Flags  -> (Native, Protected)
	 */
	void UDamageComponent::OnRep_HealthInformation()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.DamageComponent.OnRep_HealthInformation");
		
		UDamageComponent_OnRep_HealthInformation_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E073B0
	 * 		Name   -> Function GbxGameSystemCore.DamageComponent.OnRep_DeathHitReaction
	 * 		Flags  -> (Native, Protected)
	 */
	void UDamageComponent::OnRep_DeathHitReaction()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.DamageComponent.OnRep_DeathHitReaction");
		
		UDamageComponent_OnRep_DeathHitReaction_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E073F0
	 * 		Name   -> Function GbxGameSystemCore.DamageComponent.OnRep_bCurrentlyDead
	 * 		Flags  -> (Final, Native, Private)
	 */
	void UDamageComponent::OnRep_bCurrentlyDead()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.DamageComponent.OnRep_bCurrentlyDead");
		
		UDamageComponent_OnRep_bCurrentlyDead_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E072F0
	 * 		Name   -> Function GbxGameSystemCore.DamageComponent.OnOwnerExperienceLevelChanged
	 * 		Flags  -> (Final, Native, Private)
	 * Parameters:
	 * 		int32_t                                            OldExperienceLevel                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            NewExperienceLevel                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UDamageComponent::OnOwnerExperienceLevelChanged(int32_t OldExperienceLevel, int32_t NewExperienceLevel)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.DamageComponent.OnOwnerExperienceLevelChanged");
		
		UDamageComponent_OnOwnerExperienceLevelChanged_Params params {};
		params.OldExperienceLevel = OldExperienceLevel;
		params.NewExperienceLevel = NewExperienceLevel;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E07250
	 * 		Name   -> Function GbxGameSystemCore.DamageComponent.OnHealthResourceNowNotDepleted
	 * 		Flags  -> (Final, Native, Private)
	 * Parameters:
	 * 		struct FGameResourcePoolReference                  ResourcePool                                               (Parm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	void UDamageComponent::OnHealthResourceNowNotDepleted(const struct FGameResourcePoolReference& ResourcePool)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.DamageComponent.OnHealthResourceNowNotDepleted");
		
		UDamageComponent_OnHealthResourceNowNotDepleted_Params params {};
		params.ResourcePool = ResourcePool;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E07250
	 * 		Name   -> Function GbxGameSystemCore.DamageComponent.OnHealthResourceNowDepleted
	 * 		Flags  -> (Final, Native, Private)
	 * Parameters:
	 * 		struct FGameResourcePoolReference                  ResourcePool                                               (Parm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	void UDamageComponent::OnHealthResourceNowDepleted(const struct FGameResourcePoolReference& ResourcePool)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.DamageComponent.OnHealthResourceNowDepleted");
		
		UDamageComponent_OnHealthResourceNowDepleted_Params params {};
		params.ResourcePool = ResourcePool;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E07220
	 * 		Name   -> Function GbxGameSystemCore.DamageComponent.IsInGodMode
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool UDamageComponent::IsInGodMode()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.DamageComponent.IsInGodMode");
		
		UDamageComponent_IsInGodMode_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E071F0
	 * 		Name   -> Function GbxGameSystemCore.DamageComponent.IsInDemiGodMode
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool UDamageComponent::IsInDemiGodMode()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.DamageComponent.IsInDemiGodMode");
		
		UDamageComponent_IsInDemiGodMode_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E07110
	 * 		Name   -> Function GbxGameSystemCore.DamageComponent.IsDamageOverkill
	 * 		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		float                                              DamageAmount                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              OverkillThreshold                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UDamageComponent::IsDamageOverkill(float DamageAmount, float OverkillThreshold)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.DamageComponent.IsDamageOverkill");
		
		UDamageComponent_IsDamageOverkill_Params params {};
		params.DamageAmount = DamageAmount;
		params.OverkillThreshold = OverkillThreshold;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007A5960
	 * 		Name   -> Function GbxGameSystemCore.DamageComponent.GetValidDamageEventFunctionNames
	 * 		Flags  -> (Final, Native, Private, HasOutParms, Const)
	 * Parameters:
	 * 		TArray<class FName>                                Names                                                      (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	 */
	void UDamageComponent::GetValidDamageEventFunctionNames(TArray<class FName>* Names)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.DamageComponent.GetValidDamageEventFunctionNames");
		
		UDamageComponent_GetValidDamageEventFunctionNames_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (Names != nullptr)
			*Names = params.Names;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E070D0
	 * 		Name   -> Function GbxGameSystemCore.DamageComponent.GetTotalMaxHealth
	 * 		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	float UDamageComponent::GetTotalMaxHealth()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.DamageComponent.GetTotalMaxHealth");
		
		UDamageComponent_GetTotalMaxHealth_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E070A0
	 * 		Name   -> Function GbxGameSystemCore.DamageComponent.GetMaxShield
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	float UDamageComponent::GetMaxShield()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.DamageComponent.GetMaxShield");
		
		UDamageComponent_GetMaxShield_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E07070
	 * 		Name   -> Function GbxGameSystemCore.DamageComponent.GetMaxHealth
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	float UDamageComponent::GetMaxHealth()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.DamageComponent.GetMaxHealth");
		
		UDamageComponent_GetMaxHealth_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E07040
	 * 		Name   -> Function GbxGameSystemCore.DamageComponent.GetCurrentShield
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	float UDamageComponent::GetCurrentShield()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.DamageComponent.GetCurrentShield");
		
		UDamageComponent_GetCurrentShield_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E07010
	 * 		Name   -> Function GbxGameSystemCore.DamageComponent.GetCurrentHealthPercent
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	float UDamageComponent::GetCurrentHealthPercent()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.DamageComponent.GetCurrentHealthPercent");
		
		UDamageComponent_GetCurrentHealthPercent_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E06FE0
	 * 		Name   -> Function GbxGameSystemCore.DamageComponent.GetCurrentHealth
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	float UDamageComponent::GetCurrentHealth()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.DamageComponent.GetCurrentHealth");
		
		UDamageComponent_GetCurrentHealth_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E06E60
	 * 		Name   -> Function GbxGameSystemCore.DamageComponent.BroadcastPlayImpactSplatterEffect
	 * 		Flags  -> (Net, Native, Event, NetMulticast, Protected)
	 * Parameters:
	 * 		class UImpactData*                                 ImpactData                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector_NetQuantize100                      HitLocation                                                (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector_NetQuantizeNormal                   HitDirection                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              DamageSeverity                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UDamageComponent::BroadcastPlayImpactSplatterEffect(class UImpactData* ImpactData, const struct FVector_NetQuantize100& HitLocation, const struct FVector_NetQuantizeNormal& HitDirection, float DamageSeverity)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.DamageComponent.BroadcastPlayImpactSplatterEffect");
		
		UDamageComponent_BroadcastPlayImpactSplatterEffect_Params params {};
		params.ImpactData = ImpactData;
		params.HitLocation = HitLocation;
		params.HitDirection = HitDirection;
		params.DamageSeverity = DamageSeverity;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDamageComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDamageComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.DamageComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDamageFilter.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDamageFilter::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.DamageFilter");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDamageGlobalsData.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDamageGlobalsData::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.DamageGlobalsData");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E0AB70
	 * 		Name   -> Function GbxGameSystemCore.DamageModifierComponent.UnregisterConditionalDamageModifier
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UConditionalDamageModifier*                  Modifier                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UDamageModifierComponent::UnregisterConditionalDamageModifier(class UConditionalDamageModifier* Modifier)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.DamageModifierComponent.UnregisterConditionalDamageModifier");
		
		UDamageModifierComponent_UnregisterConditionalDamageModifier_Params params {};
		params.Modifier = Modifier;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E0A8E0
	 * 		Name   -> Function GbxGameSystemCore.DamageModifierComponent.RegisterConditionalDamageModifier
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UConditionalDamageModifier*                  Modifier                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UDamageModifierComponent::RegisterConditionalDamageModifier(class UConditionalDamageModifier* Modifier)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.DamageModifierComponent.RegisterConditionalDamageModifier");
		
		UDamageModifierComponent_RegisterConditionalDamageModifier_Params params {};
		params.Modifier = Modifier;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDamageModifierComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDamageModifierComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.DamageModifierComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E0A860
	 * 		Name   -> Function GbxGameSystemCore.DamageOverTimeManager.OnParticleSystemStopped
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		class UParticleSystemComponent*                    ParticleSystem                                             (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UDamageOverTimeManager::OnParticleSystemStopped(class UParticleSystemComponent* ParticleSystem)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.DamageOverTimeManager.OnParticleSystemStopped");
		
		UDamageOverTimeManager_OnParticleSystemStopped_Params params {};
		params.ParticleSystem = ParticleSystem;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDamageOverTimeManager.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDamageOverTimeManager::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.DamageOverTimeManager");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDamageSource.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDamageSource::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.DamageSource");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x008AFD90
	 * 		Name   -> Function GbxGameSystemCore.GbxDamageType.IsElementalType
	 * 		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool UGbxDamageType::IsElementalType()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxDamageType.IsElementalType");
		
		UGbxDamageType_IsElementalType_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGbxDamageType.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGbxDamageType::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.GbxDamageType");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UEnvQueryContext_EnvQueryParam.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UEnvQueryContext_EnvQueryParam::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.EnvQueryContext_EnvQueryParam");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E199E0
	 * 		Name   -> Function GbxGameSystemCore.FirstPersonComponent.SetBaseEyeToWeaponTransform
	 * 		Flags  -> (Final, Native, Private, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FTransform                                  NewWeaponTransform                                         (Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UFirstPersonComponent::SetBaseEyeToWeaponTransform(const struct FTransform& NewWeaponTransform)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.FirstPersonComponent.SetBaseEyeToWeaponTransform");
		
		UFirstPersonComponent_SetBaseEyeToWeaponTransform_Params params {};
		params.NewWeaponTransform = NewWeaponTransform;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E184A0
	 * 		Name   -> Function GbxGameSystemCore.FirstPersonComponent.GetFirstPersonComponentByName
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		class FName                                        Name                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class USceneComponent* UFirstPersonComponent::GetFirstPersonComponentByName(const class FName& Name)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.FirstPersonComponent.GetFirstPersonComponentByName");
		
		UFirstPersonComponent_GetFirstPersonComponentByName_Params params {};
		params.Name = Name;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UFirstPersonComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UFirstPersonComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.FirstPersonComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x005D70B0
	 * 		Name   -> Function GbxGameSystemCore.GbxGameInstance.DebugLoadStartupAssets
	 * 		Flags  -> (Final, Exec, Native, Public)
	 */
	void UGbxGameInstance::DebugLoadStartupAssets()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxGameInstance.DebugLoadStartupAssets");
		
		UGbxGameInstance_DebugLoadStartupAssets_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGbxGameInstance.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGbxGameInstance::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.GbxGameInstance");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGlobalAIData.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGlobalAIData::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.GlobalAIData");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGbxGlobalsData.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGbxGlobalsData::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.GbxGlobalsData");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E61DC0
	 * 		Name   -> Function GbxGameSystemCore.HitRegionComponent.TriggerClientEvent
	 * 		Flags  -> (Net, NetReliable, Native, Event, NetMulticast, Protected)
	 * Parameters:
	 * 		struct FDamageReactionEventSummary                 EventSummary                                               (ConstParm, Parm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	void UHitRegionComponent::TriggerClientEvent(const struct FDamageReactionEventSummary& EventSummary)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.HitRegionComponent.TriggerClientEvent");
		
		UHitRegionComponent_TriggerClientEvent_Params params {};
		params.EventSummary = EventSummary;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007A5960
	 * 		Name   -> Function GbxGameSystemCore.HitRegionComponent.GetValidDamageEventFunctionNames
	 * 		Flags  -> (Final, Native, Protected, HasOutParms, Const)
	 * Parameters:
	 * 		TArray<class FName>                                Array                                                      (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	 */
	void UHitRegionComponent::GetValidDamageEventFunctionNames(TArray<class FName>* Array)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.HitRegionComponent.GetValidDamageEventFunctionNames");
		
		UHitRegionComponent_GetValidDamageEventFunctionNames_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (Array != nullptr)
			*Array = params.Array;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007A5960
	 * 		Name   -> Function GbxGameSystemCore.HitRegionComponent.GetValidAssociatedComponentNames
	 * 		Flags  -> (Final, Native, Protected, HasOutParms, Const)
	 * Parameters:
	 * 		TArray<class FName>                                Array                                                      (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	 */
	void UHitRegionComponent::GetValidAssociatedComponentNames(TArray<class FName>* Array)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.HitRegionComponent.GetValidAssociatedComponentNames");
		
		UHitRegionComponent_GetValidAssociatedComponentNames_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (Array != nullptr)
			*Array = params.Array;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E61870
	 * 		Name   -> Function GbxGameSystemCore.HitRegionComponent.GetHitRegionPercentHealth
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		class UHitRegionData*                              HitRegion                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UPrimitiveComponent*                         AssociatedComponent                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	float UHitRegionComponent::GetHitRegionPercentHealth(class UHitRegionData* HitRegion, class UPrimitiveComponent* AssociatedComponent)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.HitRegionComponent.GetHitRegionPercentHealth");
		
		UHitRegionComponent_GetHitRegionPercentHealth_Params params {};
		params.HitRegion = HitRegion;
		params.AssociatedComponent = AssociatedComponent;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E617B0
	 * 		Name   -> Function GbxGameSystemCore.HitRegionComponent.GetHitRegionMaxHealth
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		class UHitRegionData*                              HitRegion                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UPrimitiveComponent*                         AssociatedComponent                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	float UHitRegionComponent::GetHitRegionMaxHealth(class UHitRegionData* HitRegion, class UPrimitiveComponent* AssociatedComponent)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.HitRegionComponent.GetHitRegionMaxHealth");
		
		UHitRegionComponent_GetHitRegionMaxHealth_Params params {};
		params.HitRegion = HitRegion;
		params.AssociatedComponent = AssociatedComponent;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E616F0
	 * 		Name   -> Function GbxGameSystemCore.HitRegionComponent.GetHitRegionCurrentHealth
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		class UHitRegionData*                              HitRegion                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UPrimitiveComponent*                         AssociatedComponent                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	float UHitRegionComponent::GetHitRegionCurrentHealth(class UHitRegionData* HitRegion, class UPrimitiveComponent* AssociatedComponent)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.HitRegionComponent.GetHitRegionCurrentHealth");
		
		UHitRegionComponent_GetHitRegionCurrentHealth_Params params {};
		params.HitRegion = HitRegion;
		params.AssociatedComponent = AssociatedComponent;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UHitRegionComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UHitRegionComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.HitRegionComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UHitRegionData.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UHitRegionData::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.HitRegionData");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007A5960
	 * 		Name   -> Function GbxGameSystemCore.ActorPartData.EnumeratePossibleExcluders
	 * 		Flags  -> (Final, Native, Private, HasOutParms, Const)
	 * Parameters:
	 * 		TArray<class UActorPartData*>                      OutPartList                                                (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	 */
	void UActorPartData::EnumeratePossibleExcluders(TArray<class UActorPartData*>* OutPartList)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.ActorPartData.EnumeratePossibleExcluders");
		
		UActorPartData_EnumeratePossibleExcluders_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutPartList != nullptr)
			*OutPartList = params.OutPartList;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007A5960
	 * 		Name   -> Function GbxGameSystemCore.ActorPartData.EnumeratePossibleDependencies
	 * 		Flags  -> (Final, Native, Private, HasOutParms, Const)
	 * Parameters:
	 * 		TArray<class UActorPartData*>                      OutPartList                                                (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	 */
	void UActorPartData::EnumeratePossibleDependencies(TArray<class UActorPartData*>* OutPartList)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.ActorPartData.EnumeratePossibleDependencies");
		
		UActorPartData_EnumeratePossibleDependencies_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutPartList != nullptr)
			*OutPartList = params.OutPartList;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007A5960
	 * 		Name   -> Function GbxGameSystemCore.ActorPartData.EnumerateOtherParts
	 * 		Flags  -> (Final, Native, Private, HasOutParms, Const)
	 * Parameters:
	 * 		TArray<class UActorPartData*>                      OutPartList                                                (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	 */
	void UActorPartData::EnumerateOtherParts(TArray<class UActorPartData*>* OutPartList)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.ActorPartData.EnumerateOtherParts");
		
		UActorPartData_EnumerateOtherParts_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutPartList != nullptr)
			*OutPartList = params.OutPartList;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007A5960
	 * 		Name   -> Function GbxGameSystemCore.ActorPartData.EnumerateGestaltMeshPartNames
	 * 		Flags  -> (Final, Native, Private, HasOutParms, Const)
	 * Parameters:
	 * 		TArray<class FName>                                OutPartNameList                                            (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	 */
	void UActorPartData::EnumerateGestaltMeshPartNames(TArray<class FName>* OutPartNameList)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.ActorPartData.EnumerateGestaltMeshPartNames");
		
		UActorPartData_EnumerateGestaltMeshPartNames_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutPartNameList != nullptr)
			*OutPartNameList = params.OutPartNameList;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UActorPartData.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UActorPartData::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.ActorPartData");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x014E69D0
	 * 		Name   -> Function GbxGameSystemCore.DataTableAttributeValueResolver.GetDataTableColumnNames
	 * 		Flags  -> (Final, Native, Protected, HasOutParms, Const)
	 * Parameters:
	 * 		TArray<class FString>                              ValueNames                                                 (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	 */
	void UDataTableAttributeValueResolver::GetDataTableColumnNames(TArray<class FString>* ValueNames)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.DataTableAttributeValueResolver.GetDataTableColumnNames");
		
		UDataTableAttributeValueResolver_GetDataTableColumnNames_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (ValueNames != nullptr)
			*ValueNames = params.ValueNames;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDataTableAttributeValueResolver.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDataTableAttributeValueResolver::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.DataTableAttributeValueResolver");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0178F8F0
	 * 		Name   -> Function GbxGameSystemCore.DataTableFunctionAttributeValueResolver.GetDataTableRow
	 * 		Flags  -> (Event, Protected, BlueprintEvent, Const)
	 * Parameters:
	 * 		class UObject*                                     Context                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FDataTableRowHandle UDataTableFunctionAttributeValueResolver::GetDataTableRow(class UObject* Context)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.DataTableFunctionAttributeValueResolver.GetDataTableRow");
		
		UDataTableFunctionAttributeValueResolver_GetDataTableRow_Params params {};
		params.Context = Context;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDataTableFunctionAttributeValueResolver.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDataTableFunctionAttributeValueResolver::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.DataTableFunctionAttributeValueResolver");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ULadderInteractData.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ULadderInteractData::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.LadderInteractData");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UNavComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UNavComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.NavComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E59230
	 * 		Name   -> Function GbxGameSystemCore.GbxSkeletalMeshComponent.ShowGestaltMeshParts
	 * 		Flags  -> (Final, Native, Private, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		TArray<class UGestaltPartData_Mesh*>               Parts                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		bool                                               bLocalOnly                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGbxSkeletalMeshComponent::ShowGestaltMeshParts(TArray<class UGestaltPartData_Mesh*> Parts, bool bLocalOnly)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxSkeletalMeshComponent.ShowGestaltMeshParts");
		
		UGbxSkeletalMeshComponent_ShowGestaltMeshParts_Params params {};
		params.Parts = Parts;
		params.bLocalOnly = bLocalOnly;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E59160
	 * 		Name   -> Function GbxGameSystemCore.GbxSkeletalMeshComponent.ShowGestaltMeshPart
	 * 		Flags  -> (Final, Native, Private, BlueprintCallable)
	 * Parameters:
	 * 		class UGestaltPartData_Mesh*                       GestaltMeshPart                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bLocalOnly                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGbxSkeletalMeshComponent::ShowGestaltMeshPart(class UGestaltPartData_Mesh* GestaltMeshPart, bool bLocalOnly)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxSkeletalMeshComponent.ShowGestaltMeshPart");
		
		UGbxSkeletalMeshComponent_ShowGestaltMeshPart_Params params {};
		params.GestaltMeshPart = GestaltMeshPart;
		params.bLocalOnly = bLocalOnly;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E59060
	 * 		Name   -> Function GbxGameSystemCore.GbxSkeletalMeshComponent.SetUpdateOverrideValues
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		TArray<float>                                      UpdateRateOverrides                                        (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		bool                                               bEnableOverrideProperties                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGbxSkeletalMeshComponent::SetUpdateOverrideValues(TArray<float> UpdateRateOverrides, bool bEnableOverrideProperties)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxSkeletalMeshComponent.SetUpdateOverrideValues");
		
		UGbxSkeletalMeshComponent_SetUpdateOverrideValues_Params params {};
		params.UpdateRateOverrides = UpdateRateOverrides;
		params.bEnableOverrideProperties = bEnableOverrideProperties;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E58FE0
	 * 		Name   -> Function GbxGameSystemCore.GbxSkeletalMeshComponent.SetParentAnimationComponent
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class USkeletalMeshComponent*                      ParentComponent                                            (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGbxSkeletalMeshComponent::SetParentAnimationComponent(class USkeletalMeshComponent* ParentComponent)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxSkeletalMeshComponent.SetParentAnimationComponent");
		
		UGbxSkeletalMeshComponent_SetParentAnimationComponent_Params params {};
		params.ParentComponent = ParentComponent;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E58F60
	 * 		Name   -> Function GbxGameSystemCore.GbxSkeletalMeshComponent.SetGestaltPartList
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UGestaltPartListData*                        NewGestaltPartList                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGbxSkeletalMeshComponent::SetGestaltPartList(class UGestaltPartListData* NewGestaltPartList)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxSkeletalMeshComponent.SetGestaltPartList");
		
		UGbxSkeletalMeshComponent_SetGestaltPartList_Params params {};
		params.NewGestaltPartList = NewGestaltPartList;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x005D70B0
	 * 		Name   -> Function GbxGameSystemCore.GbxSkeletalMeshComponent.RunPoseTest
	 * 		Flags  -> (Final, Native, Private)
	 */
	void UGbxSkeletalMeshComponent::RunPoseTest()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxSkeletalMeshComponent.RunPoseTest");
		
		UGbxSkeletalMeshComponent_RunPoseTest_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E58EB0
	 * 		Name   -> Function GbxGameSystemCore.GbxSkeletalMeshComponent.OnRep_GlobalBoneMod
	 * 		Flags  -> (Final, Native, Public)
	 */
	void UGbxSkeletalMeshComponent::OnRep_GlobalBoneMod()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxSkeletalMeshComponent.OnRep_GlobalBoneMod");
		
		UGbxSkeletalMeshComponent_OnRep_GlobalBoneMod_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E58E90
	 * 		Name   -> Function GbxGameSystemCore.GbxSkeletalMeshComponent.OnRep_GestaltMeshParts
	 * 		Flags  -> (Final, Native, Private)
	 */
	void UGbxSkeletalMeshComponent::OnRep_GestaltMeshParts()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxSkeletalMeshComponent.OnRep_GestaltMeshParts");
		
		UGbxSkeletalMeshComponent_OnRep_GestaltMeshParts_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E58D60
	 * 		Name   -> Function GbxGameSystemCore.GbxSkeletalMeshComponent.LinkSkelMeshAnimInstances
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		TArray<class USkeletalMeshComponent*>              InLinkedSkelMeshComponents                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	void UGbxSkeletalMeshComponent::LinkSkelMeshAnimInstances(TArray<class USkeletalMeshComponent*> InLinkedSkelMeshComponents)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxSkeletalMeshComponent.LinkSkelMeshAnimInstances");
		
		UGbxSkeletalMeshComponent_LinkSkelMeshAnimInstances_Params params {};
		params.InLinkedSkelMeshComponents = InLinkedSkelMeshComponents;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E58CE0
	 * 		Name   -> Function GbxGameSystemCore.GbxSkeletalMeshComponent.LinkSkelMeshAnimInstance
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class USkeletalMeshComponent*                      InLinkedSkelMeshComponent                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGbxSkeletalMeshComponent::LinkSkelMeshAnimInstance(class USkeletalMeshComponent* InLinkedSkelMeshComponent)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxSkeletalMeshComponent.LinkSkelMeshAnimInstance");
		
		UGbxSkeletalMeshComponent_LinkSkelMeshAnimInstance_Params params {};
		params.InLinkedSkelMeshComponent = InLinkedSkelMeshComponent;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E58C50
	 * 		Name   -> Function GbxGameSystemCore.GbxSkeletalMeshComponent.IsGestaltMeshPartVisible
	 * 		Flags  -> (Final, Native, Private, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		class UGestaltPartData_Mesh*                       GestaltMeshPart                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UGbxSkeletalMeshComponent::IsGestaltMeshPartVisible(class UGestaltPartData_Mesh* GestaltMeshPart)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxSkeletalMeshComponent.IsGestaltMeshPartVisible");
		
		UGbxSkeletalMeshComponent_IsGestaltMeshPartVisible_Params params {};
		params.GestaltMeshPart = GestaltMeshPart;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E58BC0
	 * 		Name   -> Function GbxGameSystemCore.GbxSkeletalMeshComponent.IsCustomizationTargetFor
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		class UGbxCustomizationTargetData*                 TargetToTest                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UGbxSkeletalMeshComponent::IsCustomizationTargetFor(class UGbxCustomizationTargetData* TargetToTest)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxSkeletalMeshComponent.IsCustomizationTargetFor");
		
		UGbxSkeletalMeshComponent_IsCustomizationTargetFor_Params params {};
		params.TargetToTest = TargetToTest;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E58AC0
	 * 		Name   -> Function GbxGameSystemCore.GbxSkeletalMeshComponent.HideGestaltMeshParts
	 * 		Flags  -> (Final, Native, Private, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		TArray<class UGestaltPartData_Mesh*>               Parts                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		bool                                               bLocalOnly                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGbxSkeletalMeshComponent::HideGestaltMeshParts(TArray<class UGestaltPartData_Mesh*> Parts, bool bLocalOnly)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxSkeletalMeshComponent.HideGestaltMeshParts");
		
		UGbxSkeletalMeshComponent_HideGestaltMeshParts_Params params {};
		params.Parts = Parts;
		params.bLocalOnly = bLocalOnly;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E589F0
	 * 		Name   -> Function GbxGameSystemCore.GbxSkeletalMeshComponent.HideGestaltMeshPart
	 * 		Flags  -> (Final, Native, Private, BlueprintCallable)
	 * Parameters:
	 * 		class UGestaltPartData_Mesh*                       GestaltMeshPart                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bLocalOnly                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGbxSkeletalMeshComponent::HideGestaltMeshPart(class UGestaltPartData_Mesh* GestaltMeshPart, bool bLocalOnly)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxSkeletalMeshComponent.HideGestaltMeshPart");
		
		UGbxSkeletalMeshComponent_HideGestaltMeshPart_Params params {};
		params.GestaltMeshPart = GestaltMeshPart;
		params.bLocalOnly = bLocalOnly;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E58970
	 * 		Name   -> Function GbxGameSystemCore.GbxSkeletalMeshComponent.GetUpdateOverrideValues
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	TArray<float> UGbxSkeletalMeshComponent::GetUpdateOverrideValues()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxSkeletalMeshComponent.GetUpdateOverrideValues");
		
		UGbxSkeletalMeshComponent_GetUpdateOverrideValues_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007A5960
	 * 		Name   -> Function GbxGameSystemCore.GbxSkeletalMeshComponent.GetAvailableBoneNames
	 * 		Flags  -> (Final, Native, Private, HasOutParms, Const)
	 * Parameters:
	 * 		TArray<class FName>                                Array                                                      (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	 */
	void UGbxSkeletalMeshComponent::GetAvailableBoneNames(TArray<class FName>* Array)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxSkeletalMeshComponent.GetAvailableBoneNames");
		
		UGbxSkeletalMeshComponent_GetAvailableBoneNames_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (Array != nullptr)
			*Array = params.Array;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E58850
	 * 		Name   -> Function GbxGameSystemCore.GbxSkeletalMeshComponent.CopyGestaltPartList
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class AActor*                                      GestaltPartListSource                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGbxSkeletalMeshComponent::CopyGestaltPartList(class AActor* GestaltPartListSource)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxSkeletalMeshComponent.CopyGestaltPartList");
		
		UGbxSkeletalMeshComponent_CopyGestaltPartList_Params params {};
		params.GestaltPartListSource = GestaltPartListSource;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGbxSkeletalMeshComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGbxSkeletalMeshComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.GbxSkeletalMeshComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E68D30
	 * 		Name   -> Function GbxGameSystemCore.PawnAttachSlotComponent.SetPersistentAttachSocketName
	 * 		Flags  -> (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class FName                                        SocketName                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UPawnAttachSlotComponent::SetPersistentAttachSocketName(const class FName& SocketName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.PawnAttachSlotComponent.SetPersistentAttachSocketName");
		
		UPawnAttachSlotComponent_SetPersistentAttachSocketName_Params params {};
		params.SocketName = SocketName;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E68C70
	 * 		Name   -> Function GbxGameSystemCore.PawnAttachSlotComponent.SetDetachabilityLocked
	 * 		Flags  -> (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bLock                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FName                                        Reason                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UPawnAttachSlotComponent::SetDetachabilityLocked(bool bLock, const class FName& Reason)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.PawnAttachSlotComponent.SetDetachabilityLocked");
		
		UPawnAttachSlotComponent_SetDetachabilityLocked_Params params {};
		params.bLock = bLock;
		params.Reason = Reason;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E68B30
	 * 		Name   -> Function GbxGameSystemCore.PawnAttachSlotComponent.RequestDetachPawn
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void UPawnAttachSlotComponent::RequestDetachPawn()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.PawnAttachSlotComponent.RequestDetachPawn");
		
		UPawnAttachSlotComponent_RequestDetachPawn_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E689F0
	 * 		Name   -> Function GbxGameSystemCore.PawnAttachSlotComponent.OnRep_AttachState
	 * 		Flags  -> (Final, Native, Private)
	 */
	void UPawnAttachSlotComponent::OnRep_AttachState()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.PawnAttachSlotComponent.OnRep_AttachState");
		
		UPawnAttachSlotComponent_OnRep_AttachState_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E689D0
	 * 		Name   -> Function GbxGameSystemCore.PawnAttachSlotComponent.ManuallyFinishAttach
	 * 		Flags  -> (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
	 */
	void UPawnAttachSlotComponent::ManuallyFinishAttach()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.PawnAttachSlotComponent.ManuallyFinishAttach");
		
		UPawnAttachSlotComponent_ManuallyFinishAttach_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E68940
	 * 		Name   -> Function GbxGameSystemCore.PawnAttachSlotComponent.IsOccupied
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		bool                                               bIncludeDetaching                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UPawnAttachSlotComponent::IsOccupied(bool bIncludeDetaching)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.PawnAttachSlotComponent.IsOccupied");
		
		UPawnAttachSlotComponent_IsOccupied_Params params {};
		params.bIncludeDetaching = bIncludeDetaching;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E688C0
	 * 		Name   -> Function GbxGameSystemCore.PawnAttachSlotComponent.HandleActorDestroyed
	 * 		Flags  -> (Final, Native, Private)
	 * Parameters:
	 * 		class AActor*                                      Actor                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UPawnAttachSlotComponent::HandleActorDestroyed(class AActor* Actor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.PawnAttachSlotComponent.HandleActorDestroyed");
		
		UPawnAttachSlotComponent_HandleActorDestroyed_Params params {};
		params.Actor = Actor;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E68860
	 * 		Name   -> Function GbxGameSystemCore.PawnAttachSlotComponent.GetPersistentAttachSocketTransform
	 * 		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
	 */
	struct FTransform UPawnAttachSlotComponent::GetPersistentAttachSocketTransform()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.PawnAttachSlotComponent.GetPersistentAttachSocketTransform");
		
		UPawnAttachSlotComponent_GetPersistentAttachSocketTransform_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E687C0
	 * 		Name   -> Function GbxGameSystemCore.PawnAttachSlotComponent.GetOccupant
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		bool                                               bIncludeDetaching                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class APawn* UPawnAttachSlotComponent::GetOccupant(bool bIncludeDetaching)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.PawnAttachSlotComponent.GetOccupant");
		
		UPawnAttachSlotComponent_GetOccupant_Params params {};
		params.bIncludeDetaching = bIncludeDetaching;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E687A0
	 * 		Name   -> Function GbxGameSystemCore.PawnAttachSlotComponent.GetAttachStatus
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	EPawnAttachStatus UPawnAttachSlotComponent::GetAttachStatus()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.PawnAttachSlotComponent.GetAttachStatus");
		
		UPawnAttachSlotComponent_GetAttachStatus_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E68490
	 * 		Name   -> Function GbxGameSystemCore.PawnAttachSlotComponent.DetachPawn
	 * 		Flags  -> (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bInstant                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bSkipPlacement                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UPawnAttachSlotComponent::DetachPawn(bool bInstant, bool bSkipPlacement)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.PawnAttachSlotComponent.DetachPawn");
		
		UPawnAttachSlotComponent_DetachPawn_Params params {};
		params.bInstant = bInstant;
		params.bSkipPlacement = bSkipPlacement;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E68290
	 * 		Name   -> Function GbxGameSystemCore.PawnAttachSlotComponent.AttachPawn
	 * 		Flags  -> (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class APawn*                                       AttachingPawn                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bInstant                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UPawnAttachSlotComponent::AttachPawn(class APawn* AttachingPawn, bool bInstant)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.PawnAttachSlotComponent.AttachPawn");
		
		UPawnAttachSlotComponent_AttachPawn_Params params {};
		params.AttachingPawn = AttachingPawn;
		params.bInstant = bInstant;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UPawnAttachSlotComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UPawnAttachSlotComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.PawnAttachSlotComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGbxProfile.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGbxProfile::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.GbxProfile");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E6C660
	 * 		Name   -> Function GbxGameSystemCore.RadiusDamageReplicationManager.Multicast_StopRadiusEffect
	 * 		Flags  -> (Net, NetReliable, Native, Event, NetMulticast, Public)
	 * Parameters:
	 * 		class AActor*                                      ContextActor                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UClass*                                      DamageData                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bStopAllForContext                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARadiusDamageReplicationManager::Multicast_StopRadiusEffect(class AActor* ContextActor, class UClass* DamageData, bool bStopAllForContext)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.RadiusDamageReplicationManager.Multicast_StopRadiusEffect");
		
		ARadiusDamageReplicationManager_Multicast_StopRadiusEffect_Params params {};
		params.ContextActor = ContextActor;
		params.DamageData = DamageData;
		params.bStopAllForContext = bStopAllForContext;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E6C310
	 * 		Name   -> Function GbxGameSystemCore.RadiusDamageReplicationManager.Multicast_ProcessRadiusRequest
	 * 		Flags  -> (Net, Native, Event, NetMulticast, Public)
	 * Parameters:
	 * 		class AActor*                                      ContextActor                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UClass*                                      DamageData                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UClass*                                      DamageType                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Radius                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector_NetQuantize                         Location                                                   (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Damage                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UExplosionData*                              ExplosionData                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UParticleSystem*                             DefaultParticles                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UWwiseEvent*                                 DefaultAudioEvent                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UImpactData*                                 DefaultImpactData                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FGbxSignificanceEvent                       SignificanceEvent                                          (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 * 		float                                              Force                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARadiusDamageReplicationManager::Multicast_ProcessRadiusRequest(class AActor* ContextActor, class UClass* DamageData, class UClass* DamageType, float Radius, const struct FVector_NetQuantize& Location, float Damage, class UExplosionData* ExplosionData, class UParticleSystem* DefaultParticles, class UWwiseEvent* DefaultAudioEvent, class UImpactData* DefaultImpactData, const struct FGbxSignificanceEvent& SignificanceEvent, float Force)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.RadiusDamageReplicationManager.Multicast_ProcessRadiusRequest");
		
		ARadiusDamageReplicationManager_Multicast_ProcessRadiusRequest_Params params {};
		params.ContextActor = ContextActor;
		params.DamageData = DamageData;
		params.DamageType = DamageType;
		params.Radius = Radius;
		params.Location = Location;
		params.Damage = Damage;
		params.ExplosionData = ExplosionData;
		params.DefaultParticles = DefaultParticles;
		params.DefaultAudioEvent = DefaultAudioEvent;
		params.DefaultImpactData = DefaultImpactData;
		params.SignificanceEvent = SignificanceEvent;
		params.Force = Force;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ARadiusDamageReplicationManager.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ARadiusDamageReplicationManager::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.RadiusDamageReplicationManager");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URecentDamageTrackingComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URecentDamageTrackingComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.RecentDamageTrackingComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGbxSaveGame.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGbxSaveGame::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.GbxSaveGame");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction USaveGameChannel.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* USaveGameChannel::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.SaveGameChannel");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGbxSignificanceManager.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGbxSignificanceManager::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.GbxSignificanceManager");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGbxSingletons.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGbxSingletons::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.GbxSingletons");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UStanceDataSelector.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UStanceDataSelector::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.StanceDataSelector");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UStatusEffectGlobalsData.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UStatusEffectGlobalsData::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.StatusEffectGlobalsData");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E74B10
	 * 		Name   -> Function GbxGameSystemCore.StatusEffectManagerComponent.RemoveStatusEffectInstance
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		struct FStatusEffectInstanceReference              Reference                                                  (Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	bool UStatusEffectManagerComponent::RemoveStatusEffectInstance(struct FStatusEffectInstanceReference* Reference)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.StatusEffectManagerComponent.RemoveStatusEffectInstance");
		
		UStatusEffectManagerComponent_RemoveStatusEffectInstance_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (Reference != nullptr)
			*Reference = params.Reference;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E74A60
	 * 		Name   -> Function GbxGameSystemCore.StatusEffectManagerComponent.RemoveStatusEffect
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		struct FStatusEffectRemoveSpec                     Spec                                                       (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	bool UStatusEffectManagerComponent::RemoveStatusEffect(const struct FStatusEffectRemoveSpec& Spec)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.StatusEffectManagerComponent.RemoveStatusEffect");
		
		UStatusEffectManagerComponent_RemoveStatusEffect_Params params {};
		params.Spec = Spec;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E749B0
	 * 		Name   -> Function GbxGameSystemCore.StatusEffectManagerComponent.QueryStatusEffect
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		struct FStatusEffectQuery                          Query                                                      (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	struct FStatusEffectQueryResult UStatusEffectManagerComponent::QueryStatusEffect(const struct FStatusEffectQuery& Query)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.StatusEffectManagerComponent.QueryStatusEffect");
		
		UStatusEffectManagerComponent_QueryStatusEffect_Params params {};
		params.Query = Query;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E742A0
	 * 		Name   -> Function GbxGameSystemCore.StatusEffectManagerComponent.AddStatusEffect
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		struct FStatusEffectSpec                           Spec                                                       (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	struct FStatusEffectInstanceReference UStatusEffectManagerComponent::AddStatusEffect(const struct FStatusEffectSpec& Spec)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.StatusEffectManagerComponent.AddStatusEffect");
		
		UStatusEffectManagerComponent_AddStatusEffect_Params params {};
		params.Spec = Spec;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UStatusEffectManagerComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UStatusEffectManagerComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.StatusEffectManagerComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E79110
	 * 		Name   -> Function GbxGameSystemCore.StatusEffectsStatics.RemoveStatusEffectInstance
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		class AActor*                                      Target                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FStatusEffectInstanceReference              Reference                                                  (Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	bool UStatusEffectsStatics::STATIC_RemoveStatusEffectInstance(class AActor* Target, struct FStatusEffectInstanceReference* Reference)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.StatusEffectsStatics.RemoveStatusEffectInstance");
		
		UStatusEffectsStatics_RemoveStatusEffectInstance_Params params {};
		params.Target = Target;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (Reference != nullptr)
			*Reference = params.Reference;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E79030
	 * 		Name   -> Function GbxGameSystemCore.StatusEffectsStatics.RemoveStatusEffect
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		class AActor*                                      Target                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FStatusEffectRemoveSpec                     RemoveSpec                                                 (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	bool UStatusEffectsStatics::STATIC_RemoveStatusEffect(class AActor* Target, const struct FStatusEffectRemoveSpec& RemoveSpec)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.StatusEffectsStatics.RemoveStatusEffect");
		
		UStatusEffectsStatics_RemoveStatusEffect_Params params {};
		params.Target = Target;
		params.RemoveSpec = RemoveSpec;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E78F50
	 * 		Name   -> Function GbxGameSystemCore.StatusEffectsStatics.QueryStatusEffect
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		class AActor*                                      Target                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FStatusEffectQuery                          Query                                                      (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	struct FStatusEffectQueryResult UStatusEffectsStatics::STATIC_QueryStatusEffect(class AActor* Target, const struct FStatusEffectQuery& Query)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.StatusEffectsStatics.QueryStatusEffect");
		
		UStatusEffectsStatics_QueryStatusEffect_Params params {};
		params.Target = Target;
		params.Query = Query;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E76EF0
	 * 		Name   -> Function GbxGameSystemCore.StatusEffectsStatics.AddStatusEffect
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		class AActor*                                      Target                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FStatusEffectSpec                           Spec                                                       (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	struct FStatusEffectInstanceReference UStatusEffectsStatics::STATIC_AddStatusEffect(class AActor* Target, const struct FStatusEffectSpec& Spec)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.StatusEffectsStatics.AddStatusEffect");
		
		UStatusEffectsStatics_AddStatusEffect_Params params {};
		params.Target = Target;
		params.Spec = Spec;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UStatusEffectsStatics.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UStatusEffectsStatics::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.StatusEffectsStatics");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E81F50
	 * 		Name   -> Function GbxGameSystemCore.UseComponent.StopUsingCurrentObject
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		EUsabilityType                                     UseType                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UUseComponent::StopUsingCurrentObject(EUsabilityType UseType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.UseComponent.StopUsingCurrentObject");
		
		UUseComponent_StopUsingCurrentObject_Params params {};
		params.UseType = UseType;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E81ED0
	 * 		Name   -> Function GbxGameSystemCore.UseComponent.StartUsingCurrentObject
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		EUsabilityType                                     UseType                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UUseComponent::StartUsingCurrentObject(EUsabilityType UseType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.UseComponent.StartUsingCurrentObject");
		
		UUseComponent_StartUsingCurrentObject_Params params {};
		params.UseType = UseType;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E81CD0
	 * 		Name   -> Function GbxGameSystemCore.UseComponent.ServerUseObject
	 * 		Flags  -> (Final, Net, NetReliable, Native, Event, Private, NetServer, NetValidate)
	 * Parameters:
	 * 		class UUsableComponent*                            UsableObject                                               (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EUsabilityType                                     UseType                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bHeld                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UUseComponent::ServerUseObject(class UUsableComponent* UsableObject, EUsabilityType UseType, bool bHeld)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.UseComponent.ServerUseObject");
		
		UUseComponent_ServerUseObject_Params params {};
		params.UsableObject = UsableObject;
		params.UseType = UseType;
		params.bHeld = bHeld;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E81BD0
	 * 		Name   -> Function GbxGameSystemCore.UseComponent.ServerStopUsingObject
	 * 		Flags  -> (Final, Net, NetReliable, Native, Event, Private, NetServer, NetValidate)
	 * Parameters:
	 * 		class UUsableComponent*                            UsableObject                                               (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EUsabilityType                                     UseType                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UUseComponent::ServerStopUsingObject(class UUsableComponent* UsableObject, EUsabilityType UseType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.UseComponent.ServerStopUsingObject");
		
		UUseComponent_ServerStopUsingObject_Params params {};
		params.UsableObject = UsableObject;
		params.UseType = UseType;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E81AD0
	 * 		Name   -> Function GbxGameSystemCore.UseComponent.ServerStartUsingObject
	 * 		Flags  -> (Final, Net, NetReliable, Native, Event, Private, NetServer, NetValidate)
	 * Parameters:
	 * 		class UUsableComponent*                            UsableObject                                               (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EUsabilityType                                     UseType                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UUseComponent::ServerStartUsingObject(class UUsableComponent* UsableObject, EUsabilityType UseType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.UseComponent.ServerStartUsingObject");
		
		UUseComponent_ServerStartUsingObject_Params params {};
		params.UsableObject = UsableObject;
		params.UseType = UseType;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0178F8F0
	 * 		Name   -> DelegateFunction GbxGameSystemCore.UseComponent.OnUsableChanged__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate, HasOutParms, HasDefaults)
	 * Parameters:
	 * 		class UUsableComponent*                            NewUsableComponent                                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FUsabilityInfo                              InUsabilityInfo                                            (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     NewUsableComponentImpactPoint                              (Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              NewUsableComponentDistanceAway                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UUseComponent::OnUsableChanged__DelegateSignature(class UUsableComponent* NewUsableComponent, const struct FUsabilityInfo& InUsabilityInfo, const struct FVector& NewUsableComponentImpactPoint, float NewUsableComponentDistanceAway)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction GbxGameSystemCore.UseComponent.OnUsableChanged__DelegateSignature");
		
		UUseComponent_OnUsableChanged__DelegateSignature_Params params {};
		params.NewUsableComponent = NewUsableComponent;
		params.InUsabilityInfo = InUsabilityInfo;
		params.NewUsableComponentImpactPoint = NewUsableComponentImpactPoint;
		params.NewUsableComponentDistanceAway = NewUsableComponentDistanceAway;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0178F8F0
	 * 		Name   -> DelegateFunction GbxGameSystemCore.UseComponent.OnUsabilityChanged__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate, HasOutParms)
	 * Parameters:
	 * 		class UUsableComponent*                            NewUsableComponent                                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FUsabilityInfo                              InUsabilityInfo                                            (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UUseComponent::OnUsabilityChanged__DelegateSignature(class UUsableComponent* NewUsableComponent, const struct FUsabilityInfo& InUsabilityInfo)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction GbxGameSystemCore.UseComponent.OnUsabilityChanged__DelegateSignature");
		
		UUseComponent_OnUsabilityChanged__DelegateSignature_Params params {};
		params.NewUsableComponent = NewUsableComponent;
		params.InUsabilityInfo = InUsabilityInfo;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0178F8F0
	 * 		Name   -> DelegateFunction GbxGameSystemCore.UseComponent.OnUnableToAffordUsableObject__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 * Parameters:
	 * 		class UUsableComponent*                            Usable                                                     (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EUsabilityType                                     UseType                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bUseHeld                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UUseComponent::OnUnableToAffordUsableObject__DelegateSignature(class UUsableComponent* Usable, EUsabilityType UseType, bool bUseHeld)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction GbxGameSystemCore.UseComponent.OnUnableToAffordUsableObject__DelegateSignature");
		
		UUseComponent_OnUnableToAffordUsableObject__DelegateSignature_Params params {};
		params.Usable = Usable;
		params.UseType = UseType;
		params.bUseHeld = bUseHeld;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0178F8F0
	 * 		Name   -> DelegateFunction GbxGameSystemCore.UseComponent.OnImpactDataChanged__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate, HasDefaults)
	 * Parameters:
	 * 		class UUsableComponent*                            NewUsableComponent                                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     NewUsableComponentImpactPoint                              (Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              NewUsableComponentDistanceAway                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UUseComponent::OnImpactDataChanged__DelegateSignature(class UUsableComponent* NewUsableComponent, const struct FVector& NewUsableComponentImpactPoint, float NewUsableComponentDistanceAway)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction GbxGameSystemCore.UseComponent.OnImpactDataChanged__DelegateSignature");
		
		UUseComponent_OnImpactDataChanged__DelegateSignature_Params params {};
		params.NewUsableComponent = NewUsableComponent;
		params.NewUsableComponentImpactPoint = NewUsableComponentImpactPoint;
		params.NewUsableComponentDistanceAway = NewUsableComponentDistanceAway;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0178F8F0
	 * 		Name   -> DelegateFunction GbxGameSystemCore.UseComponent.OnHoldUseStopped__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 */
	void UUseComponent::OnHoldUseStopped__DelegateSignature()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction GbxGameSystemCore.UseComponent.OnHoldUseStopped__DelegateSignature");
		
		UUseComponent_OnHoldUseStopped__DelegateSignature_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E81940
	 * 		Name   -> Function GbxGameSystemCore.UseComponent.GetCurrentUsable
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	class UUsableComponent* UUseComponent::GetCurrentUsable()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.UseComponent.GetCurrentUsable");
		
		UUseComponent_GetCurrentUsable_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E818C0
	 * 		Name   -> Function GbxGameSystemCore.UseComponent.ForceUsingObject
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UUsableComponent*                            UsableObject                                               (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UUseComponent::ForceUsingObject(class UUsableComponent* UsableObject)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.UseComponent.ForceUsingObject");
		
		UUseComponent_ForceUsingObject_Params params {};
		params.UsableObject = UsableObject;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E817C0
	 * 		Name   -> Function GbxGameSystemCore.UseComponent.ClientNotifyAttemptedUseCouldNotAfford
	 * 		Flags  -> (Final, Net, Native, Event, Private, NetClient)
	 * Parameters:
	 * 		class UUsableComponent*                            Usable                                                     (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EUsabilityType                                     UseType                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bUseHeld                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UUseComponent::ClientNotifyAttemptedUseCouldNotAfford(class UUsableComponent* Usable, EUsabilityType UseType, bool bUseHeld)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.UseComponent.ClientNotifyAttemptedUseCouldNotAfford");
		
		UUseComponent_ClientNotifyAttemptedUseCouldNotAfford_Params params {};
		params.Usable = Usable;
		params.UseType = UseType;
		params.bUseHeld = bUseHeld;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E81730
	 * 		Name   -> Function GbxGameSystemCore.UseComponent.CanUseCurrentUsable
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		EUsabilityType                                     Type                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UUseComponent::CanUseCurrentUsable(EUsabilityType Type)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.UseComponent.CanUseCurrentUsable");
		
		UUseComponent_CanUseCurrentUsable_Params params {};
		params.Type = Type;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E816A0
	 * 		Name   -> Function GbxGameSystemCore.UseComponent.CanInteractWithCurrentUsable
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		EUsabilityType                                     Type                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UUseComponent::CanInteractWithCurrentUsable(EUsabilityType Type)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.UseComponent.CanInteractWithCurrentUsable");
		
		UUseComponent_CanInteractWithCurrentUsable_Params params {};
		params.Type = Type;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UUseComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UUseComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.UseComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ULevelGroupData.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ULevelGroupData::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.LevelGroupData");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02DF31A0
	 * 		Name   -> Function GbxGameSystemCore.ActorPartSetData.EnumeratePartListForPartType
	 * 		Flags  -> (Native, Protected, HasOutParms, Const)
	 * Parameters:
	 * 		unsigned char                                      PartType                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		TArray<class UActorPartData*>                      OutPartList                                                (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	 */
	void UActorPartSetData::EnumeratePartListForPartType(unsigned char PartType, TArray<class UActorPartData*>* OutPartList)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.ActorPartSetData.EnumeratePartListForPartType");
		
		UActorPartSetData_EnumeratePartListForPartType_Params params {};
		params.PartType = PartType;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutPartList != nullptr)
			*OutPartList = params.OutPartList;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UActorPartSetData.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UActorPartSetData::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.ActorPartSetData");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction APrototypeActor.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* APrototypeActor::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.PrototypeActor");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UStatusEffectStackingStrategyData.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UStatusEffectStackingStrategyData::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.StatusEffectStackingStrategyData");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UUIStatData_Attribute.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UUIStatData_Attribute::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.UIStatData_Attribute");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UUIStatFormulaEvaluator.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UUIStatFormulaEvaluator::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.UIStatFormulaEvaluator");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGbxWeaponSlotData.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGbxWeaponSlotData::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.GbxWeaponSlotData");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ULevelData.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ULevelData::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.LevelData");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UActorAttributeContextResolver.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UActorAttributeContextResolver::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.ActorAttributeContextResolver");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UAIChargeData.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UAIChargeData::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.AIChargeData");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UAIDataProvider_AttributeData.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UAIDataProvider_AttributeData::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.AIDataProvider_AttributeData");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UAIDataProvider_AttributeInitializationData.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UAIDataProvider_AttributeInitializationData::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.AIDataProvider_AttributeInitializationData");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UAIDataProvider_AttributeInitializer.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UAIDataProvider_AttributeInitializer::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.AIDataProvider_AttributeInitializer");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02DF38D0
	 * 		Name   -> Function GbxGameSystemCore.AIDodgeComponent.TriggerZoneDodge
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      TargetActor                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     ZoneLoc                                                    (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     ZoneVel                                                    (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      ActorRef                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UAIDodgeComponent::STATIC_TriggerZoneDodge(class UObject* WorldContextObject, class AActor* TargetActor, const struct FVector& ZoneLoc, const struct FVector& ZoneVel, class AActor* ActorRef)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.AIDodgeComponent.TriggerZoneDodge");
		
		UAIDodgeComponent_TriggerZoneDodge_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.TargetActor = TargetActor;
		params.ZoneLoc = ZoneLoc;
		params.ZoneVel = ZoneVel;
		params.ActorRef = ActorRef;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02DF3780
	 * 		Name   -> Function GbxGameSystemCore.AIDodgeComponent.TriggerGrenadeDodge
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     GrenadeLoc                                                 (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      Instigator                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              ExtraDelay                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UAIDodgeComponent::STATIC_TriggerGrenadeDodge(class UObject* WorldContextObject, const struct FVector& GrenadeLoc, class AActor* Instigator, float ExtraDelay)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.AIDodgeComponent.TriggerGrenadeDodge");
		
		UAIDodgeComponent_TriggerGrenadeDodge_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.GrenadeLoc = GrenadeLoc;
		params.Instigator = Instigator;
		params.ExtraDelay = ExtraDelay;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02DF35C0
	 * 		Name   -> Function GbxGameSystemCore.AIDodgeComponent.TriggerDodge
	 * 		Flags  -> (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		EAIDodgeType                                       Type                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     SourceLoc                                                  (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      SourceActor                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              ExtraDelay                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bForced                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UAIDodgeComponent::TriggerDodge(EAIDodgeType Type, const struct FVector& SourceLoc, class AActor* SourceActor, float ExtraDelay, bool bForced)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.AIDodgeComponent.TriggerDodge");
		
		UAIDodgeComponent_TriggerDodge_Params params {};
		params.Type = Type;
		params.SourceLoc = SourceLoc;
		params.SourceActor = SourceActor;
		params.ExtraDelay = ExtraDelay;
		params.bForced = bForced;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02DF3470
	 * 		Name   -> Function GbxGameSystemCore.AIDodgeComponent.TriggerBulletDodge
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     MuzzleLoc                                                  (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     BulletVel                                                  (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      Instigator                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UAIDodgeComponent::STATIC_TriggerBulletDodge(class UObject* WorldContextObject, const struct FVector& MuzzleLoc, const struct FVector& BulletVel, class AActor* Instigator)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.AIDodgeComponent.TriggerBulletDodge");
		
		UAIDodgeComponent_TriggerBulletDodge_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.MuzzleLoc = MuzzleLoc;
		params.BulletVel = BulletVel;
		params.Instigator = Instigator;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UAIDodgeComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UAIDodgeComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.AIDodgeComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UAimControlData.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UAimControlData::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.AimControlData");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02DF3290
	 * 		Name   -> Function GbxGameSystemCore.AISense_Bullet.ReportBulletEvent
	 * 		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		class UObject*                                     WorldContext                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     StartLoc                                                   (Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     EndLoc                                                     (Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bFirstEvent                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      Instigator                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Strength                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UAISense_Bullet::STATIC_ReportBulletEvent(class UObject* WorldContext, const struct FVector& StartLoc, const struct FVector& EndLoc, bool bFirstEvent, class AActor* Instigator, float Strength)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.AISense_Bullet.ReportBulletEvent");
		
		UAISense_Bullet_ReportBulletEvent_Params params {};
		params.WorldContext = WorldContext;
		params.StartLoc = StartLoc;
		params.EndLoc = EndLoc;
		params.bFirstEvent = bFirstEvent;
		params.Instigator = Instigator;
		params.Strength = Strength;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UAISense_Bullet.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UAISense_Bullet::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.AISense_Bullet");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UAISense_GbxPrediction.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UAISense_GbxPrediction::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.AISense_GbxPrediction");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02DF7AA0
	 * 		Name   -> Function GbxGameSystemCore.AISense_GbxSight.ForceSightEvent
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UObject*                                     WorldContext                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      SeenActor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      LookingActor                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UAISense_GbxSight::STATIC_ForceSightEvent(class UObject* WorldContext, class AActor* SeenActor, class AActor* LookingActor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.AISense_GbxSight.ForceSightEvent");
		
		UAISense_GbxSight_ForceSightEvent_Params params {};
		params.WorldContext = WorldContext;
		params.SeenActor = SeenActor;
		params.LookingActor = LookingActor;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UAISense_GbxSight.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UAISense_GbxSight::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.AISense_GbxSight");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UAISenseConfig_Bullet.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UAISenseConfig_Bullet::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.AISenseConfig_Bullet");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UAISenseConfig_GbxPrediction.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UAISenseConfig_GbxPrediction::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.AISenseConfig_GbxPrediction");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UAnimNotify_CanInterruptAnim.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UAnimNotify_CanInterruptAnim::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.AnimNotify_CanInterruptAnim");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UAnimNotify_CauseDamage.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UAnimNotify_CauseDamage::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.AnimNotify_CauseDamage");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UAnimNotify_Feedback.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UAnimNotify_Feedback::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.AnimNotify_Feedback");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UAnimNotify_Footstep.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UAnimNotify_Footstep::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.AnimNotify_Footstep");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UAnimNotify_GbxAction.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UAnimNotify_GbxAction::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.AnimNotify_GbxAction");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UAnimNotify_HandPlant.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UAnimNotify_HandPlant::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.AnimNotify_HandPlant");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UAnimNotify_PlayJumpedImpact.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UAnimNotify_PlayJumpedImpact::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.AnimNotify_PlayJumpedImpact");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UAnimNotify_PlayLandedImpact.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UAnimNotify_PlayLandedImpact::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.AnimNotify_PlayLandedImpact");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UAnimNotify_SetRagdollObjectHoldTransform.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UAnimNotify_SetRagdollObjectHoldTransform::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.AnimNotify_SetRagdollObjectHoldTransform");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UAnimNotify_StretchBonesMarker.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UAnimNotify_StretchBonesMarker::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.AnimNotify_StretchBonesMarker");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UAnimNotifyState_DeathOverride.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UAnimNotifyState_DeathOverride::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.AnimNotifyState_DeathOverride");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UAnimNotifyState_DisableLegIK.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UAnimNotifyState_DisableLegIK::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.AnimNotifyState_DisableLegIK");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UAnimNotifyState_DisableLegIKTracing.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UAnimNotifyState_DisableLegIKTracing::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.AnimNotifyState_DisableLegIKTracing");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UAnimNotifyState_DisableLookAt.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UAnimNotifyState_DisableLookAt::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.AnimNotifyState_DisableLookAt");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UAnimNotifyState_Feedback.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UAnimNotifyState_Feedback::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.AnimNotifyState_Feedback");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UAnimNotifyState_GbxAction.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UAnimNotifyState_GbxAction::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.AnimNotifyState_GbxAction");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UAnimNotifyState_RootMotionRotation.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UAnimNotifyState_RootMotionRotation::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.AnimNotifyState_RootMotionRotation");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UAnimNotifyState_SoftAlign.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UAnimNotifyState_SoftAlign::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.AnimNotifyState_SoftAlign");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UAnimNotifyState_StretchAction.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UAnimNotifyState_StretchAction::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.AnimNotifyState_StretchAction");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UAnimNotifyState_StretchBonesMarker.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UAnimNotifyState_StretchBonesMarker::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.AnimNotifyState_StretchBonesMarker");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UAsyncExplosionImpactManager.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UAsyncExplosionImpactManager::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.AsyncExplosionImpactManager");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UAttributeEffectMultiMutatorData.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UAttributeEffectMultiMutatorData::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.AttributeEffectMultiMutatorData");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02DF7950
	 * 		Name   -> Function GbxGameSystemCore.AttributeInitializer.EvaluateBalanceFormula
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		float                                              Multiplier                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Level                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Power                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Offset                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	float UAttributeInitializer::STATIC_EvaluateBalanceFormula(float Multiplier, float Level, float Power, float Offset)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.AttributeInitializer.EvaluateBalanceFormula");
		
		UAttributeInitializer_EvaluateBalanceFormula_Params params {};
		params.Multiplier = Multiplier;
		params.Level = Level;
		params.Power = Power;
		params.Offset = Offset;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0178F8F0
	 * 		Name   -> Function GbxGameSystemCore.AttributeInitializer.CalculateAttributeInitialValue
	 * 		Flags  -> (Event, Public, BlueprintEvent, Const)
	 * Parameters:
	 * 		class UObject*                                     Context                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	float UAttributeInitializer::CalculateAttributeInitialValue(class UObject* Context)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.AttributeInitializer.CalculateAttributeInitialValue");
		
		UAttributeInitializer_CalculateAttributeInitialValue_Params params {};
		params.Context = Context;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UAttributeInitializer.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UAttributeInitializer::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.AttributeInitializer");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UAttributeModifierTestContext.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UAttributeModifierTestContext::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.AttributeModifierTestContext");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UTestAttributePropertyValueResolver.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UTestAttributePropertyValueResolver::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.TestAttributePropertyValueResolver");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UAttributePropertyValueResolverTestContext.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UAttributePropertyValueResolverTestContext::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.AttributePropertyValueResolverTestContext");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UBalanceFormulaAttributeValueResolver.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UBalanceFormulaAttributeValueResolver::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.BalanceFormulaAttributeValueResolver");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UBalanceStateAttributeValueResolver.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UBalanceStateAttributeValueResolver::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.BalanceStateAttributeValueResolver");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UBalanceTableAttributeValueResolver.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UBalanceTableAttributeValueResolver::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.BalanceTableAttributeValueResolver");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UBlackboardKeyAttributeContextResolver.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UBlackboardKeyAttributeContextResolver::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.BlackboardKeyAttributeContextResolver");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UBlackboardKeyType_GbxFlag.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UBlackboardKeyType_GbxFlag::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.BlackboardKeyType_GbxFlag");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UBlackboardKeyType_Struct.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UBlackboardKeyType_Struct::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.BlackboardKeyType_Struct");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UBlackboardKeyType_TargetActorInfo.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UBlackboardKeyType_TargetActorInfo::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.BlackboardKeyType_TargetActorInfo");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02DFC720
	 * 		Name   -> Function GbxGameSystemCore.BoneModBlueprintLibrary.SetBoneTranslation
	 * 		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		class FName                                        BoneName                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     Translation                                                (ConstParm, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UObject*                                     Target                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              InBlendTime                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EAlphaBlendOption                                  InBlendOption                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UCurveFloat*                                 InCustomBlendCurve                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UBoneModBlueprintLibrary::STATIC_SetBoneTranslation(const class FName& BoneName, const struct FVector& Translation, class UObject* Target, float InBlendTime, EAlphaBlendOption InBlendOption, class UCurveFloat* InCustomBlendCurve)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.BoneModBlueprintLibrary.SetBoneTranslation");
		
		UBoneModBlueprintLibrary_SetBoneTranslation_Params params {};
		params.BoneName = BoneName;
		params.Translation = Translation;
		params.Target = Target;
		params.InBlendTime = InBlendTime;
		params.InBlendOption = InBlendOption;
		params.InCustomBlendCurve = InCustomBlendCurve;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02DFC720
	 * 		Name   -> Function GbxGameSystemCore.BoneModBlueprintLibrary.SetBoneScale3D
	 * 		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		class FName                                        BoneName                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     Scale3D                                                    (ConstParm, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UObject*                                     Target                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              InBlendTime                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EAlphaBlendOption                                  InBlendOption                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UCurveFloat*                                 InCustomBlendCurve                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UBoneModBlueprintLibrary::STATIC_SetBoneScale3D(const class FName& BoneName, const struct FVector& Scale3D, class UObject* Target, float InBlendTime, EAlphaBlendOption InBlendOption, class UCurveFloat* InCustomBlendCurve)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.BoneModBlueprintLibrary.SetBoneScale3D");
		
		UBoneModBlueprintLibrary_SetBoneScale3D_Params params {};
		params.BoneName = BoneName;
		params.Scale3D = Scale3D;
		params.Target = Target;
		params.InBlendTime = InBlendTime;
		params.InBlendOption = InBlendOption;
		params.InCustomBlendCurve = InCustomBlendCurve;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02DFC8E0
	 * 		Name   -> Function GbxGameSystemCore.BoneModBlueprintLibrary.SetBoneScale
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class FName                                        BoneName                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Scale                                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UObject*                                     Target                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              InBlendTime                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EAlphaBlendOption                                  InBlendOption                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UCurveFloat*                                 InCustomBlendCurve                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UBoneModBlueprintLibrary::STATIC_SetBoneScale(const class FName& BoneName, float Scale, class UObject* Target, float InBlendTime, EAlphaBlendOption InBlendOption, class UCurveFloat* InCustomBlendCurve)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.BoneModBlueprintLibrary.SetBoneScale");
		
		UBoneModBlueprintLibrary_SetBoneScale_Params params {};
		params.BoneName = BoneName;
		params.Scale = Scale;
		params.Target = Target;
		params.InBlendTime = InBlendTime;
		params.InBlendOption = InBlendOption;
		params.InCustomBlendCurve = InCustomBlendCurve;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02DFC720
	 * 		Name   -> Function GbxGameSystemCore.BoneModBlueprintLibrary.SetBoneRotation
	 * 		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		class FName                                        BoneName                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FRotator                                    Rotation                                                   (ConstParm, Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		class UObject*                                     Target                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              InBlendTime                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EAlphaBlendOption                                  InBlendOption                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UCurveFloat*                                 InCustomBlendCurve                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UBoneModBlueprintLibrary::STATIC_SetBoneRotation(const class FName& BoneName, const struct FRotator& Rotation, class UObject* Target, float InBlendTime, EAlphaBlendOption InBlendOption, class UCurveFloat* InCustomBlendCurve)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.BoneModBlueprintLibrary.SetBoneRotation");
		
		UBoneModBlueprintLibrary_SetBoneRotation_Params params {};
		params.BoneName = BoneName;
		params.Rotation = Rotation;
		params.Target = Target;
		params.InBlendTime = InBlendTime;
		params.InBlendOption = InBlendOption;
		params.InCustomBlendCurve = InCustomBlendCurve;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02DFC420
	 * 		Name   -> Function GbxGameSystemCore.BoneModBlueprintLibrary.SetBoneModUseTranslation
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class FName                                        BoneModName                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bUseTranslation                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UObject*                                     Target                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UBoneModBlueprintLibrary::STATIC_SetBoneModUseTranslation(const class FName& BoneModName, bool bUseTranslation, class UObject* Target)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.BoneModBlueprintLibrary.SetBoneModUseTranslation");
		
		UBoneModBlueprintLibrary_SetBoneModUseTranslation_Params params {};
		params.BoneModName = BoneModName;
		params.bUseTranslation = bUseTranslation;
		params.Target = Target;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02DFC320
	 * 		Name   -> Function GbxGameSystemCore.BoneModBlueprintLibrary.SetBoneModUseScale
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class FName                                        BoneModName                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bUseScale                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UObject*                                     Target                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UBoneModBlueprintLibrary::STATIC_SetBoneModUseScale(const class FName& BoneModName, bool bUseScale, class UObject* Target)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.BoneModBlueprintLibrary.SetBoneModUseScale");
		
		UBoneModBlueprintLibrary_SetBoneModUseScale_Params params {};
		params.BoneModName = BoneModName;
		params.bUseScale = bUseScale;
		params.Target = Target;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02DFC220
	 * 		Name   -> Function GbxGameSystemCore.BoneModBlueprintLibrary.SetBoneModUseRotation
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class FName                                        BoneModName                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bUseRotation                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UObject*                                     Target                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UBoneModBlueprintLibrary::STATIC_SetBoneModUseRotation(const class FName& BoneModName, bool bUseRotation, class UObject* Target)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.BoneModBlueprintLibrary.SetBoneModUseRotation");
		
		UBoneModBlueprintLibrary_SetBoneModUseRotation_Params params {};
		params.BoneModName = BoneModName;
		params.bUseRotation = bUseRotation;
		params.Target = Target;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02DFC120
	 * 		Name   -> Function GbxGameSystemCore.BoneModBlueprintLibrary.SetBoneModTranslationSpace
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class FName                                        BoneModName                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EBoneControlSpace                                  TranslationSpace                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UObject*                                     Target                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UBoneModBlueprintLibrary::STATIC_SetBoneModTranslationSpace(const class FName& BoneModName, EBoneControlSpace TranslationSpace, class UObject* Target)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.BoneModBlueprintLibrary.SetBoneModTranslationSpace");
		
		UBoneModBlueprintLibrary_SetBoneModTranslationSpace_Params params {};
		params.BoneModName = BoneModName;
		params.TranslationSpace = TranslationSpace;
		params.Target = Target;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02DFC020
	 * 		Name   -> Function GbxGameSystemCore.BoneModBlueprintLibrary.SetBoneModTranslation
	 * 		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		class FName                                        BoneModName                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     Translation                                                (ConstParm, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UObject*                                     Target                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UBoneModBlueprintLibrary::STATIC_SetBoneModTranslation(const class FName& BoneModName, const struct FVector& Translation, class UObject* Target)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.BoneModBlueprintLibrary.SetBoneModTranslation");
		
		UBoneModBlueprintLibrary_SetBoneModTranslation_Params params {};
		params.BoneModName = BoneModName;
		params.Translation = Translation;
		params.Target = Target;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02DFBEB0
	 * 		Name   -> Function GbxGameSystemCore.BoneModBlueprintLibrary.SetBoneModTransform
	 * 		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		class FName                                        BoneModName                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FTransform                                  Transform                                                  (ConstParm, Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		class UObject*                                     Target                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UBoneModBlueprintLibrary::STATIC_SetBoneModTransform(const class FName& BoneModName, const struct FTransform& Transform, class UObject* Target)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.BoneModBlueprintLibrary.SetBoneModTransform");
		
		UBoneModBlueprintLibrary_SetBoneModTransform_Params params {};
		params.BoneModName = BoneModName;
		params.Transform = Transform;
		params.Target = Target;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02DFBCB0
	 * 		Name   -> Function GbxGameSystemCore.BoneModBlueprintLibrary.SetBoneModScale3D
	 * 		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		class FName                                        BoneModName                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     Scale                                                      (ConstParm, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UObject*                                     Target                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UBoneModBlueprintLibrary::STATIC_SetBoneModScale3D(const class FName& BoneModName, const struct FVector& Scale, class UObject* Target)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.BoneModBlueprintLibrary.SetBoneModScale3D");
		
		UBoneModBlueprintLibrary_SetBoneModScale3D_Params params {};
		params.BoneModName = BoneModName;
		params.Scale = Scale;
		params.Target = Target;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02DFBDB0
	 * 		Name   -> Function GbxGameSystemCore.BoneModBlueprintLibrary.SetBoneModScale
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class FName                                        BoneModName                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Scale                                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UObject*                                     Target                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UBoneModBlueprintLibrary::STATIC_SetBoneModScale(const class FName& BoneModName, float Scale, class UObject* Target)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.BoneModBlueprintLibrary.SetBoneModScale");
		
		UBoneModBlueprintLibrary_SetBoneModScale_Params params {};
		params.BoneModName = BoneModName;
		params.Scale = Scale;
		params.Target = Target;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02DFBBB0
	 * 		Name   -> Function GbxGameSystemCore.BoneModBlueprintLibrary.SetBoneModRotationSpace
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class FName                                        BoneModName                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EBoneControlSpace                                  RotationSpace                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UObject*                                     Target                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UBoneModBlueprintLibrary::STATIC_SetBoneModRotationSpace(const class FName& BoneModName, EBoneControlSpace RotationSpace, class UObject* Target)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.BoneModBlueprintLibrary.SetBoneModRotationSpace");
		
		UBoneModBlueprintLibrary_SetBoneModRotationSpace_Params params {};
		params.BoneModName = BoneModName;
		params.RotationSpace = RotationSpace;
		params.Target = Target;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02DFBAB0
	 * 		Name   -> Function GbxGameSystemCore.BoneModBlueprintLibrary.SetBoneModRotation
	 * 		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		class FName                                        BoneModName                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FRotator                                    Rotation                                                   (ConstParm, Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		class UObject*                                     Target                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UBoneModBlueprintLibrary::STATIC_SetBoneModRotation(const class FName& BoneModName, const struct FRotator& Rotation, class UObject* Target)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.BoneModBlueprintLibrary.SetBoneModRotation");
		
		UBoneModBlueprintLibrary_SetBoneModRotation_Params params {};
		params.BoneModName = BoneModName;
		params.Rotation = Rotation;
		params.Target = Target;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02DFB9B0
	 * 		Name   -> Function GbxGameSystemCore.BoneModBlueprintLibrary.SetBoneModReplaceTranslation
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class FName                                        BoneModName                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bReplaceTranslation                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UObject*                                     Target                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UBoneModBlueprintLibrary::STATIC_SetBoneModReplaceTranslation(const class FName& BoneModName, bool bReplaceTranslation, class UObject* Target)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.BoneModBlueprintLibrary.SetBoneModReplaceTranslation");
		
		UBoneModBlueprintLibrary_SetBoneModReplaceTranslation_Params params {};
		params.BoneModName = BoneModName;
		params.bReplaceTranslation = bReplaceTranslation;
		params.Target = Target;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02DFB8B0
	 * 		Name   -> Function GbxGameSystemCore.BoneModBlueprintLibrary.SetBoneModReplaceScale
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class FName                                        BoneModName                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bReplaceScale                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UObject*                                     Target                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UBoneModBlueprintLibrary::STATIC_SetBoneModReplaceScale(const class FName& BoneModName, bool bReplaceScale, class UObject* Target)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.BoneModBlueprintLibrary.SetBoneModReplaceScale");
		
		UBoneModBlueprintLibrary_SetBoneModReplaceScale_Params params {};
		params.BoneModName = BoneModName;
		params.bReplaceScale = bReplaceScale;
		params.Target = Target;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02DFB7B0
	 * 		Name   -> Function GbxGameSystemCore.BoneModBlueprintLibrary.SetBoneModReplaceRotation
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class FName                                        BoneModName                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bReplaceRotation                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UObject*                                     Target                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UBoneModBlueprintLibrary::STATIC_SetBoneModReplaceRotation(const class FName& BoneModName, bool bReplaceRotation, class UObject* Target)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.BoneModBlueprintLibrary.SetBoneModReplaceRotation");
		
		UBoneModBlueprintLibrary_SetBoneModReplaceRotation_Params params {};
		params.BoneModName = BoneModName;
		params.bReplaceRotation = bReplaceRotation;
		params.Target = Target;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02DFB6C0
	 * 		Name   -> Function GbxGameSystemCore.BoneModBlueprintLibrary.SetBoneModName
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class FName                                        BoneModName                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FName                                        NewBoneModName                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UObject*                                     Target                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UBoneModBlueprintLibrary::STATIC_SetBoneModName(const class FName& BoneModName, const class FName& NewBoneModName, class UObject* Target)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.BoneModBlueprintLibrary.SetBoneModName");
		
		UBoneModBlueprintLibrary_SetBoneModName_Params params {};
		params.BoneModName = BoneModName;
		params.NewBoneModName = NewBoneModName;
		params.Target = Target;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02DFC5D0
	 * 		Name   -> Function GbxGameSystemCore.BoneModBlueprintLibrary.SetBoneModifyProfileState
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class FName                                        StateName                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bActive                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UObject*                                     Target                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              BlendTime                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UBoneModBlueprintLibrary::STATIC_SetBoneModifyProfileState(const class FName& StateName, bool bActive, class UObject* Target, float BlendTime)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.BoneModBlueprintLibrary.SetBoneModifyProfileState");
		
		UBoneModBlueprintLibrary_SetBoneModifyProfileState_Params params {};
		params.StateName = StateName;
		params.bActive = bActive;
		params.Target = Target;
		params.BlendTime = BlendTime;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02DFC520
	 * 		Name   -> Function GbxGameSystemCore.BoneModBlueprintLibrary.SetBoneModifyProfile
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UGbxBoneModifyProfile*                       BoneModifyProfile                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UObject*                                     Target                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UBoneModBlueprintLibrary::STATIC_SetBoneModifyProfile(class UGbxBoneModifyProfile* BoneModifyProfile, class UObject* Target)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.BoneModBlueprintLibrary.SetBoneModifyProfile");
		
		UBoneModBlueprintLibrary_SetBoneModifyProfile_Params params {};
		params.BoneModifyProfile = BoneModifyProfile;
		params.Target = Target;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02DFB5D0
	 * 		Name   -> Function GbxGameSystemCore.BoneModBlueprintLibrary.SetBoneModBoneName
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class FName                                        BoneModName                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FName                                        BoneModBoneName                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UObject*                                     Target                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UBoneModBlueprintLibrary::STATIC_SetBoneModBoneName(const class FName& BoneModName, const class FName& BoneModBoneName, class UObject* Target)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.BoneModBlueprintLibrary.SetBoneModBoneName");
		
		UBoneModBlueprintLibrary_SetBoneModBoneName_Params params {};
		params.BoneModName = BoneModName;
		params.BoneModBoneName = BoneModBoneName;
		params.Target = Target;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02DFB4D0
	 * 		Name   -> Function GbxGameSystemCore.BoneModBlueprintLibrary.SetBoneModBlendTime
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class FName                                        BoneModName                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              BlendTime                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UObject*                                     Target                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UBoneModBlueprintLibrary::STATIC_SetBoneModBlendTime(const class FName& BoneModName, float BlendTime, class UObject* Target)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.BoneModBlueprintLibrary.SetBoneModBlendTime");
		
		UBoneModBlueprintLibrary_SetBoneModBlendTime_Params params {};
		params.BoneModName = BoneModName;
		params.BlendTime = BlendTime;
		params.Target = Target;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02DFB380
	 * 		Name   -> Function GbxGameSystemCore.BoneModBlueprintLibrary.SetBoneModAlphaBlend
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class FName                                        BoneModName                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FAlphaBlend                                 Blend                                                      (ConstParm, Parm, NoDestructor, NativeAccessSpecifierPublic)
	 * 		class UObject*                                     Target                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UBoneModBlueprintLibrary::STATIC_SetBoneModAlphaBlend(const class FName& BoneModName, const struct FAlphaBlend& Blend, class UObject* Target)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.BoneModBlueprintLibrary.SetBoneModAlphaBlend");
		
		UBoneModBlueprintLibrary_SetBoneModAlphaBlend_Params params {};
		params.BoneModName = BoneModName;
		params.Blend = Blend;
		params.Target = Target;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02DFB280
	 * 		Name   -> Function GbxGameSystemCore.BoneModBlueprintLibrary.SetBoneModActive
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class FName                                        BoneModName                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bActive                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UObject*                                     Target                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UBoneModBlueprintLibrary::STATIC_SetBoneModActive(const class FName& BoneModName, bool bActive, class UObject* Target)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.BoneModBlueprintLibrary.SetBoneModActive");
		
		UBoneModBlueprintLibrary_SetBoneModActive_Params params {};
		params.BoneModName = BoneModName;
		params.bActive = bActive;
		params.Target = Target;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02DFB060
	 * 		Name   -> Function GbxGameSystemCore.BoneModBlueprintLibrary.SetBoneMod
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		struct FBoneModInstance                            InBoneMod                                                  (Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 * 		class FName                                        BoneModToSet                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UObject*                                     Target                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bBlendIn                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UBoneModBlueprintLibrary::STATIC_SetBoneMod(struct FBoneModInstance* InBoneMod, const class FName& BoneModToSet, class UObject* Target, bool bBlendIn)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.BoneModBlueprintLibrary.SetBoneMod");
		
		UBoneModBlueprintLibrary_SetBoneMod_Params params {};
		params.BoneModToSet = BoneModToSet;
		params.Target = Target;
		params.bBlendIn = bBlendIn;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (InBoneMod != nullptr)
			*InBoneMod = params.InBoneMod;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02DFAF60
	 * 		Name   -> Function GbxGameSystemCore.BoneModBlueprintLibrary.RemoveBoneMod
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class FName                                        BoneModToRemove                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UObject*                                     Target                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bBlendOut                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UBoneModBlueprintLibrary::STATIC_RemoveBoneMod(const class FName& BoneModToRemove, class UObject* Target, bool bBlendOut)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.BoneModBlueprintLibrary.RemoveBoneMod");
		
		UBoneModBlueprintLibrary_RemoveBoneMod_Params params {};
		params.BoneModToRemove = BoneModToRemove;
		params.Target = Target;
		params.bBlendOut = bBlendOut;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02DFA8B0
	 * 		Name   -> Function GbxGameSystemCore.BoneModBlueprintLibrary.GetBoneMod
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		class FName                                        BoneModName                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FBoneModInstance                            BoneMod                                                    (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
	 * 		class UObject*                                     Target                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UBoneModBlueprintLibrary::STATIC_GetBoneMod(const class FName& BoneModName, struct FBoneModInstance* BoneMod, class UObject* Target)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.BoneModBlueprintLibrary.GetBoneMod");
		
		UBoneModBlueprintLibrary_GetBoneMod_Params params {};
		params.BoneModName = BoneModName;
		params.Target = Target;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (BoneMod != nullptr)
			*BoneMod = params.BoneMod;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02DFA350
	 * 		Name   -> Function GbxGameSystemCore.BoneModBlueprintLibrary.CreateBoneMod
	 * 		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		class FName                                        InBoneModName                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FName                                        InBoneName                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     InTranslation                                              (ConstParm, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FRotator                                    InRotation                                                 (ConstParm, Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     InScale                                                    (ConstParm, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              InBlendTime                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UObject*                                     Target                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EAlphaBlendOption                                  InBlendOption                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UCurveFloat*                                 InCustomBlendCurve                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bInUseTranslation                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bInUseRotation                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bInUseScale                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bInReplaceTranslation                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bInReplaceRotation                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bInReplaceScale                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EBoneControlSpace                                  InTranslationSpace                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EBoneControlSpace                                  InRotationSpace                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bBlendIn                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UBoneModBlueprintLibrary::STATIC_CreateBoneMod(const class FName& InBoneModName, const class FName& InBoneName, const struct FVector& InTranslation, const struct FRotator& InRotation, const struct FVector& InScale, float InBlendTime, class UObject* Target, EAlphaBlendOption InBlendOption, class UCurveFloat* InCustomBlendCurve, bool bInUseTranslation, bool bInUseRotation, bool bInUseScale, bool bInReplaceTranslation, bool bInReplaceRotation, bool bInReplaceScale, EBoneControlSpace InTranslationSpace, EBoneControlSpace InRotationSpace, bool bBlendIn)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.BoneModBlueprintLibrary.CreateBoneMod");
		
		UBoneModBlueprintLibrary_CreateBoneMod_Params params {};
		params.InBoneModName = InBoneModName;
		params.InBoneName = InBoneName;
		params.InTranslation = InTranslation;
		params.InRotation = InRotation;
		params.InScale = InScale;
		params.InBlendTime = InBlendTime;
		params.Target = Target;
		params.InBlendOption = InBlendOption;
		params.InCustomBlendCurve = InCustomBlendCurve;
		params.bInUseTranslation = bInUseTranslation;
		params.bInUseRotation = bInUseRotation;
		params.bInUseScale = bInUseScale;
		params.bInReplaceTranslation = bInReplaceTranslation;
		params.bInReplaceRotation = bInReplaceRotation;
		params.bInReplaceScale = bInReplaceScale;
		params.InTranslationSpace = InTranslationSpace;
		params.InRotationSpace = InRotationSpace;
		params.bBlendIn = bBlendIn;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UBoneModBlueprintLibrary.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UBoneModBlueprintLibrary::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.BoneModBlueprintLibrary");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UBoneModComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UBoneModComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.BoneModComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UBTDecorator_GbxCondition.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UBTDecorator_GbxCondition::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.BTDecorator_GbxCondition");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UBTTask_PlayGbxAction.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UBTTask_PlayGbxAction::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.BTTask_PlayGbxAction");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UCauseDamageContextSourceInterface.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UCauseDamageContextSourceInterface::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.CauseDamageContextSourceInterface");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UChallengeConditionData.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UChallengeConditionData::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.ChallengeConditionData");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E01100
	 * 		Name   -> Function GbxGameSystemCore.ChallengeLevelActorComponent.SetIsStationary
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bInIsStationary                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UChallengeLevelActorComponent::SetIsStationary(bool bInIsStationary)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.ChallengeLevelActorComponent.SetIsStationary");
		
		UChallengeLevelActorComponent_SetIsStationary_Params params {};
		params.bInIsStationary = bInIsStationary;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E01070
	 * 		Name   -> Function GbxGameSystemCore.ChallengeLevelActorComponent.SetInWorldIconEnabled
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bEnable                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UChallengeLevelActorComponent::SetInWorldIconEnabled(bool bEnable)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.ChallengeLevelActorComponent.SetInWorldIconEnabled");
		
		UChallengeLevelActorComponent_SetInWorldIconEnabled_Params params {};
		params.bEnable = bEnable;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E00AF0
	 * 		Name   -> Function GbxGameSystemCore.ChallengeLevelActorComponent.OnRep_IsStationary
	 * 		Flags  -> (Final, Native, Private)
	 * Parameters:
	 * 		bool                                               bOldIsStationary                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UChallengeLevelActorComponent::OnRep_IsStationary(bool bOldIsStationary)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.ChallengeLevelActorComponent.OnRep_IsStationary");
		
		UChallengeLevelActorComponent_OnRep_IsStationary_Params params {};
		params.bOldIsStationary = bOldIsStationary;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E00A60
	 * 		Name   -> Function GbxGameSystemCore.ChallengeLevelActorComponent.OnRep_InWorldIconEnabled
	 * 		Flags  -> (Final, Native, Private)
	 * Parameters:
	 * 		bool                                               bOldEnabled                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UChallengeLevelActorComponent::OnRep_InWorldIconEnabled(bool bOldEnabled)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.ChallengeLevelActorComponent.OnRep_InWorldIconEnabled");
		
		UChallengeLevelActorComponent_OnRep_InWorldIconEnabled_Params params {};
		params.bOldEnabled = bOldEnabled;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E00A40
	 * 		Name   -> Function GbxGameSystemCore.ChallengeLevelActorComponent.OnRep_ChallengeReference
	 * 		Flags  -> (Final, Native, Private)
	 */
	void UChallengeLevelActorComponent::OnRep_ChallengeReference()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.ChallengeLevelActorComponent.OnRep_ChallengeReference");
		
		UChallengeLevelActorComponent_OnRep_ChallengeReference_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E00880
	 * 		Name   -> Function GbxGameSystemCore.ChallengeLevelActorComponent.HandleAttachmentChanged
	 * 		Flags  -> (Final, Native, Private)
	 */
	void UChallengeLevelActorComponent::HandleAttachmentChanged()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.ChallengeLevelActorComponent.HandleAttachmentChanged");
		
		UChallengeLevelActorComponent_HandleAttachmentChanged_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E00090
	 * 		Name   -> Function GbxGameSystemCore.ChallengeLevelActorComponent.GetAssociatedActor
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	class AActor* UChallengeLevelActorComponent::GetAssociatedActor()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.ChallengeLevelActorComponent.GetAssociatedActor");
		
		UChallengeLevelActorComponent_GetAssociatedActor_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UChallengeLevelActorComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UChallengeLevelActorComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.ChallengeLevelActorComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E00E60
	 * 		Name   -> Function GbxGameSystemCore.ChallengeLevelParentComponent.RemoveAssociatedActorComponent
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UChallengeLevelActorComponent*               AssociatedComponent                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UChallengeLevelParentComponent::RemoveAssociatedActorComponent(class UChallengeLevelActorComponent* AssociatedComponent)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.ChallengeLevelParentComponent.RemoveAssociatedActorComponent");
		
		UChallengeLevelParentComponent_RemoveAssociatedActorComponent_Params params {};
		params.AssociatedComponent = AssociatedComponent;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E00DE0
	 * 		Name   -> Function GbxGameSystemCore.ChallengeLevelParentComponent.RemoveAssociatedActor
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class AActor*                                      AssociatedActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UChallengeLevelParentComponent::RemoveAssociatedActor(class AActor* AssociatedActor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.ChallengeLevelParentComponent.RemoveAssociatedActor");
		
		UChallengeLevelParentComponent_RemoveAssociatedActor_Params params {};
		params.AssociatedActor = AssociatedActor;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02DFFCE0
	 * 		Name   -> Function GbxGameSystemCore.ChallengeLevelParentComponent.ClearAssociatedActors
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void UChallengeLevelParentComponent::ClearAssociatedActors()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.ChallengeLevelParentComponent.ClearAssociatedActors");
		
		UChallengeLevelParentComponent_ClearAssociatedActors_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02DFFB00
	 * 		Name   -> Function GbxGameSystemCore.ChallengeLevelParentComponent.AddAssociatedActor
	 * 		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		class AActor*                                      AssociatedActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UClass*                                      ComponentClass                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     RelativeOffset                                             (Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UChallengeLevelParentComponent::AddAssociatedActor(class AActor* AssociatedActor, class UClass* ComponentClass, const struct FVector& RelativeOffset)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.ChallengeLevelParentComponent.AddAssociatedActor");
		
		UChallengeLevelParentComponent_AddAssociatedActor_Params params {};
		params.AssociatedActor = AssociatedActor;
		params.ComponentClass = ComponentClass;
		params.RelativeOffset = RelativeOffset;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UChallengeLevelParentComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UChallengeLevelParentComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.ChallengeLevelParentComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UChallengeObserverInterface.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UChallengeObserverInterface::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.ChallengeObserverInterface");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UChallengeRewardData.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UChallengeRewardData::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.ChallengeRewardData");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UChallengeSystemSettings.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UChallengeSystemSettings::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.ChallengeSystemSettings");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UCharacterBestTargetAttributeContextResolver.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UCharacterBestTargetAttributeContextResolver::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.CharacterBestTargetAttributeContextResolver");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UCharacterMovementAttributeValueResolver.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UCharacterMovementAttributeValueResolver::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.CharacterMovementAttributeValueResolver");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E00D30
	 * 		Name   -> Function GbxGameSystemCore.CinematicModeBlueprintLibrary.PushCinematicMode
	 * 		Flags  -> (Final, BlueprintAuthorityOnly, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UCinematicModeData*                          InCinematicMode                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UCinematicModeBlueprintLibrary::STATIC_PushCinematicMode(class UObject* WorldContextObject, class UCinematicModeData* InCinematicMode)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.CinematicModeBlueprintLibrary.PushCinematicMode");
		
		UCinematicModeBlueprintLibrary_PushCinematicMode_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.InCinematicMode = InCinematicMode;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E00C80
	 * 		Name   -> Function GbxGameSystemCore.CinematicModeBlueprintLibrary.PopCinematicMode
	 * 		Flags  -> (Final, BlueprintAuthorityOnly, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UCinematicModeData*                          InCinematicMode                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UCinematicModeBlueprintLibrary::STATIC_PopCinematicMode(class UObject* WorldContextObject, class UCinematicModeData* InCinematicMode)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.CinematicModeBlueprintLibrary.PopCinematicMode");
		
		UCinematicModeBlueprintLibrary_PopCinematicMode_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.InCinematicMode = InCinematicMode;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02DFFD00
	 * 		Name   -> Function GbxGameSystemCore.CinematicModeBlueprintLibrary.ClearCinematicMode
	 * 		Flags  -> (Final, BlueprintAuthorityOnly, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UCinematicModeBlueprintLibrary::STATIC_ClearCinematicMode(class UObject* WorldContextObject)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.CinematicModeBlueprintLibrary.ClearCinematicMode");
		
		UCinematicModeBlueprintLibrary_ClearCinematicMode_Params params {};
		params.WorldContextObject = WorldContextObject;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02DFFC30
	 * 		Name   -> Function GbxGameSystemCore.CinematicModeBlueprintLibrary.ClearAndSetCinematicMode
	 * 		Flags  -> (Final, BlueprintAuthorityOnly, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UCinematicModeData*                          InCinematicMode                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UCinematicModeBlueprintLibrary::STATIC_ClearAndSetCinematicMode(class UObject* WorldContextObject, class UCinematicModeData* InCinematicMode)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.CinematicModeBlueprintLibrary.ClearAndSetCinematicMode");
		
		UCinematicModeBlueprintLibrary_ClearAndSetCinematicMode_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.InCinematicMode = InCinematicMode;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UCinematicModeBlueprintLibrary.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UCinematicModeBlueprintLibrary::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.CinematicModeBlueprintLibrary");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AClothManagerInterface.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AClothManagerInterface::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.ClothManagerInterface");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01409690
	 * 		Name   -> Function GbxGameSystemCore.Beacon.OnBeaconSourceEndPlay
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		class AActor*                                      Actor                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EEndPlayReason                                     EndPlayReason                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ABeacon::OnBeaconSourceEndPlay(class AActor* Actor, EEndPlayReason EndPlayReason)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.Beacon.OnBeaconSourceEndPlay");
		
		ABeacon_OnBeaconSourceEndPlay_Params params {};
		params.Actor = Actor;
		params.EndPlayReason = EndPlayReason;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ABeacon.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ABeacon::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.Beacon");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UConditionalAttributeValueResolver.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UConditionalAttributeValueResolver::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.ConditionalAttributeValueResolver");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UConditionalDamageModifier.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UConditionalDamageModifier::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.ConditionalDamageModifier");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UConditionalDamageCriticalModifier.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UConditionalDamageCriticalModifier::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.ConditionalDamageCriticalModifier");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UConditionalDamageHitRegionModifier.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UConditionalDamageHitRegionModifier::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.ConditionalDamageHitRegionModifier");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UConditionalDamageTypeModifier.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UConditionalDamageTypeModifier::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.ConditionalDamageTypeModifier");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UConditionalDamageValueModifier.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UConditionalDamageValueModifier::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.ConditionalDamageValueModifier");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UConstantAttributeValueResolver.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UConstantAttributeValueResolver::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.ConstantAttributeValueResolver");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E04520
	 * 		Name   -> Function GbxGameSystemCore.ControlledMoveFunctionLibrary.StopControlledMove
	 * 		Flags  -> (Final, BlueprintAuthorityOnly, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class AActor*                                      Actor                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UClass*                                      ControlledMove                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bZeroVelocity                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bInterrupted                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UControlledMoveFunctionLibrary::STATIC_StopControlledMove(class AActor* Actor, class UClass* ControlledMove, bool bZeroVelocity, bool bInterrupted)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.ControlledMoveFunctionLibrary.StopControlledMove");
		
		UControlledMoveFunctionLibrary_StopControlledMove_Params params {};
		params.Actor = Actor;
		params.ControlledMove = ControlledMove;
		params.bZeroVelocity = bZeroVelocity;
		params.bInterrupted = bInterrupted;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E042E0
	 * 		Name   -> Function GbxGameSystemCore.ControlledMoveFunctionLibrary.StartControlledMove
	 * 		Flags  -> (Final, BlueprintAuthorityOnly, Native, Static, Public, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		class AActor*                                      Actor                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UClass*                                      ControlledMove                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      Instigator                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              SpeedOverride                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              DurationOverride                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              LaunchAngleOverride                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      TargetActor                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     TargetLocation                                             (Parm, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UControlledMoveFunctionLibrary::STATIC_StartControlledMove(class AActor* Actor, class UClass* ControlledMove, class AActor* Instigator, float SpeedOverride, float DurationOverride, float LaunchAngleOverride, class AActor* TargetActor, const struct FVector& TargetLocation)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.ControlledMoveFunctionLibrary.StartControlledMove");
		
		UControlledMoveFunctionLibrary_StartControlledMove_Params params {};
		params.Actor = Actor;
		params.ControlledMove = ControlledMove;
		params.Instigator = Instigator;
		params.SpeedOverride = SpeedOverride;
		params.DurationOverride = DurationOverride;
		params.LaunchAngleOverride = LaunchAngleOverride;
		params.TargetActor = TargetActor;
		params.TargetLocation = TargetLocation;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E03D40
	 * 		Name   -> Function GbxGameSystemCore.ControlledMoveFunctionLibrary.IsPerformingSpecificControlledMove
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class AActor*                                      Actor                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UClass*                                      ControlledMove                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UControlledMoveFunctionLibrary::STATIC_IsPerformingSpecificControlledMove(class AActor* Actor, class UClass* ControlledMove)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.ControlledMoveFunctionLibrary.IsPerformingSpecificControlledMove");
		
		UControlledMoveFunctionLibrary_IsPerformingSpecificControlledMove_Params params {};
		params.Actor = Actor;
		params.ControlledMove = ControlledMove;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E03CC0
	 * 		Name   -> Function GbxGameSystemCore.ControlledMoveFunctionLibrary.IsPerformingControlledMove
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class AActor*                                      Actor                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UControlledMoveFunctionLibrary::STATIC_IsPerformingControlledMove(class AActor* Actor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.ControlledMoveFunctionLibrary.IsPerformingControlledMove");
		
		UControlledMoveFunctionLibrary_IsPerformingControlledMove_Params params {};
		params.Actor = Actor;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UControlledMoveFunctionLibrary.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UControlledMoveFunctionLibrary::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.ControlledMoveFunctionLibrary");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UControllerAttributeContextResolver.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UControllerAttributeContextResolver::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.ControllerAttributeContextResolver");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E03BC0
	 * 		Name   -> Function GbxGameSystemCore.CoordinatedEffectBlueprintLibrary.GetOriginalOverrideMaterialAtIndex
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class UMeshComponent*                              MeshComponent                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            Index                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            OutActualIndex                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UMaterialInterface* UCoordinatedEffectBlueprintLibrary::STATIC_GetOriginalOverrideMaterialAtIndex(class UMeshComponent* MeshComponent, int32_t Index, int32_t* OutActualIndex)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.CoordinatedEffectBlueprintLibrary.GetOriginalOverrideMaterialAtIndex");
		
		UCoordinatedEffectBlueprintLibrary_GetOriginalOverrideMaterialAtIndex_Params params {};
		params.MeshComponent = MeshComponent;
		params.Index = Index;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutActualIndex != nullptr)
			*OutActualIndex = params.OutActualIndex;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UCoordinatedEffectBlueprintLibrary.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UCoordinatedEffectBlueprintLibrary::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.CoordinatedEffectBlueprintLibrary");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDamageableInterface.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDamageableInterface::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.DamageableInterface");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDamageAreaType.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDamageAreaType::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.DamageAreaType");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDamageAreaType_BaseRound.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDamageAreaType_BaseRound::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.DamageAreaType_BaseRound");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDamageAreaType_Sphere.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDamageAreaType_Sphere::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.DamageAreaType_Sphere");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDamageAreaType_Cylinder.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDamageAreaType_Cylinder::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.DamageAreaType_Cylinder");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDamageAreaType_Cone.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDamageAreaType_Cone::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.DamageAreaType_Cone");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDamageAreaType_Box.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDamageAreaType_Box::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.DamageAreaType_Box");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDamageAreaType_Capsule.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDamageAreaType_Capsule::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.DamageAreaType_Capsule");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDamageAsyncManager.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDamageAsyncManager::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.DamageAsyncManager");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDamageCauserInterface.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDamageCauserInterface::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.DamageCauserInterface");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E0AA80
	 * 		Name   -> Function GbxGameSystemCore.DamageStatics.StopCausingDamageToTarget
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class AActor*                                      DamageCauser                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      DamageTarget                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UClass*                                      DamageData                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UDamageStatics::STATIC_StopCausingDamageToTarget(class AActor* DamageCauser, class AActor* DamageTarget, class UClass* DamageData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.DamageStatics.StopCausingDamageToTarget");
		
		UDamageStatics_StopCausingDamageToTarget_Params params {};
		params.DamageCauser = DamageCauser;
		params.DamageTarget = DamageTarget;
		params.DamageData = DamageData;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E0A9D0
	 * 		Name   -> Function GbxGameSystemCore.DamageStatics.StopCausingDamage
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class AActor*                                      DamageCauser                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UClass*                                      DamageData                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UDamageStatics::STATIC_StopCausingDamage(class AActor* DamageCauser, class UClass* DamageData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.DamageStatics.StopCausingDamage");
		
		UDamageStatics_StopCausingDamage_Params params {};
		params.DamageCauser = DamageCauser;
		params.DamageData = DamageData;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E0A960
	 * 		Name   -> Function GbxGameSystemCore.DamageStatics.StopCausingAllDamage
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class AActor*                                      DamageCauser                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UDamageStatics::STATIC_StopCausingAllDamage(class AActor* DamageCauser)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.DamageStatics.StopCausingAllDamage");
		
		UDamageStatics_StopCausingAllDamage_Params params {};
		params.DamageCauser = DamageCauser;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E0A4E0
	 * 		Name   -> Function GbxGameSystemCore.DamageStatics.MakePipelineDamageInput
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class AActor*                                      DamageCauser                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      DamageReceiver                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UClass*                                      DamageType                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UClass*                                      DamageSource                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FHitResult                                  HitInfo                                                    (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     HitLocation                                                (Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     HitDirection                                               (Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     HitForceDirection                                          (Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FForceSelection                             HitForceMagnitude                                          (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	struct FPipelineDamageInput UDamageStatics::STATIC_MakePipelineDamageInput(class AActor* DamageCauser, class AActor* DamageReceiver, class UClass* DamageType, class UClass* DamageSource, const struct FHitResult& HitInfo, const struct FVector& HitLocation, const struct FVector& HitDirection, const struct FVector& HitForceDirection, const struct FForceSelection& HitForceMagnitude)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.DamageStatics.MakePipelineDamageInput");
		
		UDamageStatics_MakePipelineDamageInput_Params params {};
		params.DamageCauser = DamageCauser;
		params.DamageReceiver = DamageReceiver;
		params.DamageType = DamageType;
		params.DamageSource = DamageSource;
		params.HitInfo = HitInfo;
		params.HitLocation = HitLocation;
		params.HitDirection = HitDirection;
		params.HitForceDirection = HitForceDirection;
		params.HitForceMagnitude = HitForceMagnitude;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E0A3F0
	 * 		Name   -> Function GbxGameSystemCore.DamageStatics.GetSummary_ForceSelection
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FForceSelection                             ForceSelection                                             (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	class FString UDamageStatics::STATIC_GetSummary_ForceSelection(const struct FForceSelection& ForceSelection)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.DamageStatics.GetSummary_ForceSelection");
		
		UDamageStatics_GetSummary_ForceSelection_Params params {};
		params.ForceSelection = ForceSelection;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E0A340
	 * 		Name   -> Function GbxGameSystemCore.DamageStatics.GetDamageTypeFromClass
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class UClass*                                      DamageTypeClass                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UGbxDamageType* UDamageStatics::STATIC_GetDamageTypeFromClass(class UClass* DamageTypeClass)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.DamageStatics.GetDamageTypeFromClass");
		
		UDamageStatics_GetDamageTypeFromClass_Params params {};
		params.DamageTypeClass = DamageTypeClass;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E0A340
	 * 		Name   -> Function GbxGameSystemCore.DamageStatics.GetDamageSourceFromClass
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class UClass*                                      DamageSourceClass                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UDamageSource* UDamageStatics::STATIC_GetDamageSourceFromClass(class UClass* DamageSourceClass)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.DamageStatics.GetDamageSourceFromClass");
		
		UDamageStatics_GetDamageSourceFromClass_Params params {};
		params.DamageSourceClass = DamageSourceClass;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E0A2A0
	 * 		Name   -> Function GbxGameSystemCore.DamageStatics.Conv_ForceSelectionToFloat
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FForceSelection                             ForceSelection                                             (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	float UDamageStatics::STATIC_Conv_ForceSelectionToFloat(const struct FForceSelection& ForceSelection)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.DamageStatics.Conv_ForceSelectionToFloat");
		
		UDamageStatics_Conv_ForceSelectionToFloat_Params params {};
		params.ForceSelection = ForceSelection;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E0A210
	 * 		Name   -> Function GbxGameSystemCore.DamageStatics.Conv_FloatToForceSelection
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		float                                              ForceSelection                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FForceSelection UDamageStatics::STATIC_Conv_FloatToForceSelection(float ForceSelection)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.DamageStatics.Conv_FloatToForceSelection");
		
		UDamageStatics_Conv_FloatToForceSelection_Params params {};
		params.ForceSelection = ForceSelection;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E09DD0
	 * 		Name   -> Function GbxGameSystemCore.DamageStatics.ApplyDamageInRadius
	 * 		Flags  -> (Final, BlueprintAuthorityOnly, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              BaseDamage                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     Origin                                                     (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Radius                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UClass*                                      DamageType                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UClass*                                      DamageSource                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		TArray<class AActor*>                              IgnoreActors                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      DamageCauser                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AController*                                 EventInstigator                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FForceSelection                             BaseImpactForce                                            (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 * 		ECollisionChannel                                  DamagePreventionChannel                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bDamageFalloff                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UDamageModifierComponent*                    DamageModifierComponent                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UFeedbackData*                               InstigatorFeedback                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bUseInstigatorRadiusDamageScale                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UDamageStatics::STATIC_ApplyDamageInRadius(class UObject* WorldContextObject, float BaseDamage, const struct FVector& Origin, float Radius, class UClass* DamageType, class UClass* DamageSource, TArray<class AActor*> IgnoreActors, class AActor* DamageCauser, class AController* EventInstigator, const struct FForceSelection& BaseImpactForce, ECollisionChannel DamagePreventionChannel, bool bDamageFalloff, class UDamageModifierComponent* DamageModifierComponent, class UFeedbackData* InstigatorFeedback, bool bUseInstigatorRadiusDamageScale)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.DamageStatics.ApplyDamageInRadius");
		
		UDamageStatics_ApplyDamageInRadius_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.BaseDamage = BaseDamage;
		params.Origin = Origin;
		params.Radius = Radius;
		params.DamageType = DamageType;
		params.DamageSource = DamageSource;
		params.IgnoreActors = IgnoreActors;
		params.DamageCauser = DamageCauser;
		params.EventInstigator = EventInstigator;
		params.BaseImpactForce = BaseImpactForce;
		params.DamagePreventionChannel = DamagePreventionChannel;
		params.bDamageFalloff = bDamageFalloff;
		params.DamageModifierComponent = DamageModifierComponent;
		params.InstigatorFeedback = InstigatorFeedback;
		params.bUseInstigatorRadiusDamageScale = bUseInstigatorRadiusDamageScale;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E09C70
	 * 		Name   -> Function GbxGameSystemCore.DamageStatics.ApplyDamageEx
	 * 		Flags  -> (Final, BlueprintAuthorityOnly, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		struct FPipelineDamageInput                        PipelineInput                                              (Parm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 * 		float                                              BaseDamage                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UDamageStatics::STATIC_ApplyDamageEx(const struct FPipelineDamageInput& PipelineInput, float BaseDamage)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.DamageStatics.ApplyDamageEx");
		
		UDamageStatics_ApplyDamageEx_Params params {};
		params.PipelineInput = PipelineInput;
		params.BaseDamage = BaseDamage;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E09AC0
	 * 		Name   -> Function GbxGameSystemCore.DamageStatics.ApplyDamage
	 * 		Flags  -> (Final, BlueprintAuthorityOnly, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class AActor*                                      DamageReceiver                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              BaseDamage                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UClass*                                      DamageType                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UClass*                                      DamageSource                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AController*                                 EventInstigator                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      DamageCauser                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UDamageStatics::STATIC_ApplyDamage(class AActor* DamageReceiver, float BaseDamage, class UClass* DamageType, class UClass* DamageSource, class AController* EventInstigator, class AActor* DamageCauser)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.DamageStatics.ApplyDamage");
		
		UDamageStatics_ApplyDamage_Params params {};
		params.DamageReceiver = DamageReceiver;
		params.BaseDamage = BaseDamage;
		params.DamageType = DamageType;
		params.DamageSource = DamageSource;
		params.EventInstigator = EventInstigator;
		params.DamageCauser = DamageCauser;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDamageStatics.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDamageStatics::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.DamageStatics");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDeathData.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDeathData::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.DeathData");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ADecorator.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ADecorator::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.Decorator");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDrunkenBaseMovementComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDrunkenBaseMovementComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.DrunkenBaseMovementComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDrunkenRandomMovementComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDrunkenRandomMovementComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.DrunkenRandomMovementComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDrunkenWaveMovementComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDrunkenWaveMovementComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.DrunkenWaveMovementComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E0F560
	 * 		Name   -> Function GbxGameSystemCore.DynamicPhysicalAnimationComponent.SetStrengthMultiplier
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		float                                              NewValue                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UDynamicPhysicalAnimationComponent::SetStrengthMultiplier(float NewValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.DynamicPhysicalAnimationComponent.SetStrengthMultiplier");
		
		UDynamicPhysicalAnimationComponent_SetStrengthMultiplier_Params params {};
		params.NewValue = NewValue;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E0F4E0
	 * 		Name   -> Function GbxGameSystemCore.DynamicPhysicalAnimationComponent.SetSkeletalMeshComponent
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class USkeletalMeshComponent*                      NewSkeletalMeshComponent                                   (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UDynamicPhysicalAnimationComponent::SetSkeletalMeshComponent(class USkeletalMeshComponent* NewSkeletalMeshComponent)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.DynamicPhysicalAnimationComponent.SetSkeletalMeshComponent");
		
		UDynamicPhysicalAnimationComponent_SetSkeletalMeshComponent_Params params {};
		params.NewSkeletalMeshComponent = NewSkeletalMeshComponent;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E0F460
	 * 		Name   -> Function GbxGameSystemCore.DynamicPhysicalAnimationComponent.SetRootMotionControl
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		EPhysicalAnimationRootMotionControl                MotionControl                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UDynamicPhysicalAnimationComponent::SetRootMotionControl(EPhysicalAnimationRootMotionControl MotionControl)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.DynamicPhysicalAnimationComponent.SetRootMotionControl");
		
		UDynamicPhysicalAnimationComponent_SetRootMotionControl_Params params {};
		params.MotionControl = MotionControl;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E0F3B0
	 * 		Name   -> Function GbxGameSystemCore.DynamicPhysicalAnimationComponent.SetHasAnimationPlaying
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bPlaying                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UDynamicPhysicalAnimationComponent::SetHasAnimationPlaying(bool bPlaying)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.DynamicPhysicalAnimationComponent.SetHasAnimationPlaying");
		
		UDynamicPhysicalAnimationComponent_SetHasAnimationPlaying_Params params {};
		params.bPlaying = bPlaying;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E0F320
	 * 		Name   -> Function GbxGameSystemCore.DynamicPhysicalAnimationComponent.SetEnableRagdoll
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bEnable                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UDynamicPhysicalAnimationComponent::SetEnableRagdoll(bool bEnable)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.DynamicPhysicalAnimationComponent.SetEnableRagdoll");
		
		UDynamicPhysicalAnimationComponent_SetEnableRagdoll_Params params {};
		params.bEnable = bEnable;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E0F260
	 * 		Name   -> Function GbxGameSystemCore.DynamicPhysicalAnimationComponent.SetEnablePhysicalAnimation
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bEnable                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FName                                        BodyName                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UDynamicPhysicalAnimationComponent::SetEnablePhysicalAnimation(bool bEnable, const class FName& BodyName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.DynamicPhysicalAnimationComponent.SetEnablePhysicalAnimation");
		
		UDynamicPhysicalAnimationComponent_SetEnablePhysicalAnimation_Params params {};
		params.bEnable = bEnable;
		params.BodyName = BodyName;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E0F1E0
	 * 		Name   -> Function GbxGameSystemCore.DynamicPhysicalAnimationComponent.SetActiveProfile
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UPhysicalAnimationProfileAsset*              Profile                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UDynamicPhysicalAnimationComponent::SetActiveProfile(class UPhysicalAnimationProfileAsset* Profile)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.DynamicPhysicalAnimationComponent.SetActiveProfile");
		
		UDynamicPhysicalAnimationComponent_SetActiveProfile_Params params {};
		params.Profile = Profile;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E0E780
	 * 		Name   -> Function GbxGameSystemCore.DynamicPhysicalAnimationComponent.OnRigidBodyOverlap
	 * 		Flags  -> (Final, Native, Public, HasOutParms, HasDefaults)
	 * Parameters:
	 * 		class UPrimitiveComponent*                         HitComponent                                               (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      OtherActor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UPrimitiveComponent*                         OtherComp                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     NormalImpulse                                              (Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FHitResult                                  Hit                                                        (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	void UDynamicPhysicalAnimationComponent::OnRigidBodyOverlap(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, const struct FVector& NormalImpulse, const struct FHitResult& Hit)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.DynamicPhysicalAnimationComponent.OnRigidBodyOverlap");
		
		UDynamicPhysicalAnimationComponent_OnRigidBodyOverlap_Params params {};
		params.HitComponent = HitComponent;
		params.OtherActor = OtherActor;
		params.OtherComp = OtherComp;
		params.NormalImpulse = NormalImpulse;
		params.Hit = Hit;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E0E5A0
	 * 		Name   -> Function GbxGameSystemCore.DynamicPhysicalAnimationComponent.GetStrengthMultiplier
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	float UDynamicPhysicalAnimationComponent::GetStrengthMultiplier()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.DynamicPhysicalAnimationComponent.GetStrengthMultiplier");
		
		UDynamicPhysicalAnimationComponent_GetStrengthMultiplier_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E0E580
	 * 		Name   -> Function GbxGameSystemCore.DynamicPhysicalAnimationComponent.GetRootMotionControl
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	EPhysicalAnimationRootMotionControl UDynamicPhysicalAnimationComponent::GetRootMotionControl()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.DynamicPhysicalAnimationComponent.GetRootMotionControl");
		
		UDynamicPhysicalAnimationComponent_GetRootMotionControl_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E0E1E0
	 * 		Name   -> Function GbxGameSystemCore.DynamicPhysicalAnimationComponent.DetachBodyFromAllExternalRigidBodies
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class FName                                        BodyName                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UDynamicPhysicalAnimationComponent::DetachBodyFromAllExternalRigidBodies(const class FName& BodyName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.DynamicPhysicalAnimationComponent.DetachBodyFromAllExternalRigidBodies");
		
		UDynamicPhysicalAnimationComponent_DetachBodyFromAllExternalRigidBodies_Params params {};
		params.BodyName = BodyName;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E0E050
	 * 		Name   -> Function GbxGameSystemCore.DynamicPhysicalAnimationComponent.AttachBodyTo
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class FName                                        BodyName                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UPrimitiveComponent*                         AttachToComponent                                          (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FName                                        AttachToBodyName                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              VelocitySpaceBlend                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              BreakForce                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UDynamicPhysicalAnimationComponent::AttachBodyTo(const class FName& BodyName, class UPrimitiveComponent* AttachToComponent, const class FName& AttachToBodyName, float VelocitySpaceBlend, float BreakForce)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.DynamicPhysicalAnimationComponent.AttachBodyTo");
		
		UDynamicPhysicalAnimationComponent_AttachBodyTo_Params params {};
		params.BodyName = BodyName;
		params.AttachToComponent = AttachToComponent;
		params.AttachToBodyName = AttachToBodyName;
		params.VelocitySpaceBlend = VelocitySpaceBlend;
		params.BreakForce = BreakForce;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDynamicPhysicalAnimationComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDynamicPhysicalAnimationComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.DynamicPhysicalAnimationComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UEnvQueryContext_AimStart.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UEnvQueryContext_AimStart::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.EnvQueryContext_AimStart");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UEnvQueryContext_AimEnd.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UEnvQueryContext_AimEnd::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.EnvQueryContext_AimEnd");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UEnvQueryContext_Owner_AimStart.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UEnvQueryContext_Owner_AimStart::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.EnvQueryContext_Owner_AimStart");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UEnvQueryContext_Owner_AimEnd.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UEnvQueryContext_Owner_AimEnd::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.EnvQueryContext_Owner_AimEnd");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UEnvQueryContext_LastResult.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UEnvQueryContext_LastResult::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.EnvQueryContext_LastResult");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UEnvQueryContext_Origin.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UEnvQueryContext_Origin::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.EnvQueryContext_Origin");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UEnvQueryContext_PlayerMaster.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UEnvQueryContext_PlayerMaster::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.EnvQueryContext_PlayerMaster");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UEnvQueryContext_Players.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UEnvQueryContext_Players::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.EnvQueryContext_Players");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UEnvQueryContext_QuerierAimDirection.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UEnvQueryContext_QuerierAimDirection::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.EnvQueryContext_QuerierAimDirection");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UEnvQueryContext_QuerierAimDirection2D.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UEnvQueryContext_QuerierAimDirection2D::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.EnvQueryContext_QuerierAimDirection2D");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UEnvQueryContext_QuerierAimLocation.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UEnvQueryContext_QuerierAimLocation::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.EnvQueryContext_QuerierAimLocation");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UEnvQueryContext_QuerierMoveDirection.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UEnvQueryContext_QuerierMoveDirection::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.EnvQueryContext_QuerierMoveDirection");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UEnvQueryContext_TargetNavLocation.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UEnvQueryContext_TargetNavLocation::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.EnvQueryContext_TargetNavLocation");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UEnvQueryGenerator_TargetActorInfo.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UEnvQueryGenerator_TargetActorInfo::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.EnvQueryGenerator_TargetActorInfo");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UEnvQueryItemType_Targetable.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UEnvQueryItemType_Targetable::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.EnvQueryItemType_Targetable");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UEnvQueryItemType_TargetActorInfo.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UEnvQueryItemType_TargetActorInfo::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.EnvQueryItemType_TargetActorInfo");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UEnvQueryContext_InputTarget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UEnvQueryContext_InputTarget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.EnvQueryContext_InputTarget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UEnvQueryContext_InputTargetMoveDir.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UEnvQueryContext_InputTargetMoveDir::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.EnvQueryContext_InputTargetMoveDir");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E0F030
	 * 		Name   -> Function GbxGameSystemCore.EnvQueryParamsExt.RunEnvQueryForBestLocation
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		class UObject*                                     QueryOwner                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FEnvQueryParams                             QueryParams                                                (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     ResultLocation                                             (Parm, OutParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UEnvQueryParamsExt::STATIC_RunEnvQueryForBestLocation(class UObject* QueryOwner, const struct FEnvQueryParams& QueryParams, struct FVector* ResultLocation)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.EnvQueryParamsExt.RunEnvQueryForBestLocation");
		
		UEnvQueryParamsExt_RunEnvQueryForBestLocation_Params params {};
		params.QueryOwner = QueryOwner;
		params.QueryParams = QueryParams;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (ResultLocation != nullptr)
			*ResultLocation = params.ResultLocation;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E0EE80
	 * 		Name   -> Function GbxGameSystemCore.EnvQueryParamsExt.RunEnvQueryForBestActor
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		class UObject*                                     QueryOwner                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FEnvQueryParams                             QueryParams                                                (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      ResultActor                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UEnvQueryParamsExt::STATIC_RunEnvQueryForBestActor(class UObject* QueryOwner, const struct FEnvQueryParams& QueryParams, class AActor** ResultActor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.EnvQueryParamsExt.RunEnvQueryForBestActor");
		
		UEnvQueryParamsExt_RunEnvQueryForBestActor_Params params {};
		params.QueryOwner = QueryOwner;
		params.QueryParams = QueryParams;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (ResultActor != nullptr)
			*ResultActor = params.ResultActor;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E0ECB0
	 * 		Name   -> Function GbxGameSystemCore.EnvQueryParamsExt.RunEnvQueryForAllLocations
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		class UObject*                                     QueryOwner                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FEnvQueryParams                             QueryParams                                                (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 * 		TArray<struct FVector>                             ResultLocations                                            (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	 */
	bool UEnvQueryParamsExt::STATIC_RunEnvQueryForAllLocations(class UObject* QueryOwner, const struct FEnvQueryParams& QueryParams, TArray<struct FVector>* ResultLocations)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.EnvQueryParamsExt.RunEnvQueryForAllLocations");
		
		UEnvQueryParamsExt_RunEnvQueryForAllLocations_Params params {};
		params.QueryOwner = QueryOwner;
		params.QueryParams = QueryParams;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (ResultLocations != nullptr)
			*ResultLocations = params.ResultLocations;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E0EAE0
	 * 		Name   -> Function GbxGameSystemCore.EnvQueryParamsExt.RunEnvQueryForAllActors
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		class UObject*                                     QueryOwner                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FEnvQueryParams                             QueryParams                                                (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 * 		TArray<class AActor*>                              ResultActors                                               (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	 */
	bool UEnvQueryParamsExt::STATIC_RunEnvQueryForAllActors(class UObject* QueryOwner, const struct FEnvQueryParams& QueryParams, TArray<class AActor*>* ResultActors)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.EnvQueryParamsExt.RunEnvQueryForAllActors");
		
		UEnvQueryParamsExt_RunEnvQueryForAllActors_Params params {};
		params.QueryOwner = QueryOwner;
		params.QueryParams = QueryParams;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (ResultActors != nullptr)
			*ResultActors = params.ResultActors;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E0E660
	 * 		Name   -> Function GbxGameSystemCore.EnvQueryParamsExt.HasQuery
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FEnvQueryParams                             QueryParams                                                (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	bool UEnvQueryParamsExt::STATIC_HasQuery(const struct FEnvQueryParams& QueryParams)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.EnvQueryParamsExt.HasQuery");
		
		UEnvQueryParamsExt_HasQuery_Params params {};
		params.QueryParams = QueryParams;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E0E260
	 * 		Name   -> Function GbxGameSystemCore.EnvQueryParamsExt.GetDescription
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FEnvQueryParams                             QueryParams                                                (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	class FString UEnvQueryParamsExt::STATIC_GetDescription(const struct FEnvQueryParams& QueryParams)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.EnvQueryParamsExt.GetDescription");
		
		UEnvQueryParamsExt_GetDescription_Params params {};
		params.QueryParams = QueryParams;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UEnvQueryParamsExt.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UEnvQueryParamsExt::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.EnvQueryParamsExt");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UEnvQueryParamsProvider.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UEnvQueryParamsProvider::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.EnvQueryParamsProvider");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UEnvQueryTest_ProjectilesHomingTowardsTarget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UEnvQueryTest_ProjectilesHomingTowardsTarget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.EnvQueryTest_ProjectilesHomingTowardsTarget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UEnvQueryTestAsset.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UEnvQueryTestAsset::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.EnvQueryTestAsset");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UEQSProxyInterface.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UEQSProxyInterface::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.EQSProxyInterface");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E0E930
	 * 		Name   -> Function GbxGameSystemCore.ExplosionBlueprintLibrary.PlayExplosion
	 * 		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		class UExplosionData*                              ExplosionData                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Size                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     ExplosionLocation                                          (Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UObject*                                     Context                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UClass*                                      DamageType                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UParticleSystemComponent* UExplosionBlueprintLibrary::STATIC_PlayExplosion(class UExplosionData* ExplosionData, float Size, const struct FVector& ExplosionLocation, class UObject* Context, class UClass* DamageType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.ExplosionBlueprintLibrary.PlayExplosion");
		
		UExplosionBlueprintLibrary_PlayExplosion_Params params {};
		params.ExplosionData = ExplosionData;
		params.Size = Size;
		params.ExplosionLocation = ExplosionLocation;
		params.Context = Context;
		params.DamageType = DamageType;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UExplosionBlueprintLibrary.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UExplosionBlueprintLibrary::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.ExplosionBlueprintLibrary");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E147F0
	 * 		Name   -> Function GbxGameSystemCore.DamageInfoFunctionLibrary.SetImpactForce
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		struct FDamageInfo                                 DamageInfo                                                 (Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 * 		float                                              InImpactForce                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UDamageInfoFunctionLibrary::STATIC_SetImpactForce(struct FDamageInfo* DamageInfo, float InImpactForce)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.DamageInfoFunctionLibrary.SetImpactForce");
		
		UDamageInfoFunctionLibrary_SetImpactForce_Params params {};
		params.InImpactForce = InImpactForce;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (DamageInfo != nullptr)
			*DamageInfo = params.DamageInfo;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E14650
	 * 		Name   -> Function GbxGameSystemCore.DamageInfoFunctionLibrary.SetDamageType
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		struct FDamageInfo                                 DamageInfo                                                 (Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 * 		class UClass*                                      InDamageType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UDamageInfoFunctionLibrary::STATIC_SetDamageType(struct FDamageInfo* DamageInfo, class UClass* InDamageType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.DamageInfoFunctionLibrary.SetDamageType");
		
		UDamageInfoFunctionLibrary_SetDamageType_Params params {};
		params.InDamageType = InDamageType;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (DamageInfo != nullptr)
			*DamageInfo = params.DamageInfo;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E14540
	 * 		Name   -> Function GbxGameSystemCore.DamageInfoFunctionLibrary.SetDamageSource
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		struct FDamageInfo                                 DamageInfo                                                 (Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 * 		class UClass*                                      InDamageSource                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UDamageInfoFunctionLibrary::STATIC_SetDamageSource(struct FDamageInfo* DamageInfo, class UClass* InDamageSource)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.DamageInfoFunctionLibrary.SetDamageSource");
		
		UDamageInfoFunctionLibrary_SetDamageSource_Params params {};
		params.InDamageSource = InDamageSource;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (DamageInfo != nullptr)
			*DamageInfo = params.DamageInfo;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E14440
	 * 		Name   -> Function GbxGameSystemCore.DamageInfoFunctionLibrary.SetDamageRadius
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		struct FDamageInfo                                 DamageInfo                                                 (Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 * 		float                                              InDamageRadius                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UDamageInfoFunctionLibrary::STATIC_SetDamageRadius(struct FDamageInfo* DamageInfo, float InDamageRadius)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.DamageInfoFunctionLibrary.SetDamageRadius");
		
		UDamageInfoFunctionLibrary_SetDamageRadius_Params params {};
		params.InDamageRadius = InDamageRadius;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (DamageInfo != nullptr)
			*DamageInfo = params.DamageInfo;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E14330
	 * 		Name   -> Function GbxGameSystemCore.DamageInfoFunctionLibrary.SetDamageModifierComponent
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		struct FDamageInfo                                 DamageInfo                                                 (Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 * 		class UDamageModifierComponent*                    InModifierComponent                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UDamageInfoFunctionLibrary::STATIC_SetDamageModifierComponent(struct FDamageInfo* DamageInfo, class UDamageModifierComponent* InModifierComponent)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.DamageInfoFunctionLibrary.SetDamageModifierComponent");
		
		UDamageInfoFunctionLibrary_SetDamageModifierComponent_Params params {};
		params.InModifierComponent = InModifierComponent;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (DamageInfo != nullptr)
			*DamageInfo = params.DamageInfo;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E14220
	 * 		Name   -> Function GbxGameSystemCore.DamageInfoFunctionLibrary.SetDamageCauser
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		struct FDamageInfo                                 DamageInfo                                                 (Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      InDamageCauser                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UDamageInfoFunctionLibrary::STATIC_SetDamageCauser(struct FDamageInfo* DamageInfo, class AActor* InDamageCauser)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.DamageInfoFunctionLibrary.SetDamageCauser");
		
		UDamageInfoFunctionLibrary_SetDamageCauser_Params params {};
		params.InDamageCauser = InDamageCauser;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (DamageInfo != nullptr)
			*DamageInfo = params.DamageInfo;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E14120
	 * 		Name   -> Function GbxGameSystemCore.DamageInfoFunctionLibrary.SetDamage
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		struct FDamageInfo                                 DamageInfo                                                 (Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 * 		float                                              InDamage                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UDamageInfoFunctionLibrary::STATIC_SetDamage(struct FDamageInfo* DamageInfo, float InDamage)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.DamageInfoFunctionLibrary.SetDamage");
		
		UDamageInfoFunctionLibrary_SetDamage_Params params {};
		params.InDamage = InDamage;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (DamageInfo != nullptr)
			*DamageInfo = params.DamageInfo;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E14000
	 * 		Name   -> Function GbxGameSystemCore.DamageInfoFunctionLibrary.SetCriticalHitDamageOverrides
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		struct FDamageInfo                                 DamageInfo                                                 (Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 * 		struct FCriticalHitDamageOverrides                 Overrides                                                  (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UDamageInfoFunctionLibrary::STATIC_SetCriticalHitDamageOverrides(struct FDamageInfo* DamageInfo, const struct FCriticalHitDamageOverrides& Overrides)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.DamageInfoFunctionLibrary.SetCriticalHitDamageOverrides");
		
		UDamageInfoFunctionLibrary_SetCriticalHitDamageOverrides_Params params {};
		params.Overrides = Overrides;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (DamageInfo != nullptr)
			*DamageInfo = params.DamageInfo;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E13EF0
	 * 		Name   -> Function GbxGameSystemCore.DamageInfoFunctionLibrary.SetApplyCriticalHitModsToAoEDamage
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		struct FDamageInfo                                 DamageInfo                                                 (Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 * 		bool                                               bApplyCriticalHitModsToAoEDamage                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UDamageInfoFunctionLibrary::STATIC_SetApplyCriticalHitModsToAoEDamage(struct FDamageInfo* DamageInfo, bool bApplyCriticalHitModsToAoEDamage)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.DamageInfoFunctionLibrary.SetApplyCriticalHitModsToAoEDamage");
		
		UDamageInfoFunctionLibrary_SetApplyCriticalHitModsToAoEDamage_Params params {};
		params.bApplyCriticalHitModsToAoEDamage = bApplyCriticalHitModsToAoEDamage;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (DamageInfo != nullptr)
			*DamageInfo = params.DamageInfo;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E12C40
	 * 		Name   -> Function GbxGameSystemCore.DamageInfoFunctionLibrary.GetImpactForce
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FDamageInfo                                 DamageInfo                                                 (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	float UDamageInfoFunctionLibrary::STATIC_GetImpactForce(const struct FDamageInfo& DamageInfo)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.DamageInfoFunctionLibrary.GetImpactForce");
		
		UDamageInfoFunctionLibrary_GetImpactForce_Params params {};
		params.DamageInfo = DamageInfo;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E128C0
	 * 		Name   -> Function GbxGameSystemCore.DamageInfoFunctionLibrary.GetDamageType
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FDamageInfo                                 DamageInfo                                                 (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	class UClass* UDamageInfoFunctionLibrary::STATIC_GetDamageType(const struct FDamageInfo& DamageInfo)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.DamageInfoFunctionLibrary.GetDamageType");
		
		UDamageInfoFunctionLibrary_GetDamageType_Params params {};
		params.DamageInfo = DamageInfo;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E12800
	 * 		Name   -> Function GbxGameSystemCore.DamageInfoFunctionLibrary.GetDamageSource
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FDamageInfo                                 DamageInfo                                                 (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	class UClass* UDamageInfoFunctionLibrary::STATIC_GetDamageSource(const struct FDamageInfo& DamageInfo)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.DamageInfoFunctionLibrary.GetDamageSource");
		
		UDamageInfoFunctionLibrary_GetDamageSource_Params params {};
		params.DamageInfo = DamageInfo;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E12740
	 * 		Name   -> Function GbxGameSystemCore.DamageInfoFunctionLibrary.GetDamageRadius
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FDamageInfo                                 DamageInfo                                                 (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	float UDamageInfoFunctionLibrary::STATIC_GetDamageRadius(const struct FDamageInfo& DamageInfo)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.DamageInfoFunctionLibrary.GetDamageRadius");
		
		UDamageInfoFunctionLibrary_GetDamageRadius_Params params {};
		params.DamageInfo = DamageInfo;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E12680
	 * 		Name   -> Function GbxGameSystemCore.DamageInfoFunctionLibrary.GetDamageModifierComponent
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FDamageInfo                                 DamageInfo                                                 (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	class UDamageModifierComponent* UDamageInfoFunctionLibrary::STATIC_GetDamageModifierComponent(const struct FDamageInfo& DamageInfo)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.DamageInfoFunctionLibrary.GetDamageModifierComponent");
		
		UDamageInfoFunctionLibrary_GetDamageModifierComponent_Params params {};
		params.DamageInfo = DamageInfo;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E125C0
	 * 		Name   -> Function GbxGameSystemCore.DamageInfoFunctionLibrary.GetDamageCauser
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FDamageInfo                                 DamageInfo                                                 (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	class AActor* UDamageInfoFunctionLibrary::STATIC_GetDamageCauser(const struct FDamageInfo& DamageInfo)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.DamageInfoFunctionLibrary.GetDamageCauser");
		
		UDamageInfoFunctionLibrary_GetDamageCauser_Params params {};
		params.DamageInfo = DamageInfo;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E12500
	 * 		Name   -> Function GbxGameSystemCore.DamageInfoFunctionLibrary.GetDamage
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FDamageInfo                                 DamageInfo                                                 (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	float UDamageInfoFunctionLibrary::STATIC_GetDamage(const struct FDamageInfo& DamageInfo)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.DamageInfoFunctionLibrary.GetDamage");
		
		UDamageInfoFunctionLibrary_GetDamage_Params params {};
		params.DamageInfo = DamageInfo;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E12440
	 * 		Name   -> Function GbxGameSystemCore.DamageInfoFunctionLibrary.GetCriticalHitDamageOverrides
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FDamageInfo                                 DamageInfo                                                 (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	struct FCriticalHitDamageOverrides UDamageInfoFunctionLibrary::STATIC_GetCriticalHitDamageOverrides(const struct FDamageInfo& DamageInfo)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.DamageInfoFunctionLibrary.GetCriticalHitDamageOverrides");
		
		UDamageInfoFunctionLibrary_GetCriticalHitDamageOverrides_Params params {};
		params.DamageInfo = DamageInfo;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E12380
	 * 		Name   -> Function GbxGameSystemCore.DamageInfoFunctionLibrary.GetApplyCriticalHitModsToAoEDamage
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FDamageInfo                                 DamageInfo                                                 (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	bool UDamageInfoFunctionLibrary::STATIC_GetApplyCriticalHitModsToAoEDamage(const struct FDamageInfo& DamageInfo)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.DamageInfoFunctionLibrary.GetApplyCriticalHitModsToAoEDamage");
		
		UDamageInfoFunctionLibrary_GetApplyCriticalHitModsToAoEDamage_Params params {};
		params.DamageInfo = DamageInfo;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDamageInfoFunctionLibrary.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDamageInfoFunctionLibrary::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.DamageInfoFunctionLibrary");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E14760
	 * 		Name   -> Function GbxGameSystemCore.ExplosionComponent.SetExplosionLocation
	 * 		Flags  -> (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FVector                                     NewLocation                                                (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UExplosionComponent::SetExplosionLocation(const struct FVector& NewLocation)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.ExplosionComponent.SetExplosionLocation");
		
		UExplosionComponent_SetExplosionLocation_Params params {};
		params.NewLocation = NewLocation;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E122B0
	 * 		Name   -> Function GbxGameSystemCore.ExplosionComponent.Explode
	 * 		Flags  -> (Native, Event, Public, HasOutParms, BlueprintCallable, BlueprintEvent)
	 * Parameters:
	 * 		struct FDamageInfo                                 DamageInfo                                                 (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	void UExplosionComponent::Explode(const struct FDamageInfo& DamageInfo)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.ExplosionComponent.Explode");
		
		UExplosionComponent_Explode_Params params {};
		params.DamageInfo = DamageInfo;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UExplosionComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UExplosionComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.ExplosionComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E13DB0
	 * 		Name   -> Function GbxGameSystemCore.ExplosionData.SelectExplosion
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		float                                              Size                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UClass*                                      DamageType                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FExplosionSizeProperties UExplosionData::SelectExplosion(float Size, class UClass* DamageType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.ExplosionData.SelectExplosion");
		
		UExplosionData_SelectExplosion_Params params {};
		params.Size = Size;
		params.DamageType = DamageType;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UExplosionData.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UExplosionData::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.ExplosionData");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E12980
	 * 		Name   -> Function GbxGameSystemCore.ExplosionSizeSelectionData.GetExplosionPropertiesBySize
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		float                                              Size                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FExplosionSizeProperties UExplosionSizeSelectionData::GetExplosionPropertiesBySize(float Size)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.ExplosionSizeSelectionData.GetExplosionPropertiesBySize");
		
		UExplosionSizeSelectionData_GetExplosionPropertiesBySize_Params params {};
		params.Size = Size;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UExplosionSizeSelectionData.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UExplosionSizeSelectionData::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.ExplosionSizeSelectionData");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UEyesOfDeathComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UEyesOfDeathComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.EyesOfDeathComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E14B20
	 * 		Name   -> Function GbxGameSystemCore.FeedbackData.StopFeedbackForAll
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UFeedbackData*                               FeedbackData                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UFeedbackData::STATIC_StopFeedbackForAll(class UFeedbackData* FeedbackData, class UObject* WorldContextObject)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.FeedbackData.StopFeedbackForAll");
		
		UFeedbackData_StopFeedbackForAll_Params params {};
		params.FeedbackData = FeedbackData;
		params.WorldContextObject = WorldContextObject;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E14A70
	 * 		Name   -> Function GbxGameSystemCore.FeedbackData.StopFeedback
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UFeedbackData*                               FeedbackData                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class APlayerController*                           Controller                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UFeedbackData::STATIC_StopFeedback(class UFeedbackData* FeedbackData, class APlayerController* Controller)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.FeedbackData.StopFeedback");
		
		UFeedbackData_StopFeedback_Params params {};
		params.FeedbackData = FeedbackData;
		params.Controller = Controller;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E149B0
	 * 		Name   -> Function GbxGameSystemCore.FeedbackData.StopDefaultFeedbackForAll
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		struct FFeedbackTableRowHandle                     Feedback                                                   (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 * 		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UFeedbackData::STATIC_StopDefaultFeedbackForAll(const struct FFeedbackTableRowHandle& Feedback, class UObject* WorldContextObject)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.FeedbackData.StopDefaultFeedbackForAll");
		
		UFeedbackData_StopDefaultFeedbackForAll_Params params {};
		params.Feedback = Feedback;
		params.WorldContextObject = WorldContextObject;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E148F0
	 * 		Name   -> Function GbxGameSystemCore.FeedbackData.StopDefaultFeedback
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		struct FFeedbackTableRowHandle                     Feedback                                                   (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 * 		class APlayerController*                           Controller                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UFeedbackData::STATIC_StopDefaultFeedback(const struct FFeedbackTableRowHandle& Feedback, class APlayerController* Controller)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.FeedbackData.StopDefaultFeedback");
		
		UFeedbackData_StopDefaultFeedback_Params params {};
		params.Feedback = Feedback;
		params.Controller = Controller;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E13B50
	 * 		Name   -> Function GbxGameSystemCore.FeedbackData.PerformFeedbackForAllAtLocation
	 * 		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		class UFeedbackData*                               FeedbackData                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     SourceLocation                                             (Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FRangedDistanceOverrides                    RangedDistanceOverrides                                    (ConstParm, Parm, NoDestructor, NativeAccessSpecifierPublic)
	 * 		bool                                               bLoop                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UObject*                                     SourceContext                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class APlayerController*                           ControllerToIgnore                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UFeedbackData*                               OverrideControllerFeedback                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UFeedbackData::STATIC_PerformFeedbackForAllAtLocation(class UFeedbackData* FeedbackData, const struct FVector& SourceLocation, const struct FRangedDistanceOverrides& RangedDistanceOverrides, bool bLoop, class UObject* WorldContextObject, class UObject* SourceContext, class APlayerController* ControllerToIgnore, class UFeedbackData* OverrideControllerFeedback)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.FeedbackData.PerformFeedbackForAllAtLocation");
		
		UFeedbackData_PerformFeedbackForAllAtLocation_Params params {};
		params.FeedbackData = FeedbackData;
		params.SourceLocation = SourceLocation;
		params.RangedDistanceOverrides = RangedDistanceOverrides;
		params.bLoop = bLoop;
		params.WorldContextObject = WorldContextObject;
		params.SourceContext = SourceContext;
		params.ControllerToIgnore = ControllerToIgnore;
		params.OverrideControllerFeedback = OverrideControllerFeedback;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E13950
	 * 		Name   -> Function GbxGameSystemCore.FeedbackData.PerformFeedbackForAll
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UFeedbackData*                               FeedbackData                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Scale                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bLoop                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UObject*                                     SourceContext                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class APlayerController*                           ControllerToIgnore                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UFeedbackData*                               OverrideControllerFeedback                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UFeedbackData::STATIC_PerformFeedbackForAll(class UFeedbackData* FeedbackData, float Scale, bool bLoop, class UObject* WorldContextObject, class UObject* SourceContext, class APlayerController* ControllerToIgnore, class UFeedbackData* OverrideControllerFeedback)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.FeedbackData.PerformFeedbackForAll");
		
		UFeedbackData_PerformFeedbackForAll_Params params {};
		params.FeedbackData = FeedbackData;
		params.Scale = Scale;
		params.bLoop = bLoop;
		params.WorldContextObject = WorldContextObject;
		params.SourceContext = SourceContext;
		params.ControllerToIgnore = ControllerToIgnore;
		params.OverrideControllerFeedback = OverrideControllerFeedback;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E136F0
	 * 		Name   -> Function GbxGameSystemCore.FeedbackData.PerformFeedbackAtLocation
	 * 		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		class UFeedbackData*                               FeedbackData                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class APlayerController*                           Controller                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     SourceLocation                                             (Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FRangedDistanceOverrides                    RangedDistanceOverrides                                    (ConstParm, Parm, NoDestructor, NativeAccessSpecifierPublic)
	 * 		bool                                               bLoop                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UObject*                                     SourceContext                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class APlayerController*                           ControllerToIgnore                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UFeedbackData*                               OverrideControllerFeedback                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UFeedbackData::STATIC_PerformFeedbackAtLocation(class UFeedbackData* FeedbackData, class APlayerController* Controller, const struct FVector& SourceLocation, const struct FRangedDistanceOverrides& RangedDistanceOverrides, bool bLoop, class UObject* SourceContext, class APlayerController* ControllerToIgnore, class UFeedbackData* OverrideControllerFeedback)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.FeedbackData.PerformFeedbackAtLocation");
		
		UFeedbackData_PerformFeedbackAtLocation_Params params {};
		params.FeedbackData = FeedbackData;
		params.Controller = Controller;
		params.SourceLocation = SourceLocation;
		params.RangedDistanceOverrides = RangedDistanceOverrides;
		params.bLoop = bLoop;
		params.SourceContext = SourceContext;
		params.ControllerToIgnore = ControllerToIgnore;
		params.OverrideControllerFeedback = OverrideControllerFeedback;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E13560
	 * 		Name   -> Function GbxGameSystemCore.FeedbackData.PerformFeedback
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UFeedbackData*                               FeedbackData                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class APlayerController*                           Controller                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Scale                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bLoop                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UObject*                                     SourceContext                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UFeedbackData::STATIC_PerformFeedback(class UFeedbackData* FeedbackData, class APlayerController* Controller, float Scale, bool bLoop, class UObject* SourceContext)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.FeedbackData.PerformFeedback");
		
		UFeedbackData_PerformFeedback_Params params {};
		params.FeedbackData = FeedbackData;
		params.Controller = Controller;
		params.Scale = Scale;
		params.bLoop = bLoop;
		params.SourceContext = SourceContext;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E132F0
	 * 		Name   -> Function GbxGameSystemCore.FeedbackData.PerformDefaultFeedbackForAllAtLocation
	 * 		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FFeedbackTableRowHandle                     Feedback                                                   (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     SourceLocation                                             (Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FRangedDistanceOverrides                    RangedDistanceOverrides                                    (ConstParm, Parm, NoDestructor, NativeAccessSpecifierPublic)
	 * 		bool                                               bLoop                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UObject*                                     SourceContext                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class APlayerController*                           ControllerToIgnore                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UFeedbackData*                               OverrideControllerFeedback                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UFeedbackData::STATIC_PerformDefaultFeedbackForAllAtLocation(const struct FFeedbackTableRowHandle& Feedback, const struct FVector& SourceLocation, const struct FRangedDistanceOverrides& RangedDistanceOverrides, bool bLoop, class UObject* WorldContextObject, class UObject* SourceContext, class APlayerController* ControllerToIgnore, class UFeedbackData* OverrideControllerFeedback)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.FeedbackData.PerformDefaultFeedbackForAllAtLocation");
		
		UFeedbackData_PerformDefaultFeedbackForAllAtLocation_Params params {};
		params.Feedback = Feedback;
		params.SourceLocation = SourceLocation;
		params.RangedDistanceOverrides = RangedDistanceOverrides;
		params.bLoop = bLoop;
		params.WorldContextObject = WorldContextObject;
		params.SourceContext = SourceContext;
		params.ControllerToIgnore = ControllerToIgnore;
		params.OverrideControllerFeedback = OverrideControllerFeedback;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E130E0
	 * 		Name   -> Function GbxGameSystemCore.FeedbackData.PerformDefaultFeedbackForAll
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		struct FFeedbackTableRowHandle                     Feedback                                                   (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 * 		float                                              Scale                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bLoop                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UObject*                                     SourceContext                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class APlayerController*                           ControllerToIgnore                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UFeedbackData*                               OverrideControllerFeedback                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UFeedbackData::STATIC_PerformDefaultFeedbackForAll(const struct FFeedbackTableRowHandle& Feedback, float Scale, bool bLoop, class UObject* WorldContextObject, class UObject* SourceContext, class APlayerController* ControllerToIgnore, class UFeedbackData* OverrideControllerFeedback)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.FeedbackData.PerformDefaultFeedbackForAll");
		
		UFeedbackData_PerformDefaultFeedbackForAll_Params params {};
		params.Feedback = Feedback;
		params.Scale = Scale;
		params.bLoop = bLoop;
		params.WorldContextObject = WorldContextObject;
		params.SourceContext = SourceContext;
		params.ControllerToIgnore = ControllerToIgnore;
		params.OverrideControllerFeedback = OverrideControllerFeedback;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E12E80
	 * 		Name   -> Function GbxGameSystemCore.FeedbackData.PerformDefaultFeedbackAtLocation
	 * 		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FFeedbackTableRowHandle                     Feedback                                                   (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 * 		class APlayerController*                           Controller                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     SourceLocation                                             (Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FRangedDistanceOverrides                    RangedDistanceOverrides                                    (ConstParm, Parm, NoDestructor, NativeAccessSpecifierPublic)
	 * 		bool                                               bLoop                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UObject*                                     SourceContext                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class APlayerController*                           ControllerToIgnore                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UFeedbackData*                               OverrideControllerFeedback                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UFeedbackData::STATIC_PerformDefaultFeedbackAtLocation(const struct FFeedbackTableRowHandle& Feedback, class APlayerController* Controller, const struct FVector& SourceLocation, const struct FRangedDistanceOverrides& RangedDistanceOverrides, bool bLoop, class UObject* SourceContext, class APlayerController* ControllerToIgnore, class UFeedbackData* OverrideControllerFeedback)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.FeedbackData.PerformDefaultFeedbackAtLocation");
		
		UFeedbackData_PerformDefaultFeedbackAtLocation_Params params {};
		params.Feedback = Feedback;
		params.Controller = Controller;
		params.SourceLocation = SourceLocation;
		params.RangedDistanceOverrides = RangedDistanceOverrides;
		params.bLoop = bLoop;
		params.SourceContext = SourceContext;
		params.ControllerToIgnore = ControllerToIgnore;
		params.OverrideControllerFeedback = OverrideControllerFeedback;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E12D00
	 * 		Name   -> Function GbxGameSystemCore.FeedbackData.PerformDefaultFeedback
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		struct FFeedbackTableRowHandle                     Feedback                                                   (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 * 		class APlayerController*                           Controller                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Scale                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bLoop                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UObject*                                     SourceContext                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UFeedbackData::STATIC_PerformDefaultFeedback(const struct FFeedbackTableRowHandle& Feedback, class APlayerController* Controller, float Scale, bool bLoop, class UObject* SourceContext)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.FeedbackData.PerformDefaultFeedback");
		
		UFeedbackData_PerformDefaultFeedback_Params params {};
		params.Feedback = Feedback;
		params.Controller = Controller;
		params.Scale = Scale;
		params.bLoop = bLoop;
		params.SourceContext = SourceContext;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E12BB0
	 * 		Name   -> Function GbxGameSystemCore.FeedbackData.GetFeedbackDuration
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UFeedbackData*                               FeedbackData                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	float UFeedbackData::STATIC_GetFeedbackDuration(class UFeedbackData* FeedbackData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.FeedbackData.GetFeedbackDuration");
		
		UFeedbackData_GetFeedbackDuration_Params params {};
		params.FeedbackData = FeedbackData;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E12A90
	 * 		Name   -> Function GbxGameSystemCore.FeedbackData.GetFeedbackDataRange
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		class UFeedbackData*                               FeedbackData                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              MinRange                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              MaxRange                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UFeedbackData::STATIC_GetFeedbackDataRange(class UFeedbackData* FeedbackData, float* MinRange, float* MaxRange)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.FeedbackData.GetFeedbackDataRange");
		
		UFeedbackData_GetFeedbackDataRange_Params params {};
		params.FeedbackData = FeedbackData;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (MinRange != nullptr)
			*MinRange = params.MinRange;
		if (MaxRange != nullptr)
			*MaxRange = params.MaxRange;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UFeedbackData.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UFeedbackData::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.FeedbackData");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AFirstPersonConfigurationData.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AFirstPersonConfigurationData::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.FirstPersonConfigurationData");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E190D0
	 * 		Name   -> Function GbxGameSystemCore.FXVolumeManager.OnVolumeDestroyed
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		class AActor*                                      DestroyedActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UFXVolumeManager::OnVolumeDestroyed(class AActor* DestroyedActor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.FXVolumeManager.OnVolumeDestroyed");
		
		UFXVolumeManager_OnVolumeDestroyed_Params params {};
		params.DestroyedActor = DestroyedActor;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E19050
	 * 		Name   -> Function GbxGameSystemCore.FXVolumeManager.OnPlayerDestroyed
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		class AActor*                                      DestroyedActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UFXVolumeManager::OnPlayerDestroyed(class AActor* DestroyedActor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.FXVolumeManager.OnPlayerDestroyed");
		
		UFXVolumeManager_OnPlayerDestroyed_Params params {};
		params.DestroyedActor = DestroyedActor;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UFXVolumeManager.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UFXVolumeManager::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.FXVolumeManager");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E18E90
	 * 		Name   -> Function GbxGameSystemCore.FXVolume.OnActorLeftVolume
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		class UPrimitiveComponent*                         OverlappedComponent                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      Other                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UPrimitiveComponent*                         OtherComp                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            OtherBodyIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AFXVolume::OnActorLeftVolume(class UPrimitiveComponent* OverlappedComponent, class AActor* Other, class UPrimitiveComponent* OtherComp, int32_t OtherBodyIndex)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.FXVolume.OnActorLeftVolume");
		
		AFXVolume_OnActorLeftVolume_Params params {};
		params.OverlappedComponent = OverlappedComponent;
		params.Other = Other;
		params.OtherComp = OtherComp;
		params.OtherBodyIndex = OtherBodyIndex;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E18CA0
	 * 		Name   -> Function GbxGameSystemCore.FXVolume.OnActorEnteredVolume
	 * 		Flags  -> (Final, Native, Public, HasOutParms)
	 * Parameters:
	 * 		class UPrimitiveComponent*                         OverlappedComp                                             (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      Other                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UPrimitiveComponent*                         OtherComp                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            OtherBodyIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bFromSweep                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FHitResult                                  OverlapInfo                                                (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	void AFXVolume::OnActorEnteredVolume(class UPrimitiveComponent* OverlappedComp, class AActor* Other, class UPrimitiveComponent* OtherComp, int32_t OtherBodyIndex, bool bFromSweep, const struct FHitResult& OverlapInfo)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.FXVolume.OnActorEnteredVolume");
		
		AFXVolume_OnActorEnteredVolume_Params params {};
		params.OverlappedComp = OverlappedComp;
		params.Other = Other;
		params.OtherComp = OtherComp;
		params.OtherBodyIndex = OtherBodyIndex;
		params.bFromSweep = bFromSweep;
		params.OverlapInfo = OverlapInfo;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AFXVolume.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AFXVolume::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.FXVolume");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGameplayTagBasedAttributeValueResolver.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGameplayTagBasedAttributeValueResolver::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.GameplayTagBasedAttributeValueResolver");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E18530
	 * 		Name   -> Function GbxGameSystemCore.GameplayTagContainerComponent.GetGameplayTagContainerFromActor
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		class AActor*                                      Actor                                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EContainsTagComponent                              Branches                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UGameplayTagContainerComponent* UGameplayTagContainerComponent::STATIC_GetGameplayTagContainerFromActor(class AActor* Actor, EContainsTagComponent* Branches)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GameplayTagContainerComponent.GetGameplayTagContainerFromActor");
		
		UGameplayTagContainerComponent_GetGameplayTagContainerFromActor_Params params {};
		params.Actor = Actor;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (Branches != nullptr)
			*Branches = params.Branches;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGameplayTagContainerComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGameplayTagContainerComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.GameplayTagContainerComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E19810
	 * 		Name   -> Function GbxGameSystemCore.GameplayTask_RunEnvQuery.RunEnvQueryOnLocation
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		class AActor*                                      QueryOwner                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FEnvQueryParams                             QueryParams                                                (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     Location                                                   (Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UGameplayTask_RunEnvQuery* UGameplayTask_RunEnvQuery::STATIC_RunEnvQueryOnLocation(class AActor* QueryOwner, const struct FEnvQueryParams& QueryParams, const struct FVector& Location)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GameplayTask_RunEnvQuery.RunEnvQueryOnLocation");
		
		UGameplayTask_RunEnvQuery_RunEnvQueryOnLocation_Params params {};
		params.QueryOwner = QueryOwner;
		params.QueryParams = QueryParams;
		params.Location = Location;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E19670
	 * 		Name   -> Function GbxGameSystemCore.GameplayTask_RunEnvQuery.RunEnvQueryOnActor
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		class AActor*                                      QueryOwner                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FEnvQueryParams                             QueryParams                                                (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      Actor                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UGameplayTask_RunEnvQuery* UGameplayTask_RunEnvQuery::STATIC_RunEnvQueryOnActor(class AActor* QueryOwner, const struct FEnvQueryParams& QueryParams, class AActor* Actor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GameplayTask_RunEnvQuery.RunEnvQueryOnActor");
		
		UGameplayTask_RunEnvQuery_RunEnvQueryOnActor_Params params {};
		params.QueryOwner = QueryOwner;
		params.QueryParams = QueryParams;
		params.Actor = Actor;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E19500
	 * 		Name   -> Function GbxGameSystemCore.GameplayTask_RunEnvQuery.RunEnvQuery
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		class AActor*                                      QueryOwner                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FEnvQueryParams                             QueryParams                                                (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	class UGameplayTask_RunEnvQuery* UGameplayTask_RunEnvQuery::STATIC_RunEnvQuery(class AActor* QueryOwner, const struct FEnvQueryParams& QueryParams)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GameplayTask_RunEnvQuery.RunEnvQuery");
		
		UGameplayTask_RunEnvQuery_RunEnvQuery_Params params {};
		params.QueryOwner = QueryOwner;
		params.QueryParams = QueryParams;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E18A70
	 * 		Name   -> Function GbxGameSystemCore.GameplayTask_RunEnvQuery.GetResultLocations
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		struct FEnvQueryResult                             QueryResult                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		TArray<struct FVector>                             ResultLocations                                            (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	 */
	bool UGameplayTask_RunEnvQuery::STATIC_GetResultLocations(const struct FEnvQueryResult& QueryResult, TArray<struct FVector>* ResultLocations)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GameplayTask_RunEnvQuery.GetResultLocations");
		
		UGameplayTask_RunEnvQuery_GetResultLocations_Params params {};
		params.QueryResult = QueryResult;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (ResultLocations != nullptr)
			*ResultLocations = params.ResultLocations;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E18940
	 * 		Name   -> Function GbxGameSystemCore.GameplayTask_RunEnvQuery.GetResultLocation
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FEnvQueryResult                             QueryResult                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     ResultLocation                                             (Parm, OutParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UGameplayTask_RunEnvQuery::STATIC_GetResultLocation(const struct FEnvQueryResult& QueryResult, struct FVector* ResultLocation)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GameplayTask_RunEnvQuery.GetResultLocation");
		
		UGameplayTask_RunEnvQuery_GetResultLocation_Params params {};
		params.QueryResult = QueryResult;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (ResultLocation != nullptr)
			*ResultLocation = params.ResultLocation;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E187F0
	 * 		Name   -> Function GbxGameSystemCore.GameplayTask_RunEnvQuery.GetResultActors
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		struct FEnvQueryResult                             QueryResult                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		TArray<class AActor*>                              ResultActors                                               (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	 */
	bool UGameplayTask_RunEnvQuery::STATIC_GetResultActors(const struct FEnvQueryResult& QueryResult, TArray<class AActor*>* ResultActors)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GameplayTask_RunEnvQuery.GetResultActors");
		
		UGameplayTask_RunEnvQuery_GetResultActors_Params params {};
		params.QueryResult = QueryResult;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (ResultActors != nullptr)
			*ResultActors = params.ResultActors;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E186B0
	 * 		Name   -> Function GbxGameSystemCore.GameplayTask_RunEnvQuery.GetResultActor
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		struct FEnvQueryResult                             QueryResult                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      ResultActor                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UGameplayTask_RunEnvQuery::STATIC_GetResultActor(const struct FEnvQueryResult& QueryResult, class AActor** ResultActor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GameplayTask_RunEnvQuery.GetResultActor");
		
		UGameplayTask_RunEnvQuery_GetResultActor_Params params {};
		params.QueryResult = QueryResult;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (ResultActor != nullptr)
			*ResultActor = params.ResultActor;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGameplayTask_RunEnvQuery.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGameplayTask_RunEnvQuery::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.GameplayTask_RunEnvQuery");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGameResourceData.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGameResourceData::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.GameResourceData");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGameResourcePoolAttributePropertyValueResolver.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGameResourcePoolAttributePropertyValueResolver::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.GameResourcePoolAttributePropertyValueResolver");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGameResourcePoolClampedMaxValueResolver.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGameResourcePoolClampedMaxValueResolver::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.GameResourcePoolClampedMaxValueResolver");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGameResourcePoolClampedValueResolver.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGameResourcePoolClampedValueResolver::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.GameResourcePoolClampedValueResolver");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGameResourcePoolCurrentValueResolver.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGameResourcePoolCurrentValueResolver::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.GameResourcePoolCurrentValueResolver");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGameResourcePoolCurrentValueNoPauseOnHealResolver.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGameResourcePoolCurrentValueNoPauseOnHealResolver::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.GameResourcePoolCurrentValueNoPauseOnHealResolver");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGameResourcePoolData.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGameResourcePoolData::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.GameResourcePoolData");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E19290
	 * 		Name   -> Function GbxGameSystemCore.GameResourcePoolManagerComponent.RemoveResourcePoolDelegate
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		class UGameResourceData*                           InResourceData                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FName                                        DelegatePropertyName                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FScriptDelegate                              ScriptDelegate                                             (Parm, ZeroConstructor, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UGameResourcePoolManagerComponent::RemoveResourcePoolDelegate(class UGameResourceData* InResourceData, const class FName& DelegatePropertyName, const class FScriptDelegate& ScriptDelegate)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GameResourcePoolManagerComponent.RemoveResourcePoolDelegate");
		
		UGameResourcePoolManagerComponent_RemoveResourcePoolDelegate_Params params {};
		params.InResourceData = InResourceData;
		params.DelegatePropertyName = DelegatePropertyName;
		params.ScriptDelegate = ScriptDelegate;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E19150
	 * 		Name   -> Function GbxGameSystemCore.GameResourcePoolManagerComponent.RecalculateAttributeInitializedPoolProperties
	 * 		Flags  -> (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
	 */
	void UGameResourcePoolManagerComponent::RecalculateAttributeInitializedPoolProperties()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GameResourcePoolManagerComponent.RecalculateAttributeInitializedPoolProperties");
		
		UGameResourcePoolManagerComponent_RecalculateAttributeInitializedPoolProperties_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E18FD0
	 * 		Name   -> Function GbxGameSystemCore.GameResourcePoolManagerComponent.OnOwnerExperienceLevelChanged
	 * 		Flags  -> (Final, Native, Private)
	 * Parameters:
	 * 		int32_t                                            OldExperienceLevel                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGameResourcePoolManagerComponent::OnOwnerExperienceLevelChanged(int32_t OldExperienceLevel)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GameResourcePoolManagerComponent.OnOwnerExperienceLevelChanged");
		
		UGameResourcePoolManagerComponent_OnOwnerExperienceLevelChanged_Params params {};
		params.OldExperienceLevel = OldExperienceLevel;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E18600
	 * 		Name   -> Function GbxGameSystemCore.GameResourcePoolManagerComponent.GetResourcePoolByResource
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UGameResourceData*                           Resource                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FGameResourcePoolReference UGameResourcePoolManagerComponent::GetResourcePoolByResource(class UGameResourceData* Resource)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GameResourcePoolManagerComponent.GetResourcePoolByResource");
		
		UGameResourcePoolManagerComponent_GetResourcePoolByResource_Params params {};
		params.Resource = Resource;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E17DD0
	 * 		Name   -> Function GbxGameSystemCore.GameResourcePoolManagerComponent.CreatePool
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UGameResourcePoolData*                       PoolData                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bReinitializeExistingPool                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FGameResourcePoolReference UGameResourcePoolManagerComponent::CreatePool(class UGameResourcePoolData* PoolData, bool bReinitializeExistingPool)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GameResourcePoolManagerComponent.CreatePool");
		
		UGameResourcePoolManagerComponent_CreatePool_Params params {};
		params.PoolData = PoolData;
		params.bReinitializeExistingPool = bReinitializeExistingPool;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E17BD0
	 * 		Name   -> Function GbxGameSystemCore.GameResourcePoolManagerComponent.ClearResourcePoolDelegate
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		class UGameResourceData*                           InResourceData                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FName                                        DelegatePropertyName                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGameResourcePoolManagerComponent::ClearResourcePoolDelegate(class UGameResourceData* InResourceData, const class FName& DelegatePropertyName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GameResourcePoolManagerComponent.ClearResourcePoolDelegate");
		
		UGameResourcePoolManagerComponent_ClearResourcePoolDelegate_Params params {};
		params.InResourceData = InResourceData;
		params.DelegatePropertyName = DelegatePropertyName;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E177F0
	 * 		Name   -> Function GbxGameSystemCore.GameResourcePoolManagerComponent.AddResourcePoolDelegate
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		class UGameResourceData*                           InResourceData                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FName                                        DelegatePropertyName                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FScriptDelegate                              ScriptDelegate                                             (Parm, ZeroConstructor, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UGameResourcePoolManagerComponent::AddResourcePoolDelegate(class UGameResourceData* InResourceData, const class FName& DelegatePropertyName, const class FScriptDelegate& ScriptDelegate)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GameResourcePoolManagerComponent.AddResourcePoolDelegate");
		
		UGameResourcePoolManagerComponent_AddResourcePoolDelegate_Params params {};
		params.InResourceData = InResourceData;
		params.DelegatePropertyName = DelegatePropertyName;
		params.ScriptDelegate = ScriptDelegate;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGameResourcePoolManagerComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGameResourcePoolManagerComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.GameResourcePoolManagerComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E19AD0
	 * 		Name   -> Function GbxGameSystemCore.GameResourcePoolFunctionLibrary.SetResourcePoolValue
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		struct FGameResourcePoolReference                  InPool                                                     (Parm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 * 		float                                              InValue                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGameResourcePoolFunctionLibrary::STATIC_SetResourcePoolValue(const struct FGameResourcePoolReference& InPool, float InValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GameResourcePoolFunctionLibrary.SetResourcePoolValue");
		
		UGameResourcePoolFunctionLibrary_SetResourcePoolValue_Params params {};
		params.InPool = InPool;
		params.InValue = InValue;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E19450
	 * 		Name   -> Function GbxGameSystemCore.GameResourcePoolFunctionLibrary.ResetResourcePoolRegenDelayByGameResourceData
	 * 		Flags  -> (Final, BlueprintAuthorityOnly, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class AActor*                                      Actor                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UGameResourceData*                           Resource                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGameResourcePoolFunctionLibrary::STATIC_ResetResourcePoolRegenDelayByGameResourceData(class AActor* Actor, class UGameResourceData* Resource)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GameResourcePoolFunctionLibrary.ResetResourcePoolRegenDelayByGameResourceData");
		
		UGameResourcePoolFunctionLibrary_ResetResourcePoolRegenDelayByGameResourceData_Params params {};
		params.Actor = Actor;
		params.Resource = Resource;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E193C0
	 * 		Name   -> Function GbxGameSystemCore.GameResourcePoolFunctionLibrary.ResetResourcePoolRegenDelay
	 * 		Flags  -> (Final, BlueprintAuthorityOnly, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		struct FGameResourcePoolReference                  InPool                                                     (Parm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	void UGameResourcePoolFunctionLibrary::STATIC_ResetResourcePoolRegenDelay(const struct FGameResourcePoolReference& InPool)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GameResourcePoolFunctionLibrary.ResetResourcePoolRegenDelay");
		
		UGameResourcePoolFunctionLibrary_ResetResourcePoolRegenDelay_Params params {};
		params.InPool = InPool;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E19170
	 * 		Name   -> Function GbxGameSystemCore.GameResourcePoolFunctionLibrary.RefillResourcePoolByPercentage
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		struct FGameResourcePoolReference                  InPool                                                     (Parm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 * 		float                                              Percentage                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              MaxPercentage                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGameResourcePoolFunctionLibrary::STATIC_RefillResourcePoolByPercentage(const struct FGameResourcePoolReference& InPool, float Percentage, float MaxPercentage)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GameResourcePoolFunctionLibrary.RefillResourcePoolByPercentage");
		
		UGameResourcePoolFunctionLibrary_RefillResourcePoolByPercentage_Params params {};
		params.InPool = InPool;
		params.Percentage = Percentage;
		params.MaxPercentage = MaxPercentage;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E18BC0
	 * 		Name   -> Function GbxGameSystemCore.GameResourcePoolFunctionLibrary.IsResourcePoolInState
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		struct FGameResourcePoolReference                  InPool                                                     (Parm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 * 		EGameResourcePoolState                             InState                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UGameResourcePoolFunctionLibrary::STATIC_IsResourcePoolInState(const struct FGameResourcePoolReference& InPool, EGameResourcePoolState InState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GameResourcePoolFunctionLibrary.IsResourcePoolInState");
		
		UGameResourcePoolFunctionLibrary_IsResourcePoolInState_Params params {};
		params.InPool = InPool;
		params.InState = InState;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E18330
	 * 		Name   -> Function GbxGameSystemCore.GameResourcePoolFunctionLibrary.GetDelegatePrefixForResourceEvent
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms)
	 * Parameters:
	 * 		struct FGameResourceUserEvent                      InResourceUserEvent                                        (Parm, OutParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	class FName UGameResourcePoolFunctionLibrary::STATIC_GetDelegatePrefixForResourceEvent(struct FGameResourceUserEvent* InResourceUserEvent)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GameResourcePoolFunctionLibrary.GetDelegatePrefixForResourceEvent");
		
		UGameResourcePoolFunctionLibrary_GetDelegatePrefixForResourceEvent_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (InResourceUserEvent != nullptr)
			*InResourceUserEvent = params.InResourceUserEvent;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E18220
	 * 		Name   -> Function GbxGameSystemCore.GameResourcePoolFunctionLibrary.EqualEqual_ResourcePoolReference
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FGameResourcePoolReference                  A                                                          (Parm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 * 		struct FGameResourcePoolReference                  B                                                          (Parm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	bool UGameResourcePoolFunctionLibrary::STATIC_EqualEqual_ResourcePoolReference(const struct FGameResourcePoolReference& A, const struct FGameResourcePoolReference& B)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GameResourcePoolFunctionLibrary.EqualEqual_ResourcePoolReference");
		
		UGameResourcePoolFunctionLibrary_EqualEqual_ResourcePoolReference_Params params {};
		params.A = A;
		params.B = B;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E18140
	 * 		Name   -> Function GbxGameSystemCore.GameResourcePoolFunctionLibrary.EqualEqual_ResourcePoolData
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FGameResourcePoolReference                  ResourcePoolReference                                      (Parm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 * 		class UGameResourcePoolData*                       ResourcePoolData                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UGameResourcePoolFunctionLibrary::STATIC_EqualEqual_ResourcePoolData(const struct FGameResourcePoolReference& ResourcePoolReference, class UGameResourcePoolData* ResourcePoolData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GameResourcePoolFunctionLibrary.EqualEqual_ResourcePoolData");
		
		UGameResourcePoolFunctionLibrary_EqualEqual_ResourcePoolData_Params params {};
		params.ResourcePoolReference = ResourcePoolReference;
		params.ResourcePoolData = ResourcePoolData;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E18060
	 * 		Name   -> Function GbxGameSystemCore.GameResourcePoolFunctionLibrary.EqualEqual_ResourceData
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FGameResourcePoolReference                  ResourcePoolReference                                      (Parm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 * 		class UGameResourceData*                           ResourceData                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UGameResourcePoolFunctionLibrary::STATIC_EqualEqual_ResourceData(const struct FGameResourcePoolReference& ResourcePoolReference, class UGameResourceData* ResourceData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GameResourcePoolFunctionLibrary.EqualEqual_ResourceData");
		
		UGameResourcePoolFunctionLibrary_EqualEqual_ResourceData_Params params {};
		params.ResourcePoolReference = ResourcePoolReference;
		params.ResourceData = ResourceData;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E17F40
	 * 		Name   -> Function GbxGameSystemCore.GameResourcePoolFunctionLibrary.DrainResourcePoolByPercentage
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		struct FGameResourcePoolReference                  InPool                                                     (Parm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 * 		float                                              Percentage                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              MinPercentage                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGameResourcePoolFunctionLibrary::STATIC_DrainResourcePoolByPercentage(const struct FGameResourcePoolReference& InPool, float Percentage, float MinPercentage)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GameResourcePoolFunctionLibrary.DrainResourcePoolByPercentage");
		
		UGameResourcePoolFunctionLibrary_DrainResourcePoolByPercentage_Params params {};
		params.InPool = InPool;
		params.Percentage = Percentage;
		params.MinPercentage = MinPercentage;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E17EB0
	 * 		Name   -> Function GbxGameSystemCore.GameResourcePoolFunctionLibrary.DeleteResourcePool
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		struct FGameResourcePoolReference                  InPool                                                     (Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	void UGameResourcePoolFunctionLibrary::STATIC_DeleteResourcePool(struct FGameResourcePoolReference* InPool)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GameResourcePoolFunctionLibrary.DeleteResourcePool");
		
		UGameResourcePoolFunctionLibrary_DeleteResourcePool_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (InPool != nullptr)
			*InPool = params.InPool;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E17D20
	 * 		Name   -> Function GbxGameSystemCore.GameResourcePoolFunctionLibrary.ClearResourcePoolRegenDelayByGameResourceData
	 * 		Flags  -> (Final, BlueprintAuthorityOnly, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class AActor*                                      Actor                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UGameResourceData*                           Resource                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGameResourcePoolFunctionLibrary::STATIC_ClearResourcePoolRegenDelayByGameResourceData(class AActor* Actor, class UGameResourceData* Resource)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GameResourcePoolFunctionLibrary.ClearResourcePoolRegenDelayByGameResourceData");
		
		UGameResourcePoolFunctionLibrary_ClearResourcePoolRegenDelayByGameResourceData_Params params {};
		params.Actor = Actor;
		params.Resource = Resource;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E17C90
	 * 		Name   -> Function GbxGameSystemCore.GameResourcePoolFunctionLibrary.ClearResourcePoolRegenDelay
	 * 		Flags  -> (Final, BlueprintAuthorityOnly, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		struct FGameResourcePoolReference                  InPool                                                     (Parm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	void UGameResourcePoolFunctionLibrary::STATIC_ClearResourcePoolRegenDelay(const struct FGameResourcePoolReference& InPool)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GameResourcePoolFunctionLibrary.ClearResourcePoolRegenDelay");
		
		UGameResourcePoolFunctionLibrary_ClearResourcePoolRegenDelay_Params params {};
		params.InPool = InPool;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E17A00
	 * 		Name   -> Function GbxGameSystemCore.GameResourcePoolFunctionLibrary.BreakResourcePoolReference
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FGameResourcePoolReference                  InPool                                                     (Parm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 * 		bool                                               bValid                                                     (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              CurrentValue                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              MinValue                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              MaxValue                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGameResourcePoolFunctionLibrary::STATIC_BreakResourcePoolReference(const struct FGameResourcePoolReference& InPool, bool* bValid, float* CurrentValue, float* MinValue, float* MaxValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GameResourcePoolFunctionLibrary.BreakResourcePoolReference");
		
		UGameResourcePoolFunctionLibrary_BreakResourcePoolReference_Params params {};
		params.InPool = InPool;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (bValid != nullptr)
			*bValid = params.bValid;
		if (CurrentValue != nullptr)
			*CurrentValue = params.CurrentValue;
		if (MinValue != nullptr)
			*MinValue = params.MinValue;
		if (MaxValue != nullptr)
			*MaxValue = params.MaxValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E17920
	 * 		Name   -> Function GbxGameSystemCore.GameResourcePoolFunctionLibrary.AdjustResourcePoolValue
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		struct FGameResourcePoolReference                  InPool                                                     (Parm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 * 		float                                              InValue                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGameResourcePoolFunctionLibrary::STATIC_AdjustResourcePoolValue(const struct FGameResourcePoolReference& InPool, float InValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GameResourcePoolFunctionLibrary.AdjustResourcePoolValue");
		
		UGameResourcePoolFunctionLibrary_AdjustResourcePoolValue_Params params {};
		params.InPool = InPool;
		params.InValue = InValue;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGameResourcePoolFunctionLibrary.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGameResourcePoolFunctionLibrary::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.GameResourcePoolFunctionLibrary");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGameStatChannel.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGameStatChannel::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.GameStatChannel");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGameStatData.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGameStatData::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.GameStatData");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGameStateAttributeContextResolver.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGameStateAttributeContextResolver::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.GameStateAttributeContextResolver");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGameStatList.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGameStatList::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.GameStatList");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E1F010
	 * 		Name   -> Function GbxGameSystemCore.GameStatsComponent.UpdateStat
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UGameStatData*                               GameStat                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            NewValue                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGameStatsComponent::UpdateStat(class UGameStatData* GameStat, int32_t NewValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GameStatsComponent.UpdateStat");
		
		UGameStatsComponent_UpdateStat_Params params {};
		params.GameStat = GameStat;
		params.NewValue = NewValue;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E1E200
	 * 		Name   -> Function GbxGameSystemCore.GameStatsComponent.IncrementStat
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UGameStatData*                               GameStat                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            Amount                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGameStatsComponent::IncrementStat(class UGameStatData* GameStat, int32_t Amount)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GameStatsComponent.IncrementStat");
		
		UGameStatsComponent_IncrementStat_Params params {};
		params.GameStat = GameStat;
		params.Amount = Amount;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E1E070
	 * 		Name   -> Function GbxGameSystemCore.GameStatsComponent.GetStatValue
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UGameStatData*                               GameStat                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	int32_t UGameStatsComponent::GetStatValue(class UGameStatData* GameStat)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GameStatsComponent.GetStatValue");
		
		UGameStatsComponent_GetStatValue_Params params {};
		params.GameStat = GameStat;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E1DF20
	 * 		Name   -> Function GbxGameSystemCore.GameStatsComponent.GetGameStats
	 * 		Flags  -> (Final, Native, Public, Const)
	 */
	TArray<struct FGameStat> UGameStatsComponent::GetGameStats()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GameStatsComponent.GetGameStats");
		
		UGameStatsComponent_GetGameStats_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGameStatsComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGameStatsComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.GameStatsComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E1EF10
	 * 		Name   -> Function GbxGameSystemCore.GameStatsManager.UpdateStat
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class AActor*                                      StatContext                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UGameStatData*                               GameStat                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            NewValue                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AGameStatsManager::UpdateStat(class AActor* StatContext, class UGameStatData* GameStat, int32_t NewValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GameStatsManager.UpdateStat");
		
		AGameStatsManager_UpdateStat_Params params {};
		params.StatContext = StatContext;
		params.GameStat = GameStat;
		params.NewValue = NewValue;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E1E100
	 * 		Name   -> Function GbxGameSystemCore.GameStatsManager.IncrementStat
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class AActor*                                      StatContext                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UGameStatData*                               GameStat                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            IncrementAmount                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AGameStatsManager::IncrementStat(class AActor* StatContext, class UGameStatData* GameStat, int32_t IncrementAmount)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GameStatsManager.IncrementStat");
		
		AGameStatsManager_IncrementStat_Params params {};
		params.StatContext = StatContext;
		params.GameStat = GameStat;
		params.IncrementAmount = IncrementAmount;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E1DFB0
	 * 		Name   -> Function GbxGameSystemCore.GameStatsManager.GetStatValue
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class AActor*                                      StatContext                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UGameStatData*                               GameStat                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	int32_t AGameStatsManager::GetStatValue(class AActor* StatContext, class UGameStatData* GameStat)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GameStatsManager.GetStatValue");
		
		AGameStatsManager_GetStatValue_Params params {};
		params.StatContext = StatContext;
		params.GameStat = GameStat;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AGameStatsManager.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AGameStatsManager::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.GameStatsManager");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E1EDB0
	 * 		Name   -> Function GbxGameSystemCore.GbxAction_AICharge.OnStrike
	 * 		Flags  -> (Native, Event, Public, BlueprintEvent, Const)
	 * Parameters:
	 * 		class AActor*                                      Actor                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGbxAction_AICharge::OnStrike(class AActor* Actor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxAction_AICharge.OnStrike");
		
		UGbxAction_AICharge_OnStrike_Params params {};
		params.Actor = Actor;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E1ED20
	 * 		Name   -> Function GbxGameSystemCore.GbxAction_AICharge.OnStopForFriendly
	 * 		Flags  -> (Native, Event, Public, BlueprintEvent, Const)
	 * Parameters:
	 * 		class AActor*                                      Actor                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGbxAction_AICharge::OnStopForFriendly(class AActor* Actor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxAction_AICharge.OnStopForFriendly");
		
		UGbxAction_AICharge_OnStopForFriendly_Params params {};
		params.Actor = Actor;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E1EC90
	 * 		Name   -> Function GbxGameSystemCore.GbxAction_AICharge.OnReachCliff
	 * 		Flags  -> (Native, Event, Public, BlueprintEvent, Const)
	 * Parameters:
	 * 		class AActor*                                      Actor                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGbxAction_AICharge::OnReachCliff(class AActor* Actor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxAction_AICharge.OnReachCliff");
		
		UGbxAction_AICharge_OnReachCliff_Params params {};
		params.Actor = Actor;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E1EC00
	 * 		Name   -> Function GbxGameSystemCore.GbxAction_AICharge.OnMiss
	 * 		Flags  -> (Native, Event, Public, BlueprintEvent, Const)
	 * Parameters:
	 * 		class AActor*                                      Actor                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGbxAction_AICharge::OnMiss(class AActor* Actor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxAction_AICharge.OnMiss");
		
		UGbxAction_AICharge_OnMiss_Params params {};
		params.Actor = Actor;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02919C80
	 * 		Name   -> Function GbxGameSystemCore.GbxAction_AICharge.OnLoop
	 * 		Flags  -> (Native, Event, Public, BlueprintEvent, Const)
	 * Parameters:
	 * 		class AActor*                                      Actor                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGbxAction_AICharge::OnLoop(class AActor* Actor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxAction_AICharge.OnLoop");
		
		UGbxAction_AICharge_OnLoop_Params params {};
		params.Actor = Actor;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E1EB70
	 * 		Name   -> Function GbxGameSystemCore.GbxAction_AICharge.OnHitWall
	 * 		Flags  -> (Native, Event, Public, BlueprintEvent, Const)
	 * Parameters:
	 * 		class AActor*                                      Actor                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGbxAction_AICharge::OnHitWall(class AActor* Actor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxAction_AICharge.OnHitWall");
		
		UGbxAction_AICharge_OnHitWall_Params params {};
		params.Actor = Actor;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGbxAction_AICharge.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGbxAction_AICharge::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.GbxAction_AICharge");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGbxAction_BlueprintBase.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGbxAction_BlueprintBase::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.GbxAction_BlueprintBase");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGbxAction_ConditionContainer.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGbxAction_ConditionContainer::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.GbxAction_ConditionContainer");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGbxAction_DirectionContainer.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGbxAction_DirectionContainer::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.GbxAction_DirectionContainer");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGbxAction_DodgePicker.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGbxAction_DodgePicker::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.GbxAction_DodgePicker");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGbxAction_DropshipSpawn.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGbxAction_DropshipSpawn::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.GbxAction_DropshipSpawn");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGbxAction_KeyedContainer.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGbxAction_KeyedContainer::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.GbxAction_KeyedContainer");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGbxAction_Launch.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGbxAction_Launch::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.GbxAction_Launch");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMotionMatchedAnimationTable.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMotionMatchedAnimationTable::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.MotionMatchedAnimationTable");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGbxAction_Ragdoll.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGbxAction_Ragdoll::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.GbxAction_Ragdoll");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGbxAction_RandomContainer.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGbxAction_RandomContainer::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.GbxAction_RandomContainer");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGbxAction_StretchBones.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGbxAction_StretchBones::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.GbxAction_StretchBones");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E28730
	 * 		Name   -> Function GbxGameSystemCore.StretchBonesBlueprintLibrary.SetStretchBonesTarget
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		TArray<struct FGbxActionRegister>                  GbxActionRegisters                                         (Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      TargetActor                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     TargetPosition                                             (Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	TArray<struct FGbxActionRegister> UStretchBonesBlueprintLibrary::STATIC_SetStretchBonesTarget(TArray<struct FGbxActionRegister>* GbxActionRegisters, class AActor* TargetActor, const struct FVector& TargetPosition)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.StretchBonesBlueprintLibrary.SetStretchBonesTarget");
		
		UStretchBonesBlueprintLibrary_SetStretchBonesTarget_Params params {};
		params.TargetActor = TargetActor;
		params.TargetPosition = TargetPosition;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (GbxActionRegisters != nullptr)
			*GbxActionRegisters = params.GbxActionRegisters;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E28630
	 * 		Name   -> Function GbxGameSystemCore.StretchBonesBlueprintLibrary.SetStretchBonesDistance
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		TArray<struct FGbxActionRegister>                  GbxActionRegisters                                         (Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		float                                              Distance                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	TArray<struct FGbxActionRegister> UStretchBonesBlueprintLibrary::STATIC_SetStretchBonesDistance(TArray<struct FGbxActionRegister>* GbxActionRegisters, float Distance)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.StretchBonesBlueprintLibrary.SetStretchBonesDistance");
		
		UStretchBonesBlueprintLibrary_SetStretchBonesDistance_Params params {};
		params.Distance = Distance;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (GbxActionRegisters != nullptr)
			*GbxActionRegisters = params.GbxActionRegisters;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UStretchBonesBlueprintLibrary.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UStretchBonesBlueprintLibrary::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.StretchBonesBlueprintLibrary");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E28B70
	 * 		Name   -> Function GbxGameSystemCore.GbxActionBlueprintLibrary.StopLoopingActionClass
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UClass*                                      ActionClass                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      Target                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGbxActionBlueprintLibrary::STATIC_StopLoopingActionClass(class UClass* ActionClass, class AActor* Target)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxActionBlueprintLibrary.StopLoopingActionClass");
		
		UGbxActionBlueprintLibrary_StopLoopingActionClass_Params params {};
		params.ActionClass = ActionClass;
		params.Target = Target;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E289B0
	 * 		Name   -> Function GbxGameSystemCore.GbxActionBlueprintLibrary.StopActionSlot
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class FName                                        ActionSlotName                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      Target                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGbxActionBlueprintLibrary::STATIC_StopActionSlot(const class FName& ActionSlotName, class AActor* Target)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxActionBlueprintLibrary.StopActionSlot");
		
		UGbxActionBlueprintLibrary_StopActionSlot_Params params {};
		params.ActionSlotName = ActionSlotName;
		params.Target = Target;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E28AE0
	 * 		Name   -> Function GbxGameSystemCore.GbxActionBlueprintLibrary.StopActions
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class AActor*                                      Target                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGbxActionBlueprintLibrary::STATIC_StopActions(class AActor* Target)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxActionBlueprintLibrary.StopActions");
		
		UGbxActionBlueprintLibrary_StopActions_Params params {};
		params.Target = Target;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E28880
	 * 		Name   -> Function GbxGameSystemCore.GbxActionBlueprintLibrary.StopActionClass
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UClass*                                      ActionClass                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      Target                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGbxActionBlueprintLibrary::STATIC_StopActionClass(class UClass* ActionClass, class AActor* Target)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxActionBlueprintLibrary.StopActionClass");
		
		UGbxActionBlueprintLibrary_StopActionClass_Params params {};
		params.ActionClass = ActionClass;
		params.Target = Target;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E284C0
	 * 		Name   -> Function GbxGameSystemCore.GbxActionBlueprintLibrary.SetObjectGbxActionRegister
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		TArray<struct FGbxActionRegister>                  GbxActionRegisters                                         (Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		class FName                                        RegisterKey                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UObject*                                     Value                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bReplicates                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	TArray<struct FGbxActionRegister> UGbxActionBlueprintLibrary::STATIC_SetObjectGbxActionRegister(TArray<struct FGbxActionRegister>* GbxActionRegisters, const class FName& RegisterKey, class UObject* Value, bool bReplicates)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxActionBlueprintLibrary.SetObjectGbxActionRegister");
		
		UGbxActionBlueprintLibrary_SetObjectGbxActionRegister_Params params {};
		params.RegisterKey = RegisterKey;
		params.Value = Value;
		params.bReplicates = bReplicates;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (GbxActionRegisters != nullptr)
			*GbxActionRegisters = params.GbxActionRegisters;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E28350
	 * 		Name   -> Function GbxGameSystemCore.GbxActionBlueprintLibrary.SetNameGbxActionRegister
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		TArray<struct FGbxActionRegister>                  GbxActionRegisters                                         (Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		class FName                                        RegisterKey                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FName                                        Value                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bReplicates                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	TArray<struct FGbxActionRegister> UGbxActionBlueprintLibrary::STATIC_SetNameGbxActionRegister(TArray<struct FGbxActionRegister>* GbxActionRegisters, const class FName& RegisterKey, const class FName& Value, bool bReplicates)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxActionBlueprintLibrary.SetNameGbxActionRegister");
		
		UGbxActionBlueprintLibrary_SetNameGbxActionRegister_Params params {};
		params.RegisterKey = RegisterKey;
		params.Value = Value;
		params.bReplicates = bReplicates;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (GbxActionRegisters != nullptr)
			*GbxActionRegisters = params.GbxActionRegisters;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E281E0
	 * 		Name   -> Function GbxGameSystemCore.GbxActionBlueprintLibrary.SetIntGbxActionRegister
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		TArray<struct FGbxActionRegister>                  GbxActionRegisters                                         (Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		class FName                                        RegisterKey                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            Value                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bReplicates                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	TArray<struct FGbxActionRegister> UGbxActionBlueprintLibrary::STATIC_SetIntGbxActionRegister(TArray<struct FGbxActionRegister>* GbxActionRegisters, const class FName& RegisterKey, int32_t Value, bool bReplicates)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxActionBlueprintLibrary.SetIntGbxActionRegister");
		
		UGbxActionBlueprintLibrary_SetIntGbxActionRegister_Params params {};
		params.RegisterKey = RegisterKey;
		params.Value = Value;
		params.bReplicates = bReplicates;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (GbxActionRegisters != nullptr)
			*GbxActionRegisters = params.GbxActionRegisters;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E28070
	 * 		Name   -> Function GbxGameSystemCore.GbxActionBlueprintLibrary.SetFloatGbxActionRegister
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		TArray<struct FGbxActionRegister>                  GbxActionRegisters                                         (Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		class FName                                        RegisterKey                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Value                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bReplicates                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	TArray<struct FGbxActionRegister> UGbxActionBlueprintLibrary::STATIC_SetFloatGbxActionRegister(TArray<struct FGbxActionRegister>* GbxActionRegisters, const class FName& RegisterKey, float Value, bool bReplicates)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxActionBlueprintLibrary.SetFloatGbxActionRegister");
		
		UGbxActionBlueprintLibrary_SetFloatGbxActionRegister_Params params {};
		params.RegisterKey = RegisterKey;
		params.Value = Value;
		params.bReplicates = bReplicates;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (GbxActionRegisters != nullptr)
			*GbxActionRegisters = params.GbxActionRegisters;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E27CE0
	 * 		Name   -> Function GbxGameSystemCore.GbxActionBlueprintLibrary.K2_UpdateActionPlayRate
	 * 		Flags  -> (Final, Native, Static, Private, BlueprintCallable)
	 * Parameters:
	 * 		class UGbxAction*                                  Action                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              PlayRate                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGbxActionBlueprintLibrary::STATIC_K2_UpdateActionPlayRate(class UGbxAction* Action, float PlayRate)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxActionBlueprintLibrary.K2_UpdateActionPlayRate");
		
		UGbxActionBlueprintLibrary_K2_UpdateActionPlayRate_Params params {};
		params.Action = Action;
		params.PlayRate = PlayRate;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E27C20
	 * 		Name   -> Function GbxGameSystemCore.GbxActionBlueprintLibrary.K2_UpdateActionDirection
	 * 		Flags  -> (Final, Native, Static, Private, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		class UGbxAction*                                  Action                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     Direction                                                  (Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGbxActionBlueprintLibrary::STATIC_K2_UpdateActionDirection(class UGbxAction* Action, const struct FVector& Direction)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxActionBlueprintLibrary.K2_UpdateActionDirection");
		
		UGbxActionBlueprintLibrary_K2_UpdateActionDirection_Params params {};
		params.Action = Action;
		params.Direction = Direction;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E27B70
	 * 		Name   -> Function GbxGameSystemCore.GbxActionBlueprintLibrary.K2_StopActionObj
	 * 		Flags  -> (Final, Native, Static, Private, BlueprintCallable)
	 * Parameters:
	 * 		class UGbxAction*                                  Action                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      Target                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGbxActionBlueprintLibrary::STATIC_K2_StopActionObj(class UGbxAction* Action, class AActor* Target)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxActionBlueprintLibrary.K2_StopActionObj");
		
		UGbxActionBlueprintLibrary_K2_StopActionObj_Params params {};
		params.Action = Action;
		params.Target = Target;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x006686B0
	 * 		Name   -> Function GbxGameSystemCore.GbxActionBlueprintLibrary.K2_ShowGbxActionScreenLogs
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bShowLogsOnScreen                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGbxActionBlueprintLibrary::STATIC_K2_ShowGbxActionScreenLogs(bool bShowLogsOnScreen)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxActionBlueprintLibrary.K2_ShowGbxActionScreenLogs");
		
		UGbxActionBlueprintLibrary_K2_ShowGbxActionScreenLogs_Params params {};
		params.bShowLogsOnScreen = bShowLogsOnScreen;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E27920
	 * 		Name   -> Function GbxGameSystemCore.GbxActionBlueprintLibrary.K2_Resume
	 * 		Flags  -> (Final, Native, Static, Private, BlueprintCallable)
	 * Parameters:
	 * 		class UGbxAction*                                  Action                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGbxActionBlueprintLibrary::STATIC_K2_Resume(class UGbxAction* Action)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxActionBlueprintLibrary.K2_Resume");
		
		UGbxActionBlueprintLibrary_K2_Resume_Params params {};
		params.Action = Action;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E27B00
	 * 		Name   -> Function GbxGameSystemCore.GbxActionBlueprintLibrary.K2_ReplicatedProceedToNextSection
	 * 		Flags  -> (Final, Native, Static, Private, BlueprintCallable)
	 * Parameters:
	 * 		class UGbxAction*                                  Action                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGbxActionBlueprintLibrary::STATIC_K2_ReplicatedProceedToNextSection(class UGbxAction* Action)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxActionBlueprintLibrary.K2_ReplicatedProceedToNextSection");
		
		UGbxActionBlueprintLibrary_K2_ReplicatedProceedToNextSection_Params params {};
		params.Action = Action;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E27A90
	 * 		Name   -> Function GbxGameSystemCore.GbxActionBlueprintLibrary.K2_ReplicatedJumpToNextSection
	 * 		Flags  -> (Final, Native, Static, Private, BlueprintCallable)
	 * Parameters:
	 * 		class UGbxAction*                                  Action                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGbxActionBlueprintLibrary::STATIC_K2_ReplicatedJumpToNextSection(class UGbxAction* Action)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxActionBlueprintLibrary.K2_ReplicatedJumpToNextSection");
		
		UGbxActionBlueprintLibrary_K2_ReplicatedJumpToNextSection_Params params {};
		params.Action = Action;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E27A20
	 * 		Name   -> Function GbxGameSystemCore.GbxActionBlueprintLibrary.K2_ProceedToNextSection
	 * 		Flags  -> (Final, Native, Static, Private, BlueprintCallable)
	 * Parameters:
	 * 		class UGbxAction*                                  Action                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGbxActionBlueprintLibrary::STATIC_K2_ProceedToNextSection(class UGbxAction* Action)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxActionBlueprintLibrary.K2_ProceedToNextSection");
		
		UGbxActionBlueprintLibrary_K2_ProceedToNextSection_Params params {};
		params.Action = Action;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E27920
	 * 		Name   -> Function GbxGameSystemCore.GbxActionBlueprintLibrary.K2_Pause
	 * 		Flags  -> (Final, Native, Static, Private, BlueprintCallable)
	 * Parameters:
	 * 		class UGbxAction*                                  Action                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGbxActionBlueprintLibrary::STATIC_K2_Pause(class UGbxAction* Action)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxActionBlueprintLibrary.K2_Pause");
		
		UGbxActionBlueprintLibrary_K2_Pause_Params params {};
		params.Action = Action;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E278B0
	 * 		Name   -> Function GbxGameSystemCore.GbxActionBlueprintLibrary.K2_JumpToNextSection
	 * 		Flags  -> (Final, Native, Static, Private, BlueprintCallable)
	 * Parameters:
	 * 		class UGbxAction*                                  Action                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGbxActionBlueprintLibrary::STATIC_K2_JumpToNextSection(class UGbxAction* Action)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxActionBlueprintLibrary.K2_JumpToNextSection");
		
		UGbxActionBlueprintLibrary_K2_JumpToNextSection_Params params {};
		params.Action = Action;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E27790
	 * 		Name   -> Function GbxGameSystemCore.GbxActionBlueprintLibrary.K2_GetTimeRemaining
	 * 		Flags  -> (Final, Native, Static, Private, BlueprintCallable)
	 * Parameters:
	 * 		class UGbxAction*                                  Target                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	float UGbxActionBlueprintLibrary::STATIC_K2_GetTimeRemaining(class UGbxAction* Target)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxActionBlueprintLibrary.K2_GetTimeRemaining");
		
		UGbxActionBlueprintLibrary_K2_GetTimeRemaining_Params params {};
		params.Target = Target;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E27700
	 * 		Name   -> Function GbxGameSystemCore.GbxActionBlueprintLibrary.K2_GetMaxCurrentTime
	 * 		Flags  -> (Final, Native, Static, Private, BlueprintCallable)
	 * Parameters:
	 * 		class UGbxAction*                                  Action                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	float UGbxActionBlueprintLibrary::STATIC_K2_GetMaxCurrentTime(class UGbxAction* Action)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxActionBlueprintLibrary.K2_GetMaxCurrentTime");
		
		UGbxActionBlueprintLibrary_K2_GetMaxCurrentTime_Params params {};
		params.Action = Action;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E27520
	 * 		Name   -> Function GbxGameSystemCore.GbxActionBlueprintLibrary.K2_GetActionByClass
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UClass*                                      ActionClass                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      Target                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UGbxAction* UGbxActionBlueprintLibrary::STATIC_K2_GetActionByClass(class UClass* ActionClass, class AActor* Target)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxActionBlueprintLibrary.K2_GetActionByClass");
		
		UGbxActionBlueprintLibrary_K2_GetActionByClass_Params params {};
		params.ActionClass = ActionClass;
		params.Target = Target;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E27300
	 * 		Name   -> Function GbxGameSystemCore.GbxActionBlueprintLibrary.GetSummary_AnimActionDef
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FAnimActionDef                              AnimActionDef                                              (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	class FString UGbxActionBlueprintLibrary::STATIC_GetSummary_AnimActionDef(const struct FAnimActionDef& AnimActionDef)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxActionBlueprintLibrary.GetSummary_AnimActionDef");
		
		UGbxActionBlueprintLibrary_GetSummary_AnimActionDef_Params params {};
		params.AnimActionDef = AnimActionDef;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E27240
	 * 		Name   -> Function GbxGameSystemCore.GbxActionBlueprintLibrary.GetKeyedActionClass
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		struct FGameplayTag                                ActionKey                                                  (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      Target                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UClass* UGbxActionBlueprintLibrary::STATIC_GetKeyedActionClass(const struct FGameplayTag& ActionKey, class AActor* Target)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxActionBlueprintLibrary.GetKeyedActionClass");
		
		UGbxActionBlueprintLibrary_GetKeyedActionClass_Params params {};
		params.ActionKey = ActionKey;
		params.Target = Target;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGbxActionBlueprintLibrary.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGbxActionBlueprintLibrary::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.GbxActionBlueprintLibrary");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E28DA0
	 * 		Name   -> Function GbxGameSystemCore.GbxActionComponent.UpdateActionRemoteServer
	 * 		Flags  -> (Final, Net, NetReliable, Native, Event, Private, NetServer, NetValidate)
	 * Parameters:
	 * 		struct FActionState_Base                           ActionData                                                 (Parm, NativeAccessSpecifierPublic)
	 */
	void UGbxActionComponent::UpdateActionRemoteServer(const struct FActionState_Base& ActionData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxActionComponent.UpdateActionRemoteServer");
		
		UGbxActionComponent_UpdateActionRemoteServer_Params params {};
		params.ActionData = ActionData;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E28CA0
	 * 		Name   -> Function GbxGameSystemCore.GbxActionComponent.StopOnRemoteServer
	 * 		Flags  -> (Final, Net, NetReliable, Native, Event, Private, NetServer, NetValidate)
	 * Parameters:
	 * 		int32_t                                            ManagerRepId                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EGbxActionEndState                                 EndState                                                   (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGbxActionComponent::StopOnRemoteServer(int32_t ManagerRepId, EGbxActionEndState EndState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxActionComponent.StopOnRemoteServer");
		
		UGbxActionComponent_StopOnRemoteServer_Params params {};
		params.ManagerRepId = ManagerRepId;
		params.EndState = EndState;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E28C20
	 * 		Name   -> Function GbxGameSystemCore.GbxActionComponent.StopLoopingActionClass
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UClass*                                      ActionClass                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGbxActionComponent::StopLoopingActionClass(class UClass* ActionClass)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxActionComponent.StopLoopingActionClass");
		
		UGbxActionComponent_StopLoopingActionClass_Params params {};
		params.ActionClass = ActionClass;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E28A60
	 * 		Name   -> Function GbxGameSystemCore.GbxActionComponent.StopActionSlot
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class FName                                        ActionSlotName                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGbxActionComponent::StopActionSlot(const class FName& ActionSlotName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxActionComponent.StopActionSlot");
		
		UGbxActionComponent_StopActionSlot_Params params {};
		params.ActionSlotName = ActionSlotName;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E28B50
	 * 		Name   -> Function GbxGameSystemCore.GbxActionComponent.StopActions
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void UGbxActionComponent::StopActions()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxActionComponent.StopActions");
		
		UGbxActionComponent_StopActions_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E28930
	 * 		Name   -> Function GbxGameSystemCore.GbxActionComponent.StopActionClass
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UClass*                                      ActionClass                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGbxActionComponent::StopActionClass(class UClass* ActionClass)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxActionComponent.StopActionClass");
		
		UGbxActionComponent_StopActionClass_Params params {};
		params.ActionClass = ActionClass;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E27F40
	 * 		Name   -> Function GbxGameSystemCore.GbxActionComponent.PlayOnRemoteServer
	 * 		Flags  -> (Final, Net, NetReliable, Native, Event, Private, NetServer, NetValidate)
	 * Parameters:
	 * 		class UClass*                                      ActionClass                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FActionState_Base                           ActionData                                                 (Parm, NativeAccessSpecifierPublic)
	 */
	void UGbxActionComponent::PlayOnRemoteServer(class UClass* ActionClass, const struct FActionState_Base& ActionData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxActionComponent.PlayOnRemoteServer");
		
		UGbxActionComponent_PlayOnRemoteServer_Params params {};
		params.ActionClass = ActionClass;
		params.ActionData = ActionData;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E27EC0
	 * 		Name   -> Function GbxGameSystemCore.GbxActionComponent.OnComponentUnregistered
	 * 		Flags  -> (Final, Native, Private)
	 * Parameters:
	 * 		class UActorComponent*                             ActorComponent                                             (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGbxActionComponent::OnComponentUnregistered(class UActorComponent* ActorComponent)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxActionComponent.OnComponentUnregistered");
		
		UGbxActionComponent_OnComponentUnregistered_Params params {};
		params.ActorComponent = ActorComponent;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E27E40
	 * 		Name   -> Function GbxGameSystemCore.GbxActionComponent.OnComponentDetached
	 * 		Flags  -> (Final, Native, Private)
	 * Parameters:
	 * 		class USceneComponent*                             SceneComponent                                             (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGbxActionComponent::OnComponentDetached(class USceneComponent* SceneComponent)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxActionComponent.OnComponentDetached");
		
		UGbxActionComponent_OnComponentDetached_Params params {};
		params.SceneComponent = SceneComponent;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E27DC0
	 * 		Name   -> Function GbxGameSystemCore.GbxActionComponent.OnComponentAttached
	 * 		Flags  -> (Final, Native, Private)
	 * Parameters:
	 * 		class USceneComponent*                             SceneComponent                                             (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGbxActionComponent::OnComponentAttached(class USceneComponent* SceneComponent)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxActionComponent.OnComponentAttached");
		
		UGbxActionComponent_OnComponentAttached_Params params {};
		params.SceneComponent = SceneComponent;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E27DA0
	 * 		Name   -> Function GbxGameSystemCore.GbxActionComponent.NotifyInterruptRequest
	 * 		Flags  -> (Final, Native, Public)
	 */
	void UGbxActionComponent::NotifyInterruptRequest()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxActionComponent.NotifyInterruptRequest");
		
		UGbxActionComponent_NotifyInterruptRequest_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E27990
	 * 		Name   -> Function GbxGameSystemCore.GbxActionComponent.K2_Play
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UClass*                                      ActionClass                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UGbxAction* UGbxActionComponent::K2_Play(class UClass* ActionClass)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxActionComponent.K2_Play");
		
		UGbxActionComponent_K2_Play_Params params {};
		params.ActionClass = ActionClass;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E27820
	 * 		Name   -> Function GbxGameSystemCore.GbxActionComponent.K2_IsPlayingObj
	 * 		Flags  -> (Final, Native, Private, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		class UGbxAction*                                  Action                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UGbxActionComponent::K2_IsPlayingObj(class UGbxAction* Action)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxActionComponent.K2_IsPlayingObj");
		
		UGbxActionComponent_K2_IsPlayingObj_Params params {};
		params.Action = Action;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E27670
	 * 		Name   -> Function GbxGameSystemCore.GbxActionComponent.K2_GetActionBySlot
	 * 		Flags  -> (Final, Native, Private, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		class FName                                        ActionSlotName                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UGbxAction* UGbxActionComponent::K2_GetActionBySlot(const class FName& ActionSlotName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxActionComponent.K2_GetActionBySlot");
		
		UGbxActionComponent_K2_GetActionBySlot_Params params {};
		params.ActionSlotName = ActionSlotName;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E275E0
	 * 		Name   -> Function GbxGameSystemCore.GbxActionComponent.K2_GetActionByClass
	 * 		Flags  -> (Final, Native, Private, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		class UClass*                                      ActionClass                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UGbxAction* UGbxActionComponent::K2_GetActionByClass(class UClass* ActionClass)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxActionComponent.K2_GetActionByClass");
		
		UGbxActionComponent_K2_GetActionByClass_Params params {};
		params.ActionClass = ActionClass;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E27480
	 * 		Name   -> Function GbxGameSystemCore.GbxActionComponent.IsPlayingSlot
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		class FName                                        ActionSlotName                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UGbxActionComponent::IsPlayingSlot(const class FName& ActionSlotName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxActionComponent.IsPlayingSlot");
		
		UGbxActionComponent_IsPlayingSlot_Params params {};
		params.ActionSlotName = ActionSlotName;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E273F0
	 * 		Name   -> Function GbxGameSystemCore.GbxActionComponent.IsPlayingClass
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		class UClass*                                      ActionClass                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UGbxActionComponent::IsPlayingClass(class UClass* ActionClass)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxActionComponent.IsPlayingClass");
		
		UGbxActionComponent_IsPlayingClass_Params params {};
		params.ActionClass = ActionClass;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGbxActionComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGbxActionComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.GbxActionComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGbxActionDataAsset.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGbxActionDataAsset::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.GbxActionDataAsset");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AGbxActionManager.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AGbxActionManager::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.GbxActionManager");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x005D70B0
	 * 		Name   -> Function GbxGameSystemCore.GbxAnimBlueprintProfile.RebuildBoneLists
	 * 		Flags  -> (Final, Native, Private)
	 */
	void UGbxAnimBlueprintProfile::RebuildBoneLists()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxAnimBlueprintProfile.RebuildBoneLists");
		
		UGbxAnimBlueprintProfile_RebuildBoneLists_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0140A230
	 * 		Name   -> Function GbxGameSystemCore.GbxAnimBlueprintProfile.AnimBlueprintImportFunction
	 * 		Flags  -> (Final, Native, Private)
	 * Parameters:
	 * 		EAnimBPProfileImport                               ImportType                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGbxAnimBlueprintProfile::AnimBlueprintImportFunction(EAnimBPProfileImport ImportType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxAnimBlueprintProfile.AnimBlueprintImportFunction");
		
		UGbxAnimBlueprintProfile_AnimBlueprintImportFunction_Params params {};
		params.ImportType = ImportType;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGbxAnimBlueprintProfile.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGbxAnimBlueprintProfile::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.GbxAnimBlueprintProfile");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGbxAnimStateMachineDefinition.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGbxAnimStateMachineDefinition::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.GbxAnimStateMachineDefinition");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGbxAnimStateManager_Falling.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGbxAnimStateManager_Falling::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.GbxAnimStateManager_Falling");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGbxAnimStateManager_RootMotion.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGbxAnimStateManager_RootMotion::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.GbxAnimStateManager_RootMotion");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E2DD90
	 * 		Name   -> Function GbxGameSystemCore.GbxAttributeData.CanSetBaseValue
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool UGbxAttributeData::CanSetBaseValue()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxAttributeData.CanSetBaseValue");
		
		UGbxAttributeData_CanSetBaseValue_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E2DD60
	 * 		Name   -> Function GbxGameSystemCore.GbxAttributeData.CanBindToOnChangedEvent
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool UGbxAttributeData::CanBindToOnChangedEvent()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxAttributeData.CanBindToOnChangedEvent");
		
		UGbxAttributeData_CanBindToOnChangedEvent_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E2DD30
	 * 		Name   -> Function GbxGameSystemCore.GbxAttributeData.CanAddModifiers
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool UGbxAttributeData::CanAddModifiers()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxAttributeData.CanAddModifiers");
		
		UGbxAttributeData_CanAddModifiers_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E2DD00
	 * 		Name   -> Function GbxGameSystemCore.GbxAttributeData.CanAddAndRemoveModifiers
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool UGbxAttributeData::CanAddAndRemoveModifiers()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxAttributeData.CanAddAndRemoveModifiers");
		
		UGbxAttributeData_CanAddAndRemoveModifiers_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGbxAttributeData.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGbxAttributeData::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.GbxAttributeData");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E2F4C0
	 * 		Name   -> Function GbxGameSystemCore.GbxAttributeFunctionLibrary.UnbindFromOnAttributeChanged
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		struct FGbxAttributeDelegateBindingHandle          BindingHandle                                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UGbxAttributeFunctionLibrary::STATIC_UnbindFromOnAttributeChanged(const struct FGbxAttributeDelegateBindingHandle& BindingHandle)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxAttributeFunctionLibrary.UnbindFromOnAttributeChanged");
		
		UGbxAttributeFunctionLibrary_UnbindFromOnAttributeChanged_Params params {};
		params.BindingHandle = BindingHandle;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E2F3B0
	 * 		Name   -> Function GbxGameSystemCore.GbxAttributeFunctionLibrary.UnbindEventFromOnIntegerAttributeChanged
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		struct FGbxAttributeInteger                        Attribute                                                  (Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FScriptDelegate                              Delegate                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UGbxAttributeFunctionLibrary::STATIC_UnbindEventFromOnIntegerAttributeChanged(struct FGbxAttributeInteger* Attribute, const class FScriptDelegate& Delegate)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxAttributeFunctionLibrary.UnbindEventFromOnIntegerAttributeChanged");
		
		UGbxAttributeFunctionLibrary_UnbindEventFromOnIntegerAttributeChanged_Params params {};
		params.Delegate = Delegate;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (Attribute != nullptr)
			*Attribute = params.Attribute;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E2F3B0
	 * 		Name   -> Function GbxGameSystemCore.GbxAttributeFunctionLibrary.UnbindEventFromOnFloatAttributeChanged
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		struct FGbxAttributeFloat                          Attribute                                                  (Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FScriptDelegate                              Delegate                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UGbxAttributeFunctionLibrary::STATIC_UnbindEventFromOnFloatAttributeChanged(struct FGbxAttributeFloat* Attribute, const class FScriptDelegate& Delegate)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxAttributeFunctionLibrary.UnbindEventFromOnFloatAttributeChanged");
		
		UGbxAttributeFunctionLibrary_UnbindEventFromOnFloatAttributeChanged_Params params {};
		params.Delegate = Delegate;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (Attribute != nullptr)
			*Attribute = params.Attribute;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E2F320
	 * 		Name   -> Function GbxGameSystemCore.GbxAttributeFunctionLibrary.UnbindAllEventsFromOnIntegerAttributeChanged
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		struct FGbxAttributeInteger                        Attribute                                                  (Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGbxAttributeFunctionLibrary::STATIC_UnbindAllEventsFromOnIntegerAttributeChanged(struct FGbxAttributeInteger* Attribute)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxAttributeFunctionLibrary.UnbindAllEventsFromOnIntegerAttributeChanged");
		
		UGbxAttributeFunctionLibrary_UnbindAllEventsFromOnIntegerAttributeChanged_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (Attribute != nullptr)
			*Attribute = params.Attribute;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E2F320
	 * 		Name   -> Function GbxGameSystemCore.GbxAttributeFunctionLibrary.UnbindAllEventsFromOnFloatAttributeChanged
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		struct FGbxAttributeFloat                          Attribute                                                  (Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGbxAttributeFunctionLibrary::STATIC_UnbindAllEventsFromOnFloatAttributeChanged(struct FGbxAttributeFloat* Attribute)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxAttributeFunctionLibrary.UnbindAllEventsFromOnFloatAttributeChanged");
		
		UGbxAttributeFunctionLibrary_UnbindAllEventsFromOnFloatAttributeChanged_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (Attribute != nullptr)
			*Attribute = params.Attribute;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E2F290
	 * 		Name   -> Function GbxGameSystemCore.GbxAttributeFunctionLibrary.RemoveMultipleAttributeModifiers
	 * 		Flags  -> (Final, BlueprintAuthorityOnly, Native, Static, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		TArray<struct FGbxAttributeModifierHandle>         ModifierHandles                                            (Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UGbxAttributeFunctionLibrary::STATIC_RemoveMultipleAttributeModifiers(TArray<struct FGbxAttributeModifierHandle>* ModifierHandles)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxAttributeFunctionLibrary.RemoveMultipleAttributeModifiers");
		
		UGbxAttributeFunctionLibrary_RemoveMultipleAttributeModifiers_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (ModifierHandles != nullptr)
			*ModifierHandles = params.ModifierHandles;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E2F0F0
	 * 		Name   -> Function GbxGameSystemCore.GbxAttributeFunctionLibrary.RemoveModifierFromGbxAttribute
	 * 		Flags  -> (Final, BlueprintAuthorityOnly, Native, Static, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		class UGbxAttributeData*                           Attribute                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UObject*                                     ContextSource                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FGbxAttributeModifierHandle                 ModifierHandle                                             (Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		EGbxAttributeModifierActionExecOutput              ModifierActionResult                                       (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGbxAttributeFunctionLibrary::STATIC_RemoveModifierFromGbxAttribute(class UGbxAttributeData* Attribute, class UObject* ContextSource, struct FGbxAttributeModifierHandle* ModifierHandle, EGbxAttributeModifierActionExecOutput* ModifierActionResult)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxAttributeFunctionLibrary.RemoveModifierFromGbxAttribute");
		
		UGbxAttributeFunctionLibrary_RemoveModifierFromGbxAttribute_Params params {};
		params.Attribute = Attribute;
		params.ContextSource = ContextSource;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (ModifierHandle != nullptr)
			*ModifierHandle = params.ModifierHandle;
		if (ModifierActionResult != nullptr)
			*ModifierActionResult = params.ModifierActionResult;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E2F020
	 * 		Name   -> Function GbxGameSystemCore.GbxAttributeFunctionLibrary.RemoveAttributeModifier
	 * 		Flags  -> (Final, BlueprintAuthorityOnly, Native, Static, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		struct FGbxAttributeModifierHandle                 ModifierHandle                                             (Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	bool UGbxAttributeFunctionLibrary::STATIC_RemoveAttributeModifier(struct FGbxAttributeModifierHandle* ModifierHandle)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxAttributeFunctionLibrary.RemoveAttributeModifier");
		
		UGbxAttributeFunctionLibrary_RemoveAttributeModifier_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (ModifierHandle != nullptr)
			*ModifierHandle = params.ModifierHandle;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E2EED0
	 * 		Name   -> Function GbxGameSystemCore.GbxAttributeFunctionLibrary.RefreshBindingToOnAttributeChangedEvent
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		struct FGbxAttributeDelegateBindingHandle          BindingHandle                                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		class UObject*                                     ContextSource                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FGbxAttributeDelegateBindingHandle UGbxAttributeFunctionLibrary::STATIC_RefreshBindingToOnAttributeChangedEvent(const struct FGbxAttributeDelegateBindingHandle& BindingHandle, class UObject* ContextSource)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxAttributeFunctionLibrary.RefreshBindingToOnAttributeChangedEvent");
		
		UGbxAttributeFunctionLibrary_RefreshBindingToOnAttributeChangedEvent_Params params {};
		params.BindingHandle = BindingHandle;
		params.ContextSource = ContextSource;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E2EE30
	 * 		Name   -> Function GbxGameSystemCore.GbxAttributeFunctionLibrary.MakeGbxAttributeInteger
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		int32_t                                            BaseValue                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FGbxAttributeInteger UGbxAttributeFunctionLibrary::STATIC_MakeGbxAttributeInteger(int32_t BaseValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxAttributeFunctionLibrary.MakeGbxAttributeInteger");
		
		UGbxAttributeFunctionLibrary_MakeGbxAttributeInteger_Params params {};
		params.BaseValue = BaseValue;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E2ED90
	 * 		Name   -> Function GbxGameSystemCore.GbxAttributeFunctionLibrary.MakeGbxAttributeFloat
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		float                                              BaseValue                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FGbxAttributeFloat UGbxAttributeFunctionLibrary::STATIC_MakeGbxAttributeFloat(float BaseValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxAttributeFunctionLibrary.MakeGbxAttributeFloat");
		
		UGbxAttributeFunctionLibrary_MakeGbxAttributeFloat_Params params {};
		params.BaseValue = BaseValue;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E2ECA0
	 * 		Name   -> Function GbxGameSystemCore.GbxAttributeFunctionLibrary.GetValueOfAttributeAsInteger
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class UGbxAttributeData*                           Attribute                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UObject*                                     ContextSource                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            DefaultValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	int32_t UGbxAttributeFunctionLibrary::STATIC_GetValueOfAttributeAsInteger(class UGbxAttributeData* Attribute, class UObject* ContextSource, int32_t DefaultValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxAttributeFunctionLibrary.GetValueOfAttributeAsInteger");
		
		UGbxAttributeFunctionLibrary_GetValueOfAttributeAsInteger_Params params {};
		params.Attribute = Attribute;
		params.ContextSource = ContextSource;
		params.DefaultValue = DefaultValue;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E2EBB0
	 * 		Name   -> Function GbxGameSystemCore.GbxAttributeFunctionLibrary.GetValueOfAttributeAsBoolean
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class UGbxAttributeData*                           Attribute                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UObject*                                     ContextSource                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               DefaultValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UGbxAttributeFunctionLibrary::STATIC_GetValueOfAttributeAsBoolean(class UGbxAttributeData* Attribute, class UObject* ContextSource, bool DefaultValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxAttributeFunctionLibrary.GetValueOfAttributeAsBoolean");
		
		UGbxAttributeFunctionLibrary_GetValueOfAttributeAsBoolean_Params params {};
		params.Attribute = Attribute;
		params.ContextSource = ContextSource;
		params.DefaultValue = DefaultValue;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E2EAB0
	 * 		Name   -> Function GbxGameSystemCore.GbxAttributeFunctionLibrary.GetValueOfAttribute
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class UGbxAttributeData*                           Attribute                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UObject*                                     ContextSource                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              DefaultValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	float UGbxAttributeFunctionLibrary::STATIC_GetValueOfAttribute(class UGbxAttributeData* Attribute, class UObject* ContextSource, float DefaultValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxAttributeFunctionLibrary.GetValueOfAttribute");
		
		UGbxAttributeFunctionLibrary_GetValueOfAttribute_Params params {};
		params.Attribute = Attribute;
		params.ContextSource = ContextSource;
		params.DefaultValue = DefaultValue;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E2E9C0
	 * 		Name   -> Function GbxGameSystemCore.GbxAttributeFunctionLibrary.GetValueFromAttributeDefinedRow
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FDataTableRowHandle                         RowHandle                                                  (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 * 		class UObject*                                     ContextSource                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	float UGbxAttributeFunctionLibrary::STATIC_GetValueFromAttributeDefinedRow(const struct FDataTableRowHandle& RowHandle, class UObject* ContextSource)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxAttributeFunctionLibrary.GetValueFromAttributeDefinedRow");
		
		UGbxAttributeFunctionLibrary_GetValueFromAttributeDefinedRow_Params params {};
		params.RowHandle = RowHandle;
		params.ContextSource = ContextSource;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E2E870
	 * 		Name   -> Function GbxGameSystemCore.GbxAttributeFunctionLibrary.EvaluateAttributeInitializer
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class UClass*                                      Initializer                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UObject*                                     ContextSource                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	float UGbxAttributeFunctionLibrary::STATIC_EvaluateAttributeInitializer(class UClass* Initializer, class UObject* ContextSource)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxAttributeFunctionLibrary.EvaluateAttributeInitializer");
		
		UGbxAttributeFunctionLibrary_EvaluateAttributeInitializer_Params params {};
		params.Initializer = Initializer;
		params.ContextSource = ContextSource;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E2E770
	 * 		Name   -> Function GbxGameSystemCore.GbxAttributeFunctionLibrary.EvaluateAttributeInitializationData
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FAttributeInitializationData                InitializationData                                         (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 * 		class UObject*                                     ContextSource                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	float UGbxAttributeFunctionLibrary::STATIC_EvaluateAttributeInitializationData(const struct FAttributeInitializationData& InitializationData, class UObject* ContextSource)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxAttributeFunctionLibrary.EvaluateAttributeInitializationData");
		
		UGbxAttributeFunctionLibrary_EvaluateAttributeInitializationData_Params params {};
		params.InitializationData = InitializationData;
		params.ContextSource = ContextSource;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E2E680
	 * 		Name   -> Function GbxGameSystemCore.GbxAttributeFunctionLibrary.EqualEqual_GbxAttributeIntegerValue
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FGbxAttributeInteger                        A                                                          (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            B                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UGbxAttributeFunctionLibrary::STATIC_EqualEqual_GbxAttributeIntegerValue(const struct FGbxAttributeInteger& A, int32_t B)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxAttributeFunctionLibrary.EqualEqual_GbxAttributeIntegerValue");
		
		UGbxAttributeFunctionLibrary_EqualEqual_GbxAttributeIntegerValue_Params params {};
		params.A = A;
		params.B = B;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E2E570
	 * 		Name   -> Function GbxGameSystemCore.GbxAttributeFunctionLibrary.EqualEqual_GbxAttributeInteger
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FGbxAttributeInteger                        A                                                          (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FGbxAttributeInteger                        B                                                          (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UGbxAttributeFunctionLibrary::STATIC_EqualEqual_GbxAttributeInteger(const struct FGbxAttributeInteger& A, const struct FGbxAttributeInteger& B)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxAttributeFunctionLibrary.EqualEqual_GbxAttributeInteger");
		
		UGbxAttributeFunctionLibrary_EqualEqual_GbxAttributeInteger_Params params {};
		params.A = A;
		params.B = B;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E2E470
	 * 		Name   -> Function GbxGameSystemCore.GbxAttributeFunctionLibrary.EqualEqual_GbxAttributeFloatValue
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FGbxAttributeFloat                          A                                                          (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              B                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UGbxAttributeFunctionLibrary::STATIC_EqualEqual_GbxAttributeFloatValue(const struct FGbxAttributeFloat& A, float B)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxAttributeFunctionLibrary.EqualEqual_GbxAttributeFloatValue");
		
		UGbxAttributeFunctionLibrary_EqualEqual_GbxAttributeFloatValue_Params params {};
		params.A = A;
		params.B = B;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E2E360
	 * 		Name   -> Function GbxGameSystemCore.GbxAttributeFunctionLibrary.EqualEqual_GbxAttributeFloat
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FGbxAttributeFloat                          A                                                          (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FGbxAttributeFloat                          B                                                          (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UGbxAttributeFunctionLibrary::STATIC_EqualEqual_GbxAttributeFloat(const struct FGbxAttributeFloat& A, const struct FGbxAttributeFloat& B)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxAttributeFunctionLibrary.EqualEqual_GbxAttributeFloat");
		
		UGbxAttributeFunctionLibrary_EqualEqual_GbxAttributeFloat_Params params {};
		params.A = A;
		params.B = B;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E2E250
	 * 		Name   -> Function GbxGameSystemCore.GbxAttributeFunctionLibrary.Conv_GbxAttributeModifierHandleToString
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FGbxAttributeModifierHandle                 Attribute                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	class FString UGbxAttributeFunctionLibrary::STATIC_Conv_GbxAttributeModifierHandleToString(const struct FGbxAttributeModifierHandle& Attribute)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxAttributeFunctionLibrary.Conv_GbxAttributeModifierHandleToString");
		
		UGbxAttributeFunctionLibrary_Conv_GbxAttributeModifierHandleToString_Params params {};
		params.Attribute = Attribute;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E2E170
	 * 		Name   -> Function GbxGameSystemCore.GbxAttributeFunctionLibrary.Conv_GbxAttributeIntegerToString
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FGbxAttributeInteger                        Attribute                                                  (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class FString UGbxAttributeFunctionLibrary::STATIC_Conv_GbxAttributeIntegerToString(const struct FGbxAttributeInteger& Attribute)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxAttributeFunctionLibrary.Conv_GbxAttributeIntegerToString");
		
		UGbxAttributeFunctionLibrary_Conv_GbxAttributeIntegerToString_Params params {};
		params.Attribute = Attribute;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E2E0D0
	 * 		Name   -> Function GbxGameSystemCore.GbxAttributeFunctionLibrary.Conv_GbxAttributeIntegerToInteger
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FGbxAttributeInteger                        Attribute                                                  (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	int32_t UGbxAttributeFunctionLibrary::STATIC_Conv_GbxAttributeIntegerToInteger(const struct FGbxAttributeInteger& Attribute)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxAttributeFunctionLibrary.Conv_GbxAttributeIntegerToInteger");
		
		UGbxAttributeFunctionLibrary_Conv_GbxAttributeIntegerToInteger_Params params {};
		params.Attribute = Attribute;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E2DFF0
	 * 		Name   -> Function GbxGameSystemCore.GbxAttributeFunctionLibrary.Conv_GbxAttributeFloatToString
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FGbxAttributeFloat                          Attribute                                                  (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class FString UGbxAttributeFunctionLibrary::STATIC_Conv_GbxAttributeFloatToString(const struct FGbxAttributeFloat& Attribute)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxAttributeFunctionLibrary.Conv_GbxAttributeFloatToString");
		
		UGbxAttributeFunctionLibrary_Conv_GbxAttributeFloatToString_Params params {};
		params.Attribute = Attribute;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E2DF50
	 * 		Name   -> Function GbxGameSystemCore.GbxAttributeFunctionLibrary.Conv_GbxAttributeFloatToFloat
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FGbxAttributeFloat                          Attribute                                                  (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	float UGbxAttributeFunctionLibrary::STATIC_Conv_GbxAttributeFloatToFloat(const struct FGbxAttributeFloat& Attribute)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxAttributeFunctionLibrary.Conv_GbxAttributeFloatToFloat");
		
		UGbxAttributeFunctionLibrary_Conv_GbxAttributeFloatToFloat_Params params {};
		params.Attribute = Attribute;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E2DE50
	 * 		Name   -> Function GbxGameSystemCore.GbxAttributeFunctionLibrary.Conv_AttributeInitializationDataToString
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FAttributeInitializationData                InitData                                                   (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	class FString UGbxAttributeFunctionLibrary::STATIC_Conv_AttributeInitializationDataToString(const struct FAttributeInitializationData& InitData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxAttributeFunctionLibrary.Conv_AttributeInitializationDataToString");
		
		UGbxAttributeFunctionLibrary_Conv_AttributeInitializationDataToString_Params params {};
		params.InitData = InitData;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E2DBC0
	 * 		Name   -> Function GbxGameSystemCore.GbxAttributeFunctionLibrary.BreakGbxAttributeInteger
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FGbxAttributeInteger                        Attribute                                                  (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            Value                                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            BaseValue                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGbxAttributeFunctionLibrary::STATIC_BreakGbxAttributeInteger(const struct FGbxAttributeInteger& Attribute, int32_t* Value, int32_t* BaseValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxAttributeFunctionLibrary.BreakGbxAttributeInteger");
		
		UGbxAttributeFunctionLibrary_BreakGbxAttributeInteger_Params params {};
		params.Attribute = Attribute;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (Value != nullptr)
			*Value = params.Value;
		if (BaseValue != nullptr)
			*BaseValue = params.BaseValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E2DA80
	 * 		Name   -> Function GbxGameSystemCore.GbxAttributeFunctionLibrary.BreakGbxAttributeFloat
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FGbxAttributeFloat                          Attribute                                                  (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Value                                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              BaseValue                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGbxAttributeFunctionLibrary::STATIC_BreakGbxAttributeFloat(const struct FGbxAttributeFloat& Attribute, float* Value, float* BaseValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxAttributeFunctionLibrary.BreakGbxAttributeFloat");
		
		UGbxAttributeFunctionLibrary_BreakGbxAttributeFloat_Params params {};
		params.Attribute = Attribute;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (Value != nullptr)
			*Value = params.Value;
		if (BaseValue != nullptr)
			*BaseValue = params.BaseValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E2D970
	 * 		Name   -> Function GbxGameSystemCore.GbxAttributeFunctionLibrary.BindEventToOnIntegerAttributeChanged
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		struct FGbxAttributeInteger                        Attribute                                                  (Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FScriptDelegate                              Delegate                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UGbxAttributeFunctionLibrary::STATIC_BindEventToOnIntegerAttributeChanged(struct FGbxAttributeInteger* Attribute, const class FScriptDelegate& Delegate)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxAttributeFunctionLibrary.BindEventToOnIntegerAttributeChanged");
		
		UGbxAttributeFunctionLibrary_BindEventToOnIntegerAttributeChanged_Params params {};
		params.Delegate = Delegate;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (Attribute != nullptr)
			*Attribute = params.Attribute;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E2D970
	 * 		Name   -> Function GbxGameSystemCore.GbxAttributeFunctionLibrary.BindEventToOnFloatAttributeChanged
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		struct FGbxAttributeFloat                          Attribute                                                  (Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FScriptDelegate                              Delegate                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UGbxAttributeFunctionLibrary::STATIC_BindEventToOnFloatAttributeChanged(struct FGbxAttributeFloat* Attribute, const class FScriptDelegate& Delegate)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxAttributeFunctionLibrary.BindEventToOnFloatAttributeChanged");
		
		UGbxAttributeFunctionLibrary_BindEventToOnFloatAttributeChanged_Params params {};
		params.Delegate = Delegate;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (Attribute != nullptr)
			*Attribute = params.Attribute;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E2D7F0
	 * 		Name   -> Function GbxGameSystemCore.GbxAttributeFunctionLibrary.BindEventToOnAttributeChanged
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		class UGbxAttributeData*                           Attribute                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UObject*                                     ContextSource                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FScriptDelegate                              Delegate                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	struct FGbxAttributeDelegateBindingHandle UGbxAttributeFunctionLibrary::STATIC_BindEventToOnAttributeChanged(class UGbxAttributeData* Attribute, class UObject* ContextSource, const class FScriptDelegate& Delegate)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxAttributeFunctionLibrary.BindEventToOnAttributeChanged");
		
		UGbxAttributeFunctionLibrary_BindEventToOnAttributeChanged_Params params {};
		params.Attribute = Attribute;
		params.ContextSource = ContextSource;
		params.Delegate = Delegate;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E2D600
	 * 		Name   -> Function GbxGameSystemCore.GbxAttributeFunctionLibrary.ApplyMultipleAttributeEffects
	 * 		Flags  -> (Final, BlueprintAuthorityOnly, Native, Static, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		TArray<struct FAttributeEffectData>                Effects                                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		class UObject*                                     ModifierValueContext                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UObject*                                     AttributeToModifyContextSource                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	TArray<struct FGbxAttributeModifierHandle> UGbxAttributeFunctionLibrary::STATIC_ApplyMultipleAttributeEffects(TArray<struct FAttributeEffectData> Effects, class UObject* ModifierValueContext, class UObject* AttributeToModifyContextSource)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxAttributeFunctionLibrary.ApplyMultipleAttributeEffects");
		
		UGbxAttributeFunctionLibrary_ApplyMultipleAttributeEffects_Params params {};
		params.Effects = Effects;
		params.ModifierValueContext = ModifierValueContext;
		params.AttributeToModifyContextSource = AttributeToModifyContextSource;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E2D4E0
	 * 		Name   -> Function GbxGameSystemCore.GbxAttributeFunctionLibrary.ApplyMultipleAttributeBaseValueData
	 * 		Flags  -> (Final, BlueprintAuthorityOnly, Native, Static, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		TArray<struct FAttributeBaseValueData>             BaseValueData                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		class UObject*                                     AttributeToSetContextSource                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UObject*                                     ValueContext                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGbxAttributeFunctionLibrary::STATIC_ApplyMultipleAttributeBaseValueData(TArray<struct FAttributeBaseValueData> BaseValueData, class UObject* AttributeToSetContextSource, class UObject* ValueContext)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxAttributeFunctionLibrary.ApplyMultipleAttributeBaseValueData");
		
		UGbxAttributeFunctionLibrary_ApplyMultipleAttributeBaseValueData_Params params {};
		params.BaseValueData = BaseValueData;
		params.AttributeToSetContextSource = AttributeToSetContextSource;
		params.ValueContext = ValueContext;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E2D310
	 * 		Name   -> Function GbxGameSystemCore.GbxAttributeFunctionLibrary.ApplyAttributeEffect
	 * 		Flags  -> (Final, BlueprintAuthorityOnly, Native, Static, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		struct FAttributeEffectData                        Effect                                                     (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 * 		class UObject*                                     ModifierValueContext                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UObject*                                     AttributeToModifyContextSource                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EGbxAttributeModifierActionExecOutput              ModifierActionResult                                       (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FGbxAttributeModifierHandle UGbxAttributeFunctionLibrary::STATIC_ApplyAttributeEffect(const struct FAttributeEffectData& Effect, class UObject* ModifierValueContext, class UObject* AttributeToModifyContextSource, EGbxAttributeModifierActionExecOutput* ModifierActionResult)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxAttributeFunctionLibrary.ApplyAttributeEffect");
		
		UGbxAttributeFunctionLibrary_ApplyAttributeEffect_Params params {};
		params.Effect = Effect;
		params.ModifierValueContext = ModifierValueContext;
		params.AttributeToModifyContextSource = AttributeToModifyContextSource;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (ModifierActionResult != nullptr)
			*ModifierActionResult = params.ModifierActionResult;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E2D1A0
	 * 		Name   -> Function GbxGameSystemCore.GbxAttributeFunctionLibrary.ApplyAttributeBaseValueData
	 * 		Flags  -> (Final, BlueprintAuthorityOnly, Native, Static, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		struct FAttributeBaseValueData                     BaseValueData                                              (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 * 		class UObject*                                     AttributeToSetContextSource                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UObject*                                     ValueContext                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EGbxAttributeModifierActionExecOutput              ModifierActionResult                                       (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGbxAttributeFunctionLibrary::STATIC_ApplyAttributeBaseValueData(const struct FAttributeBaseValueData& BaseValueData, class UObject* AttributeToSetContextSource, class UObject* ValueContext, EGbxAttributeModifierActionExecOutput* ModifierActionResult)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxAttributeFunctionLibrary.ApplyAttributeBaseValueData");
		
		UGbxAttributeFunctionLibrary_ApplyAttributeBaseValueData_Params params {};
		params.BaseValueData = BaseValueData;
		params.AttributeToSetContextSource = AttributeToSetContextSource;
		params.ValueContext = ValueContext;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (ModifierActionResult != nullptr)
			*ModifierActionResult = params.ModifierActionResult;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E2CFA0
	 * 		Name   -> Function GbxGameSystemCore.GbxAttributeFunctionLibrary.AddModifierToGbxAttribute
	 * 		Flags  -> (Final, BlueprintAuthorityOnly, Native, Static, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		class UGbxAttributeData*                           Attribute                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UObject*                                     ContextSource                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EGbxAttributeModifierType                          ModifierType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              ModifierValue                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EGbxAttributeModifierActionExecOutput              ModifierActionResult                                       (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FGbxAttributeModifierHandle UGbxAttributeFunctionLibrary::STATIC_AddModifierToGbxAttribute(class UGbxAttributeData* Attribute, class UObject* ContextSource, EGbxAttributeModifierType ModifierType, float ModifierValue, EGbxAttributeModifierActionExecOutput* ModifierActionResult)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxAttributeFunctionLibrary.AddModifierToGbxAttribute");
		
		UGbxAttributeFunctionLibrary_AddModifierToGbxAttribute_Params params {};
		params.Attribute = Attribute;
		params.ContextSource = ContextSource;
		params.ModifierType = ModifierType;
		params.ModifierValue = ModifierValue;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (ModifierActionResult != nullptr)
			*ModifierActionResult = params.ModifierActionResult;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGbxAttributeFunctionLibrary.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGbxAttributeFunctionLibrary::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.GbxAttributeFunctionLibrary");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E33990
	 * 		Name   -> Function GbxGameSystemCore.GbxAttributesComponent.IsAttributeSetClassUnrelatedToExistingSet
	 * 		Flags  -> (Final, Native, Public, Const)
	 * Parameters:
	 * 		class UClass*                                      AttributeSetClass                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UGbxAttributesComponent::IsAttributeSetClassUnrelatedToExistingSet(class UClass* AttributeSetClass)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxAttributesComponent.IsAttributeSetClassUnrelatedToExistingSet");
		
		UGbxAttributesComponent_IsAttributeSetClassUnrelatedToExistingSet_Params params {};
		params.AttributeSetClass = AttributeSetClass;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGbxAttributesComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGbxAttributesComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.GbxAttributesComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGbxAttributeSet.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGbxAttributeSet::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.GbxAttributeSet");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGbxAttributeSetBlueprint.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGbxAttributeSetBlueprint::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.GbxAttributeSetBlueprint");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGbxAttributeSetContextResolver.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGbxAttributeSetContextResolver::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.GbxAttributeSetContextResolver");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGbxAttributeSetValueResolver.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGbxAttributeSetValueResolver::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.GbxAttributeSetValueResolver");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E34E70
	 * 		Name   -> Function GbxGameSystemCore.GbxBlackboardKeySelectorExt.SetValueAsVector
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FGbxBlackboardKeySelector                   Key                                                        (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 * 		class UBlackboardComponent*                        BlackboardComponent                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     Value                                                      (Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGbxBlackboardKeySelectorExt::STATIC_SetValueAsVector(const struct FGbxBlackboardKeySelector& Key, class UBlackboardComponent* BlackboardComponent, const struct FVector& Value)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxBlackboardKeySelectorExt.SetValueAsVector");
		
		UGbxBlackboardKeySelectorExt_SetValueAsVector_Params params {};
		params.Key = Key;
		params.BlackboardComponent = BlackboardComponent;
		params.Value = Value;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E34D20
	 * 		Name   -> Function GbxGameSystemCore.GbxBlackboardKeySelectorExt.SetValueAsTargetActorInfo
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FGbxBlackboardKeySelector                   Key                                                        (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 * 		class UBlackboardComponent*                        BlackboardComponent                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FTargetActorInfo                            Value                                                      (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	void UGbxBlackboardKeySelectorExt::STATIC_SetValueAsTargetActorInfo(const struct FGbxBlackboardKeySelector& Key, class UBlackboardComponent* BlackboardComponent, const struct FTargetActorInfo& Value)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxBlackboardKeySelectorExt.SetValueAsTargetActorInfo");
		
		UGbxBlackboardKeySelectorExt_SetValueAsTargetActorInfo_Params params {};
		params.Key = Key;
		params.BlackboardComponent = BlackboardComponent;
		params.Value = Value;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E34BA0
	 * 		Name   -> Function GbxGameSystemCore.GbxBlackboardKeySelectorExt.SetValueAsString
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		struct FGbxBlackboardKeySelector                   Key                                                        (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 * 		class UBlackboardComponent*                        BlackboardComponent                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FString                                      Value                                                      (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGbxBlackboardKeySelectorExt::STATIC_SetValueAsString(const struct FGbxBlackboardKeySelector& Key, class UBlackboardComponent* BlackboardComponent, const class FString& Value)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxBlackboardKeySelectorExt.SetValueAsString");
		
		UGbxBlackboardKeySelectorExt_SetValueAsString_Params params {};
		params.Key = Key;
		params.BlackboardComponent = BlackboardComponent;
		params.Value = Value;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E34A80
	 * 		Name   -> Function GbxGameSystemCore.GbxBlackboardKeySelectorExt.SetValueAsRotator
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FGbxBlackboardKeySelector                   Key                                                        (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 * 		class UBlackboardComponent*                        BlackboardComponent                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FRotator                                    Value                                                      (Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UGbxBlackboardKeySelectorExt::STATIC_SetValueAsRotator(const struct FGbxBlackboardKeySelector& Key, class UBlackboardComponent* BlackboardComponent, const struct FRotator& Value)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxBlackboardKeySelectorExt.SetValueAsRotator");
		
		UGbxBlackboardKeySelectorExt_SetValueAsRotator_Params params {};
		params.Key = Key;
		params.BlackboardComponent = BlackboardComponent;
		params.Value = Value;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E34960
	 * 		Name   -> Function GbxGameSystemCore.GbxBlackboardKeySelectorExt.SetValueAsObject
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		struct FGbxBlackboardKeySelector                   Key                                                        (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 * 		class UBlackboardComponent*                        BlackboardComponent                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UObject*                                     Value                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGbxBlackboardKeySelectorExt::STATIC_SetValueAsObject(const struct FGbxBlackboardKeySelector& Key, class UBlackboardComponent* BlackboardComponent, class UObject* Value)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxBlackboardKeySelectorExt.SetValueAsObject");
		
		UGbxBlackboardKeySelectorExt_SetValueAsObject_Params params {};
		params.Key = Key;
		params.BlackboardComponent = BlackboardComponent;
		params.Value = Value;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E34840
	 * 		Name   -> Function GbxGameSystemCore.GbxBlackboardKeySelectorExt.SetValueAsName
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		struct FGbxBlackboardKeySelector                   Key                                                        (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 * 		class UBlackboardComponent*                        BlackboardComponent                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FName                                        Value                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGbxBlackboardKeySelectorExt::STATIC_SetValueAsName(const struct FGbxBlackboardKeySelector& Key, class UBlackboardComponent* BlackboardComponent, const class FName& Value)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxBlackboardKeySelectorExt.SetValueAsName");
		
		UGbxBlackboardKeySelectorExt_SetValueAsName_Params params {};
		params.Key = Key;
		params.BlackboardComponent = BlackboardComponent;
		params.Value = Value;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E34730
	 * 		Name   -> Function GbxGameSystemCore.GbxBlackboardKeySelectorExt.SetValueAsInt
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		struct FGbxBlackboardKeySelector                   Key                                                        (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 * 		class UBlackboardComponent*                        BlackboardComponent                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            Value                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGbxBlackboardKeySelectorExt::STATIC_SetValueAsInt(const struct FGbxBlackboardKeySelector& Key, class UBlackboardComponent* BlackboardComponent, int32_t Value)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxBlackboardKeySelectorExt.SetValueAsInt");
		
		UGbxBlackboardKeySelectorExt_SetValueAsInt_Params params {};
		params.Key = Key;
		params.BlackboardComponent = BlackboardComponent;
		params.Value = Value;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E34610
	 * 		Name   -> Function GbxGameSystemCore.GbxBlackboardKeySelectorExt.SetValueAsFloat
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		struct FGbxBlackboardKeySelector                   Key                                                        (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 * 		class UBlackboardComponent*                        BlackboardComponent                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Value                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGbxBlackboardKeySelectorExt::STATIC_SetValueAsFloat(const struct FGbxBlackboardKeySelector& Key, class UBlackboardComponent* BlackboardComponent, float Value)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxBlackboardKeySelectorExt.SetValueAsFloat");
		
		UGbxBlackboardKeySelectorExt_SetValueAsFloat_Params params {};
		params.Key = Key;
		params.BlackboardComponent = BlackboardComponent;
		params.Value = Value;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E344B0
	 * 		Name   -> Function GbxGameSystemCore.GbxBlackboardKeySelectorExt.SetValueAsFlag
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		struct FGbxBlackboardKeySelector                   Key                                                        (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 * 		class UBlackboardComponent*                        BlackboardComponent                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               Value                                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Duration                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGbxBlackboardKeySelectorExt::STATIC_SetValueAsFlag(const struct FGbxBlackboardKeySelector& Key, class UBlackboardComponent* BlackboardComponent, bool Value, float Duration)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxBlackboardKeySelectorExt.SetValueAsFlag");
		
		UGbxBlackboardKeySelectorExt_SetValueAsFlag_Params params {};
		params.Key = Key;
		params.BlackboardComponent = BlackboardComponent;
		params.Value = Value;
		params.Duration = Duration;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E34390
	 * 		Name   -> Function GbxGameSystemCore.GbxBlackboardKeySelectorExt.SetValueAsEnum
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		struct FGbxBlackboardKeySelector                   Key                                                        (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 * 		class UBlackboardComponent*                        BlackboardComponent                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		unsigned char                                      Value                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGbxBlackboardKeySelectorExt::STATIC_SetValueAsEnum(const struct FGbxBlackboardKeySelector& Key, class UBlackboardComponent* BlackboardComponent, unsigned char Value)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxBlackboardKeySelectorExt.SetValueAsEnum");
		
		UGbxBlackboardKeySelectorExt_SetValueAsEnum_Params params {};
		params.Key = Key;
		params.BlackboardComponent = BlackboardComponent;
		params.Value = Value;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E34270
	 * 		Name   -> Function GbxGameSystemCore.GbxBlackboardKeySelectorExt.SetValueAsClass
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		struct FGbxBlackboardKeySelector                   Key                                                        (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 * 		class UBlackboardComponent*                        BlackboardComponent                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UClass*                                      Value                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGbxBlackboardKeySelectorExt::STATIC_SetValueAsClass(const struct FGbxBlackboardKeySelector& Key, class UBlackboardComponent* BlackboardComponent, class UClass* Value)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxBlackboardKeySelectorExt.SetValueAsClass");
		
		UGbxBlackboardKeySelectorExt_SetValueAsClass_Params params {};
		params.Key = Key;
		params.BlackboardComponent = BlackboardComponent;
		params.Value = Value;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E34150
	 * 		Name   -> Function GbxGameSystemCore.GbxBlackboardKeySelectorExt.SetValueAsBool
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		struct FGbxBlackboardKeySelector                   Key                                                        (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 * 		class UBlackboardComponent*                        BlackboardComponent                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               Value                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGbxBlackboardKeySelectorExt::STATIC_SetValueAsBool(const struct FGbxBlackboardKeySelector& Key, class UBlackboardComponent* BlackboardComponent, bool Value)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxBlackboardKeySelectorExt.SetValueAsBool");
		
		UGbxBlackboardKeySelectorExt_SetValueAsBool_Params params {};
		params.Key = Key;
		params.BlackboardComponent = BlackboardComponent;
		params.Value = Value;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E33880
	 * 		Name   -> Function GbxGameSystemCore.GbxBlackboardKeySelectorExt.GetValueAsVector
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FGbxBlackboardKeySelector                   Key                                                        (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 * 		class UBlackboardComponent*                        BlackboardComponent                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FVector UGbxBlackboardKeySelectorExt::STATIC_GetValueAsVector(const struct FGbxBlackboardKeySelector& Key, class UBlackboardComponent* BlackboardComponent)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxBlackboardKeySelectorExt.GetValueAsVector");
		
		UGbxBlackboardKeySelectorExt_GetValueAsVector_Params params {};
		params.Key = Key;
		params.BlackboardComponent = BlackboardComponent;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E33760
	 * 		Name   -> Function GbxGameSystemCore.GbxBlackboardKeySelectorExt.GetValueAsTargetActorInfo
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FGbxBlackboardKeySelector                   Key                                                        (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 * 		class UBlackboardComponent*                        BlackboardComponent                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FTargetActorInfo UGbxBlackboardKeySelectorExt::STATIC_GetValueAsTargetActorInfo(const struct FGbxBlackboardKeySelector& Key, class UBlackboardComponent* BlackboardComponent)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxBlackboardKeySelectorExt.GetValueAsTargetActorInfo");
		
		UGbxBlackboardKeySelectorExt_GetValueAsTargetActorInfo_Params params {};
		params.Key = Key;
		params.BlackboardComponent = BlackboardComponent;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E33630
	 * 		Name   -> Function GbxGameSystemCore.GbxBlackboardKeySelectorExt.GetValueAsString
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FGbxBlackboardKeySelector                   Key                                                        (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 * 		class UBlackboardComponent*                        BlackboardComponent                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class FString UGbxBlackboardKeySelectorExt::STATIC_GetValueAsString(const struct FGbxBlackboardKeySelector& Key, class UBlackboardComponent* BlackboardComponent)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxBlackboardKeySelectorExt.GetValueAsString");
		
		UGbxBlackboardKeySelectorExt_GetValueAsString_Params params {};
		params.Key = Key;
		params.BlackboardComponent = BlackboardComponent;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E33520
	 * 		Name   -> Function GbxGameSystemCore.GbxBlackboardKeySelectorExt.GetValueAsRotator
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FGbxBlackboardKeySelector                   Key                                                        (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 * 		class UBlackboardComponent*                        BlackboardComponent                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FRotator UGbxBlackboardKeySelectorExt::STATIC_GetValueAsRotator(const struct FGbxBlackboardKeySelector& Key, class UBlackboardComponent* BlackboardComponent)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxBlackboardKeySelectorExt.GetValueAsRotator");
		
		UGbxBlackboardKeySelectorExt_GetValueAsRotator_Params params {};
		params.Key = Key;
		params.BlackboardComponent = BlackboardComponent;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E33430
	 * 		Name   -> Function GbxGameSystemCore.GbxBlackboardKeySelectorExt.GetValueAsObject
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FGbxBlackboardKeySelector                   Key                                                        (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 * 		class UBlackboardComponent*                        BlackboardComponent                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UObject* UGbxBlackboardKeySelectorExt::STATIC_GetValueAsObject(const struct FGbxBlackboardKeySelector& Key, class UBlackboardComponent* BlackboardComponent)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxBlackboardKeySelectorExt.GetValueAsObject");
		
		UGbxBlackboardKeySelectorExt_GetValueAsObject_Params params {};
		params.Key = Key;
		params.BlackboardComponent = BlackboardComponent;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E33340
	 * 		Name   -> Function GbxGameSystemCore.GbxBlackboardKeySelectorExt.GetValueAsName
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FGbxBlackboardKeySelector                   Key                                                        (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 * 		class UBlackboardComponent*                        BlackboardComponent                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class FName UGbxBlackboardKeySelectorExt::STATIC_GetValueAsName(const struct FGbxBlackboardKeySelector& Key, class UBlackboardComponent* BlackboardComponent)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxBlackboardKeySelectorExt.GetValueAsName");
		
		UGbxBlackboardKeySelectorExt_GetValueAsName_Params params {};
		params.Key = Key;
		params.BlackboardComponent = BlackboardComponent;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E33260
	 * 		Name   -> Function GbxGameSystemCore.GbxBlackboardKeySelectorExt.GetValueAsInt
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FGbxBlackboardKeySelector                   Key                                                        (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 * 		class UBlackboardComponent*                        BlackboardComponent                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	int32_t UGbxBlackboardKeySelectorExt::STATIC_GetValueAsInt(const struct FGbxBlackboardKeySelector& Key, class UBlackboardComponent* BlackboardComponent)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxBlackboardKeySelectorExt.GetValueAsInt");
		
		UGbxBlackboardKeySelectorExt_GetValueAsInt_Params params {};
		params.Key = Key;
		params.BlackboardComponent = BlackboardComponent;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E33170
	 * 		Name   -> Function GbxGameSystemCore.GbxBlackboardKeySelectorExt.GetValueAsFloat
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FGbxBlackboardKeySelector                   Key                                                        (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 * 		class UBlackboardComponent*                        BlackboardComponent                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	float UGbxBlackboardKeySelectorExt::STATIC_GetValueAsFloat(const struct FGbxBlackboardKeySelector& Key, class UBlackboardComponent* BlackboardComponent)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxBlackboardKeySelectorExt.GetValueAsFloat");
		
		UGbxBlackboardKeySelectorExt_GetValueAsFloat_Params params {};
		params.Key = Key;
		params.BlackboardComponent = BlackboardComponent;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E33080
	 * 		Name   -> Function GbxGameSystemCore.GbxBlackboardKeySelectorExt.GetValueAsEnum
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FGbxBlackboardKeySelector                   Key                                                        (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 * 		class UBlackboardComponent*                        BlackboardComponent                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	unsigned char UGbxBlackboardKeySelectorExt::STATIC_GetValueAsEnum(const struct FGbxBlackboardKeySelector& Key, class UBlackboardComponent* BlackboardComponent)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxBlackboardKeySelectorExt.GetValueAsEnum");
		
		UGbxBlackboardKeySelectorExt_GetValueAsEnum_Params params {};
		params.Key = Key;
		params.BlackboardComponent = BlackboardComponent;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E32F90
	 * 		Name   -> Function GbxGameSystemCore.GbxBlackboardKeySelectorExt.GetValueAsClass
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FGbxBlackboardKeySelector                   Key                                                        (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 * 		class UBlackboardComponent*                        BlackboardComponent                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UClass* UGbxBlackboardKeySelectorExt::STATIC_GetValueAsClass(const struct FGbxBlackboardKeySelector& Key, class UBlackboardComponent* BlackboardComponent)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxBlackboardKeySelectorExt.GetValueAsClass");
		
		UGbxBlackboardKeySelectorExt_GetValueAsClass_Params params {};
		params.Key = Key;
		params.BlackboardComponent = BlackboardComponent;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E32EA0
	 * 		Name   -> Function GbxGameSystemCore.GbxBlackboardKeySelectorExt.GetValueAsBool
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FGbxBlackboardKeySelector                   Key                                                        (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 * 		class UBlackboardComponent*                        BlackboardComponent                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UGbxBlackboardKeySelectorExt::STATIC_GetValueAsBool(const struct FGbxBlackboardKeySelector& Key, class UBlackboardComponent* BlackboardComponent)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxBlackboardKeySelectorExt.GetValueAsBool");
		
		UGbxBlackboardKeySelectorExt_GetValueAsBool_Params params {};
		params.Key = Key;
		params.BlackboardComponent = BlackboardComponent;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E32DB0
	 * 		Name   -> Function GbxGameSystemCore.GbxBlackboardKeySelectorExt.GetValueAsActor
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FGbxBlackboardKeySelector                   Key                                                        (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 * 		class UBlackboardComponent*                        BlackboardComponent                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class AActor* UGbxBlackboardKeySelectorExt::STATIC_GetValueAsActor(const struct FGbxBlackboardKeySelector& Key, class UBlackboardComponent* BlackboardComponent)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxBlackboardKeySelectorExt.GetValueAsActor");
		
		UGbxBlackboardKeySelectorExt_GetValueAsActor_Params params {};
		params.Key = Key;
		params.BlackboardComponent = BlackboardComponent;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E32B90
	 * 		Name   -> Function GbxGameSystemCore.GbxBlackboardKeySelectorExt.GetPropertyDescription
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms)
	 * Parameters:
	 * 		struct FGbxBlackboardKeySelector                   BBKey                                                      (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 * 		class UProperty*                                   Property                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class FString UGbxBlackboardKeySelectorExt::STATIC_GetPropertyDescription(const struct FGbxBlackboardKeySelector& BBKey, class UProperty* Property)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxBlackboardKeySelectorExt.GetPropertyDescription");
		
		UGbxBlackboardKeySelectorExt_GetPropertyDescription_Params params {};
		params.BBKey = BBKey;
		params.Property = Property;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E32450
	 * 		Name   -> Function GbxGameSystemCore.GbxBlackboardKeySelectorExt.ClearValue
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		struct FGbxBlackboardKeySelector                   Key                                                        (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 * 		class UBlackboardComponent*                        BlackboardComponent                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGbxBlackboardKeySelectorExt::STATIC_ClearValue(const struct FGbxBlackboardKeySelector& Key, class UBlackboardComponent* BlackboardComponent)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxBlackboardKeySelectorExt.ClearValue");
		
		UGbxBlackboardKeySelectorExt_ClearValue_Params params {};
		params.Key = Key;
		params.BlackboardComponent = BlackboardComponent;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGbxBlackboardKeySelectorExt.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGbxBlackboardKeySelectorExt::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.GbxBlackboardKeySelectorExt");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGbxBoneModifyProfile.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGbxBoneModifyProfile::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.GbxBoneModifyProfile");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGbxCameraShake.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGbxCameraShake::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.GbxCameraShake");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGbxCondition_ActorIsOfClass.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGbxCondition_ActorIsOfClass::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.GbxCondition_ActorIsOfClass");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGbxCondition_AttackedRecently.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGbxCondition_AttackedRecently::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.GbxCondition_AttackedRecently");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E3FFC0
	 * 		Name   -> Function GbxGameSystemCore.GbxCondition_Blueprint.EvaluateCondition
	 * 		Flags  -> (Native, Event, Protected, BlueprintEvent, Const)
	 * Parameters:
	 * 		class UObject*                                     Context                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UObject*                                     OptionalContext                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UGbxCondition_Blueprint::EvaluateCondition(class UObject* Context, class UObject* OptionalContext)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxCondition_Blueprint.EvaluateCondition");
		
		UGbxCondition_Blueprint_EvaluateCondition_Params params {};
		params.Context = Context;
		params.OptionalContext = OptionalContext;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGbxCondition_Blueprint.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGbxCondition_Blueprint::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.GbxCondition_Blueprint");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGbxCondition_CharacterMass.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGbxCondition_CharacterMass::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.GbxCondition_CharacterMass");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGbxCondition_Comparison.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGbxCondition_Comparison::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.GbxCondition_Comparison");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGbxCondition_Compound.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGbxCondition_Compound::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.GbxCondition_Compound");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGbxCondition_Flag.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGbxCondition_Flag::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.GbxCondition_Flag");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGbxCondition_HasActorTags.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGbxCondition_HasActorTags::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.GbxCondition_HasActorTags");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGbxCondition_HasGameplayTags.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGbxCondition_HasGameplayTags::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.GbxCondition_HasGameplayTags");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGbxCondition_HasInstigatedStatusEffect.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGbxCondition_HasInstigatedStatusEffect::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.GbxCondition_HasInstigatedStatusEffect");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGbxCondition_IsBlackboardTarget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGbxCondition_IsBlackboardTarget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.GbxCondition_IsBlackboardTarget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGbxCondition_IsLowOnHealth.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGbxCondition_IsLowOnHealth::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.GbxCondition_IsLowOnHealth");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGbxCondition_IsPlayerController.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGbxCondition_IsPlayerController::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.GbxCondition_IsPlayerController");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGbxCondition_IsTargetAimedAtMe.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGbxCondition_IsTargetAimedAtMe::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.GbxCondition_IsTargetAimedAtMe");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGbxCondition_IsTrue.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGbxCondition_IsTrue::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.GbxCondition_IsTrue");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x021622C0
	 * 		Name   -> Function GbxGameSystemCore.GbxCondition_List.RequiresNativeClass
	 * 		Flags  -> (Native, Public, Const)
	 */
	bool UGbxCondition_List::RequiresNativeClass()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxCondition_List.RequiresNativeClass");
		
		UGbxCondition_List_RequiresNativeClass_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E40250
	 * 		Name   -> Function GbxGameSystemCore.GbxCondition_List.GetRequiredInterface
	 * 		Flags  -> (Native, Public, Const)
	 */
	class UClass* UGbxCondition_List::GetRequiredInterface()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxCondition_List.GetRequiredInterface");
		
		UGbxCondition_List_GetRequiredInterface_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGbxCondition_List.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGbxCondition_List::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.GbxCondition_List");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGbxCondition_SensedRecently.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGbxCondition_SensedRecently::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.GbxCondition_SensedRecently");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGbxCondition_TeamAttitude.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGbxCondition_TeamAttitude::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.GbxCondition_TeamAttitude");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGbxCondition_TeamCheck.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGbxCondition_TeamCheck::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.GbxCondition_TeamCheck");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGbxCustomizationInterface.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGbxCustomizationInterface::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.GbxCustomizationInterface");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGbxCustomizationTargetData.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGbxCustomizationTargetData::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.GbxCustomizationTargetData");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGbxCustomizationTypeData.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGbxCustomizationTypeData::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.GbxCustomizationTypeData");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E46FF0
	 * 		Name   -> Function GbxGameSystemCore.GbxDataTableFunctionLibrary.GetDataTableValueFromHandle
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FDataTableValueHandle                       ValueHandle                                                (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 * 		class UObject*                                     ContextSource                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              DefaultValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	float UGbxDataTableFunctionLibrary::STATIC_GetDataTableValueFromHandle(const struct FDataTableValueHandle& ValueHandle, class UObject* ContextSource, float DefaultValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxDataTableFunctionLibrary.GetDataTableValueFromHandle");
		
		UGbxDataTableFunctionLibrary_GetDataTableValueFromHandle_Params params {};
		params.ValueHandle = ValueHandle;
		params.ContextSource = ContextSource;
		params.DefaultValue = DefaultValue;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E46BB0
	 * 		Name   -> Function GbxGameSystemCore.GbxDataTableFunctionLibrary.GetDataTableValue
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		class UDataTable*                                  Table                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FName                                        RowName                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FName                                        ValueName                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UScriptStruct*                               ValueInStructType                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            OutValue                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UGbxDataTableFunctionLibrary::STATIC_GetDataTableValue(class UDataTable* Table, const class FName& RowName, const class FName& ValueName, class UScriptStruct* ValueInStructType, int32_t* OutValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxDataTableFunctionLibrary.GetDataTableValue");
		
		UGbxDataTableFunctionLibrary_GetDataTableValue_Params params {};
		params.Table = Table;
		params.RowName = RowName;
		params.ValueName = ValueName;
		params.ValueInStructType = ValueInStructType;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutValue != nullptr)
			*OutValue = params.OutValue;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E46080
	 * 		Name   -> Function GbxGameSystemCore.GbxDataTableFunctionLibrary.Conv_DataTableValueHandleToString
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FDataTableValueHandle                       ValueHandle                                                (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	class FString UGbxDataTableFunctionLibrary::STATIC_Conv_DataTableValueHandleToString(const struct FDataTableValueHandle& ValueHandle)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxDataTableFunctionLibrary.Conv_DataTableValueHandleToString");
		
		UGbxDataTableFunctionLibrary_Conv_DataTableValueHandleToString_Params params {};
		params.ValueHandle = ValueHandle;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGbxDataTableFunctionLibrary.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGbxDataTableFunctionLibrary::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.GbxDataTableFunctionLibrary");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGbxEnvQueryHotSpotProviderInterface.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGbxEnvQueryHotSpotProviderInterface::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.GbxEnvQueryHotSpotProviderInterface");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E46AE0
	 * 		Name   -> Function GbxGameSystemCore.GbxEqsRenderingComponent.GetAvailableEnvQueryParamRefNames
	 * 		Flags  -> (Final, Native, Public, HasOutParms, Const)
	 * Parameters:
	 * 		TArray<class FString>                              Names                                                      (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	 */
	void UGbxEqsRenderingComponent::GetAvailableEnvQueryParamRefNames(TArray<class FString>* Names)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxEqsRenderingComponent.GetAvailableEnvQueryParamRefNames");
		
		UGbxEqsRenderingComponent_GetAvailableEnvQueryParamRefNames_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (Names != nullptr)
			*Names = params.Names;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGbxEqsRenderingComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGbxEqsRenderingComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.GbxEqsRenderingComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGbxEventDelegateBinding.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGbxEventDelegateBinding::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.GbxEventDelegateBinding");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E47F10
	 * 		Name   -> Function GbxGameSystemCore.GbxFeedbackBase.StopGbxFeedback
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UGbxFeedbackBase*                            FeedbackData                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AGbxPlayerController*                        Controller                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGbxFeedbackBase::STATIC_StopGbxFeedback(class UGbxFeedbackBase* FeedbackData, class UObject* WorldContextObject, class AGbxPlayerController* Controller)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxFeedbackBase.StopGbxFeedback");
		
		UGbxFeedbackBase_StopGbxFeedback_Params params {};
		params.FeedbackData = FeedbackData;
		params.WorldContextObject = WorldContextObject;
		params.Controller = Controller;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E476F0
	 * 		Name   -> Function GbxGameSystemCore.GbxFeedbackBase.PlayGbxFeedbackData3D
	 * 		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		class UGbxFeedbackBase*                            FeedbackData                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AGbxPlayerController*                        Controller                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     SourceLocation                                             (Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bLoop                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bIgnoreController                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Scale                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UObject*                                     SourceContext                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              EffectFalloffMinDistance                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              EffectFalloffMaxDistance                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGbxFeedbackBase::STATIC_PlayGbxFeedbackData3D(class UGbxFeedbackBase* FeedbackData, class UObject* WorldContextObject, class AGbxPlayerController* Controller, const struct FVector& SourceLocation, bool bLoop, bool bIgnoreController, float Scale, class UObject* SourceContext, float EffectFalloffMinDistance, float EffectFalloffMaxDistance)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxFeedbackBase.PlayGbxFeedbackData3D");
		
		UGbxFeedbackBase_PlayGbxFeedbackData3D_Params params {};
		params.FeedbackData = FeedbackData;
		params.WorldContextObject = WorldContextObject;
		params.Controller = Controller;
		params.SourceLocation = SourceLocation;
		params.bLoop = bLoop;
		params.bIgnoreController = bIgnoreController;
		params.Scale = Scale;
		params.SourceContext = SourceContext;
		params.EffectFalloffMinDistance = EffectFalloffMinDistance;
		params.EffectFalloffMaxDistance = EffectFalloffMaxDistance;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E474F0
	 * 		Name   -> Function GbxGameSystemCore.GbxFeedbackBase.PlayGbxFeedbackData2D
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UGbxFeedbackBase*                            FeedbackData                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AGbxPlayerController*                        Controller                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bLoop                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bIgnoreController                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Scale                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UObject*                                     SourceContext                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGbxFeedbackBase::STATIC_PlayGbxFeedbackData2D(class UGbxFeedbackBase* FeedbackData, class UObject* WorldContextObject, class AGbxPlayerController* Controller, bool bLoop, bool bIgnoreController, float Scale, class UObject* SourceContext)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxFeedbackBase.PlayGbxFeedbackData2D");
		
		UGbxFeedbackBase_PlayGbxFeedbackData2D_Params params {};
		params.FeedbackData = FeedbackData;
		params.WorldContextObject = WorldContextObject;
		params.Controller = Controller;
		params.bLoop = bLoop;
		params.bIgnoreController = bIgnoreController;
		params.Scale = Scale;
		params.SourceContext = SourceContext;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGbxFeedbackBase.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGbxFeedbackBase::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.GbxFeedbackBase");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGbxFeedbackData.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGbxFeedbackData::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.GbxFeedbackData");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGbxFeedbackList.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGbxFeedbackList::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.GbxFeedbackList");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGbxFeedbackManager.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGbxFeedbackManager::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.GbxFeedbackManager");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGbxFlagData.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGbxFlagData::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.GbxFlagData");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E47DF0
	 * 		Name   -> Function GbxGameSystemCore.GbxFlagFunctionLibrary.SetFlagValue
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FGbxFlag                                    Flag                                                       (Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 * 		bool                                               bNewValue                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGbxFlagFunctionLibrary::STATIC_SetFlagValue(class UObject* WorldContextObject, struct FGbxFlag* Flag, bool bNewValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxFlagFunctionLibrary.SetFlagValue");
		
		UGbxFlagFunctionLibrary_SetFlagValue_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.bNewValue = bNewValue;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (Flag != nullptr)
			*Flag = params.Flag;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E47CD0
	 * 		Name   -> Function GbxGameSystemCore.GbxFlagFunctionLibrary.SetFlagTrueTimed
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FGbxFlag                                    Flag                                                       (Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 * 		float                                              Duration                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGbxFlagFunctionLibrary::STATIC_SetFlagTrueTimed(class UObject* WorldContextObject, struct FGbxFlag* Flag, float Duration)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxFlagFunctionLibrary.SetFlagTrueTimed");
		
		UGbxFlagFunctionLibrary_SetFlagTrueTimed_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.Duration = Duration;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (Flag != nullptr)
			*Flag = params.Flag;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E47BA0
	 * 		Name   -> Function GbxGameSystemCore.GbxFlagFunctionLibrary.SetFlagDataValue
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UGbxFlagData*                                FlagData                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UObject*                                     ContextSource                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bNewValue                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGbxFlagFunctionLibrary::STATIC_SetFlagDataValue(class UObject* WorldContextObject, class UGbxFlagData* FlagData, class UObject* ContextSource, bool bNewValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxFlagFunctionLibrary.SetFlagDataValue");
		
		UGbxFlagFunctionLibrary_SetFlagDataValue_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.FlagData = FlagData;
		params.ContextSource = ContextSource;
		params.bNewValue = bNewValue;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E47A60
	 * 		Name   -> Function GbxGameSystemCore.GbxFlagFunctionLibrary.SetFlagDataTrueTimed
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UGbxFlagData*                                FlagData                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UObject*                                     ContextSource                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Duration                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGbxFlagFunctionLibrary::STATIC_SetFlagDataTrueTimed(class UObject* WorldContextObject, class UGbxFlagData* FlagData, class UObject* ContextSource, float Duration)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxFlagFunctionLibrary.SetFlagDataTrueTimed");
		
		UGbxFlagFunctionLibrary_SetFlagDataTrueTimed_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.FlagData = FlagData;
		params.ContextSource = ContextSource;
		params.Duration = Duration;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E47200
	 * 		Name   -> Function GbxGameSystemCore.GbxFlagFunctionLibrary.GetFlagValue
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FGbxFlag                                    Flag                                                       (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	bool UGbxFlagFunctionLibrary::STATIC_GetFlagValue(class UObject* WorldContextObject, const struct FGbxFlag& Flag)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxFlagFunctionLibrary.GetFlagValue");
		
		UGbxFlagFunctionLibrary_GetFlagValue_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.Flag = Flag;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E47110
	 * 		Name   -> Function GbxGameSystemCore.GbxFlagFunctionLibrary.GetFlagDataValue
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UGbxFlagData*                                FlagData                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UObject*                                     ContextSource                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UGbxFlagFunctionLibrary::STATIC_GetFlagDataValue(class UObject* WorldContextObject, class UGbxFlagData* FlagData, class UObject* ContextSource)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxFlagFunctionLibrary.GetFlagDataValue");
		
		UGbxFlagFunctionLibrary_GetFlagDataValue_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.FlagData = FlagData;
		params.ContextSource = ContextSource;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E469C0
	 * 		Name   -> Function GbxGameSystemCore.GbxFlagFunctionLibrary.FlagTrueWithin
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FGbxFlag                                    Flag                                                       (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 * 		float                                              CheckTime                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UGbxFlagFunctionLibrary::STATIC_FlagTrueWithin(class UObject* WorldContextObject, const struct FGbxFlag& Flag, float CheckTime)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxFlagFunctionLibrary.FlagTrueWithin");
		
		UGbxFlagFunctionLibrary_FlagTrueWithin_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.Flag = Flag;
		params.CheckTime = CheckTime;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E468A0
	 * 		Name   -> Function GbxGameSystemCore.GbxFlagFunctionLibrary.FlagTrueFor
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FGbxFlag                                    Flag                                                       (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 * 		float                                              CheckTime                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UGbxFlagFunctionLibrary::STATIC_FlagTrueFor(class UObject* WorldContextObject, const struct FGbxFlag& Flag, float CheckTime)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxFlagFunctionLibrary.FlagTrueFor");
		
		UGbxFlagFunctionLibrary_FlagTrueFor_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.Flag = Flag;
		params.CheckTime = CheckTime;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E46780
	 * 		Name   -> Function GbxGameSystemCore.GbxFlagFunctionLibrary.FlagFalseWithin
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FGbxFlag                                    Flag                                                       (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 * 		float                                              CheckTime                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UGbxFlagFunctionLibrary::STATIC_FlagFalseWithin(class UObject* WorldContextObject, const struct FGbxFlag& Flag, float CheckTime)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxFlagFunctionLibrary.FlagFalseWithin");
		
		UGbxFlagFunctionLibrary_FlagFalseWithin_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.Flag = Flag;
		params.CheckTime = CheckTime;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E46660
	 * 		Name   -> Function GbxGameSystemCore.GbxFlagFunctionLibrary.FlagFalseFor
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FGbxFlag                                    Flag                                                       (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 * 		float                                              CheckTime                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UGbxFlagFunctionLibrary::STATIC_FlagFalseFor(class UObject* WorldContextObject, const struct FGbxFlag& Flag, float CheckTime)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxFlagFunctionLibrary.FlagFalseFor");
		
		UGbxFlagFunctionLibrary_FlagFalseFor_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.Flag = Flag;
		params.CheckTime = CheckTime;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E46520
	 * 		Name   -> Function GbxGameSystemCore.GbxFlagFunctionLibrary.FlagDataTrueWithin
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UGbxFlagData*                                FlagData                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UObject*                                     ContextSource                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              CheckTime                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UGbxFlagFunctionLibrary::STATIC_FlagDataTrueWithin(class UObject* WorldContextObject, class UGbxFlagData* FlagData, class UObject* ContextSource, float CheckTime)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxFlagFunctionLibrary.FlagDataTrueWithin");
		
		UGbxFlagFunctionLibrary_FlagDataTrueWithin_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.FlagData = FlagData;
		params.ContextSource = ContextSource;
		params.CheckTime = CheckTime;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E463E0
	 * 		Name   -> Function GbxGameSystemCore.GbxFlagFunctionLibrary.FlagDataTrueFor
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UGbxFlagData*                                FlagData                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UObject*                                     ContextSource                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              CheckTime                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UGbxFlagFunctionLibrary::STATIC_FlagDataTrueFor(class UObject* WorldContextObject, class UGbxFlagData* FlagData, class UObject* ContextSource, float CheckTime)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxFlagFunctionLibrary.FlagDataTrueFor");
		
		UGbxFlagFunctionLibrary_FlagDataTrueFor_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.FlagData = FlagData;
		params.ContextSource = ContextSource;
		params.CheckTime = CheckTime;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E462A0
	 * 		Name   -> Function GbxGameSystemCore.GbxFlagFunctionLibrary.FlagDataFalseWithin
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UGbxFlagData*                                FlagData                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UObject*                                     ContextSource                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              CheckTime                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UGbxFlagFunctionLibrary::STATIC_FlagDataFalseWithin(class UObject* WorldContextObject, class UGbxFlagData* FlagData, class UObject* ContextSource, float CheckTime)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxFlagFunctionLibrary.FlagDataFalseWithin");
		
		UGbxFlagFunctionLibrary_FlagDataFalseWithin_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.FlagData = FlagData;
		params.ContextSource = ContextSource;
		params.CheckTime = CheckTime;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E46160
	 * 		Name   -> Function GbxGameSystemCore.GbxFlagFunctionLibrary.FlagDataFalseFor
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UGbxFlagData*                                FlagData                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UObject*                                     ContextSource                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              CheckTime                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UGbxFlagFunctionLibrary::STATIC_FlagDataFalseFor(class UObject* WorldContextObject, class UGbxFlagData* FlagData, class UObject* ContextSource, float CheckTime)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxFlagFunctionLibrary.FlagDataFalseFor");
		
		UGbxFlagFunctionLibrary_FlagDataFalseFor_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.FlagData = FlagData;
		params.ContextSource = ContextSource;
		params.CheckTime = CheckTime;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGbxFlagFunctionLibrary.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGbxFlagFunctionLibrary::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.GbxFlagFunctionLibrary");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UFlagPropertyTestContext.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UFlagPropertyTestContext::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.FlagPropertyTestContext");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UFlagPropertyTestContextResolver.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UFlagPropertyTestContextResolver::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.FlagPropertyTestContextResolver");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGbxFlagValueResolver.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGbxFlagValueResolver::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.GbxFlagValueResolver");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGbxFlagValueResolver_Property.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGbxFlagValueResolver_Property::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.GbxFlagValueResolver_Property");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UBaseMenuStackMenuInfo.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UBaseMenuStackMenuInfo::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.BaseMenuStackMenuInfo");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E4EDA0
	 * 		Name   -> Function GbxGameSystemCore.GbxGameplayStatics.SetTeamCollisionResponseWith
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class AActor*                                      Actor                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      TeamActor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bIgnore                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGbxGameplayStatics::STATIC_SetTeamCollisionResponseWith(class AActor* Actor, class AActor* TeamActor, bool bIgnore)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxGameplayStatics.SetTeamCollisionResponseWith");
		
		UGbxGameplayStatics_SetTeamCollisionResponseWith_Params params {};
		params.Actor = Actor;
		params.TeamActor = TeamActor;
		params.bIgnore = bIgnore;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E4ECA0
	 * 		Name   -> Function GbxGameSystemCore.GbxGameplayStatics.SetTeamCollisionResponseToChannel
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class AActor*                                      Actor                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		ETeamCollisionChannel                              Channel                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bIgnore                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGbxGameplayStatics::STATIC_SetTeamCollisionResponseToChannel(class AActor* Actor, ETeamCollisionChannel Channel, bool bIgnore)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxGameplayStatics.SetTeamCollisionResponseToChannel");
		
		UGbxGameplayStatics_SetTeamCollisionResponseToChannel_Params params {};
		params.Actor = Actor;
		params.Channel = Channel;
		params.bIgnore = bIgnore;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E4EBA0
	 * 		Name   -> Function GbxGameSystemCore.GbxGameplayStatics.SetTeamCollisionChannelFrom
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class AActor*                                      Actor                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      TeamActor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bOn                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGbxGameplayStatics::STATIC_SetTeamCollisionChannelFrom(class AActor* Actor, class AActor* TeamActor, bool bOn)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxGameplayStatics.SetTeamCollisionChannelFrom");
		
		UGbxGameplayStatics_SetTeamCollisionChannelFrom_Params params {};
		params.Actor = Actor;
		params.TeamActor = TeamActor;
		params.bOn = bOn;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E4EAA0
	 * 		Name   -> Function GbxGameSystemCore.GbxGameplayStatics.SetTeamCollisionChannel
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class AActor*                                      Actor                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		ETeamCollisionChannel                              Channel                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bOn                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGbxGameplayStatics::STATIC_SetTeamCollisionChannel(class AActor* Actor, ETeamCollisionChannel Channel, bool bOn)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxGameplayStatics.SetTeamCollisionChannel");
		
		UGbxGameplayStatics_SetTeamCollisionChannel_Params params {};
		params.Actor = Actor;
		params.Channel = Channel;
		params.bOn = bOn;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E4E9E0
	 * 		Name   -> Function GbxGameSystemCore.GbxGameplayStatics.SetPlayerMaster
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class AActor*                                      AIActor                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      PlayerMaster                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UGbxGameplayStatics::STATIC_SetPlayerMaster(class AActor* AIActor, class AActor* PlayerMaster)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxGameplayStatics.SetPlayerMaster");
		
		UGbxGameplayStatics_SetPlayerMaster_Params params {};
		params.AIActor = AIActor;
		params.PlayerMaster = PlayerMaster;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E4E8A0
	 * 		Name   -> Function GbxGameSystemCore.GbxGameplayStatics.SetComponentTeamCollisionResponseWith
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class USceneComponent*                             Component                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      TeamActor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bIgnore                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bPropagateToChildren                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGbxGameplayStatics::STATIC_SetComponentTeamCollisionResponseWith(class USceneComponent* Component, class AActor* TeamActor, bool bIgnore, bool bPropagateToChildren)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxGameplayStatics.SetComponentTeamCollisionResponseWith");
		
		UGbxGameplayStatics_SetComponentTeamCollisionResponseWith_Params params {};
		params.Component = Component;
		params.TeamActor = TeamActor;
		params.bIgnore = bIgnore;
		params.bPropagateToChildren = bPropagateToChildren;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E4E760
	 * 		Name   -> Function GbxGameSystemCore.GbxGameplayStatics.SetComponentTeamCollisionResponseToChannel
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class USceneComponent*                             Component                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		ETeamCollisionChannel                              Channel                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bIgnore                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bPropagateToChildren                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGbxGameplayStatics::STATIC_SetComponentTeamCollisionResponseToChannel(class USceneComponent* Component, ETeamCollisionChannel Channel, bool bIgnore, bool bPropagateToChildren)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxGameplayStatics.SetComponentTeamCollisionResponseToChannel");
		
		UGbxGameplayStatics_SetComponentTeamCollisionResponseToChannel_Params params {};
		params.Component = Component;
		params.Channel = Channel;
		params.bIgnore = bIgnore;
		params.bPropagateToChildren = bPropagateToChildren;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E4E620
	 * 		Name   -> Function GbxGameSystemCore.GbxGameplayStatics.SetComponentTeamCollisionChannel
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class USceneComponent*                             Component                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		ETeamCollisionChannel                              Channel                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bOn                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bPropagateToChildren                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGbxGameplayStatics::STATIC_SetComponentTeamCollisionChannel(class USceneComponent* Component, ETeamCollisionChannel Channel, bool bOn, bool bPropagateToChildren)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxGameplayStatics.SetComponentTeamCollisionChannel");
		
		UGbxGameplayStatics_SetComponentTeamCollisionChannel_Params params {};
		params.Component = Component;
		params.Channel = Channel;
		params.bOn = bOn;
		params.bPropagateToChildren = bPropagateToChildren;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E4C880
	 * 		Name   -> Function GbxGameSystemCore.GbxGameplayStatics.ProjectFromQueryToSimulation
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		class UGbxSkeletalMeshComponent*                   Component                                                  (ConstParm, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FName                                        BodyName                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     InOutHitPoint                                              (Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     InOutHitNormal                                             (Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGbxGameplayStatics::STATIC_ProjectFromQueryToSimulation(class UGbxSkeletalMeshComponent* Component, const class FName& BodyName, struct FVector* InOutHitPoint, struct FVector* InOutHitNormal)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxGameplayStatics.ProjectFromQueryToSimulation");
		
		UGbxGameplayStatics_ProjectFromQueryToSimulation_Params params {};
		params.Component = Component;
		params.BodyName = BodyName;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (InOutHitPoint != nullptr)
			*InOutHitPoint = params.InOutHitPoint;
		if (InOutHitNormal != nullptr)
			*InOutHitNormal = params.InOutHitNormal;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E4BB90
	 * 		Name   -> Function GbxGameSystemCore.GbxGameplayStatics.GetPrimaryPlayerController
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class APlayerController* UGbxGameplayStatics::STATIC_GetPrimaryPlayerController(class UObject* WorldContextObject)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxGameplayStatics.GetPrimaryPlayerController");
		
		UGbxGameplayStatics_GetPrimaryPlayerController_Params params {};
		params.WorldContextObject = WorldContextObject;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E4BA00
	 * 		Name   -> Function GbxGameSystemCore.GbxGameplayStatics.GetAssociatedPrimaryCharacter
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class AActor*                                      Actor                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class AGbxCharacter* UGbxGameplayStatics::STATIC_GetAssociatedPrimaryCharacter(class AActor* Actor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxGameplayStatics.GetAssociatedPrimaryCharacter");
		
		UGbxGameplayStatics_GetAssociatedPrimaryCharacter_Params params {};
		params.Actor = Actor;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E4A910
	 * 		Name   -> Function GbxGameSystemCore.GbxGameplayStatics.AlignTransformToSurface
	 * 		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FTransform                                  Transform                                                  (Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     SurfaceNormal                                              (Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FTransform UGbxGameplayStatics::STATIC_AlignTransformToSurface(const struct FTransform& Transform, const struct FVector& SurfaceNormal)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxGameplayStatics.AlignTransformToSurface");
		
		UGbxGameplayStatics_AlignTransformToSurface_Params params {};
		params.Transform = Transform;
		params.SurfaceNormal = SurfaceNormal;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGbxGameplayStatics.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGbxGameplayStatics::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.GbxGameplayStatics");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E4F6F0
	 * 		Name   -> Function GbxGameSystemCore.GbxGameStatsBlueprintLibrary.UpdateStatForParty
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UGameStatData*                               StatData                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            NewValue                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGbxGameStatsBlueprintLibrary::STATIC_UpdateStatForParty(class UObject* WorldContextObject, class UGameStatData* StatData, int32_t NewValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxGameStatsBlueprintLibrary.UpdateStatForParty");
		
		UGbxGameStatsBlueprintLibrary_UpdateStatForParty_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.StatData = StatData;
		params.NewValue = NewValue;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E4F600
	 * 		Name   -> Function GbxGameSystemCore.GbxGameStatsBlueprintLibrary.UpdateStat
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class AActor*                                      ContextActor                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UGameStatData*                               StatData                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            NewValue                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGbxGameStatsBlueprintLibrary::STATIC_UpdateStat(class AActor* ContextActor, class UGameStatData* StatData, int32_t NewValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxGameStatsBlueprintLibrary.UpdateStat");
		
		UGbxGameStatsBlueprintLibrary_UpdateStat_Params params {};
		params.ContextActor = ContextActor;
		params.StatData = StatData;
		params.NewValue = NewValue;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E4C210
	 * 		Name   -> Function GbxGameSystemCore.GbxGameStatsBlueprintLibrary.IncrementStatForParty
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UGameStatData*                               StatData                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            Amount                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGbxGameStatsBlueprintLibrary::STATIC_IncrementStatForParty(class UObject* WorldContextObject, class UGameStatData* StatData, int32_t Amount)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxGameStatsBlueprintLibrary.IncrementStatForParty");
		
		UGbxGameStatsBlueprintLibrary_IncrementStatForParty_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.StatData = StatData;
		params.Amount = Amount;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E4C120
	 * 		Name   -> Function GbxGameSystemCore.GbxGameStatsBlueprintLibrary.IncrementStat
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class AActor*                                      ContextActor                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UGameStatData*                               StatData                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            Amount                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGbxGameStatsBlueprintLibrary::STATIC_IncrementStat(class AActor* ContextActor, class UGameStatData* StatData, int32_t Amount)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxGameStatsBlueprintLibrary.IncrementStat");
		
		UGbxGameStatsBlueprintLibrary_IncrementStat_Params params {};
		params.ContextActor = ContextActor;
		params.StatData = StatData;
		params.Amount = Amount;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E4BE00
	 * 		Name   -> Function GbxGameSystemCore.GbxGameStatsBlueprintLibrary.GetStatValue
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class AActor*                                      ContextActor                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UGameStatData*                               StatData                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	int32_t UGbxGameStatsBlueprintLibrary::STATIC_GetStatValue(class AActor* ContextActor, class UGameStatData* StatData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxGameStatsBlueprintLibrary.GetStatValue");
		
		UGbxGameStatsBlueprintLibrary_GetStatValue_Params params {};
		params.ContextActor = ContextActor;
		params.StatData = StatData;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E4B3A0
	 * 		Name   -> Function GbxGameSystemCore.GbxGameStatsBlueprintLibrary.DecrementStatForParty
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UGameStatData*                               StatData                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            Amount                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGbxGameStatsBlueprintLibrary::STATIC_DecrementStatForParty(class UObject* WorldContextObject, class UGameStatData* StatData, int32_t Amount)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxGameStatsBlueprintLibrary.DecrementStatForParty");
		
		UGbxGameStatsBlueprintLibrary_DecrementStatForParty_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.StatData = StatData;
		params.Amount = Amount;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E4B2B0
	 * 		Name   -> Function GbxGameSystemCore.GbxGameStatsBlueprintLibrary.DecrementStat
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class AActor*                                      ContextActor                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UGameStatData*                               StatData                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            Amount                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGbxGameStatsBlueprintLibrary::STATIC_DecrementStat(class AActor* ContextActor, class UGameStatData* StatData, int32_t Amount)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxGameStatsBlueprintLibrary.DecrementStat");
		
		UGbxGameStatsBlueprintLibrary_DecrementStat_Params params {};
		params.ContextActor = ContextActor;
		params.StatData = StatData;
		params.Amount = Amount;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGbxGameStatsBlueprintLibrary.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGbxGameStatsBlueprintLibrary::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.GbxGameStatsBlueprintLibrary");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E4E4A0
	 * 		Name   -> Function GbxGameSystemCore.GbxGameSystemCoreBlueprintLibrary.SetComponentPhysicalRotation
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UPrimitiveComponent*                         Target                                                     (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              PitchRotation                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              YawRotation                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              RollRotation                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FName                                        BoneName                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGbxGameSystemCoreBlueprintLibrary::STATIC_SetComponentPhysicalRotation(class UPrimitiveComponent* Target, float PitchRotation, float YawRotation, float RollRotation, const class FName& BoneName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxGameSystemCoreBlueprintLibrary.SetComponentPhysicalRotation");
		
		UGbxGameSystemCoreBlueprintLibrary_SetComponentPhysicalRotation_Params params {};
		params.Target = Target;
		params.PitchRotation = PitchRotation;
		params.YawRotation = YawRotation;
		params.RollRotation = RollRotation;
		params.BoneName = BoneName;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E4E3F0
	 * 		Name   -> Function GbxGameSystemCore.GbxGameSystemCoreBlueprintLibrary.ResourceUnlockTurns
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class AActor*                                      Actor                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FName                                        Reason                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGbxGameSystemCoreBlueprintLibrary::STATIC_ResourceUnlockTurns(class AActor* Actor, const class FName& Reason)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxGameSystemCoreBlueprintLibrary.ResourceUnlockTurns");
		
		UGbxGameSystemCoreBlueprintLibrary_ResourceUnlockTurns_Params params {};
		params.Actor = Actor;
		params.Reason = Reason;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E4E340
	 * 		Name   -> Function GbxGameSystemCore.GbxGameSystemCoreBlueprintLibrary.ResourceUnlockTickAndRefreshBones
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class AActor*                                      Actor                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FName                                        Reason                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGbxGameSystemCoreBlueprintLibrary::STATIC_ResourceUnlockTickAndRefreshBones(class AActor* Actor, const class FName& Reason)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxGameSystemCoreBlueprintLibrary.ResourceUnlockTickAndRefreshBones");
		
		UGbxGameSystemCoreBlueprintLibrary_ResourceUnlockTickAndRefreshBones_Params params {};
		params.Actor = Actor;
		params.Reason = Reason;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E4E290
	 * 		Name   -> Function GbxGameSystemCore.GbxGameSystemCoreBlueprintLibrary.ResourceUnlockRotation
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class AActor*                                      Actor                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FName                                        Reason                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGbxGameSystemCoreBlueprintLibrary::STATIC_ResourceUnlockRotation(class AActor* Actor, const class FName& Reason)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxGameSystemCoreBlueprintLibrary.ResourceUnlockRotation");
		
		UGbxGameSystemCoreBlueprintLibrary_ResourceUnlockRotation_Params params {};
		params.Actor = Actor;
		params.Reason = Reason;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E4E1E0
	 * 		Name   -> Function GbxGameSystemCore.GbxGameSystemCoreBlueprintLibrary.ResourceUnlockMovement
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class AActor*                                      Actor                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FName                                        Reason                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGbxGameSystemCoreBlueprintLibrary::STATIC_ResourceUnlockMovement(class AActor* Actor, const class FName& Reason)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxGameSystemCoreBlueprintLibrary.ResourceUnlockMovement");
		
		UGbxGameSystemCoreBlueprintLibrary_ResourceUnlockMovement_Params params {};
		params.Actor = Actor;
		params.Reason = Reason;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E4E130
	 * 		Name   -> Function GbxGameSystemCore.GbxGameSystemCoreBlueprintLibrary.ResourceUnlockMomentum
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class AActor*                                      Actor                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FName                                        Reason                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGbxGameSystemCoreBlueprintLibrary::STATIC_ResourceUnlockMomentum(class AActor* Actor, const class FName& Reason)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxGameSystemCoreBlueprintLibrary.ResourceUnlockMomentum");
		
		UGbxGameSystemCoreBlueprintLibrary_ResourceUnlockMomentum_Params params {};
		params.Actor = Actor;
		params.Reason = Reason;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E4E080
	 * 		Name   -> Function GbxGameSystemCore.GbxGameSystemCoreBlueprintLibrary.ResourceUnlockMantling
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class AActor*                                      Actor                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FName                                        Reason                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGbxGameSystemCoreBlueprintLibrary::STATIC_ResourceUnlockMantling(class AActor* Actor, const class FName& Reason)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxGameSystemCoreBlueprintLibrary.ResourceUnlockMantling");
		
		UGbxGameSystemCoreBlueprintLibrary_ResourceUnlockMantling_Params params {};
		params.Actor = Actor;
		params.Reason = Reason;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E4DFD0
	 * 		Name   -> Function GbxGameSystemCore.GbxGameSystemCoreBlueprintLibrary.ResourceUnlockLookAtTargetLocation
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class AActor*                                      Actor                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FName                                        Reason                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGbxGameSystemCoreBlueprintLibrary::STATIC_ResourceUnlockLookAtTargetLocation(class AActor* Actor, const class FName& Reason)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxGameSystemCoreBlueprintLibrary.ResourceUnlockLookAtTargetLocation");
		
		UGbxGameSystemCoreBlueprintLibrary_ResourceUnlockLookAtTargetLocation_Params params {};
		params.Actor = Actor;
		params.Reason = Reason;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E4DF20
	 * 		Name   -> Function GbxGameSystemCore.GbxGameSystemCoreBlueprintLibrary.ResourceUnlockLookAt
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class AActor*                                      Actor                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FName                                        Reason                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGbxGameSystemCoreBlueprintLibrary::STATIC_ResourceUnlockLookAt(class AActor* Actor, const class FName& Reason)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxGameSystemCoreBlueprintLibrary.ResourceUnlockLookAt");
		
		UGbxGameSystemCoreBlueprintLibrary_ResourceUnlockLookAt_Params params {};
		params.Actor = Actor;
		params.Reason = Reason;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E4DE70
	 * 		Name   -> Function GbxGameSystemCore.GbxGameSystemCoreBlueprintLibrary.ResourceUnlockJumping
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class AActor*                                      Actor                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FName                                        Reason                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGbxGameSystemCoreBlueprintLibrary::STATIC_ResourceUnlockJumping(class AActor* Actor, const class FName& Reason)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxGameSystemCoreBlueprintLibrary.ResourceUnlockJumping");
		
		UGbxGameSystemCoreBlueprintLibrary_ResourceUnlockJumping_Params params {};
		params.Actor = Actor;
		params.Reason = Reason;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E4DDC0
	 * 		Name   -> Function GbxGameSystemCore.GbxGameSystemCoreBlueprintLibrary.ResourceUnlockHandIk
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class AActor*                                      Actor                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FName                                        Reason                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGbxGameSystemCoreBlueprintLibrary::STATIC_ResourceUnlockHandIk(class AActor* Actor, const class FName& Reason)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxGameSystemCoreBlueprintLibrary.ResourceUnlockHandIk");
		
		UGbxGameSystemCoreBlueprintLibrary_ResourceUnlockHandIk_Params params {};
		params.Actor = Actor;
		params.Reason = Reason;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E4DD10
	 * 		Name   -> Function GbxGameSystemCore.GbxGameSystemCoreBlueprintLibrary.ResourceUnlockGod
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class AActor*                                      Actor                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FName                                        Reason                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGbxGameSystemCoreBlueprintLibrary::STATIC_ResourceUnlockGod(class AActor* Actor, const class FName& Reason)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxGameSystemCoreBlueprintLibrary.ResourceUnlockGod");
		
		UGbxGameSystemCoreBlueprintLibrary_ResourceUnlockGod_Params params {};
		params.Actor = Actor;
		params.Reason = Reason;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E4DC60
	 * 		Name   -> Function GbxGameSystemCore.GbxGameSystemCoreBlueprintLibrary.ResourceUnlockFootIkTracing
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class AActor*                                      Actor                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FName                                        Reason                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGbxGameSystemCoreBlueprintLibrary::STATIC_ResourceUnlockFootIkTracing(class AActor* Actor, const class FName& Reason)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxGameSystemCoreBlueprintLibrary.ResourceUnlockFootIkTracing");
		
		UGbxGameSystemCoreBlueprintLibrary_ResourceUnlockFootIkTracing_Params params {};
		params.Actor = Actor;
		params.Reason = Reason;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E4DBB0
	 * 		Name   -> Function GbxGameSystemCore.GbxGameSystemCoreBlueprintLibrary.ResourceUnlockFootIk
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class AActor*                                      Actor                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FName                                        Reason                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGbxGameSystemCoreBlueprintLibrary::STATIC_ResourceUnlockFootIk(class AActor* Actor, const class FName& Reason)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxGameSystemCoreBlueprintLibrary.ResourceUnlockFootIk");
		
		UGbxGameSystemCoreBlueprintLibrary_ResourceUnlockFootIk_Params params {};
		params.Actor = Actor;
		params.Reason = Reason;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E4DB00
	 * 		Name   -> Function GbxGameSystemCore.GbxGameSystemCoreBlueprintLibrary.ResourceUnlockDodging
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class AActor*                                      Actor                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FName                                        Reason                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGbxGameSystemCoreBlueprintLibrary::STATIC_ResourceUnlockDodging(class AActor* Actor, const class FName& Reason)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxGameSystemCoreBlueprintLibrary.ResourceUnlockDodging");
		
		UGbxGameSystemCoreBlueprintLibrary_ResourceUnlockDodging_Params params {};
		params.Actor = Actor;
		params.Reason = Reason;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E4DA50
	 * 		Name   -> Function GbxGameSystemCore.GbxGameSystemCoreBlueprintLibrary.ResourceUnlockDemigod
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class AActor*                                      Actor                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FName                                        Reason                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGbxGameSystemCoreBlueprintLibrary::STATIC_ResourceUnlockDemigod(class AActor* Actor, const class FName& Reason)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxGameSystemCoreBlueprintLibrary.ResourceUnlockDemigod");
		
		UGbxGameSystemCoreBlueprintLibrary_ResourceUnlockDemigod_Params params {};
		params.Actor = Actor;
		params.Reason = Reason;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E4D9A0
	 * 		Name   -> Function GbxGameSystemCore.GbxGameSystemCoreBlueprintLibrary.ResourceUnlockCrouching
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class AActor*                                      Actor                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FName                                        Reason                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGbxGameSystemCoreBlueprintLibrary::STATIC_ResourceUnlockCrouching(class AActor* Actor, const class FName& Reason)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxGameSystemCoreBlueprintLibrary.ResourceUnlockCrouching");
		
		UGbxGameSystemCoreBlueprintLibrary_ResourceUnlockCrouching_Params params {};
		params.Actor = Actor;
		params.Reason = Reason;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E4D840
	 * 		Name   -> Function GbxGameSystemCore.GbxGameSystemCoreBlueprintLibrary.ResourceUnlockAIThinking
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class AActor*                                      Actor                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FName                                        Reason                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGbxGameSystemCoreBlueprintLibrary::STATIC_ResourceUnlockAIThinking(class AActor* Actor, const class FName& Reason)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxGameSystemCoreBlueprintLibrary.ResourceUnlockAIThinking");
		
		UGbxGameSystemCoreBlueprintLibrary_ResourceUnlockAIThinking_Params params {};
		params.Actor = Actor;
		params.Reason = Reason;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E4D8F0
	 * 		Name   -> Function GbxGameSystemCore.GbxGameSystemCoreBlueprintLibrary.ResourceUnlockAiming
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class AActor*                                      Actor                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FName                                        Reason                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGbxGameSystemCoreBlueprintLibrary::STATIC_ResourceUnlockAiming(class AActor* Actor, const class FName& Reason)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxGameSystemCoreBlueprintLibrary.ResourceUnlockAiming");
		
		UGbxGameSystemCoreBlueprintLibrary_ResourceUnlockAiming_Params params {};
		params.Actor = Actor;
		params.Reason = Reason;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E4D790
	 * 		Name   -> Function GbxGameSystemCore.GbxGameSystemCoreBlueprintLibrary.ResourceLockTurns
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class AActor*                                      Actor                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FName                                        Reason                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGbxGameSystemCoreBlueprintLibrary::STATIC_ResourceLockTurns(class AActor* Actor, const class FName& Reason)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxGameSystemCoreBlueprintLibrary.ResourceLockTurns");
		
		UGbxGameSystemCoreBlueprintLibrary_ResourceLockTurns_Params params {};
		params.Actor = Actor;
		params.Reason = Reason;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E4D6E0
	 * 		Name   -> Function GbxGameSystemCore.GbxGameSystemCoreBlueprintLibrary.ResourceLockTickAndRefreshBones
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class AActor*                                      Actor                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FName                                        Reason                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGbxGameSystemCoreBlueprintLibrary::STATIC_ResourceLockTickAndRefreshBones(class AActor* Actor, const class FName& Reason)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxGameSystemCoreBlueprintLibrary.ResourceLockTickAndRefreshBones");
		
		UGbxGameSystemCoreBlueprintLibrary_ResourceLockTickAndRefreshBones_Params params {};
		params.Actor = Actor;
		params.Reason = Reason;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E4D5E0
	 * 		Name   -> Function GbxGameSystemCore.GbxGameSystemCoreBlueprintLibrary.ResourceLockTargetable
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class AActor*                                      Actor                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FName                                        Reason                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bTargetable                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGbxGameSystemCoreBlueprintLibrary::STATIC_ResourceLockTargetable(class AActor* Actor, const class FName& Reason, bool bTargetable)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxGameSystemCoreBlueprintLibrary.ResourceLockTargetable");
		
		UGbxGameSystemCoreBlueprintLibrary_ResourceLockTargetable_Params params {};
		params.Actor = Actor;
		params.Reason = Reason;
		params.bTargetable = bTargetable;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E4D530
	 * 		Name   -> Function GbxGameSystemCore.GbxGameSystemCoreBlueprintLibrary.ResourceLockRotation
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class AActor*                                      Actor                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FName                                        Reason                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGbxGameSystemCoreBlueprintLibrary::STATIC_ResourceLockRotation(class AActor* Actor, const class FName& Reason)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxGameSystemCoreBlueprintLibrary.ResourceLockRotation");
		
		UGbxGameSystemCoreBlueprintLibrary_ResourceLockRotation_Params params {};
		params.Actor = Actor;
		params.Reason = Reason;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E4D480
	 * 		Name   -> Function GbxGameSystemCore.GbxGameSystemCoreBlueprintLibrary.ResourceLockPhysicsRotation
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class AActor*                                      Actor                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FName                                        Reason                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGbxGameSystemCoreBlueprintLibrary::STATIC_ResourceLockPhysicsRotation(class AActor* Actor, const class FName& Reason)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxGameSystemCoreBlueprintLibrary.ResourceLockPhysicsRotation");
		
		UGbxGameSystemCoreBlueprintLibrary_ResourceLockPhysicsRotation_Params params {};
		params.Actor = Actor;
		params.Reason = Reason;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E4D3D0
	 * 		Name   -> Function GbxGameSystemCore.GbxGameSystemCoreBlueprintLibrary.ResourceLockMovement
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class AActor*                                      Actor                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FName                                        Reason                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGbxGameSystemCoreBlueprintLibrary::STATIC_ResourceLockMovement(class AActor* Actor, const class FName& Reason)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxGameSystemCoreBlueprintLibrary.ResourceLockMovement");
		
		UGbxGameSystemCoreBlueprintLibrary_ResourceLockMovement_Params params {};
		params.Actor = Actor;
		params.Reason = Reason;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E4D320
	 * 		Name   -> Function GbxGameSystemCore.GbxGameSystemCoreBlueprintLibrary.ResourceLockMomentum
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class AActor*                                      Actor                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FName                                        Reason                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGbxGameSystemCoreBlueprintLibrary::STATIC_ResourceLockMomentum(class AActor* Actor, const class FName& Reason)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxGameSystemCoreBlueprintLibrary.ResourceLockMomentum");
		
		UGbxGameSystemCoreBlueprintLibrary_ResourceLockMomentum_Params params {};
		params.Actor = Actor;
		params.Reason = Reason;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E4D270
	 * 		Name   -> Function GbxGameSystemCore.GbxGameSystemCoreBlueprintLibrary.ResourceLockMantling
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class AActor*                                      Actor                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FName                                        Reason                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGbxGameSystemCoreBlueprintLibrary::STATIC_ResourceLockMantling(class AActor* Actor, const class FName& Reason)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxGameSystemCoreBlueprintLibrary.ResourceLockMantling");
		
		UGbxGameSystemCoreBlueprintLibrary_ResourceLockMantling_Params params {};
		params.Actor = Actor;
		params.Reason = Reason;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E4D1C0
	 * 		Name   -> Function GbxGameSystemCore.GbxGameSystemCoreBlueprintLibrary.ResourceLockLookAtTargetLocation
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class AActor*                                      Actor                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FName                                        Reason                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGbxGameSystemCoreBlueprintLibrary::STATIC_ResourceLockLookAtTargetLocation(class AActor* Actor, const class FName& Reason)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxGameSystemCoreBlueprintLibrary.ResourceLockLookAtTargetLocation");
		
		UGbxGameSystemCoreBlueprintLibrary_ResourceLockLookAtTargetLocation_Params params {};
		params.Actor = Actor;
		params.Reason = Reason;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E4D110
	 * 		Name   -> Function GbxGameSystemCore.GbxGameSystemCoreBlueprintLibrary.ResourceLockLookAt
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class AActor*                                      Actor                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FName                                        Reason                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGbxGameSystemCoreBlueprintLibrary::STATIC_ResourceLockLookAt(class AActor* Actor, const class FName& Reason)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxGameSystemCoreBlueprintLibrary.ResourceLockLookAt");
		
		UGbxGameSystemCoreBlueprintLibrary_ResourceLockLookAt_Params params {};
		params.Actor = Actor;
		params.Reason = Reason;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E4D060
	 * 		Name   -> Function GbxGameSystemCore.GbxGameSystemCoreBlueprintLibrary.ResourceLockJumping
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class AActor*                                      Actor                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FName                                        Reason                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGbxGameSystemCoreBlueprintLibrary::STATIC_ResourceLockJumping(class AActor* Actor, const class FName& Reason)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxGameSystemCoreBlueprintLibrary.ResourceLockJumping");
		
		UGbxGameSystemCoreBlueprintLibrary_ResourceLockJumping_Params params {};
		params.Actor = Actor;
		params.Reason = Reason;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E4CFB0
	 * 		Name   -> Function GbxGameSystemCore.GbxGameSystemCoreBlueprintLibrary.ResourceLockHandIk
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class AActor*                                      Actor                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FName                                        Reason                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGbxGameSystemCoreBlueprintLibrary::STATIC_ResourceLockHandIk(class AActor* Actor, const class FName& Reason)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxGameSystemCoreBlueprintLibrary.ResourceLockHandIk");
		
		UGbxGameSystemCoreBlueprintLibrary_ResourceLockHandIk_Params params {};
		params.Actor = Actor;
		params.Reason = Reason;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E4CF00
	 * 		Name   -> Function GbxGameSystemCore.GbxGameSystemCoreBlueprintLibrary.ResourceLockGod
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class AActor*                                      Actor                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FName                                        Reason                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGbxGameSystemCoreBlueprintLibrary::STATIC_ResourceLockGod(class AActor* Actor, const class FName& Reason)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxGameSystemCoreBlueprintLibrary.ResourceLockGod");
		
		UGbxGameSystemCoreBlueprintLibrary_ResourceLockGod_Params params {};
		params.Actor = Actor;
		params.Reason = Reason;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E4CE50
	 * 		Name   -> Function GbxGameSystemCore.GbxGameSystemCoreBlueprintLibrary.ResourceLockFootIkTracing
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class AActor*                                      Actor                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FName                                        Reason                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGbxGameSystemCoreBlueprintLibrary::STATIC_ResourceLockFootIkTracing(class AActor* Actor, const class FName& Reason)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxGameSystemCoreBlueprintLibrary.ResourceLockFootIkTracing");
		
		UGbxGameSystemCoreBlueprintLibrary_ResourceLockFootIkTracing_Params params {};
		params.Actor = Actor;
		params.Reason = Reason;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E4CDA0
	 * 		Name   -> Function GbxGameSystemCore.GbxGameSystemCoreBlueprintLibrary.ResourceLockFootIk
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class AActor*                                      Actor                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FName                                        Reason                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGbxGameSystemCoreBlueprintLibrary::STATIC_ResourceLockFootIk(class AActor* Actor, const class FName& Reason)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxGameSystemCoreBlueprintLibrary.ResourceLockFootIk");
		
		UGbxGameSystemCoreBlueprintLibrary_ResourceLockFootIk_Params params {};
		params.Actor = Actor;
		params.Reason = Reason;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E4CCF0
	 * 		Name   -> Function GbxGameSystemCore.GbxGameSystemCoreBlueprintLibrary.ResourceLockDodging
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class AActor*                                      Actor                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FName                                        Reason                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGbxGameSystemCoreBlueprintLibrary::STATIC_ResourceLockDodging(class AActor* Actor, const class FName& Reason)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxGameSystemCoreBlueprintLibrary.ResourceLockDodging");
		
		UGbxGameSystemCoreBlueprintLibrary_ResourceLockDodging_Params params {};
		params.Actor = Actor;
		params.Reason = Reason;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E4CC40
	 * 		Name   -> Function GbxGameSystemCore.GbxGameSystemCoreBlueprintLibrary.ResourceLockDemigod
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class AActor*                                      Actor                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FName                                        Reason                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGbxGameSystemCoreBlueprintLibrary::STATIC_ResourceLockDemigod(class AActor* Actor, const class FName& Reason)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxGameSystemCoreBlueprintLibrary.ResourceLockDemigod");
		
		UGbxGameSystemCoreBlueprintLibrary_ResourceLockDemigod_Params params {};
		params.Actor = Actor;
		params.Reason = Reason;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E4CB90
	 * 		Name   -> Function GbxGameSystemCore.GbxGameSystemCoreBlueprintLibrary.ResourceLockCrouching
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class AActor*                                      Actor                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FName                                        Reason                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGbxGameSystemCoreBlueprintLibrary::STATIC_ResourceLockCrouching(class AActor* Actor, const class FName& Reason)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxGameSystemCoreBlueprintLibrary.ResourceLockCrouching");
		
		UGbxGameSystemCoreBlueprintLibrary_ResourceLockCrouching_Params params {};
		params.Actor = Actor;
		params.Reason = Reason;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E4C9E0
	 * 		Name   -> Function GbxGameSystemCore.GbxGameSystemCoreBlueprintLibrary.ResourceLockAIThinking
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class AActor*                                      Actor                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FName                                        Reason                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bAbort                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGbxGameSystemCoreBlueprintLibrary::STATIC_ResourceLockAIThinking(class AActor* Actor, const class FName& Reason, bool bAbort)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxGameSystemCoreBlueprintLibrary.ResourceLockAIThinking");
		
		UGbxGameSystemCoreBlueprintLibrary_ResourceLockAIThinking_Params params {};
		params.Actor = Actor;
		params.Reason = Reason;
		params.bAbort = bAbort;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E4CAE0
	 * 		Name   -> Function GbxGameSystemCore.GbxGameSystemCoreBlueprintLibrary.ResourceLockAiming
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class AActor*                                      Actor                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FName                                        Reason                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGbxGameSystemCoreBlueprintLibrary::STATIC_ResourceLockAiming(class AActor* Actor, const class FName& Reason)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxGameSystemCoreBlueprintLibrary.ResourceLockAiming");
		
		UGbxGameSystemCoreBlueprintLibrary_ResourceLockAiming_Params params {};
		params.Actor = Actor;
		params.Reason = Reason;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E4C400
	 * 		Name   -> Function GbxGameSystemCore.GbxGameSystemCoreBlueprintLibrary.IsSplitScreen
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UGameInstance*                               GameInstance                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UGbxGameSystemCoreBlueprintLibrary::STATIC_IsSplitScreen(class UGameInstance* GameInstance)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxGameSystemCoreBlueprintLibrary.IsSplitScreen");
		
		UGbxGameSystemCoreBlueprintLibrary_IsSplitScreen_Params params {};
		params.GameInstance = GameInstance;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E4C380
	 * 		Name   -> Function GbxGameSystemCore.GbxGameSystemCoreBlueprintLibrary.IsPlayer
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class AActor*                                      Actor                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UGbxGameSystemCoreBlueprintLibrary::STATIC_IsPlayer(class AActor* Actor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxGameSystemCoreBlueprintLibrary.IsPlayer");
		
		UGbxGameSystemCoreBlueprintLibrary_IsPlayer_Params params {};
		params.Actor = Actor;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E4C300
	 * 		Name   -> Function GbxGameSystemCore.GbxGameSystemCoreBlueprintLibrary.IsContentCensored
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UGbxGameSystemCoreBlueprintLibrary::STATIC_IsContentCensored(class UObject* WorldContextObject)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxGameSystemCoreBlueprintLibrary.IsContentCensored");
		
		UGbxGameSystemCoreBlueprintLibrary_IsContentCensored_Params params {};
		params.WorldContextObject = WorldContextObject;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E4BEC0
	 * 		Name   -> Function GbxGameSystemCore.GbxGameSystemCoreBlueprintLibrary.HoverComponentAtActor
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class USceneComponent*                             Component                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      TargetActor                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Altitude                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Radius                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              AccelerationTime                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Speed                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Duration                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FLatentActionInfo                           LatentInfo                                                 (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UGbxGameSystemCoreBlueprintLibrary::STATIC_HoverComponentAtActor(class USceneComponent* Component, class AActor* TargetActor, float Altitude, float Radius, float AccelerationTime, float Speed, float Duration, const struct FLatentActionInfo& LatentInfo)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxGameSystemCoreBlueprintLibrary.HoverComponentAtActor");
		
		UGbxGameSystemCoreBlueprintLibrary_HoverComponentAtActor_Params params {};
		params.Component = Component;
		params.TargetActor = TargetActor;
		params.Altitude = Altitude;
		params.Radius = Radius;
		params.AccelerationTime = AccelerationTime;
		params.Speed = Speed;
		params.Duration = Duration;
		params.LatentInfo = LatentInfo;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E4BC10
	 * 		Name   -> Function GbxGameSystemCore.GbxGameSystemCoreBlueprintLibrary.GetRelativeDirection
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FRelativeDirectionData                      RelativeDirectionData                                      (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     DefaultDirection                                           (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      SourceActor                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FName                                        SourceSocketName                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      TargetActor                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FVector UGbxGameSystemCoreBlueprintLibrary::STATIC_GetRelativeDirection(const struct FRelativeDirectionData& RelativeDirectionData, const struct FVector& DefaultDirection, class AActor* SourceActor, const class FName& SourceSocketName, class AActor* TargetActor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxGameSystemCoreBlueprintLibrary.GetRelativeDirection");
		
		UGbxGameSystemCoreBlueprintLibrary_GetRelativeDirection_Params params {};
		params.RelativeDirectionData = RelativeDirectionData;
		params.DefaultDirection = DefaultDirection;
		params.SourceActor = SourceActor;
		params.SourceSocketName = SourceSocketName;
		params.TargetActor = TargetActor;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E4BA80
	 * 		Name   -> Function GbxGameSystemCore.GbxGameSystemCoreBlueprintLibrary.GetCurveFloatValue
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FRuntimeFloatCurve                          Curve                                                      (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		float                                              InTime                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	float UGbxGameSystemCoreBlueprintLibrary::STATIC_GetCurveFloatValue(const struct FRuntimeFloatCurve& Curve, float InTime)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxGameSystemCoreBlueprintLibrary.GetCurveFloatValue");
		
		UGbxGameSystemCoreBlueprintLibrary_GetCurveFloatValue_Params params {};
		params.Curve = Curve;
		params.InTime = InTime;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E4B910
	 * 		Name   -> Function GbxGameSystemCore.GbxGameSystemCoreBlueprintLibrary.GetAreAnyPlayersOverlappingActors
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		TArray<class AActor*>                              Actors                                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	bool UGbxGameSystemCoreBlueprintLibrary::STATIC_GetAreAnyPlayersOverlappingActors(class UObject* WorldContextObject, TArray<class AActor*> Actors)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxGameSystemCoreBlueprintLibrary.GetAreAnyPlayersOverlappingActors");
		
		UGbxGameSystemCoreBlueprintLibrary_GetAreAnyPlayersOverlappingActors_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.Actors = Actors;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E4B850
	 * 		Name   -> Function GbxGameSystemCore.GbxGameSystemCoreBlueprintLibrary.GetAreAnyPlayersOverlappingActor
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      Actor                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UGbxGameSystemCoreBlueprintLibrary::STATIC_GetAreAnyPlayersOverlappingActor(class UObject* WorldContextObject, class AActor* Actor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxGameSystemCoreBlueprintLibrary.GetAreAnyPlayersOverlappingActor");
		
		UGbxGameSystemCoreBlueprintLibrary_GetAreAnyPlayersOverlappingActor_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.Actor = Actor;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E4B760
	 * 		Name   -> Function GbxGameSystemCore.GbxGameSystemCoreBlueprintLibrary.GetAreAllPlayersOverlappingActors
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		TArray<class AActor*>                              Actors                                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	bool UGbxGameSystemCoreBlueprintLibrary::STATIC_GetAreAllPlayersOverlappingActors(class UObject* WorldContextObject, TArray<class AActor*> Actors)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxGameSystemCoreBlueprintLibrary.GetAreAllPlayersOverlappingActors");
		
		UGbxGameSystemCoreBlueprintLibrary_GetAreAllPlayersOverlappingActors_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.Actors = Actors;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E4B6A0
	 * 		Name   -> Function GbxGameSystemCore.GbxGameSystemCoreBlueprintLibrary.GetAreAllPlayersOverlappingActor
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      Actor                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UGbxGameSystemCoreBlueprintLibrary::STATIC_GetAreAllPlayersOverlappingActor(class UObject* WorldContextObject, class AActor* Actor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxGameSystemCoreBlueprintLibrary.GetAreAllPlayersOverlappingActor");
		
		UGbxGameSystemCoreBlueprintLibrary_GetAreAllPlayersOverlappingActor_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.Actor = Actor;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E4B490
	 * 		Name   -> Function GbxGameSystemCore.GbxGameSystemCoreBlueprintLibrary.GetActorListTrimmedToBestCluster
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		TArray<class AActor*>                              OutputActors                                               (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     ClusterMidpoint                                            (Parm, OutParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		TArray<class AActor*>                              InputActors                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      SourceActor                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              ClusterRadius                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bPreferClusterContainingCurrentTarget                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGbxGameSystemCoreBlueprintLibrary::STATIC_GetActorListTrimmedToBestCluster(TArray<class AActor*>* OutputActors, struct FVector* ClusterMidpoint, TArray<class AActor*> InputActors, class AActor* SourceActor, float ClusterRadius, bool bPreferClusterContainingCurrentTarget)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxGameSystemCoreBlueprintLibrary.GetActorListTrimmedToBestCluster");
		
		UGbxGameSystemCoreBlueprintLibrary_GetActorListTrimmedToBestCluster_Params params {};
		params.InputActors = InputActors;
		params.SourceActor = SourceActor;
		params.ClusterRadius = ClusterRadius;
		params.bPreferClusterContainingCurrentTarget = bPreferClusterContainingCurrentTarget;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutputActors != nullptr)
			*OutputActors = params.OutputActors;
		if (ClusterMidpoint != nullptr)
			*ClusterMidpoint = params.ClusterMidpoint;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E4B1F0
	 * 		Name   -> Function GbxGameSystemCore.GbxGameSystemCoreBlueprintLibrary.BranchOnIsPlayer
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		class AActor*                                      Actor                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EIsPlayerExecOutput                                Branches                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGbxGameSystemCoreBlueprintLibrary::STATIC_BranchOnIsPlayer(class AActor* Actor, EIsPlayerExecOutput* Branches)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxGameSystemCoreBlueprintLibrary.BranchOnIsPlayer");
		
		UGbxGameSystemCoreBlueprintLibrary_BranchOnIsPlayer_Params params {};
		params.Actor = Actor;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (Branches != nullptr)
			*Branches = params.Branches;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E4B130
	 * 		Name   -> Function GbxGameSystemCore.GbxGameSystemCoreBlueprintLibrary.BranchOnIsAutonomous
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		class AActor*                                      Actor                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EIsAutonomousOuput                                 Branches                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGbxGameSystemCoreBlueprintLibrary::STATIC_BranchOnIsAutonomous(class AActor* Actor, EIsAutonomousOuput* Branches)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxGameSystemCoreBlueprintLibrary.BranchOnIsAutonomous");
		
		UGbxGameSystemCoreBlueprintLibrary_BranchOnIsAutonomous_Params params {};
		params.Actor = Actor;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (Branches != nullptr)
			*Branches = params.Branches;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E4B000
	 * 		Name   -> Function GbxGameSystemCore.GbxGameSystemCoreBlueprintLibrary.AreAnyPlayersOverlappingActors
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		TArray<class AActor*>                              Actors                                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		EPlayersOverlappingActorOutput                     Branches                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGbxGameSystemCoreBlueprintLibrary::STATIC_AreAnyPlayersOverlappingActors(class UObject* WorldContextObject, TArray<class AActor*> Actors, EPlayersOverlappingActorOutput* Branches)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxGameSystemCoreBlueprintLibrary.AreAnyPlayersOverlappingActors");
		
		UGbxGameSystemCoreBlueprintLibrary_AreAnyPlayersOverlappingActors_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.Actors = Actors;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (Branches != nullptr)
			*Branches = params.Branches;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E4AF00
	 * 		Name   -> Function GbxGameSystemCore.GbxGameSystemCoreBlueprintLibrary.AreAnyPlayersOverlappingActor
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      Actor                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EPlayersOverlappingActorOutput                     Branches                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGbxGameSystemCoreBlueprintLibrary::STATIC_AreAnyPlayersOverlappingActor(class UObject* WorldContextObject, class AActor* Actor, EPlayersOverlappingActorOutput* Branches)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxGameSystemCoreBlueprintLibrary.AreAnyPlayersOverlappingActor");
		
		UGbxGameSystemCoreBlueprintLibrary_AreAnyPlayersOverlappingActor_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.Actor = Actor;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (Branches != nullptr)
			*Branches = params.Branches;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E4ADD0
	 * 		Name   -> Function GbxGameSystemCore.GbxGameSystemCoreBlueprintLibrary.AreAnyPlayersInVolume
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		TArray<class AVolume*>                             Volumes                                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		EPlayersInVolumeOutput                             Branches                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGbxGameSystemCoreBlueprintLibrary::STATIC_AreAnyPlayersInVolume(class UObject* WorldContextObject, TArray<class AVolume*> Volumes, EPlayersInVolumeOutput* Branches)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxGameSystemCoreBlueprintLibrary.AreAnyPlayersInVolume");
		
		UGbxGameSystemCoreBlueprintLibrary_AreAnyPlayersInVolume_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.Volumes = Volumes;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (Branches != nullptr)
			*Branches = params.Branches;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E4ACA0
	 * 		Name   -> Function GbxGameSystemCore.GbxGameSystemCoreBlueprintLibrary.AreAllPlayersOverlappingActors
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		TArray<class AActor*>                              Actors                                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		EPlayersOverlappingActorOutput                     Branches                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGbxGameSystemCoreBlueprintLibrary::STATIC_AreAllPlayersOverlappingActors(class UObject* WorldContextObject, TArray<class AActor*> Actors, EPlayersOverlappingActorOutput* Branches)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxGameSystemCoreBlueprintLibrary.AreAllPlayersOverlappingActors");
		
		UGbxGameSystemCoreBlueprintLibrary_AreAllPlayersOverlappingActors_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.Actors = Actors;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (Branches != nullptr)
			*Branches = params.Branches;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E4ABA0
	 * 		Name   -> Function GbxGameSystemCore.GbxGameSystemCoreBlueprintLibrary.AreAllPlayersOverlappingActor
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      Actor                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EPlayersOverlappingActorOutput                     Branches                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGbxGameSystemCoreBlueprintLibrary::STATIC_AreAllPlayersOverlappingActor(class UObject* WorldContextObject, class AActor* Actor, EPlayersOverlappingActorOutput* Branches)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxGameSystemCoreBlueprintLibrary.AreAllPlayersOverlappingActor");
		
		UGbxGameSystemCoreBlueprintLibrary_AreAllPlayersOverlappingActor_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.Actor = Actor;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (Branches != nullptr)
			*Branches = params.Branches;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E4AA70
	 * 		Name   -> Function GbxGameSystemCore.GbxGameSystemCoreBlueprintLibrary.AreAllPlayersInVolume
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		TArray<class AVolume*>                             Volumes                                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		EPlayersInVolumeOutput                             Branches                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGbxGameSystemCoreBlueprintLibrary::STATIC_AreAllPlayersInVolume(class UObject* WorldContextObject, TArray<class AVolume*> Volumes, EPlayersInVolumeOutput* Branches)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxGameSystemCoreBlueprintLibrary.AreAllPlayersInVolume");
		
		UGbxGameSystemCoreBlueprintLibrary_AreAllPlayersInVolume_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.Volumes = Volumes;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (Branches != nullptr)
			*Branches = params.Branches;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGbxGameSystemCoreBlueprintLibrary.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGbxGameSystemCoreBlueprintLibrary::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.GbxGameSystemCoreBlueprintLibrary");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGbxHUDFeedbackData.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGbxHUDFeedbackData::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.GbxHUDFeedbackData");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGbxInventoryCategoryData.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGbxInventoryCategoryData::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.GbxInventoryCategoryData");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGbxLevelSequenceControllableInterface.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGbxLevelSequenceControllableInterface::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.GbxLevelSequenceControllableInterface");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGbxMediaData.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGbxMediaData::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.GbxMediaData");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E55620
	 * 		Name   -> Function GbxGameSystemCore.GbxMediaManager.OnMovieMediaOpenFailed
	 * 		Flags  -> (Final, Native, Private)
	 * Parameters:
	 * 		class FString                                      DeviceUrl                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGbxMediaManager::OnMovieMediaOpenFailed(const class FString& DeviceUrl)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxMediaManager.OnMovieMediaOpenFailed");
		
		UGbxMediaManager_OnMovieMediaOpenFailed_Params params {};
		params.DeviceUrl = DeviceUrl;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E55600
	 * 		Name   -> Function GbxGameSystemCore.GbxMediaManager.OnMovieMediaClosed
	 * 		Flags  -> (Final, Native, Private)
	 */
	void UGbxMediaManager::OnMovieMediaClosed()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxMediaManager.OnMovieMediaClosed");
		
		UGbxMediaManager_OnMovieMediaClosed_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E55600
	 * 		Name   -> Function GbxGameSystemCore.GbxMediaManager.OnMovieEndReached
	 * 		Flags  -> (Final, Native, Private)
	 */
	void UGbxMediaManager::OnMovieEndReached()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxMediaManager.OnMovieEndReached");
		
		UGbxMediaManager_OnMovieEndReached_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E54BF0
	 * 		Name   -> Function GbxGameSystemCore.GbxMediaManager.GbxPlayMovie
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UGbxMediaData*                               InMediaData                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UMediaPlayer* UGbxMediaManager::STATIC_GbxPlayMovie(class UObject* WorldContextObject, class UGbxMediaData* InMediaData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxMediaManager.GbxPlayMovie");
		
		UGbxMediaManager_GbxPlayMovie_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.InMediaData = InMediaData;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGbxMediaManager.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGbxMediaManager::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.GbxMediaManager");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E559C0
	 * 		Name   -> Function GbxGameSystemCore.GbxNavAvoidanceInterface.SetObstacleAvoidanceLock
	 * 		Flags  -> (Native, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bDisable                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FName                                        Reason                                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGbxNavAvoidanceInterface::SetObstacleAvoidanceLock(bool bDisable, const class FName& Reason)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxNavAvoidanceInterface.SetObstacleAvoidanceLock");
		
		UGbxNavAvoidanceInterface_SetObstacleAvoidanceLock_Params params {};
		params.bDisable = bDisable;
		params.Reason = Reason;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGbxNavAvoidanceInterface.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGbxNavAvoidanceInterface::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.GbxNavAvoidanceInterface");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AGbxPainCausingVolume.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AGbxPainCausingVolume::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.GbxPainCausingVolume");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E554B0
	 * 		Name   -> Function GbxGameSystemCore.GbxParamExt.IsValueInRangePure
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FGbxParam                                   Param                                                      (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 * 		float                                              Value                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UObject*                                     Context                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UGbxParamExt::STATIC_IsValueInRangePure(const struct FGbxParam& Param, float Value, class UObject* Context)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxParamExt.IsValueInRangePure");
		
		UGbxParamExt_IsValueInRangePure_Params params {};
		params.Param = Param;
		params.Value = Value;
		params.Context = Context;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E554B0
	 * 		Name   -> Function GbxGameSystemCore.GbxParamExt.IsValueInRange
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		struct FGbxParam                                   Param                                                      (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 * 		float                                              Value                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UObject*                                     Context                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UGbxParamExt::STATIC_IsValueInRange(const struct FGbxParam& Param, float Value, class UObject* Context)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxParamExt.IsValueInRange");
		
		UGbxParamExt_IsValueInRange_Params params {};
		params.Param = Param;
		params.Value = Value;
		params.Context = Context;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E55090
	 * 		Name   -> Function GbxGameSystemCore.GbxParamExt.GetParamPropertyDescription
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms)
	 * Parameters:
	 * 		struct FGbxParam                                   Param                                                      (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 * 		class UProperty*                                   Property                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class FString UGbxParamExt::STATIC_GetParamPropertyDescription(const struct FGbxParam& Param, class UProperty* Property)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxParamExt.GetParamPropertyDescription");
		
		UGbxParamExt_GetParamPropertyDescription_Params params {};
		params.Param = Param;
		params.Property = Property;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E54F90
	 * 		Name   -> Function GbxGameSystemCore.GbxParamExt.GetParamDescriptionText
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FGbxParam                                   Param                                                      (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	class FText UGbxParamExt::STATIC_GetParamDescriptionText(const struct FGbxParam& Param)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxParamExt.GetParamDescriptionText");
		
		UGbxParamExt_GetParamDescriptionText_Params params {};
		params.Param = Param;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E54EB0
	 * 		Name   -> Function GbxGameSystemCore.GbxParamExt.GetParamDescription
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FGbxParam                                   Param                                                      (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	class FString UGbxParamExt::STATIC_GetParamDescription(const struct FGbxParam& Param)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxParamExt.GetParamDescription");
		
		UGbxParamExt_GetParamDescription_Params params {};
		params.Param = Param;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E54DB0
	 * 		Name   -> Function GbxGameSystemCore.GbxParamExt.GetNamedParamDescriptionText
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FGbxNamedParam                              Param                                                      (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	class FText UGbxParamExt::STATIC_GetNamedParamDescriptionText(const struct FGbxNamedParam& Param)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxParamExt.GetNamedParamDescriptionText");
		
		UGbxParamExt_GetNamedParamDescriptionText_Params params {};
		params.Param = Param;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E54CD0
	 * 		Name   -> Function GbxGameSystemCore.GbxParamExt.GetNamedParamDescription
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FGbxNamedParam                              Param                                                      (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	class FString UGbxParamExt::STATIC_GetNamedParamDescription(const struct FGbxNamedParam& Param)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxParamExt.GetNamedParamDescription");
		
		UGbxParamExt_GetNamedParamDescription_Params params {};
		params.Param = Param;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E548B0
	 * 		Name   -> Function GbxGameSystemCore.GbxParamExt.EvaluatePure
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FGbxParam                                   Param                                                      (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 * 		class UObject*                                     Context                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	float UGbxParamExt::STATIC_EvaluatePure(const struct FGbxParam& Param, class UObject* Context)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxParamExt.EvaluatePure");
		
		UGbxParamExt_EvaluatePure_Params params {};
		params.Param = Param;
		params.Context = Context;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E54AD0
	 * 		Name   -> Function GbxGameSystemCore.GbxParamExt.EvaluateIntPure
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FGbxParam                                   Param                                                      (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 * 		class UObject*                                     Context                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	float UGbxParamExt::STATIC_EvaluateIntPure(const struct FGbxParam& Param, class UObject* Context)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxParamExt.EvaluateIntPure");
		
		UGbxParamExt_EvaluateIntPure_Params params {};
		params.Param = Param;
		params.Context = Context;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E54AD0
	 * 		Name   -> Function GbxGameSystemCore.GbxParamExt.EvaluateInt
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		struct FGbxParam                                   Param                                                      (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 * 		class UObject*                                     Context                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	float UGbxParamExt::STATIC_EvaluateInt(const struct FGbxParam& Param, class UObject* Context)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxParamExt.EvaluateInt");
		
		UGbxParamExt_EvaluateInt_Params params {};
		params.Param = Param;
		params.Context = Context;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E549C0
	 * 		Name   -> Function GbxGameSystemCore.GbxParamExt.EvaluateBoolPure
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FGbxParam                                   Param                                                      (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 * 		class UObject*                                     Context                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UGbxParamExt::STATIC_EvaluateBoolPure(const struct FGbxParam& Param, class UObject* Context)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxParamExt.EvaluateBoolPure");
		
		UGbxParamExt_EvaluateBoolPure_Params params {};
		params.Param = Param;
		params.Context = Context;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E549C0
	 * 		Name   -> Function GbxGameSystemCore.GbxParamExt.EvaluateBool
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		struct FGbxParam                                   Param                                                      (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 * 		class UObject*                                     Context                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UGbxParamExt::STATIC_EvaluateBool(const struct FGbxParam& Param, class UObject* Context)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxParamExt.EvaluateBool");
		
		UGbxParamExt_EvaluateBool_Params params {};
		params.Param = Param;
		params.Context = Context;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E548B0
	 * 		Name   -> Function GbxGameSystemCore.GbxParamExt.Evaluate
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		struct FGbxParam                                   Param                                                      (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 * 		class UObject*                                     Context                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	float UGbxParamExt::STATIC_Evaluate(const struct FGbxParam& Param, class UObject* Context)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxParamExt.Evaluate");
		
		UGbxParamExt_Evaluate_Params params {};
		params.Param = Param;
		params.Context = Context;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGbxParamExt.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGbxParamExt::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.GbxParamExt");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGbxPerceptionComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGbxPerceptionComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.GbxPerceptionComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGbxPhysicsCollisionHandler.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGbxPhysicsCollisionHandler::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.GbxPhysicsCollisionHandler");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E55B10
	 * 		Name   -> Function GbxGameSystemCore.GbxPhysicsSettings.StaticSetRigidBodySimulationInteractability
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class USkeletalMeshComponent*                      Comp                                                       (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bAesthetic                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FName                                        BodyName                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGbxPhysicsSettings::STATIC_StaticSetRigidBodySimulationInteractability(class USkeletalMeshComponent* Comp, bool bAesthetic, const class FName& BodyName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxPhysicsSettings.StaticSetRigidBodySimulationInteractability");
		
		UGbxPhysicsSettings_StaticSetRigidBodySimulationInteractability_Params params {};
		params.Comp = Comp;
		params.bAesthetic = bAesthetic;
		params.BodyName = BodyName;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGbxPhysicsSettings.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGbxPhysicsSettings::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.GbxPhysicsSettings");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E58E10
	 * 		Name   -> Function GbxGameSystemCore.GbxQueryManager.NotifyAIHotSpotListChangedFor
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		class AActor*                                      OwnerActor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGbxQueryManager::NotifyAIHotSpotListChangedFor(class AActor* OwnerActor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxQueryManager.NotifyAIHotSpotListChangedFor");
		
		UGbxQueryManager_NotifyAIHotSpotListChangedFor_Params params {};
		params.OwnerActor = OwnerActor;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGbxQueryManager.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGbxQueryManager::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.GbxQueryManager");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E588D0
	 * 		Name   -> Function GbxGameSystemCore.GbxSignificanceSettings.EnumerateSignificanceEvents
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms)
	 * Parameters:
	 * 		TArray<class FName>                                OutEvents                                                  (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	 */
	void UGbxSignificanceSettings::STATIC_EnumerateSignificanceEvents(TArray<class FName>* OutEvents)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxSignificanceSettings.EnumerateSignificanceEvents");
		
		UGbxSignificanceSettings_EnumerateSignificanceEvents_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutEvents != nullptr)
			*OutEvents = params.OutEvents;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGbxSignificanceSettings.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGbxSignificanceSettings::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.GbxSignificanceSettings");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E59C10
	 * 		Name   -> Function GbxGameSystemCore.GbxSimpleMotionLibrary.UpdateVectorMotion
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		float                                              DeltaTime                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     CurrentValue                                               (Parm, OutParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              ControlValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FSimpleMotionState                          Data                                                       (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		float                                              SpeedScale                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     TargetValue                                                (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FSimpleMotionInstanceState                  State                                                      (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UGbxSimpleMotionLibrary::STATIC_UpdateVectorMotion(float DeltaTime, struct FVector* CurrentValue, float ControlValue, const struct FSimpleMotionState& Data, float SpeedScale, const struct FVector& TargetValue, struct FSimpleMotionInstanceState* State)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxSimpleMotionLibrary.UpdateVectorMotion");
		
		UGbxSimpleMotionLibrary_UpdateVectorMotion_Params params {};
		params.DeltaTime = DeltaTime;
		params.ControlValue = ControlValue;
		params.Data = Data;
		params.SpeedScale = SpeedScale;
		params.TargetValue = TargetValue;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (CurrentValue != nullptr)
			*CurrentValue = params.CurrentValue;
		if (State != nullptr)
			*State = params.State;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E59980
	 * 		Name   -> Function GbxGameSystemCore.GbxSimpleMotionLibrary.UpdateRotatorMotion
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		float                                              DeltaTime                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FRotator                                    CurrentValue                                               (Parm, OutParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		float                                              ControlValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FSimpleMotionState                          Data                                                       (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		float                                              SpeedScale                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FRotator                                    TargetValue                                                (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		bool                                               bShortestRotation                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FSimpleMotionInstanceState                  State                                                      (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UGbxSimpleMotionLibrary::STATIC_UpdateRotatorMotion(float DeltaTime, struct FRotator* CurrentValue, float ControlValue, const struct FSimpleMotionState& Data, float SpeedScale, const struct FRotator& TargetValue, bool bShortestRotation, struct FSimpleMotionInstanceState* State)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxSimpleMotionLibrary.UpdateRotatorMotion");
		
		UGbxSimpleMotionLibrary_UpdateRotatorMotion_Params params {};
		params.DeltaTime = DeltaTime;
		params.ControlValue = ControlValue;
		params.Data = Data;
		params.SpeedScale = SpeedScale;
		params.TargetValue = TargetValue;
		params.bShortestRotation = bShortestRotation;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (CurrentValue != nullptr)
			*CurrentValue = params.CurrentValue;
		if (State != nullptr)
			*State = params.State;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E59740
	 * 		Name   -> Function GbxGameSystemCore.GbxSimpleMotionLibrary.UpdateFloatMotion
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		float                                              DeltaTime                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              CurrentValue                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              ControlValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FSimpleMotionState                          Data                                                       (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		float                                              SpeedScale                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              TargetValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FSimpleMotionInstanceState                  State                                                      (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UGbxSimpleMotionLibrary::STATIC_UpdateFloatMotion(float DeltaTime, float* CurrentValue, float ControlValue, const struct FSimpleMotionState& Data, float SpeedScale, float TargetValue, struct FSimpleMotionInstanceState* State)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxSimpleMotionLibrary.UpdateFloatMotion");
		
		UGbxSimpleMotionLibrary_UpdateFloatMotion_Params params {};
		params.DeltaTime = DeltaTime;
		params.ControlValue = ControlValue;
		params.Data = Data;
		params.SpeedScale = SpeedScale;
		params.TargetValue = TargetValue;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (CurrentValue != nullptr)
			*CurrentValue = params.CurrentValue;
		if (State != nullptr)
			*State = params.State;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E59520
	 * 		Name   -> Function GbxGameSystemCore.GbxSimpleMotionLibrary.TeleportVectorMotion
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FVector                                     CurrentValue                                               (Parm, OutParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              ControlValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FSimpleMotionState                          Data                                                       (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		float                                              SpeedScale                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     TargetValue                                                (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FSimpleMotionInstanceState                  State                                                      (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UGbxSimpleMotionLibrary::STATIC_TeleportVectorMotion(struct FVector* CurrentValue, float ControlValue, const struct FSimpleMotionState& Data, float SpeedScale, const struct FVector& TargetValue, struct FSimpleMotionInstanceState* State)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxSimpleMotionLibrary.TeleportVectorMotion");
		
		UGbxSimpleMotionLibrary_TeleportVectorMotion_Params params {};
		params.ControlValue = ControlValue;
		params.Data = Data;
		params.SpeedScale = SpeedScale;
		params.TargetValue = TargetValue;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (CurrentValue != nullptr)
			*CurrentValue = params.CurrentValue;
		if (State != nullptr)
			*State = params.State;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E59520
	 * 		Name   -> Function GbxGameSystemCore.GbxSimpleMotionLibrary.TeleportRotatorMotion
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FRotator                                    CurrentValue                                               (Parm, OutParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		float                                              ControlValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FSimpleMotionState                          Data                                                       (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		float                                              SpeedScale                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FRotator                                    TargetValue                                                (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		struct FSimpleMotionInstanceState                  State                                                      (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UGbxSimpleMotionLibrary::STATIC_TeleportRotatorMotion(struct FRotator* CurrentValue, float ControlValue, const struct FSimpleMotionState& Data, float SpeedScale, const struct FRotator& TargetValue, struct FSimpleMotionInstanceState* State)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxSimpleMotionLibrary.TeleportRotatorMotion");
		
		UGbxSimpleMotionLibrary_TeleportRotatorMotion_Params params {};
		params.ControlValue = ControlValue;
		params.Data = Data;
		params.SpeedScale = SpeedScale;
		params.TargetValue = TargetValue;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (CurrentValue != nullptr)
			*CurrentValue = params.CurrentValue;
		if (State != nullptr)
			*State = params.State;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E59330
	 * 		Name   -> Function GbxGameSystemCore.GbxSimpleMotionLibrary.TeleportFloatMotion
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		float                                              CurrentValue                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              ControlValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FSimpleMotionState                          Data                                                       (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		float                                              SpeedScale                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              TargetValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FSimpleMotionInstanceState                  State                                                      (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UGbxSimpleMotionLibrary::STATIC_TeleportFloatMotion(float* CurrentValue, float ControlValue, const struct FSimpleMotionState& Data, float SpeedScale, float TargetValue, struct FSimpleMotionInstanceState* State)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxSimpleMotionLibrary.TeleportFloatMotion");
		
		UGbxSimpleMotionLibrary_TeleportFloatMotion_Params params {};
		params.ControlValue = ControlValue;
		params.Data = Data;
		params.SpeedScale = SpeedScale;
		params.TargetValue = TargetValue;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (CurrentValue != nullptr)
			*CurrentValue = params.CurrentValue;
		if (State != nullptr)
			*State = params.State;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E58ED0
	 * 		Name   -> Function GbxGameSystemCore.GbxSimpleMotionLibrary.ResetMotionState
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		struct FSimpleMotionInstanceState                  State                                                      (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UGbxSimpleMotionLibrary::STATIC_ResetMotionState(struct FSimpleMotionInstanceState* State)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxSimpleMotionLibrary.ResetMotionState");
		
		UGbxSimpleMotionLibrary_ResetMotionState_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (State != nullptr)
			*State = params.State;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGbxSimpleMotionLibrary.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGbxSimpleMotionLibrary::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.GbxSimpleMotionLibrary");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AGbxSkeletalMeshActor.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AGbxSkeletalMeshActor::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.GbxSkeletalMeshActor");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGbxStaticMeshComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGbxStaticMeshComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.GbxStaticMeshComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGbxSubtitleManagerInterface.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGbxSubtitleManagerInterface::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.GbxSubtitleManagerInterface");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGbxThreatSystemInterface.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGbxThreatSystemInterface::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.GbxThreatSystemInterface");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGbxUIFormattableParameter.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGbxUIFormattableParameter::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.GbxUIFormattableParameter");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E5DCB0
	 * 		Name   -> Function GbxGameSystemCore.GbxUIName.GetFormattedText
	 * 		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	class FText UGbxUIName::GetFormattedText()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GbxUIName.GetFormattedText");
		
		UGbxUIName_GetFormattedText_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGbxUIName.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGbxUIName::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.GbxUIName");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGestaltPartData.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGestaltPartData::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.GestaltPartData");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007A5960
	 * 		Name   -> Function GbxGameSystemCore.GestaltPartData_Mesh.EnumerateGestaltMeshPartNames
	 * 		Flags  -> (Final, Native, Private, HasOutParms, Const)
	 * Parameters:
	 * 		TArray<class FName>                                OutPartNameList                                            (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	 */
	void UGestaltPartData_Mesh::EnumerateGestaltMeshPartNames(TArray<class FName>* OutPartNameList)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GestaltPartData_Mesh.EnumerateGestaltMeshPartNames");
		
		UGestaltPartData_Mesh_EnumerateGestaltMeshPartNames_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutPartNameList != nullptr)
			*OutPartNameList = params.OutPartNameList;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGestaltPartData_Mesh.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGestaltPartData_Mesh::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.GestaltPartData_Mesh");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGestaltPartData_Random.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGestaltPartData_Random::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.GestaltPartData_Random");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGestaltPartListData.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGestaltPartListData::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.GestaltPartListData");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGlobalBoneModifyProfileState.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGlobalBoneModifyProfileState::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.GlobalBoneModifyProfileState");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGlobalBoneModifyProfile.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGlobalBoneModifyProfile::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.GlobalBoneModifyProfile");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E5E180
	 * 		Name   -> Function GbxGameSystemCore.GlobalBoneModBlueprintLibrary.K2_SetGBMP
	 * 		Flags  -> (Final, Native, Static, Private, BlueprintCallable)
	 * Parameters:
	 * 		class UGlobalBoneModifyProfileState*               State                                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bEnabled                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGlobalBoneModBlueprintLibrary::STATIC_K2_SetGBMP(class UGlobalBoneModifyProfileState* State, bool bEnabled)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.GlobalBoneModBlueprintLibrary.K2_SetGBMP");
		
		UGlobalBoneModBlueprintLibrary_K2_SetGBMP_Params params {};
		params.State = State;
		params.bEnabled = bEnabled;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGlobalBoneModBlueprintLibrary.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGlobalBoneModBlueprintLibrary::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.GlobalBoneModBlueprintLibrary");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AGravityOverrideVolume.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AGravityOverrideVolume::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.GravityOverrideVolume");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UHealthResourcePoolModifierAttributeValueResolver.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UHealthResourcePoolModifierAttributeValueResolver::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.HealthResourcePoolModifierAttributeValueResolver");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UHealthTypeData.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UHealthTypeData::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.HealthTypeData");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E5E8C0
	 * 		Name   -> Function GbxGameSystemCore.HitReactionBlueprintLibrary.SetHitReactionData
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class AActor*                                      Actor                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UHitReactionData*                            HitReactionData                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UHitReactionBlueprintLibrary::STATIC_SetHitReactionData(class AActor* Actor, class UHitReactionData* HitReactionData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.HitReactionBlueprintLibrary.SetHitReactionData");
		
		UHitReactionBlueprintLibrary_SetHitReactionData_Params params {};
		params.Actor = Actor;
		params.HitReactionData = HitReactionData;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E5E6E0
	 * 		Name   -> Function GbxGameSystemCore.HitReactionBlueprintLibrary.ScriptHitReaction
	 * 		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		class AActor*                                      Actor                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      Causer                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UHitReactionTag*                             Tag                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     LocalHitDirection                                          (Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FName                                        BoneName                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FForceSelection                             Force                                                      (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UHitReactionBlueprintLibrary::STATIC_ScriptHitReaction(class AActor* Actor, class AActor* Causer, class UHitReactionTag* Tag, const struct FVector& LocalHitDirection, const class FName& BoneName, const struct FForceSelection& Force)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.HitReactionBlueprintLibrary.ScriptHitReaction");
		
		UHitReactionBlueprintLibrary_ScriptHitReaction_Params params {};
		params.Actor = Actor;
		params.Causer = Causer;
		params.Tag = Tag;
		params.LocalHitDirection = LocalHitDirection;
		params.BoneName = BoneName;
		params.Force = Force;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E5E500
	 * 		Name   -> Function GbxGameSystemCore.HitReactionBlueprintLibrary.ScriptDeath
	 * 		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		class AActor*                                      Actor                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      Causer                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UHitReactionTag*                             Tag                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     LocalHitDirection                                          (Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FName                                        BoneName                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FForceSelection                             Force                                                      (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UHitReactionBlueprintLibrary::STATIC_ScriptDeath(class AActor* Actor, class AActor* Causer, class UHitReactionTag* Tag, const struct FVector& LocalHitDirection, const class FName& BoneName, const struct FForceSelection& Force)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.HitReactionBlueprintLibrary.ScriptDeath");
		
		UHitReactionBlueprintLibrary_ScriptDeath_Params params {};
		params.Actor = Actor;
		params.Causer = Causer;
		params.Tag = Tag;
		params.LocalHitDirection = LocalHitDirection;
		params.BoneName = BoneName;
		params.Force = Force;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E5E450
	 * 		Name   -> Function GbxGameSystemCore.HitReactionBlueprintLibrary.ResourceUnlockHitReactions
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class AActor*                                      Actor                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FName                                        Reason                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UHitReactionBlueprintLibrary::STATIC_ResourceUnlockHitReactions(class AActor* Actor, const class FName& Reason)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.HitReactionBlueprintLibrary.ResourceUnlockHitReactions");
		
		UHitReactionBlueprintLibrary_ResourceUnlockHitReactions_Params params {};
		params.Actor = Actor;
		params.Reason = Reason;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E5E3A0
	 * 		Name   -> Function GbxGameSystemCore.HitReactionBlueprintLibrary.ResourceLockHitReactions
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class AActor*                                      Actor                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FName                                        Reason                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UHitReactionBlueprintLibrary::STATIC_ResourceLockHitReactions(class AActor* Actor, const class FName& Reason)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.HitReactionBlueprintLibrary.ResourceLockHitReactions");
		
		UHitReactionBlueprintLibrary_ResourceLockHitReactions_Params params {};
		params.Actor = Actor;
		params.Reason = Reason;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E5E2F0
	 * 		Name   -> Function GbxGameSystemCore.HitReactionBlueprintLibrary.RemoveHitReactionLiveLayer
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class AActor*                                      Actor                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UClass*                                      Layer                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UHitReactionBlueprintLibrary::STATIC_RemoveHitReactionLiveLayer(class AActor* Actor, class UClass* Layer)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.HitReactionBlueprintLibrary.RemoveHitReactionLiveLayer");
		
		UHitReactionBlueprintLibrary_RemoveHitReactionLiveLayer_Params params {};
		params.Actor = Actor;
		params.Layer = Layer;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E5E240
	 * 		Name   -> Function GbxGameSystemCore.HitReactionBlueprintLibrary.RemoveHitReactionDeathLayer
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class AActor*                                      Actor                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UClass*                                      Layer                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UHitReactionBlueprintLibrary::STATIC_RemoveHitReactionDeathLayer(class AActor* Actor, class UClass* Layer)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.HitReactionBlueprintLibrary.RemoveHitReactionDeathLayer");
		
		UHitReactionBlueprintLibrary_RemoveHitReactionDeathLayer_Params params {};
		params.Actor = Actor;
		params.Layer = Layer;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E5E0F0
	 * 		Name   -> Function GbxGameSystemCore.HitReactionBlueprintLibrary.K2_GetHitLocationFromAction
	 * 		Flags  -> (Final, Native, Static, Private, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class UGbxAction*                                  Action                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FVector UHitReactionBlueprintLibrary::STATIC_K2_GetHitLocationFromAction(class UGbxAction* Action)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.HitReactionBlueprintLibrary.K2_GetHitLocationFromAction");
		
		UHitReactionBlueprintLibrary_K2_GetHitLocationFromAction_Params params {};
		params.Action = Action;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E5E010
	 * 		Name   -> Function GbxGameSystemCore.HitReactionBlueprintLibrary.K2_GetHitDirectionFromAction
	 * 		Flags  -> (Final, Native, Static, Private, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class UGbxAction*                                  Action                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bLocalSpace                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FVector UHitReactionBlueprintLibrary::STATIC_K2_GetHitDirectionFromAction(class UGbxAction* Action, bool bLocalSpace)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.HitReactionBlueprintLibrary.K2_GetHitDirectionFromAction");
		
		UHitReactionBlueprintLibrary_K2_GetHitDirectionFromAction_Params params {};
		params.Action = Action;
		params.bLocalSpace = bLocalSpace;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E5DF90
	 * 		Name   -> Function GbxGameSystemCore.HitReactionBlueprintLibrary.K2_GetHitCauserFromAction
	 * 		Flags  -> (Final, Native, Static, Private, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class UGbxAction*                                  Action                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UObject* UHitReactionBlueprintLibrary::STATIC_K2_GetHitCauserFromAction(class UGbxAction* Action)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.HitReactionBlueprintLibrary.K2_GetHitCauserFromAction");
		
		UHitReactionBlueprintLibrary_K2_GetHitCauserFromAction_Params params {};
		params.Action = Action;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E5DF00
	 * 		Name   -> Function GbxGameSystemCore.HitReactionBlueprintLibrary.K2_GetHealthPercentFromAction
	 * 		Flags  -> (Final, Native, Static, Private, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class UGbxAction*                                  Action                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	float UHitReactionBlueprintLibrary::STATIC_K2_GetHealthPercentFromAction(class UGbxAction* Action)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.HitReactionBlueprintLibrary.K2_GetHealthPercentFromAction");
		
		UHitReactionBlueprintLibrary_K2_GetHealthPercentFromAction_Params params {};
		params.Action = Action;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E5DE70
	 * 		Name   -> Function GbxGameSystemCore.HitReactionBlueprintLibrary.K2_GetForceFromAction
	 * 		Flags  -> (Final, Native, Static, Private, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class UGbxAction*                                  Action                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	float UHitReactionBlueprintLibrary::STATIC_K2_GetForceFromAction(class UGbxAction* Action)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.HitReactionBlueprintLibrary.K2_GetForceFromAction");
		
		UHitReactionBlueprintLibrary_K2_GetForceFromAction_Params params {};
		params.Action = Action;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E5DDF0
	 * 		Name   -> Function GbxGameSystemCore.HitReactionBlueprintLibrary.K2_GetBoneIndexFromAction
	 * 		Flags  -> (Final, Native, Static, Private, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class UGbxAction*                                  Action                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	int32_t UHitReactionBlueprintLibrary::STATIC_K2_GetBoneIndexFromAction(class UGbxAction* Action)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.HitReactionBlueprintLibrary.K2_GetBoneIndexFromAction");
		
		UHitReactionBlueprintLibrary_K2_GetBoneIndexFromAction_Params params {};
		params.Action = Action;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E5DD30
	 * 		Name   -> Function GbxGameSystemCore.HitReactionBlueprintLibrary.IsHitReactionTagActive
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class AActor*                                      Actor                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UHitReactionTag*                             Tag                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UHitReactionBlueprintLibrary::STATIC_IsHitReactionTagActive(class AActor* Actor, class UHitReactionTag* Tag)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.HitReactionBlueprintLibrary.IsHitReactionTagActive");
		
		UHitReactionBlueprintLibrary_IsHitReactionTagActive_Params params {};
		params.Actor = Actor;
		params.Tag = Tag;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E5D9C0
	 * 		Name   -> Function GbxGameSystemCore.HitReactionBlueprintLibrary.AddHitReactionLiveLayer
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class AActor*                                      Actor                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UClass*                                      Layer                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UHitReactionBlueprintLibrary::STATIC_AddHitReactionLiveLayer(class AActor* Actor, class UClass* Layer)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.HitReactionBlueprintLibrary.AddHitReactionLiveLayer");
		
		UHitReactionBlueprintLibrary_AddHitReactionLiveLayer_Params params {};
		params.Actor = Actor;
		params.Layer = Layer;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E5D910
	 * 		Name   -> Function GbxGameSystemCore.HitReactionBlueprintLibrary.AddHitReactionDeathLayer
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class AActor*                                      Actor                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UClass*                                      Layer                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UHitReactionBlueprintLibrary::STATIC_AddHitReactionDeathLayer(class AActor* Actor, class UClass* Layer)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.HitReactionBlueprintLibrary.AddHitReactionDeathLayer");
		
		UHitReactionBlueprintLibrary_AddHitReactionDeathLayer_Params params {};
		params.Actor = Actor;
		params.Layer = Layer;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UHitReactionBlueprintLibrary.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UHitReactionBlueprintLibrary::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.HitReactionBlueprintLibrary");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UHitReactionData.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UHitReactionData::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.HitReactionData");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E5DA70
	 * 		Name   -> Function GbxGameSystemCore.HitReactionLayer_Blueprint.EvaluateTag
	 * 		Flags  -> (Native, Event, Public, BlueprintEvent, Const)
	 * Parameters:
	 * 		class UDamageComponent*                            Receiver                                                   (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UDamageCauserComponent*                      Causer                                                     (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              DamageAmount                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UGbxDamageType*                              DamageType                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UDamageSource*                               DamageSource                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UHitRegionData*                              HitRegion                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Force                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UHitReactionTag*                             PreviousTag                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UHitReactionTag* UHitReactionLayer_Blueprint::EvaluateTag(class UDamageComponent* Receiver, class UDamageCauserComponent* Causer, float DamageAmount, class UGbxDamageType* DamageType, class UDamageSource* DamageSource, class UHitRegionData* HitRegion, float Force, class UHitReactionTag* PreviousTag)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.HitReactionLayer_Blueprint.EvaluateTag");
		
		UHitReactionLayer_Blueprint_EvaluateTag_Params params {};
		params.Receiver = Receiver;
		params.Causer = Causer;
		params.DamageAmount = DamageAmount;
		params.DamageType = DamageType;
		params.DamageSource = DamageSource;
		params.HitRegion = HitRegion;
		params.Force = Force;
		params.PreviousTag = PreviousTag;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UHitReactionLayer_Blueprint.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UHitReactionLayer_Blueprint::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.HitReactionLayer_Blueprint");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UHitReactionLayer_Combine.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UHitReactionLayer_Combine::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.HitReactionLayer_Combine");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UHitReactionLayer_Condition.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UHitReactionLayer_Condition::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.HitReactionLayer_Condition");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UHitReactionLayer_Cooldown.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UHitReactionLayer_Cooldown::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.HitReactionLayer_Cooldown");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UHitReactionLayer_Map.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UHitReactionLayer_Map::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.HitReactionLayer_Map");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UHitReactionLayer_Priority.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UHitReactionLayer_Priority::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.HitReactionLayer_Priority");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UHitReactionTag.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UHitReactionTag::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.HitReactionTag");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E61CD0
	 * 		Name   -> Function GbxGameSystemCore.HitRegionFunctionLibrary.ResetHitRegionHealth
	 * 		Flags  -> (Final, BlueprintAuthorityOnly, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class AActor*                                      Actor                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UHitRegionData*                              HitRegion                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UPrimitiveComponent*                         AssociatedComponent                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UHitRegionFunctionLibrary::STATIC_ResetHitRegionHealth(class AActor* Actor, class UHitRegionData* HitRegion, class UPrimitiveComponent* AssociatedComponent)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.HitRegionFunctionLibrary.ResetHitRegionHealth");
		
		UHitRegionFunctionLibrary_ResetHitRegionHealth_Params params {};
		params.Actor = Actor;
		params.HitRegion = HitRegion;
		params.AssociatedComponent = AssociatedComponent;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E61C60
	 * 		Name   -> Function GbxGameSystemCore.HitRegionFunctionLibrary.ResetAllHitRegionHealth
	 * 		Flags  -> (Final, BlueprintAuthorityOnly, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class AActor*                                      Actor                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UHitRegionFunctionLibrary::STATIC_ResetAllHitRegionHealth(class AActor* Actor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.HitRegionFunctionLibrary.ResetAllHitRegionHealth");
		
		UHitRegionFunctionLibrary_ResetAllHitRegionHealth_Params params {};
		params.Actor = Actor;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E61B20
	 * 		Name   -> Function GbxGameSystemCore.HitRegionFunctionLibrary.RefillHitRegionHealthByPercent
	 * 		Flags  -> (Final, BlueprintAuthorityOnly, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		float                                              RefillPercent                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      Actor                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UHitRegionData*                              HitRegion                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UPrimitiveComponent*                         AssociatedComponent                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UHitRegionFunctionLibrary::STATIC_RefillHitRegionHealthByPercent(float RefillPercent, class AActor* Actor, class UHitRegionData* HitRegion, class UPrimitiveComponent* AssociatedComponent)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.HitRegionFunctionLibrary.RefillHitRegionHealthByPercent");
		
		UHitRegionFunctionLibrary_RefillHitRegionHealthByPercent_Params params {};
		params.RefillPercent = RefillPercent;
		params.Actor = Actor;
		params.HitRegion = HitRegion;
		params.AssociatedComponent = AssociatedComponent;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E619E0
	 * 		Name   -> Function GbxGameSystemCore.HitRegionFunctionLibrary.RefillHitRegionHealthByAmount
	 * 		Flags  -> (Final, BlueprintAuthorityOnly, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		float                                              RefillAmount                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      Actor                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UHitRegionData*                              HitRegion                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UPrimitiveComponent*                         AssociatedComponent                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UHitRegionFunctionLibrary::STATIC_RefillHitRegionHealthByAmount(float RefillAmount, class AActor* Actor, class UHitRegionData* HitRegion, class UPrimitiveComponent* AssociatedComponent)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.HitRegionFunctionLibrary.RefillHitRegionHealthByAmount");
		
		UHitRegionFunctionLibrary_RefillHitRegionHealthByAmount_Params params {};
		params.RefillAmount = RefillAmount;
		params.Actor = Actor;
		params.HitRegion = HitRegion;
		params.AssociatedComponent = AssociatedComponent;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E61600
	 * 		Name   -> Function GbxGameSystemCore.HitRegionFunctionLibrary.AssociateComponentWithHitRegion
	 * 		Flags  -> (Final, BlueprintAuthorityOnly, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class AActor*                                      Actor                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UPrimitiveComponent*                         ComponentToAssociate                                       (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UHitRegionData*                              HitRegion                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UHitRegionFunctionLibrary::STATIC_AssociateComponentWithHitRegion(class AActor* Actor, class UPrimitiveComponent* ComponentToAssociate, class UHitRegionData* HitRegion)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.HitRegionFunctionLibrary.AssociateComponentWithHitRegion");
		
		UHitRegionFunctionLibrary_AssociateComponentWithHitRegion_Params params {};
		params.Actor = Actor;
		params.ComponentToAssociate = ComponentToAssociate;
		params.HitRegion = HitRegion;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UHitRegionFunctionLibrary.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UHitRegionFunctionLibrary::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.HitRegionFunctionLibrary");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UIGbxProjectileManager.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UIGbxProjectileManager::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.IGbxProjectileManager");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGbxReplicatorProxyData.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGbxReplicatorProxyData::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.GbxReplicatorProxyData");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E61930
	 * 		Name   -> Function GbxGameSystemCore.InspectionInfoProvider.GetInspectionInfo
	 * 		Flags  -> (Native, Event, Public, HasOutParms, BlueprintEvent, Const)
	 * Parameters:
	 * 		struct FInspectionInfo                             InspectionInfo                                             (Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UInspectionInfoProvider::GetInspectionInfo(struct FInspectionInfo* InspectionInfo)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.InspectionInfoProvider.GetInspectionInfo");
		
		UInspectionInfoProvider_GetInspectionInfo_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (InspectionInfo != nullptr)
			*InspectionInfo = params.InspectionInfo;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UInspectionInfoProvider.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UInspectionInfoProvider::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.InspectionInfoProvider");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UImpactData.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UImpactData::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.ImpactData");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UImpactExpansionData.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UImpactExpansionData::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.ImpactExpansionData");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UImpactDataOverride.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UImpactDataOverride::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.ImpactDataOverride");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AImpactDecalManager.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AImpactDecalManager::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.ImpactDecalManager");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UPooledImpactDecalComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UPooledImpactDecalComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.PooledImpactDecalComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E65290
	 * 		Name   -> Function GbxGameSystemCore.ImpactEffectFunctionLibrary.PlayTraceImpactAndGetParticleSystemComponents
	 * 		Flags  -> (Final, RequiredAPI, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		class UImpactData*                                 ImpactData                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      Instigator                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     TraceStart                                                 (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     TraceEnd                                                   (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		TArray<class UParticleSystemComponent*>            SpawnedParticleSystemComponents                            (Parm, OutParm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 * 		ECollisionChannel                                  TraceChannel                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UImpactEffectFunctionLibrary::STATIC_PlayTraceImpactAndGetParticleSystemComponents(class UImpactData* ImpactData, class AActor* Instigator, const struct FVector& TraceStart, const struct FVector& TraceEnd, TArray<class UParticleSystemComponent*>* SpawnedParticleSystemComponents, ECollisionChannel TraceChannel)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.ImpactEffectFunctionLibrary.PlayTraceImpactAndGetParticleSystemComponents");
		
		UImpactEffectFunctionLibrary_PlayTraceImpactAndGetParticleSystemComponents_Params params {};
		params.ImpactData = ImpactData;
		params.Instigator = Instigator;
		params.TraceStart = TraceStart;
		params.TraceEnd = TraceEnd;
		params.TraceChannel = TraceChannel;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (SpawnedParticleSystemComponents != nullptr)
			*SpawnedParticleSystemComponents = params.SpawnedParticleSystemComponents;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E650A0
	 * 		Name   -> Function GbxGameSystemCore.ImpactEffectFunctionLibrary.PlayTraceImpact
	 * 		Flags  -> (Final, RequiredAPI, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		class UImpactData*                                 ImpactData                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      Instigator                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     TraceStart                                                 (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     TraceEnd                                                   (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		ECollisionChannel                                  TraceChannel                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bReplicated                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UImpactEffectFunctionLibrary::STATIC_PlayTraceImpact(class UImpactData* ImpactData, class AActor* Instigator, const struct FVector& TraceStart, const struct FVector& TraceEnd, ECollisionChannel TraceChannel, bool bReplicated)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.ImpactEffectFunctionLibrary.PlayTraceImpact");
		
		UImpactEffectFunctionLibrary_PlayTraceImpact_Params params {};
		params.ImpactData = ImpactData;
		params.Instigator = Instigator;
		params.TraceStart = TraceStart;
		params.TraceEnd = TraceEnd;
		params.TraceChannel = TraceChannel;
		params.bReplicated = bReplicated;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E64F00
	 * 		Name   -> Function GbxGameSystemCore.ImpactEffectFunctionLibrary.PlayHitResultImpactGetParticleSystemComponents
	 * 		Flags  -> (Final, RequiredAPI, Native, Static, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		class UImpactData*                                 ImpactData                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      Instigator                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FHitResult                                  HitInfo                                                    (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 * 		TArray<class UParticleSystemComponent*>            SpawnedParticleSystemComponents                            (Parm, OutParm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	void UImpactEffectFunctionLibrary::STATIC_PlayHitResultImpactGetParticleSystemComponents(class UImpactData* ImpactData, class AActor* Instigator, const struct FHitResult& HitInfo, TArray<class UParticleSystemComponent*>* SpawnedParticleSystemComponents)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.ImpactEffectFunctionLibrary.PlayHitResultImpactGetParticleSystemComponents");
		
		UImpactEffectFunctionLibrary_PlayHitResultImpactGetParticleSystemComponents_Params params {};
		params.ImpactData = ImpactData;
		params.Instigator = Instigator;
		params.HitInfo = HitInfo;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (SpawnedParticleSystemComponents != nullptr)
			*SpawnedParticleSystemComponents = params.SpawnedParticleSystemComponents;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E64D70
	 * 		Name   -> Function GbxGameSystemCore.ImpactEffectFunctionLibrary.PlayHitResultImpact
	 * 		Flags  -> (Final, RequiredAPI, Native, Static, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		class UImpactData*                                 ImpactData                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      Instigator                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FHitResult                                  HitInfo                                                    (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 * 		bool                                               bReplicated                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UImpactEffectFunctionLibrary::STATIC_PlayHitResultImpact(class UImpactData* ImpactData, class AActor* Instigator, const struct FHitResult& HitInfo, bool bReplicated)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.ImpactEffectFunctionLibrary.PlayHitResultImpact");
		
		UImpactEffectFunctionLibrary_PlayHitResultImpact_Params params {};
		params.ImpactData = ImpactData;
		params.Instigator = Instigator;
		params.HitInfo = HitInfo;
		params.bReplicated = bReplicated;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UImpactEffectFunctionLibrary.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UImpactEffectFunctionLibrary::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.ImpactEffectFunctionLibrary");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E65510
	 * 		Name   -> Function GbxGameSystemCore.ImpactFXManagerComponent.SetEffectsEnabled
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bEnabled                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UImpactFXManagerComponent::SetEffectsEnabled(bool bEnabled)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.ImpactFXManagerComponent.SetEffectsEnabled");
		
		UImpactFXManagerComponent_SetEffectsEnabled_Params params {};
		params.bEnabled = bEnabled;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E64CF0
	 * 		Name   -> Function GbxGameSystemCore.ImpactFXManagerComponent.OnTrackedParticleSystemFinished
	 * 		Flags  -> (Final, Native, Protected)
	 * Parameters:
	 * 		class UParticleSystemComponent*                    PSC                                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UImpactFXManagerComponent::OnTrackedParticleSystemFinished(class UParticleSystemComponent* PSC)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.ImpactFXManagerComponent.OnTrackedParticleSystemFinished");
		
		UImpactFXManagerComponent_OnTrackedParticleSystemFinished_Params params {};
		params.PSC = PSC;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E64C70
	 * 		Name   -> Function GbxGameSystemCore.ImpactFXManagerComponent.OnTrackedComponentDeactivated
	 * 		Flags  -> (Final, Native, Protected)
	 * Parameters:
	 * 		class UActorComponent*                             Component                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UImpactFXManagerComponent::OnTrackedComponentDeactivated(class UActorComponent* Component)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.ImpactFXManagerComponent.OnTrackedComponentDeactivated");
		
		UImpactFXManagerComponent_OnTrackedComponentDeactivated_Params params {};
		params.Component = Component;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E64AD0
	 * 		Name   -> Function GbxGameSystemCore.ImpactFXManagerComponent.OnHit
	 * 		Flags  -> (Native, Protected, HasOutParms, HasDefaults)
	 * Parameters:
	 * 		class AActor*                                      SelfActor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      OtherActor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     NormalImpulse                                              (Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FHitResult                                  Hit                                                        (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	void UImpactFXManagerComponent::OnHit(class AActor* SelfActor, class AActor* OtherActor, const struct FVector& NormalImpulse, const struct FHitResult& Hit)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.ImpactFXManagerComponent.OnHit");
		
		UImpactFXManagerComponent_OnHit_Params params {};
		params.SelfActor = SelfActor;
		params.OtherActor = OtherActor;
		params.NormalImpulse = NormalImpulse;
		params.Hit = Hit;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UImpactFXManagerComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UImpactFXManagerComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.ImpactFXManagerComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E63DD0
	 * 		Name   -> Function GbxGameSystemCore.InspectionInfoFunctionLibrary.AddScreenOutput
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		struct FInspectionInfo                             InspectionInfo                                             (Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		class FString                                      String                                                     (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EDebugDisplayVerbosityLevel                        Verbosity                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UInspectionInfoFunctionLibrary::STATIC_AddScreenOutput(struct FInspectionInfo* InspectionInfo, const class FString& String, EDebugDisplayVerbosityLevel Verbosity)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.InspectionInfoFunctionLibrary.AddScreenOutput");
		
		UInspectionInfoFunctionLibrary_AddScreenOutput_Params params {};
		params.String = String;
		params.Verbosity = Verbosity;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (InspectionInfo != nullptr)
			*InspectionInfo = params.InspectionInfo;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E63DD0
	 * 		Name   -> Function GbxGameSystemCore.InspectionInfoFunctionLibrary.AddAboveActorOutput
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		struct FInspectionInfo                             InspectionInfo                                             (Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		class FString                                      String                                                     (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EDebugDisplayVerbosityLevel                        Verbosity                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UInspectionInfoFunctionLibrary::STATIC_AddAboveActorOutput(struct FInspectionInfo* InspectionInfo, const class FString& String, EDebugDisplayVerbosityLevel Verbosity)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.InspectionInfoFunctionLibrary.AddAboveActorOutput");
		
		UInspectionInfoFunctionLibrary_AddAboveActorOutput_Params params {};
		params.String = String;
		params.Verbosity = Verbosity;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (InspectionInfo != nullptr)
			*InspectionInfo = params.InspectionInfo;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UInspectionInfoFunctionLibrary.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UInspectionInfoFunctionLibrary::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.InspectionInfoFunctionLibrary");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E65750
	 * 		Name   -> Function GbxGameSystemCore.InterpComponent.Stop
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void UInterpComponent::Stop()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.InterpComponent.Stop");
		
		UInterpComponent_Stop_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E656C0
	 * 		Name   -> Function GbxGameSystemCore.InterpComponent.SetUpdateVelocity
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bNewUpdateVelocity                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UInterpComponent::SetUpdateVelocity(bool bNewUpdateVelocity)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.InterpComponent.SetUpdateVelocity");
		
		UInterpComponent_SetUpdateVelocity_Params params {};
		params.bNewUpdateVelocity = bNewUpdateVelocity;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E65630
	 * 		Name   -> Function GbxGameSystemCore.InterpComponent.SetRemoveOnCompletion
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bRemove                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UInterpComponent::SetRemoveOnCompletion(bool bRemove)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.InterpComponent.SetRemoveOnCompletion");
		
		UInterpComponent_SetRemoveOnCompletion_Params params {};
		params.bRemove = bRemove;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E655A0
	 * 		Name   -> Function GbxGameSystemCore.InterpComponent.SetManualTick
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bManual                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UInterpComponent::SetManualTick(bool bManual)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.InterpComponent.SetManualTick");
		
		UInterpComponent_SetManualTick_Params params {};
		params.bManual = bManual;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E65480
	 * 		Name   -> Function GbxGameSystemCore.InterpComponent.SetClearVelocity
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bNewClearVelocity                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UInterpComponent::SetClearVelocity(bool bNewClearVelocity)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.InterpComponent.SetClearVelocity");
		
		UInterpComponent_SetClearVelocity_Params params {};
		params.bNewClearVelocity = bNewClearVelocity;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E64A40
	 * 		Name   -> Function GbxGameSystemCore.InterpComponent.MatchRotationToVelocity
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bInSetToInitialWhenFinished                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UInterpComponent::MatchRotationToVelocity(bool bInSetToInitialWhenFinished)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.InterpComponent.MatchRotationToVelocity");
		
		UInterpComponent_MatchRotationToVelocity_Params params {};
		params.bInSetToInitialWhenFinished = bInSetToInitialWhenFinished;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E649C0
	 * 		Name   -> Function GbxGameSystemCore.InterpComponent.ManualTick
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		float                                              DeltaTime                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UInterpComponent::ManualTick(float DeltaTime)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.InterpComponent.ManualTick");
		
		UInterpComponent_ManualTick_Params params {};
		params.DeltaTime = DeltaTime;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E64990
	 * 		Name   -> Function GbxGameSystemCore.InterpComponent.IsFinished
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool UInterpComponent::IsFinished()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.InterpComponent.IsFinished");
		
		UInterpComponent_IsFinished_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E647C0
	 * 		Name   -> Function GbxGameSystemCore.InterpComponent.InterpRotation
	 * 		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FRotator                                    NewRot                                                     (Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		float                                              InterpTime                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bLinear                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bYawOnly                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bInRelative                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UInterpComponent::InterpRotation(const struct FRotator& NewRot, float InterpTime, bool bLinear, bool bYawOnly, bool bInRelative)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.InterpComponent.InterpRotation");
		
		UInterpComponent_InterpRotation_Params params {};
		params.NewRot = NewRot;
		params.InterpTime = InterpTime;
		params.bLinear = bLinear;
		params.bYawOnly = bYawOnly;
		params.bInRelative = bInRelative;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E645F0
	 * 		Name   -> Function GbxGameSystemCore.InterpComponent.InterpLocation
	 * 		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FVector                                     NewLoc                                                     (Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              InterpTime                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bLinear                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bNoZ                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bInRelative                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UInterpComponent::InterpLocation(const struct FVector& NewLoc, float InterpTime, bool bLinear, bool bNoZ, bool bInRelative)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.InterpComponent.InterpLocation");
		
		UInterpComponent_InterpLocation_Params params {};
		params.NewLoc = NewLoc;
		params.InterpTime = InterpTime;
		params.bLinear = bLinear;
		params.bNoZ = bNoZ;
		params.bInRelative = bInRelative;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E64420
	 * 		Name   -> Function GbxGameSystemCore.InterpComponent.InterpDeltaRotation
	 * 		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FRotator                                    DeltaRot                                                   (Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		float                                              InterpTime                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bLinear                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bYawOnly                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bInRelative                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UInterpComponent::InterpDeltaRotation(const struct FRotator& DeltaRot, float InterpTime, bool bLinear, bool bYawOnly, bool bInRelative)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.InterpComponent.InterpDeltaRotation");
		
		UInterpComponent_InterpDeltaRotation_Params params {};
		params.DeltaRot = DeltaRot;
		params.InterpTime = InterpTime;
		params.bLinear = bLinear;
		params.bYawOnly = bYawOnly;
		params.bInRelative = bInRelative;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E64250
	 * 		Name   -> Function GbxGameSystemCore.InterpComponent.InterpDeltaLocation
	 * 		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FVector                                     DeltaLoc                                                   (Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              InterpTime                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bLinear                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bNoZ                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bInRelative                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UInterpComponent::InterpDeltaLocation(const struct FVector& DeltaLoc, float InterpTime, bool bLinear, bool bNoZ, bool bInRelative)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.InterpComponent.InterpDeltaLocation");
		
		UInterpComponent_InterpDeltaLocation_Params params {};
		params.DeltaLoc = DeltaLoc;
		params.InterpTime = InterpTime;
		params.bLinear = bLinear;
		params.bNoZ = bNoZ;
		params.bInRelative = bInRelative;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E640A0
	 * 		Name   -> Function GbxGameSystemCore.InterpComponent.InterpBallisticsByTime
	 * 		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FVector                                     StartLoc                                                   (Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     EndLoc                                                     (Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              LeapTime                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              LeapGravity                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FVector UInterpComponent::InterpBallisticsByTime(const struct FVector& StartLoc, const struct FVector& EndLoc, float LeapTime, float LeapGravity)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.InterpComponent.InterpBallisticsByTime");
		
		UInterpComponent_InterpBallisticsByTime_Params params {};
		params.StartLoc = StartLoc;
		params.EndLoc = EndLoc;
		params.LeapTime = LeapTime;
		params.LeapGravity = LeapGravity;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E63F10
	 * 		Name   -> Function GbxGameSystemCore.InterpComponent.InterpBallistics
	 * 		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FVector                                     StartLoc                                                   (Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     EndLoc                                                     (Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              LeapSpeed                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              LeapAngle                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	float UInterpComponent::InterpBallistics(const struct FVector& StartLoc, const struct FVector& EndLoc, float LeapSpeed, float LeapAngle)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.InterpComponent.InterpBallistics");
		
		UInterpComponent_InterpBallistics_Params params {};
		params.StartLoc = StartLoc;
		params.EndLoc = EndLoc;
		params.LeapSpeed = LeapSpeed;
		params.LeapAngle = LeapAngle;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UInterpComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UInterpComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.InterpComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ALadder.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ALadder::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.Ladder");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ULadderInterface.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ULadderInterface::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.LadderInterface");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ALadderVolume.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ALadderVolume::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.LadderVolume");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ULandingData.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ULandingData::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.LandingData");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMantleData.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMantleData::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.MantleData");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UModifierMathAttributeValueResolver.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UModifierMathAttributeValueResolver::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.ModifierMathAttributeValueResolver");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E68FC0
	 * 		Name   -> Function GbxGameSystemCore.MotionControlLibrary.UpdateSpeed
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		float                                              CurrentSpeed                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              TargetSpeed                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Acceleration                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              DeltaTime                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	float UMotionControlLibrary::STATIC_UpdateSpeed(float CurrentSpeed, float TargetSpeed, float Acceleration, float DeltaTime)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.MotionControlLibrary.UpdateSpeed");
		
		UMotionControlLibrary_UpdateSpeed_Params params {};
		params.CurrentSpeed = CurrentSpeed;
		params.TargetSpeed = TargetSpeed;
		params.Acceleration = Acceleration;
		params.DeltaTime = DeltaTime;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E68E30
	 * 		Name   -> Function GbxGameSystemCore.MotionControlLibrary.Spin
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FRotator                                    CurrentRotation                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		float                                              RotationRate                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     RotationAxis                                               (Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              DeltaTime                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FRotator UMotionControlLibrary::STATIC_Spin(const struct FRotator& CurrentRotation, float RotationRate, const struct FVector& RotationAxis, float DeltaTime)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.MotionControlLibrary.Spin");
		
		UMotionControlLibrary_Spin_Params params {};
		params.CurrentRotation = CurrentRotation;
		params.RotationRate = RotationRate;
		params.RotationAxis = RotationAxis;
		params.DeltaTime = DeltaTime;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMotionControlLibrary.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMotionControlLibrary::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.MotionControlLibrary");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E68DB0
	 * 		Name   -> Function GbxGameSystemCore.OrbitingActorComponent.SetTargetActor
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class AActor*                                      NewTarget                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UOrbitingActorComponent::SetTargetActor(class AActor* NewTarget)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.OrbitingActorComponent.SetTargetActor");
		
		UOrbitingActorComponent_SetTargetActor_Params params {};
		params.NewTarget = NewTarget;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E68A10
	 * 		Name   -> Function GbxGameSystemCore.OrbitingActorComponent.OnRep_TargetActor
	 * 		Flags  -> (Final, Native, Protected)
	 * Parameters:
	 * 		class AActor*                                      LastTarget                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UOrbitingActorComponent::OnRep_TargetActor(class AActor* LastTarget)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.OrbitingActorComponent.OnRep_TargetActor");
		
		UOrbitingActorComponent_OnRep_TargetActor_Params params {};
		params.LastTarget = LastTarget;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UOrbitingActorComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UOrbitingActorComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.OrbitingActorComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UParentChallenge.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UParentChallenge::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.ParentChallenge");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UParticleAttributeParameterEvaluator.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UParticleAttributeParameterEvaluator::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.ParticleAttributeParameterEvaluator");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UParticleConditionalEmitterEvaluator.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UParticleConditionalEmitterEvaluator::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.ParticleConditionalEmitterEvaluator");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UParticlePropertyTrackingData.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UParticlePropertyTrackingData::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.ParticlePropertyTrackingData");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E68BC0
	 * 		Name   -> Function GbxGameSystemCore.PawnAttachmentFunctionLibrary.RequestDetachPawnFromSlot
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class AActor*                                      Actor                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FName                                        SlotName                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UPawnAttachmentFunctionLibrary::STATIC_RequestDetachPawnFromSlot(class AActor* Actor, const class FName& SlotName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.PawnAttachmentFunctionLibrary.RequestDetachPawnFromSlot");
		
		UPawnAttachmentFunctionLibrary_RequestDetachPawnFromSlot_Params params {};
		params.Actor = Actor;
		params.SlotName = SlotName;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E68B50
	 * 		Name   -> Function GbxGameSystemCore.PawnAttachmentFunctionLibrary.RequestDetachPawnFromActor
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class APawn*                                       Pawn                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UPawnAttachmentFunctionLibrary::STATIC_RequestDetachPawnFromActor(class APawn* Pawn)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.PawnAttachmentFunctionLibrary.RequestDetachPawnFromActor");
		
		UPawnAttachmentFunctionLibrary_RequestDetachPawnFromActor_Params params {};
		params.Pawn = Pawn;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E68A90
	 * 		Name   -> Function GbxGameSystemCore.PawnAttachmentFunctionLibrary.QueryPawnAttachment
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class APawn*                                       Pawn                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FPawnAttachmentQueryResult UPawnAttachmentFunctionLibrary::STATIC_QueryPawnAttachment(class APawn* Pawn)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.PawnAttachmentFunctionLibrary.QueryPawnAttachment");
		
		UPawnAttachmentFunctionLibrary_QueryPawnAttachment_Params params {};
		params.Pawn = Pawn;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E68720
	 * 		Name   -> Function GbxGameSystemCore.PawnAttachmentFunctionLibrary.FindPawnAttachSlotComponent
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class APawn*                                       Pawn                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UPawnAttachSlotComponent* UPawnAttachmentFunctionLibrary::STATIC_FindPawnAttachSlotComponent(class APawn* Pawn)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.PawnAttachmentFunctionLibrary.FindPawnAttachSlotComponent");
		
		UPawnAttachmentFunctionLibrary_FindPawnAttachSlotComponent_Params params {};
		params.Pawn = Pawn;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E68620
	 * 		Name   -> Function GbxGameSystemCore.PawnAttachmentFunctionLibrary.DetachPawnFromSlot
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class AActor*                                      Actor                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FName                                        SlotName                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bInstant                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UPawnAttachmentFunctionLibrary::STATIC_DetachPawnFromSlot(class AActor* Actor, const class FName& SlotName, bool bInstant)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.PawnAttachmentFunctionLibrary.DetachPawnFromSlot");
		
		UPawnAttachmentFunctionLibrary_DetachPawnFromSlot_Params params {};
		params.Actor = Actor;
		params.SlotName = SlotName;
		params.bInstant = bInstant;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E68560
	 * 		Name   -> Function GbxGameSystemCore.PawnAttachmentFunctionLibrary.DetachPawnFromActor
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class APawn*                                       Pawn                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bInstant                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UPawnAttachmentFunctionLibrary::STATIC_DetachPawnFromActor(class APawn* Pawn, bool bInstant)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.PawnAttachmentFunctionLibrary.DetachPawnFromActor");
		
		UPawnAttachmentFunctionLibrary_DetachPawnFromActor_Params params {};
		params.Pawn = Pawn;
		params.bInstant = bInstant;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E68360
	 * 		Name   -> Function GbxGameSystemCore.PawnAttachmentFunctionLibrary.AttachPawnToSlot
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class AActor*                                      Actor                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FName                                        SlotName                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class APawn*                                       Pawn                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bInstant                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UPawnAttachmentFunctionLibrary::STATIC_AttachPawnToSlot(class AActor* Actor, const class FName& SlotName, class APawn* Pawn, bool bInstant)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.PawnAttachmentFunctionLibrary.AttachPawnToSlot");
		
		UPawnAttachmentFunctionLibrary_AttachPawnToSlot_Params params {};
		params.Actor = Actor;
		params.SlotName = SlotName;
		params.Pawn = Pawn;
		params.bInstant = bInstant;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UPawnAttachmentFunctionLibrary.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UPawnAttachmentFunctionLibrary::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.PawnAttachmentFunctionLibrary");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UPawnAttributeContextResolver.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UPawnAttributeContextResolver::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.PawnAttributeContextResolver");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UPhysicalAnimationProfileAsset.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UPhysicalAnimationProfileAsset::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.PhysicalAnimationProfileAsset");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E6C9B0
	 * 		Name   -> Function GbxGameSystemCore.ProjectileAimViewPointHomingTargetComponent.SetTargetController
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class AController*                                 InTargetController                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UProjectileAimViewPointHomingTargetComponent::SetTargetController(class AController* InTargetController)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.ProjectileAimViewPointHomingTargetComponent.SetTargetController");
		
		UProjectileAimViewPointHomingTargetComponent_SetTargetController_Params params {};
		params.InTargetController = InTargetController;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007B67D0
	 * 		Name   -> Function GbxGameSystemCore.ProjectileAimViewPointHomingTargetComponent.SetTargetActor
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class AActor*                                      InTargetActor                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UProjectileAimViewPointHomingTargetComponent::SetTargetActor(class AActor* InTargetActor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.ProjectileAimViewPointHomingTargetComponent.SetTargetActor");
		
		UProjectileAimViewPointHomingTargetComponent_SetTargetActor_Params params {};
		params.InTargetActor = InTargetActor;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E6C2F0
	 * 		Name   -> Function GbxGameSystemCore.ProjectileAimViewPointHomingTargetComponent.GetTargetController
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	class AController* UProjectileAimViewPointHomingTargetComponent::GetTargetController()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.ProjectileAimViewPointHomingTargetComponent.GetTargetController");
		
		UProjectileAimViewPointHomingTargetComponent_GetTargetController_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E6C270
	 * 		Name   -> Function GbxGameSystemCore.ProjectileAimViewPointHomingTargetComponent.GetCurrentHomingLoc
	 * 		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
	 */
	struct FVector UProjectileAimViewPointHomingTargetComponent::GetCurrentHomingLoc()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.ProjectileAimViewPointHomingTargetComponent.GetCurrentHomingLoc");
		
		UProjectileAimViewPointHomingTargetComponent_GetCurrentHomingLoc_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UProjectileAimViewPointHomingTargetComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UProjectileAimViewPointHomingTargetComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.ProjectileAimViewPointHomingTargetComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UPropertyUtilsTestContext.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UPropertyUtilsTestContext::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.PropertyUtilsTestContext");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URangedFeedbackData.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URangedFeedbackData::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.RangedFeedbackData");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007A5960
	 * 		Name   -> Function GbxGameSystemCore.ReferenceActor.EnumeratePreviewClasses
	 * 		Flags  -> (Final, Native, Public, HasOutParms, Const)
	 * Parameters:
	 * 		TArray<class FName>                                ClasssList                                                 (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	 */
	void AReferenceActor::EnumeratePreviewClasses(TArray<class FName>* ClasssList)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.ReferenceActor.EnumeratePreviewClasses");
		
		AReferenceActor_EnumeratePreviewClasses_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (ClasssList != nullptr)
			*ClasssList = params.ClasssList;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AReferenceActor.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AReferenceActor::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.ReferenceActor");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E6C880
	 * 		Name   -> Function GbxGameSystemCore.ReplicatedEmitter.OnRep_TemplateOptions
	 * 		Flags  -> (Final, Native, Protected)
	 */
	void AReplicatedEmitter::OnRep_TemplateOptions()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.ReplicatedEmitter.OnRep_TemplateOptions");
		
		AReplicatedEmitter_OnRep_TemplateOptions_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E6C860
	 * 		Name   -> Function GbxGameSystemCore.ReplicatedEmitter.OnRep_ReplicatedWwiseEvent
	 * 		Flags  -> (Final, Native, Protected)
	 */
	void AReplicatedEmitter::OnRep_ReplicatedWwiseEvent()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.ReplicatedEmitter.OnRep_ReplicatedWwiseEvent");
		
		AReplicatedEmitter_OnRep_ReplicatedWwiseEvent_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E6C840
	 * 		Name   -> Function GbxGameSystemCore.ReplicatedEmitter.OnRep_ReplicatedVectorParams
	 * 		Flags  -> (Final, Native, Protected)
	 */
	void AReplicatedEmitter::OnRep_ReplicatedVectorParams()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.ReplicatedEmitter.OnRep_ReplicatedVectorParams");
		
		AReplicatedEmitter_OnRep_ReplicatedVectorParams_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E6C820
	 * 		Name   -> Function GbxGameSystemCore.ReplicatedEmitter.OnRep_ReplicatedFloatParams
	 * 		Flags  -> (Final, Native, Protected)
	 */
	void AReplicatedEmitter::OnRep_ReplicatedFloatParams()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.ReplicatedEmitter.OnRep_ReplicatedFloatParams");
		
		AReplicatedEmitter_OnRep_ReplicatedFloatParams_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E6C800
	 * 		Name   -> Function GbxGameSystemCore.ReplicatedEmitter.OnRep_ReplicatedColorParams
	 * 		Flags  -> (Final, Native, Protected)
	 */
	void AReplicatedEmitter::OnRep_ReplicatedColorParams()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.ReplicatedEmitter.OnRep_ReplicatedColorParams");
		
		AReplicatedEmitter_OnRep_ReplicatedColorParams_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E6C7E0
	 * 		Name   -> Function GbxGameSystemCore.ReplicatedEmitter.OnRep_OwnerNoSeeEmitter
	 * 		Flags  -> (Final, Native, Protected)
	 */
	void AReplicatedEmitter::OnRep_OwnerNoSeeEmitter()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.ReplicatedEmitter.OnRep_OwnerNoSeeEmitter");
		
		AReplicatedEmitter_OnRep_OwnerNoSeeEmitter_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AReplicatedEmitter.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AReplicatedEmitter::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.ReplicatedEmitter");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UResourceWeightAttributeValueResolver.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UResourceWeightAttributeValueResolver::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.ResourceWeightAttributeValueResolver");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ARigidBodyActor.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ARigidBodyActor::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.RigidBodyActor");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E70B50
	 * 		Name   -> Function GbxGameSystemCore.RigidBodyComponent.SetKinematic
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		class UPrimitiveComponent*                         SleepingComponent                                          (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FName                                        BoneName                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URigidBodyComponent::SetKinematic(class UPrimitiveComponent* SleepingComponent, const class FName& BoneName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.RigidBodyComponent.SetKinematic");
		
		URigidBodyComponent_SetKinematic_Params params {};
		params.SleepingComponent = SleepingComponent;
		params.BoneName = BoneName;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URigidBodyComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URigidBodyComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.RigidBodyComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction USaveGameActorInterface.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* USaveGameActorInterface::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.SaveGameActorInterface");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction USceneBodySwitchAction.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* USceneBodySwitchAction::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.SceneBodySwitchAction");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E70AB0
	 * 		Name   -> Function GbxGameSystemCore.SceneBodySwitchComponent.OnRep_ReplicatedState
	 * 		Flags  -> (Final, Native, Private)
	 */
	void USceneBodySwitchComponent::OnRep_ReplicatedState()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.SceneBodySwitchComponent.OnRep_ReplicatedState");
		
		USceneBodySwitchComponent_OnRep_ReplicatedState_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E70860
	 * 		Name   -> Function GbxGameSystemCore.SceneBodySwitchComponent.HandleWwiseEventFinished
	 * 		Flags  -> (Final, Native, Private)
	 * Parameters:
	 * 		class UWwiseAudioComponent*                        WAC                                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UWwiseEvent*                                 WwiseEvent                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void USceneBodySwitchComponent::HandleWwiseEventFinished(class UWwiseAudioComponent* WAC, class UWwiseEvent* WwiseEvent)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.SceneBodySwitchComponent.HandleWwiseEventFinished");
		
		USceneBodySwitchComponent_HandleWwiseEventFinished_Params params {};
		params.WAC = WAC;
		params.WwiseEvent = WwiseEvent;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E707E0
	 * 		Name   -> Function GbxGameSystemCore.SceneBodySwitchComponent.HandleParticleSystemFinished
	 * 		Flags  -> (Final, Native, Private)
	 * Parameters:
	 * 		class UParticleSystemComponent*                    PSC                                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void USceneBodySwitchComponent::HandleParticleSystemFinished(class UParticleSystemComponent* PSC)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.SceneBodySwitchComponent.HandleParticleSystemFinished");
		
		USceneBodySwitchComponent_HandleParticleSystemFinished_Params params {};
		params.PSC = PSC;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007A5960
	 * 		Name   -> Function GbxGameSystemCore.SceneBodySwitchComponent.GetValidSwitchStateNames
	 * 		Flags  -> (Final, Native, Private, HasOutParms, Const)
	 * Parameters:
	 * 		TArray<class FName>                                OutNames                                                   (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	 */
	void USceneBodySwitchComponent::GetValidSwitchStateNames(TArray<class FName>* OutNames)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.SceneBodySwitchComponent.GetValidSwitchStateNames");
		
		USceneBodySwitchComponent_GetValidSwitchStateNames_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutNames != nullptr)
			*OutNames = params.OutNames;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction USceneBodySwitchComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* USceneBodySwitchComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.SceneBodySwitchComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x014E67D0
	 * 		Name   -> Function GbxGameSystemCore.SceneBodySwitchFunctionLibrary.EnumerateValidSwitchStateNames
	 * 		Flags  -> (Final, Native, Private, HasOutParms, Const)
	 * Parameters:
	 * 		class FName                                        SwitchName                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		TArray<class FName>                                Names                                                      (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	 */
	void USceneBodySwitchFunctionLibrary::EnumerateValidSwitchStateNames(const class FName& SwitchName, TArray<class FName>* Names)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.SceneBodySwitchFunctionLibrary.EnumerateValidSwitchStateNames");
		
		USceneBodySwitchFunctionLibrary_EnumerateValidSwitchStateNames_Params params {};
		params.SwitchName = SwitchName;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (Names != nullptr)
			*Names = params.Names;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007A5960
	 * 		Name   -> Function GbxGameSystemCore.SceneBodySwitchFunctionLibrary.EnumerateValidSwitchNames
	 * 		Flags  -> (Final, Native, Private, HasOutParms, Const)
	 * Parameters:
	 * 		TArray<class FName>                                Names                                                      (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	 */
	void USceneBodySwitchFunctionLibrary::EnumerateValidSwitchNames(TArray<class FName>* Names)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.SceneBodySwitchFunctionLibrary.EnumerateValidSwitchNames");
		
		USceneBodySwitchFunctionLibrary_EnumerateValidSwitchNames_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (Names != nullptr)
			*Names = params.Names;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E6F830
	 * 		Name   -> Function GbxGameSystemCore.SceneBodySwitchFunctionLibrary.ChangeSwitchExternal
	 * 		Flags  -> (Final, BlueprintAuthorityOnly, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class AActor*                                      Actor                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FName                                        SwitchName                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FName                                        StateName                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void USceneBodySwitchFunctionLibrary::STATIC_ChangeSwitchExternal(class AActor* Actor, const class FName& SwitchName, const class FName& StateName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.SceneBodySwitchFunctionLibrary.ChangeSwitchExternal");
		
		USceneBodySwitchFunctionLibrary_ChangeSwitchExternal_Params params {};
		params.Actor = Actor;
		params.SwitchName = SwitchName;
		params.StateName = StateName;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E6F740
	 * 		Name   -> Function GbxGameSystemCore.SceneBodySwitchFunctionLibrary.ChangeSwitch
	 * 		Flags  -> (Final, BlueprintAuthorityOnly, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UObject*                                     Context                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FName                                        SwitchName                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FName                                        StateName                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void USceneBodySwitchFunctionLibrary::STATIC_ChangeSwitch(class UObject* Context, const class FName& SwitchName, const class FName& StateName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.SceneBodySwitchFunctionLibrary.ChangeSwitch");
		
		USceneBodySwitchFunctionLibrary_ChangeSwitch_Params params {};
		params.Context = Context;
		params.SwitchName = SwitchName;
		params.StateName = StateName;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction USceneBodySwitchFunctionLibrary.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* USceneBodySwitchFunctionLibrary::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.SceneBodySwitchFunctionLibrary");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction USceneBodySwitchManagerComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* USceneBodySwitchManagerComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.SceneBodySwitchManagerComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E70C10
	 * 		Name   -> Function GbxGameSystemCore.ScreenParticleManagerComponent.ShowScreenParticleForActor
	 * 		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		class AActor*                                      Actor                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UParticleSystem*                             Template                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bHideWhenFinished                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector2D                                   ContentDims                                                (Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              ParticleDepth                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EScreenParticleScalingMode                         ScalingMode                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bOnlyOwnerSee                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bAlwaysVisible                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FName                                        Tag                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bAllowMultipleInstances                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bServerAuthority                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bTickEvenWhenPaused                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bHideDuringInGameMenu                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UScreenParticleManagerComponent::STATIC_ShowScreenParticleForActor(class AActor* Actor, class UParticleSystem* Template, bool bHideWhenFinished, const struct FVector2D& ContentDims, float ParticleDepth, EScreenParticleScalingMode ScalingMode, bool bOnlyOwnerSee, bool bAlwaysVisible, const class FName& Tag, bool bAllowMultipleInstances, bool bServerAuthority, bool bTickEvenWhenPaused, bool bHideDuringInGameMenu)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.ScreenParticleManagerComponent.ShowScreenParticleForActor");
		
		UScreenParticleManagerComponent_ShowScreenParticleForActor_Params params {};
		params.Actor = Actor;
		params.Template = Template;
		params.bHideWhenFinished = bHideWhenFinished;
		params.ContentDims = ContentDims;
		params.ParticleDepth = ParticleDepth;
		params.ScalingMode = ScalingMode;
		params.bOnlyOwnerSee = bOnlyOwnerSee;
		params.bAlwaysVisible = bAlwaysVisible;
		params.Tag = Tag;
		params.bAllowMultipleInstances = bAllowMultipleInstances;
		params.bServerAuthority = bServerAuthority;
		params.bTickEvenWhenPaused = bTickEvenWhenPaused;
		params.bHideDuringInGameMenu = bHideDuringInGameMenu;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E70AD0
	 * 		Name   -> Function GbxGameSystemCore.ScreenParticleManagerComponent.OnScreenParticleFinished
	 * 		Flags  -> (Final, Native, Private)
	 * Parameters:
	 * 		class UParticleSystemComponent*                    Component                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UScreenParticleManagerComponent::OnScreenParticleFinished(class UParticleSystemComponent* Component)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.ScreenParticleManagerComponent.OnScreenParticleFinished");
		
		UScreenParticleManagerComponent_OnScreenParticleFinished_Params params {};
		params.Component = Component;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E70920
	 * 		Name   -> Function GbxGameSystemCore.ScreenParticleManagerComponent.HideScreenParticleForActor
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class AActor*                                      Actor                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UParticleSystem*                             Template                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FName                                        Tag                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bAllowParticleToFinish                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bServerAuthority                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UScreenParticleManagerComponent::STATIC_HideScreenParticleForActor(class AActor* Actor, class UParticleSystem* Template, const class FName& Tag, bool bAllowParticleToFinish, bool bServerAuthority)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.ScreenParticleManagerComponent.HideScreenParticleForActor");
		
		UScreenParticleManagerComponent_HideScreenParticleForActor_Params params {};
		params.Actor = Actor;
		params.Template = Template;
		params.Tag = Tag;
		params.bAllowParticleToFinish = bAllowParticleToFinish;
		params.bServerAuthority = bServerAuthority;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E705A0
	 * 		Name   -> Function GbxGameSystemCore.ScreenParticleManagerComponent.ClientTrackParticleProperty
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetClient, BlueprintCallable)
	 * Parameters:
	 * 		class UParticlePropertyTrackingData*               TrackingData                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UParticleSystem*                             Template                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FName                                        Tag                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FName                                        PropertyName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              PropertyValue                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bAddToValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UMaterialInterface*                          UsedMaterialProperty                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FName                                        MaterialPropertyName                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UScreenParticleManagerComponent::ClientTrackParticleProperty(class UParticlePropertyTrackingData* TrackingData, class UParticleSystem* Template, const class FName& Tag, const class FName& PropertyName, float PropertyValue, bool bAddToValue, class UMaterialInterface* UsedMaterialProperty, const class FName& MaterialPropertyName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.ScreenParticleManagerComponent.ClientTrackParticleProperty");
		
		UScreenParticleManagerComponent_ClientTrackParticleProperty_Params params {};
		params.TrackingData = TrackingData;
		params.Template = Template;
		params.Tag = Tag;
		params.PropertyName = PropertyName;
		params.PropertyValue = PropertyValue;
		params.bAddToValue = bAddToValue;
		params.UsedMaterialProperty = UsedMaterialProperty;
		params.MaterialPropertyName = MaterialPropertyName;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E703E0
	 * 		Name   -> Function GbxGameSystemCore.ScreenParticleManagerComponent.ClientShowScreenParticleEx
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, HasDefaults, NetClient)
	 * Parameters:
	 * 		class UParticleSystem*                             Template                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		unsigned char                                      InitFlags                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector2D                                   ContentDims                                                (Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              ParticleDepth                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EScreenParticleScalingMode                         ScalingMode                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FName                                        Tag                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UScreenParticleManagerComponent::ClientShowScreenParticleEx(class UParticleSystem* Template, unsigned char InitFlags, const struct FVector2D& ContentDims, float ParticleDepth, EScreenParticleScalingMode ScalingMode, const class FName& Tag)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.ScreenParticleManagerComponent.ClientShowScreenParticleEx");
		
		UScreenParticleManagerComponent_ClientShowScreenParticleEx_Params params {};
		params.Template = Template;
		params.InitFlags = InitFlags;
		params.ContentDims = ContentDims;
		params.ParticleDepth = ParticleDepth;
		params.ScalingMode = ScalingMode;
		params.Tag = Tag;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E70080
	 * 		Name   -> Function GbxGameSystemCore.ScreenParticleManagerComponent.ClientShowScreenParticle
	 * 		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		class UParticleSystem*                             Template                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bHideWhenFinished                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector2D                                   ContentDims                                                (Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              ParticleDepth                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EScreenParticleScalingMode                         ScalingMode                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bOnlyOwnerSee                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bAlwaysVisible                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FName                                        Tag                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bAllowMultipleInstances                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bTickEvenWhenPaused                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bHideDuringInGameMenu                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bDepthPriorityWorld                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UScreenParticleManagerComponent::ClientShowScreenParticle(class UParticleSystem* Template, bool bHideWhenFinished, const struct FVector2D& ContentDims, float ParticleDepth, EScreenParticleScalingMode ScalingMode, bool bOnlyOwnerSee, bool bAlwaysVisible, const class FName& Tag, bool bAllowMultipleInstances, bool bTickEvenWhenPaused, bool bHideDuringInGameMenu, bool bDepthPriorityWorld)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.ScreenParticleManagerComponent.ClientShowScreenParticle");
		
		UScreenParticleManagerComponent_ClientShowScreenParticle_Params params {};
		params.Template = Template;
		params.bHideWhenFinished = bHideWhenFinished;
		params.ContentDims = ContentDims;
		params.ParticleDepth = ParticleDepth;
		params.ScalingMode = ScalingMode;
		params.bOnlyOwnerSee = bOnlyOwnerSee;
		params.bAlwaysVisible = bAlwaysVisible;
		params.Tag = Tag;
		params.bAllowMultipleInstances = bAllowMultipleInstances;
		params.bTickEvenWhenPaused = bTickEvenWhenPaused;
		params.bHideDuringInGameMenu = bHideDuringInGameMenu;
		params.bDepthPriorityWorld = bDepthPriorityWorld;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E6FF30
	 * 		Name   -> Function GbxGameSystemCore.ScreenParticleManagerComponent.ClientSetScreenParticleVectorParameter
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, HasDefaults, NetClient, BlueprintCallable)
	 * Parameters:
	 * 		class UParticleSystem*                             Template                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FName                                        Tag                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FName                                        ParameterName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     Param                                                      (Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UScreenParticleManagerComponent::ClientSetScreenParticleVectorParameter(class UParticleSystem* Template, const class FName& Tag, const class FName& ParameterName, const struct FVector& Param)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.ScreenParticleManagerComponent.ClientSetScreenParticleVectorParameter");
		
		UScreenParticleManagerComponent_ClientSetScreenParticleVectorParameter_Params params {};
		params.Template = Template;
		params.Tag = Tag;
		params.ParameterName = ParameterName;
		params.Param = Param;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E6FDF0
	 * 		Name   -> Function GbxGameSystemCore.ScreenParticleManagerComponent.ClientSetScreenParticleMaterialParameter
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetClient, BlueprintCallable)
	 * Parameters:
	 * 		class UParticleSystem*                             Template                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FName                                        Tag                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FName                                        ParameterName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UMaterialInterface*                          Param                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UScreenParticleManagerComponent::ClientSetScreenParticleMaterialParameter(class UParticleSystem* Template, const class FName& Tag, const class FName& ParameterName, class UMaterialInterface* Param)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.ScreenParticleManagerComponent.ClientSetScreenParticleMaterialParameter");
		
		UScreenParticleManagerComponent_ClientSetScreenParticleMaterialParameter_Params params {};
		params.Template = Template;
		params.Tag = Tag;
		params.ParameterName = ParameterName;
		params.Param = Param;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E6FCB0
	 * 		Name   -> Function GbxGameSystemCore.ScreenParticleManagerComponent.ClientSetScreenParticleFloatParameter
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetClient, BlueprintCallable)
	 * Parameters:
	 * 		class UParticleSystem*                             Template                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FName                                        Tag                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FName                                        ParameterName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Param                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UScreenParticleManagerComponent::ClientSetScreenParticleFloatParameter(class UParticleSystem* Template, const class FName& Tag, const class FName& ParameterName, float Param)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.ScreenParticleManagerComponent.ClientSetScreenParticleFloatParameter");
		
		UScreenParticleManagerComponent_ClientSetScreenParticleFloatParameter_Params params {};
		params.Template = Template;
		params.Tag = Tag;
		params.ParameterName = ParameterName;
		params.Param = Param;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E6FB60
	 * 		Name   -> Function GbxGameSystemCore.ScreenParticleManagerComponent.ClientSetScreenParticleColorParameter
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, HasDefaults, NetClient, BlueprintCallable)
	 * Parameters:
	 * 		class UParticleSystem*                             Template                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FName                                        Tag                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FName                                        ParameterName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FLinearColor                                Param                                                      (Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UScreenParticleManagerComponent::ClientSetScreenParticleColorParameter(class UParticleSystem* Template, const class FName& Tag, const class FName& ParameterName, const struct FLinearColor& Param)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.ScreenParticleManagerComponent.ClientSetScreenParticleColorParameter");
		
		UScreenParticleManagerComponent_ClientSetScreenParticleColorParameter_Params params {};
		params.Template = Template;
		params.Tag = Tag;
		params.ParameterName = ParameterName;
		params.Param = Param;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E6FA20
	 * 		Name   -> Function GbxGameSystemCore.ScreenParticleManagerComponent.ClientSetScreenParticleActorParameter
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetClient, BlueprintCallable)
	 * Parameters:
	 * 		class UParticleSystem*                             Template                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FName                                        Tag                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FName                                        ParameterName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      Param                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UScreenParticleManagerComponent::ClientSetScreenParticleActorParameter(class UParticleSystem* Template, const class FName& Tag, const class FName& ParameterName, class AActor* Param)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.ScreenParticleManagerComponent.ClientSetScreenParticleActorParameter");
		
		UScreenParticleManagerComponent_ClientSetScreenParticleActorParameter_Params params {};
		params.Template = Template;
		params.Tag = Tag;
		params.ParameterName = ParameterName;
		params.Param = Param;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E6F920
	 * 		Name   -> Function GbxGameSystemCore.ScreenParticleManagerComponent.ClientHideScreenParticle
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetClient, BlueprintCallable)
	 * Parameters:
	 * 		class UParticleSystem*                             Template                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FName                                        Tag                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bAllowParticleToFinish                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UScreenParticleManagerComponent::ClientHideScreenParticle(class UParticleSystem* Template, const class FName& Tag, bool bAllowParticleToFinish)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.ScreenParticleManagerComponent.ClientHideScreenParticle");
		
		UScreenParticleManagerComponent_ClientHideScreenParticle_Params params {};
		params.Template = Template;
		params.Tag = Tag;
		params.bAllowParticleToFinish = bAllowParticleToFinish;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UScreenParticleManagerComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UScreenParticleManagerComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.ScreenParticleManagerComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction USenseConfigProviderInterface.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* USenseConfigProviderInterface::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.SenseConfigProviderInterface");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction USignificanceInterface.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* USignificanceInterface::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.SignificanceInterface");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction USimpleMathValueResolver.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* USimpleMathValueResolver::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.SimpleMathValueResolver");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction USocketComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* USocketComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.SocketComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction USpawnSimulatedActorSwitchAction.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* USpawnSimulatedActorSwitchAction::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.SpawnSimulatedActorSwitchAction");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction USprintData.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* USprintData::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.SprintData");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E74F00
	 * 		Name   -> Function GbxGameSystemCore.StanceBlueprintLibrary.TryGetStanceComponent
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class AAIController*                               AIController                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UStanceComponent* UStanceBlueprintLibrary::STATIC_TryGetStanceComponent(class AAIController* AIController)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.StanceBlueprintLibrary.TryGetStanceComponent");
		
		UStanceBlueprintLibrary_TryGetStanceComponent_Params params {};
		params.AIController = AIController;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E74C40
	 * 		Name   -> Function GbxGameSystemCore.StanceBlueprintLibrary.SetStance
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class AActor*                                      Target                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UStanceDataProvider*                         Stance                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UStanceBlueprintLibrary::STATIC_SetStance(class AActor* Target, class UStanceDataProvider* Stance)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.StanceBlueprintLibrary.SetStance");
		
		UStanceBlueprintLibrary_SetStance_Params params {};
		params.Target = Target;
		params.Stance = Stance;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E748D0
	 * 		Name   -> Function GbxGameSystemCore.StanceBlueprintLibrary.IsStanceComponentInStance
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class UStanceComponent*                            StanceComponent                                            (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UStanceDataProvider*                         Stance                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UStanceBlueprintLibrary::STATIC_IsStanceComponentInStance(class UStanceComponent* StanceComponent, class UStanceDataProvider* Stance)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.StanceBlueprintLibrary.IsStanceComponentInStance");
		
		UStanceBlueprintLibrary_IsStanceComponentInStance_Params params {};
		params.StanceComponent = StanceComponent;
		params.Stance = Stance;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E74660
	 * 		Name   -> Function GbxGameSystemCore.StanceBlueprintLibrary.IsInStance
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class UAnimInstance*                               AnimInstance                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UStanceDataProvider*                         Stance                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UStanceBlueprintLibrary::STATIC_IsInStance(class UAnimInstance* AnimInstance, class UStanceDataProvider* Stance)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.StanceBlueprintLibrary.IsInStance");
		
		UStanceBlueprintLibrary_IsInStance_Params params {};
		params.AnimInstance = AnimInstance;
		params.Stance = Stance;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x021D9A20
	 * 		Name   -> Function GbxGameSystemCore.StanceBlueprintLibrary.EqualEqual_StanceTypeStanceType
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class UStanceType*                                 A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UStanceType*                                 B                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UStanceBlueprintLibrary::STATIC_EqualEqual_StanceTypeStanceType(class UStanceType* A, class UStanceType* B)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.StanceBlueprintLibrary.EqualEqual_StanceTypeStanceType");
		
		UStanceBlueprintLibrary_EqualEqual_StanceTypeStanceType_Params params {};
		params.A = A;
		params.B = B;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x021D9A20
	 * 		Name   -> Function GbxGameSystemCore.StanceBlueprintLibrary.EqualEqual_StanceDataStanceData
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class UStanceData*                                 A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UStanceData*                                 B                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UStanceBlueprintLibrary::STATIC_EqualEqual_StanceDataStanceData(class UStanceData* A, class UStanceData* B)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.StanceBlueprintLibrary.EqualEqual_StanceDataStanceData");
		
		UStanceBlueprintLibrary_EqualEqual_StanceDataStanceData_Params params {};
		params.A = A;
		params.B = B;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E74390
	 * 		Name   -> Function GbxGameSystemCore.StanceBlueprintLibrary.ClearStance
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class AActor*                                      Target                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UStanceBlueprintLibrary::STATIC_ClearStance(class AActor* Target)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.StanceBlueprintLibrary.ClearStance");
		
		UStanceBlueprintLibrary_ClearStance_Params params {};
		params.Target = Target;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UStanceBlueprintLibrary.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UStanceBlueprintLibrary::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.StanceBlueprintLibrary");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E74DB0
	 * 		Name   -> Function GbxGameSystemCore.StanceComponent.StackStanceChangedCallback
	 * 		Flags  -> (Final, Native, Private)
	 * Parameters:
	 * 		EStanceStackLayer                                  PreviousLayer                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UStanceData*                                 PreviousStance                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EStanceStackLayer                                  NextLayer                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UStanceData*                                 NextStance                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UStanceComponent::StackStanceChangedCallback(EStanceStackLayer PreviousLayer, class UStanceData* PreviousStance, EStanceStackLayer NextLayer, class UStanceData* NextStance)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.StanceComponent.StackStanceChangedCallback");
		
		UStanceComponent_StackStanceChangedCallback_Params params {};
		params.PreviousLayer = PreviousLayer;
		params.PreviousStance = PreviousStance;
		params.NextLayer = NextLayer;
		params.NextStance = NextStance;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E74CF0
	 * 		Name   -> Function GbxGameSystemCore.StanceComponent.SetStanceLayer
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		EStanceStackLayer                                  Layer                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UStanceDataProvider*                         NewStance                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UStanceComponent::SetStanceLayer(EStanceStackLayer Layer, class UStanceDataProvider* NewStance)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.StanceComponent.SetStanceLayer");
		
		UStanceComponent_SetStanceLayer_Params params {};
		params.Layer = Layer;
		params.NewStance = NewStance;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E74BC0
	 * 		Name   -> Function GbxGameSystemCore.StanceComponent.SetBlueprintStance
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UStanceDataProvider*                         NewStance                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UStanceComponent::SetBlueprintStance(class UStanceDataProvider* NewStance)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.StanceComponent.SetBlueprintStance");
		
		UStanceComponent_SetBlueprintStance_Params params {};
		params.NewStance = NewStance;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E74990
	 * 		Name   -> Function GbxGameSystemCore.StanceComponent.OnRep_StanceState
	 * 		Flags  -> (Final, Native, Private)
	 */
	void UStanceComponent::OnRep_StanceState()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.StanceComponent.OnRep_StanceState");
		
		UStanceComponent_OnRep_StanceState_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E74840
	 * 		Name   -> Function GbxGameSystemCore.StanceComponent.IsInStanceType
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		class UStanceType*                                 Type                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UStanceComponent::IsInStanceType(class UStanceType* Type)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.StanceComponent.IsInStanceType");
		
		UStanceComponent_IsInStanceType_Params params {};
		params.Type = Type;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E747B0
	 * 		Name   -> Function GbxGameSystemCore.StanceComponent.IsInStanceLayer
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		EStanceStackLayer                                  Layer                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UStanceComponent::IsInStanceLayer(EStanceStackLayer Layer)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.StanceComponent.IsInStanceLayer");
		
		UStanceComponent_IsInStanceLayer_Params params {};
		params.Layer = Layer;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E74720
	 * 		Name   -> Function GbxGameSystemCore.StanceComponent.IsInStance
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		class UStanceDataProvider*                         Stance                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UStanceComponent::IsInStance(class UStanceDataProvider* Stance)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.StanceComponent.IsInStance");
		
		UStanceComponent_IsInStance_Params params {};
		params.Stance = Stance;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E745D0
	 * 		Name   -> Function GbxGameSystemCore.StanceComponent.IsInAnimStance
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		class UStanceDataProvider*                         Stance                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UStanceComponent::IsInAnimStance(class UStanceDataProvider* Stance)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.StanceComponent.IsInAnimStance");
		
		UStanceComponent_IsInAnimStance_Params params {};
		params.Stance = Stance;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E745A0
	 * 		Name   -> Function GbxGameSystemCore.StanceComponent.GetTimeSpentInCurrentStance
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	float UStanceComponent::GetTimeSpentInCurrentStance()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.StanceComponent.GetTimeSpentInCurrentStance");
		
		UStanceComponent_GetTimeSpentInCurrentStance_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x014C50D0
	 * 		Name   -> Function GbxGameSystemCore.StanceComponent.GetStanceLayer
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	EStanceStackLayer UStanceComponent::GetStanceLayer()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.StanceComponent.GetStanceLayer");
		
		UStanceComponent_GetStanceLayer_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x014CA380
	 * 		Name   -> Function GbxGameSystemCore.StanceComponent.GetStance
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	class UStanceData* UStanceComponent::GetStance()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.StanceComponent.GetStance");
		
		UStanceComponent_GetStance_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E74510
	 * 		Name   -> Function GbxGameSystemCore.StanceComponent.FindTypeForStance
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		class UStanceData*                                 Stance                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UStanceType* UStanceComponent::FindTypeForStance(class UStanceData* Stance)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.StanceComponent.FindTypeForStance");
		
		UStanceComponent_FindTypeForStance_Params params {};
		params.Stance = Stance;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E74480
	 * 		Name   -> Function GbxGameSystemCore.StanceComponent.FindStanceForType
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		class UStanceType*                                 Type                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UStanceData* UStanceComponent::FindStanceForType(class UStanceType* Type)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.StanceComponent.FindStanceForType");
		
		UStanceComponent_FindStanceForType_Params params {};
		params.Type = Type;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E74400
	 * 		Name   -> Function GbxGameSystemCore.StanceComponent.ClearStanceLayer
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		EStanceStackLayer                                  Layer                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UStanceComponent::ClearStanceLayer(EStanceStackLayer Layer)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.StanceComponent.ClearStanceLayer");
		
		UStanceComponent_ClearStanceLayer_Params params {};
		params.Layer = Layer;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E74370
	 * 		Name   -> Function GbxGameSystemCore.StanceComponent.ClearBlueprintStance
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void UStanceComponent::ClearBlueprintStance()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.StanceComponent.ClearBlueprintStance");
		
		UStanceComponent_ClearBlueprintStance_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UStanceComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UStanceComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.StanceComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UStanceType.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UStanceType::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.StanceType");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0178F8F0
	 * 		Name   -> Function GbxGameSystemCore.StatusEffect.OnEndEffect
	 * 		Flags  -> (Event, Public, BlueprintEvent, Const)
	 * Parameters:
	 * 		class AActor*                                      Target                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UStatusEffect::OnEndEffect(class AActor* Target)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.StatusEffect.OnEndEffect");
		
		UStatusEffect_OnEndEffect_Params params {};
		params.Target = Target;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0178F8F0
	 * 		Name   -> Function GbxGameSystemCore.StatusEffect.OnBeginEffect
	 * 		Flags  -> (Event, Public, BlueprintEvent, Const)
	 * Parameters:
	 * 		class AActor*                                      Target                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UStatusEffect::OnBeginEffect(class AActor* Target)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.StatusEffect.OnBeginEffect");
		
		UStatusEffect_OnBeginEffect_Params params {};
		params.Target = Target;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UStatusEffect.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UStatusEffect::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.StatusEffect");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UStatusEffectModifierAttributePropertyValueResolver.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UStatusEffectModifierAttributePropertyValueResolver::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.StatusEffectModifierAttributePropertyValueResolver");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UStatusEffectStackingStrategyData_Capped.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UStatusEffectStackingStrategyData_Capped::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.StatusEffectStackingStrategyData_Capped");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E79580
	 * 		Name   -> Function GbxGameSystemCore.TargetableComponent.SetTargetUIName
	 * 		Flags  -> (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UGbxUIName*                                  NewTargetUIName                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UTargetableComponent::SetTargetUIName(class UGbxUIName* NewTargetUIName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.TargetableComponent.SetTargetUIName");
		
		UTargetableComponent_SetTargetUIName_Params params {};
		params.NewTargetUIName = NewTargetUIName;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E794B0
	 * 		Name   -> Function GbxGameSystemCore.TargetableComponent.SetTargetName
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		class FText                                        NewTargetName                                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UTargetableComponent::SetTargetName(const class FText& NewTargetName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.TargetableComponent.SetTargetName");
		
		UTargetableComponent_SetTargetName_Params params {};
		params.NewTargetName = NewTargetName;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E79430
	 * 		Name   -> Function GbxGameSystemCore.TargetableComponent.SetIsTargetableByNonPlayers
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               IsTargetable                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UTargetableComponent::SetIsTargetableByNonPlayers(bool IsTargetable)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.TargetableComponent.SetIsTargetableByNonPlayers");
		
		UTargetableComponent_SetIsTargetableByNonPlayers_Params params {};
		params.IsTargetable = IsTargetable;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E793B0
	 * 		Name   -> Function GbxGameSystemCore.TargetableComponent.SetIsTargetableByHumanPlayers
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               IsTargetable                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UTargetableComponent::SetIsTargetableByHumanPlayers(bool IsTargetable)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.TargetableComponent.SetIsTargetableByHumanPlayers");
		
		UTargetableComponent_SetIsTargetableByHumanPlayers_Params params {};
		params.IsTargetable = IsTargetable;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E79330
	 * 		Name   -> Function GbxGameSystemCore.TargetableComponent.SetIsTargetableByAIPlayers
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               IsTargetable                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UTargetableComponent::SetIsTargetableByAIPlayers(bool IsTargetable)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.TargetableComponent.SetIsTargetableByAIPlayers");
		
		UTargetableComponent_SetIsTargetableByAIPlayers_Params params {};
		params.IsTargetable = IsTargetable;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E792B0
	 * 		Name   -> Function GbxGameSystemCore.TargetableComponent.SetIsTargetable
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               IsTargetable                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UTargetableComponent::SetIsTargetable(bool IsTargetable)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.TargetableComponent.SetIsTargetable");
		
		UTargetableComponent_SetIsTargetable_Params params {};
		params.IsTargetable = IsTargetable;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E78F30
	 * 		Name   -> Function GbxGameSystemCore.TargetableComponent.OnRep_TargetUIName
	 * 		Flags  -> (Final, Native, Private)
	 */
	void UTargetableComponent::OnRep_TargetUIName()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.TargetableComponent.OnRep_TargetUIName");
		
		UTargetableComponent_OnRep_TargetUIName_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E78EA0
	 * 		Name   -> Function GbxGameSystemCore.TargetableComponent.IsTargetableByPawn
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		class APawn*                                       Pawn                                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UTargetableComponent::IsTargetableByPawn(class APawn* Pawn)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.TargetableComponent.IsTargetableByPawn");
		
		UTargetableComponent_IsTargetableByPawn_Params params {};
		params.Pawn = Pawn;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E78E40
	 * 		Name   -> Function GbxGameSystemCore.TargetableComponent.IsTargetableByNonPlayers
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool UTargetableComponent::IsTargetableByNonPlayers()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.TargetableComponent.IsTargetableByNonPlayers");
		
		UTargetableComponent_IsTargetableByNonPlayers_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E78DE0
	 * 		Name   -> Function GbxGameSystemCore.TargetableComponent.IsTargetableByHumanPlayers
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool UTargetableComponent::IsTargetableByHumanPlayers()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.TargetableComponent.IsTargetableByHumanPlayers");
		
		UTargetableComponent_IsTargetableByHumanPlayers_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E78D50
	 * 		Name   -> Function GbxGameSystemCore.TargetableComponent.IsTargetableByController
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		class AController*                                 Controller                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UTargetableComponent::IsTargetableByController(class AController* Controller)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.TargetableComponent.IsTargetableByController");
		
		UTargetableComponent_IsTargetableByController_Params params {};
		params.Controller = Controller;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E78C60
	 * 		Name   -> Function GbxGameSystemCore.TargetableComponent.IsTargetableByAIPlayers
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool UTargetableComponent::IsTargetableByAIPlayers()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.TargetableComponent.IsTargetableByAIPlayers");
		
		UTargetableComponent_IsTargetableByAIPlayers_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E78CC0
	 * 		Name   -> Function GbxGameSystemCore.TargetableComponent.IsTargetableByActor
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		class AActor*                                      Actor                                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UTargetableComponent::IsTargetableByActor(class AActor* Actor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.TargetableComponent.IsTargetableByActor");
		
		UTargetableComponent_IsTargetableByActor_Params params {};
		params.Actor = Actor;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E78C10
	 * 		Name   -> Function GbxGameSystemCore.TargetableComponent.IsTargetable
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool UTargetableComponent::IsTargetable()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.TargetableComponent.IsTargetable");
		
		UTargetableComponent_IsTargetable_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E785B0
	 * 		Name   -> Function GbxGameSystemCore.TargetableComponent.GetTargetSocketName
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	class FName UTargetableComponent::GetTargetSocketName()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.TargetableComponent.GetTargetSocketName");
		
		UTargetableComponent_GetTargetSocketName_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007A5960
	 * 		Name   -> Function GbxGameSystemCore.TargetableComponent.GetTargetProxyComponentNames
	 * 		Flags  -> (Final, Native, Private, HasOutParms, Const)
	 * Parameters:
	 * 		TArray<class FName>                                Array                                                      (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	 */
	void UTargetableComponent::GetTargetProxyComponentNames(TArray<class FName>* Array)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.TargetableComponent.GetTargetProxyComponentNames");
		
		UTargetableComponent_GetTargetProxyComponentNames_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (Array != nullptr)
			*Array = params.Array;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E78530
	 * 		Name   -> Function GbxGameSystemCore.TargetableComponent.GetTargetNameString
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	class FString UTargetableComponent::GetTargetNameString()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.TargetableComponent.GetTargetNameString");
		
		UTargetableComponent_GetTargetNameString_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E78310
	 * 		Name   -> Function GbxGameSystemCore.TargetableComponent.GetTargetLocations
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	TArray<struct FVector> UTargetableComponent::GetTargetLocations()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.TargetableComponent.GetTargetLocations");
		
		UTargetableComponent_GetTargetLocations_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E781F0
	 * 		Name   -> Function GbxGameSystemCore.TargetableComponent.GetTargetLocation
	 * 		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
	 */
	struct FVector UTargetableComponent::GetTargetLocation()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.TargetableComponent.GetTargetLocation");
		
		UTargetableComponent_GetTargetLocation_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E77970
	 * 		Name   -> Function GbxGameSystemCore.TargetableComponent.GetClosestTargetLocation
	 * 		Flags  -> (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		struct FVector                                     Origin                                                     (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     Direction                                                  (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FVector UTargetableComponent::GetClosestTargetLocation(const struct FVector& Origin, const struct FVector& Direction)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.TargetableComponent.GetClosestTargetLocation");
		
		UTargetableComponent_GetClosestTargetLocation_Params params {};
		params.Origin = Origin;
		params.Direction = Direction;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x007A5960
	 * 		Name   -> Function GbxGameSystemCore.TargetableComponent.GetAvailableSocketNames
	 * 		Flags  -> (Final, Native, Private, HasOutParms, Const)
	 * Parameters:
	 * 		TArray<class FName>                                Array                                                      (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	 */
	void UTargetableComponent::GetAvailableSocketNames(TArray<class FName>* Array)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.TargetableComponent.GetAvailableSocketNames");
		
		UTargetableComponent_GetAvailableSocketNames_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (Array != nullptr)
			*Array = params.Array;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UTargetableComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UTargetableComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.TargetableComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E78AC0
	 * 		Name   -> Function GbxGameSystemCore.TargetActorInfoLibrary.IsSenseActive
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FTargetActorInfo                            Info                                                       (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 * 		class UClass*                                      Sense                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UTargetActorInfoLibrary::STATIC_IsSenseActive(const struct FTargetActorInfo& Info, class UClass* Sense)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.TargetActorInfoLibrary.IsSenseActive");
		
		UTargetActorInfoLibrary_IsSenseActive_Params params {};
		params.Info = Info;
		params.Sense = Sense;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E789F0
	 * 		Name   -> Function GbxGameSystemCore.TargetActorInfoLibrary.IsExistingTarget
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FTargetActorInfo                            Info                                                       (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	bool UTargetActorInfoLibrary::STATIC_IsExistingTarget(const struct FTargetActorInfo& Info)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.TargetActorInfoLibrary.IsExistingTarget");
		
		UTargetActorInfoLibrary_IsExistingTarget_Params params {};
		params.Info = Info;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E78930
	 * 		Name   -> Function GbxGameSystemCore.TargetActorInfoLibrary.IsDirectlySensed
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FTargetActorInfo                            Info                                                       (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	bool UTargetActorInfoLibrary::STATIC_IsDirectlySensed(const struct FTargetActorInfo& Info)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.TargetActorInfoLibrary.IsDirectlySensed");
		
		UTargetActorInfoLibrary_IsDirectlySensed_Params params {};
		params.Info = Info;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E78690
	 * 		Name   -> Function GbxGameSystemCore.TargetActorInfoLibrary.HasStimulusForSense
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FTargetActorInfo                            Info                                                       (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 * 		class UClass*                                      Sense                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UTargetActorInfoLibrary::STATIC_HasStimulusForSense(const struct FTargetActorInfo& Info, class UClass* Sense)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.TargetActorInfoLibrary.HasStimulusForSense");
		
		UTargetActorInfoLibrary_HasStimulusForSense_Params params {};
		params.Info = Info;
		params.Sense = Sense;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E785D0
	 * 		Name   -> Function GbxGameSystemCore.TargetActorInfoLibrary.HasAnyKnownStimuli
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FTargetActorInfo                            Info                                                       (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	bool UTargetActorInfoLibrary::STATIC_HasAnyKnownStimuli(const struct FTargetActorInfo& Info)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.TargetActorInfoLibrary.HasAnyKnownStimuli");
		
		UTargetActorInfoLibrary_HasAnyKnownStimuli_Params params {};
		params.Info = Info;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E77DD0
	 * 		Name   -> Function GbxGameSystemCore.TargetActorInfoLibrary.GetStimulusLocation
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FTargetActorInfo                            Info                                                       (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 * 		class UClass*                                      Sense                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FVector UTargetActorInfoLibrary::STATIC_GetStimulusLocation(const struct FTargetActorInfo& Info, class UClass* Sense)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.TargetActorInfoLibrary.GetStimulusLocation");
		
		UTargetActorInfoLibrary_GetStimulusLocation_Params params {};
		params.Info = Info;
		params.Sense = Sense;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E77BF0
	 * 		Name   -> Function GbxGameSystemCore.TargetActorInfoLibrary.GetStimulusForSense
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FTargetActorInfo                            Info                                                       (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 * 		class UClass*                                      Sense                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FAIStimulus                                 Stimulus                                                   (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	bool UTargetActorInfoLibrary::STATIC_GetStimulusForSense(const struct FTargetActorInfo& Info, class UClass* Sense, struct FAIStimulus* Stimulus)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.TargetActorInfoLibrary.GetStimulusForSense");
		
		UTargetActorInfoLibrary_GetStimulusForSense_Params params {};
		params.Info = Info;
		params.Sense = Sense;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (Stimulus != nullptr)
			*Stimulus = params.Stimulus;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E77A80
	 * 		Name   -> Function GbxGameSystemCore.TargetActorInfoLibrary.GetReceiverLocation
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FTargetActorInfo                            Info                                                       (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 * 		class UClass*                                      Sense                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FVector UTargetActorInfoLibrary::STATIC_GetReceiverLocation(const struct FTargetActorInfo& Info, class UClass* Sense)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.TargetActorInfoLibrary.GetReceiverLocation");
		
		UTargetActorInfoLibrary_GetReceiverLocation_Params params {};
		params.Info = Info;
		params.Sense = Sense;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E774E0
	 * 		Name   -> Function GbxGameSystemCore.TargetActorInfoLibrary.GetBestStimulusLocation
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FTargetActorInfo                            Info                                                       (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 * 		float                                              Age                                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FVector UTargetActorInfoLibrary::STATIC_GetBestStimulusLocation(const struct FTargetActorInfo& Info, float* Age)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.TargetActorInfoLibrary.GetBestStimulusLocation");
		
		UTargetActorInfoLibrary_GetBestStimulusLocation_Params params {};
		params.Info = Info;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (Age != nullptr)
			*Age = params.Age;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E773A0
	 * 		Name   -> Function GbxGameSystemCore.TargetActorInfoLibrary.GetBestStimulus
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FTargetActorInfo                            Info                                                       (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 * 		struct FAIStimulus                                 Stimulus                                                   (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	bool UTargetActorInfoLibrary::STATIC_GetBestStimulus(const struct FTargetActorInfo& Info, struct FAIStimulus* Stimulus)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.TargetActorInfoLibrary.GetBestStimulus");
		
		UTargetActorInfoLibrary_GetBestStimulus_Params params {};
		params.Info = Info;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (Stimulus != nullptr)
			*Stimulus = params.Stimulus;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E77190
	 * 		Name   -> Function GbxGameSystemCore.TargetActorInfoLibrary.GetBestAttackLocation
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FTargetActorInfo                            Info                                                       (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     OutTargetVelocity                                          (Parm, OutParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FVector UTargetActorInfoLibrary::STATIC_GetBestAttackLocation(const struct FTargetActorInfo& Info, struct FVector* OutTargetVelocity)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.TargetActorInfoLibrary.GetBestAttackLocation");
		
		UTargetActorInfoLibrary_GetBestAttackLocation_Params params {};
		params.Info = Info;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutTargetVelocity != nullptr)
			*OutTargetVelocity = params.OutTargetVelocity;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E77110
	 * 		Name   -> Function GbxGameSystemCore.TargetActorInfoLibrary.FindActorTargetingComponent
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class AActor*                                      Actor                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UTargetingComponent* UTargetActorInfoLibrary::STATIC_FindActorTargetingComponent(class AActor* Actor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.TargetActorInfoLibrary.FindActorTargetingComponent");
		
		UTargetActorInfoLibrary_FindActorTargetingComponent_Params params {};
		params.Actor = Actor;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UTargetActorInfoLibrary.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UTargetActorInfoLibrary::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.TargetActorInfoLibrary");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E791F0
	 * 		Name   -> Function GbxGameSystemCore.TargetingComponent.ServerSetBestTarget
	 * 		Flags  -> (Net, NetReliable, Native, Event, Protected, NetServer, NetValidate)
	 * Parameters:
	 * 		class AActor*                                      NewBestTarget                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UTargetingComponent::ServerSetBestTarget(class AActor* NewBestTarget)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.TargetingComponent.ServerSetBestTarget");
		
		UTargetingComponent_ServerSetBestTarget_Params params {};
		params.NewBestTarget = NewBestTarget;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E788A0
	 * 		Name   -> Function GbxGameSystemCore.TargetingComponent.IsBestTargetDirectlySensed
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		int32_t                                            TargetIndex                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UTargetingComponent::IsBestTargetDirectlySensed(int32_t TargetIndex)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.TargetingComponent.IsBestTargetDirectlySensed");
		
		UTargetingComponent_IsBestTargetDirectlySensed_Params params {};
		params.TargetIndex = TargetIndex;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E78870
	 * 		Name   -> Function GbxGameSystemCore.TargetingComponent.HasTargets
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool UTargetingComponent::HasTargets()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.TargetingComponent.HasTargets");
		
		UTargetingComponent_HasTargets_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E787E0
	 * 		Name   -> Function GbxGameSystemCore.TargetingComponent.HasTarget
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		class AActor*                                      Actor                                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UTargetingComponent::HasTarget(class AActor* Actor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.TargetingComponent.HasTarget");
		
		UTargetingComponent_HasTarget_Params params {};
		params.Actor = Actor;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E78230
	 * 		Name   -> Function GbxGameSystemCore.TargetingComponent.GetTargetLocationForActor
	 * 		Flags  -> (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		class AActor*                                      Actor                                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     TargetLocation                                             (Parm, OutParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UTargetingComponent::GetTargetLocationForActor(class AActor* Actor, struct FVector* TargetLocation)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.TargetingComponent.GetTargetLocationForActor");
		
		UTargetingComponent_GetTargetLocationForActor_Params params {};
		params.Actor = Actor;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (TargetLocation != nullptr)
			*TargetLocation = params.TargetLocation;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E780F0
	 * 		Name   -> Function GbxGameSystemCore.TargetingComponent.GetTargetInfoForActor
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		class AActor*                                      Actor                                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FTargetActorInfo                            TargetInfo                                                 (Parm, OutParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	bool UTargetingComponent::GetTargetInfoForActor(class AActor* Actor, struct FTargetActorInfo* TargetInfo)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.TargetingComponent.GetTargetInfoForActor");
		
		UTargetingComponent_GetTargetInfoForActor_Params params {};
		params.Actor = Actor;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (TargetInfo != nullptr)
			*TargetInfo = params.TargetInfo;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E780D0
	 * 		Name   -> Function GbxGameSystemCore.TargetingComponent.GetTargetInfoCount
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	int32_t UTargetingComponent::GetTargetInfoCount()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.TargetingComponent.GetTargetInfoCount");
		
		UTargetingComponent_GetTargetInfoCount_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E77FD0
	 * 		Name   -> Function GbxGameSystemCore.TargetingComponent.GetTargetInfoAt
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		int32_t                                            TargetIndex                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FTargetActorInfo                            TargetInfo                                                 (Parm, OutParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	bool UTargetingComponent::GetTargetInfoAt(int32_t TargetIndex, struct FTargetActorInfo* TargetInfo)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.TargetingComponent.GetTargetInfoAt");
		
		UTargetingComponent_GetTargetInfoAt_Params params {};
		params.TargetIndex = TargetIndex;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (TargetInfo != nullptr)
			*TargetInfo = params.TargetInfo;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E77F40
	 * 		Name   -> Function GbxGameSystemCore.TargetingComponent.GetTargetActorAt
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		int32_t                                            TargetIndex                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class AActor* UTargetingComponent::GetTargetActorAt(int32_t TargetIndex)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.TargetingComponent.GetTargetActorAt");
		
		UTargetingComponent_GetTargetActorAt_Params params {};
		params.TargetIndex = TargetIndex;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E778D0
	 * 		Name   -> Function GbxGameSystemCore.TargetingComponent.GetBestThreatActor
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		bool                                               bRequireFirsthandKnowledge                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class AActor* UTargetingComponent::GetBestThreatActor(bool bRequireFirsthandKnowledge)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.TargetingComponent.GetBestThreatActor");
		
		UTargetingComponent_GetBestThreatActor_Params params {};
		params.bRequireFirsthandKnowledge = bRequireFirsthandKnowledge;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E777A0
	 * 		Name   -> Function GbxGameSystemCore.TargetingComponent.GetBestTargetLocation
	 * 		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		int32_t                                            TargetIndex                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FVector UTargetingComponent::GetBestTargetLocation(int32_t TargetIndex)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.TargetingComponent.GetBestTargetLocation");
		
		UTargetingComponent_GetBestTargetLocation_Params params {};
		params.TargetIndex = TargetIndex;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E776A0
	 * 		Name   -> Function GbxGameSystemCore.TargetingComponent.GetBestTargetInfo
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		struct FTargetActorInfo                            TargetInfo                                                 (Parm, OutParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 * 		int32_t                                            TargetIndex                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UTargetingComponent::GetBestTargetInfo(struct FTargetActorInfo* TargetInfo, int32_t TargetIndex)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.TargetingComponent.GetBestTargetInfo");
		
		UTargetingComponent_GetBestTargetInfo_Params params {};
		params.TargetIndex = TargetIndex;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (TargetInfo != nullptr)
			*TargetInfo = params.TargetInfo;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E77610
	 * 		Name   -> Function GbxGameSystemCore.TargetingComponent.GetBestTargetActor
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		int32_t                                            TargetIndex                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class AActor* UTargetingComponent::GetBestTargetActor(int32_t TargetIndex)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.TargetingComponent.GetBestTargetActor");
		
		UTargetingComponent_GetBestTargetActor_Params params {};
		params.TargetIndex = TargetIndex;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E77840
	 * 		Name   -> Function GbxGameSystemCore.TargetingComponent.GetBestTargetableComponent
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		int32_t                                            TargetIndex                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UTargetableComponent* UTargetingComponent::GetBestTargetableComponent(int32_t TargetIndex)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.TargetingComponent.GetBestTargetableComponent");
		
		UTargetingComponent_GetBestTargetableComponent_Params params {};
		params.TargetIndex = TargetIndex;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E772B0
	 * 		Name   -> Function GbxGameSystemCore.TargetingComponent.GetBestAttackTargetLocation
	 * 		Flags  -> (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		struct FVector                                     OutTargetVelocity                                          (Parm, OutParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            TargetIndex                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FVector UTargetingComponent::GetBestAttackTargetLocation(struct FVector* OutTargetVelocity, int32_t TargetIndex)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.TargetingComponent.GetBestAttackTargetLocation");
		
		UTargetingComponent_GetBestAttackTargetLocation_Params params {};
		params.TargetIndex = TargetIndex;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutTargetVelocity != nullptr)
			*OutTargetVelocity = params.OutTargetVelocity;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E77000
	 * 		Name   -> Function GbxGameSystemCore.TargetingComponent.DoesBestTargetHaveStimulusForSense
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		class UClass*                                      Sense                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              MaxAge                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            TargetIndex                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UTargetingComponent::DoesBestTargetHaveStimulusForSense(class UClass* Sense, float MaxAge, int32_t TargetIndex)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.TargetingComponent.DoesBestTargetHaveStimulusForSense");
		
		UTargetingComponent_DoesBestTargetHaveStimulusForSense_Params params {};
		params.Sense = Sense;
		params.MaxAge = MaxAge;
		params.TargetIndex = TargetIndex;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UTargetingComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UTargetingComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.TargetingComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E7EEA0
	 * 		Name   -> Function GbxGameSystemCore.TargetingDebugServerRpcComponent.SetInspectedActor
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
	 * Parameters:
	 * 		class AActor*                                      Actor                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UTargetingDebugServerRpcComponent::SetInspectedActor(class AActor* Actor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.TargetingDebugServerRpcComponent.SetInspectedActor");
		
		UTargetingDebugServerRpcComponent_SetInspectedActor_Params params {};
		params.Actor = Actor;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UTargetingDebugServerRpcComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UTargetingDebugServerRpcComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.TargetingDebugServerRpcComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E7E3B0
	 * 		Name   -> Function GbxGameSystemCore.Team.GetAttitudeToward
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		class UTeam*                                       Team                                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	ETeamAttitude UTeam::GetAttitudeToward(class UTeam* Team)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.Team.GetAttitudeToward");
		
		UTeam_GetAttitudeToward_Params params {};
		params.Team = Team;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UTeam.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UTeam::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.Team");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UTeleportInterface.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UTeleportInterface::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.TeleportInterface");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UTerritoryComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UTerritoryComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.TerritoryComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UTrivialFoleyImplementationComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UTrivialFoleyImplementationComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.TrivialFoleyImplementationComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UUIStatData_Numeric_Formula.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UUIStatData_Numeric_Formula::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.UIStatData_Numeric_Formula");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UUIStatData_Text.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UUIStatData_Text::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.UIStatData_Text");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UUIStatAttributeEffectProvider.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UUIStatAttributeEffectProvider::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.UIStatAttributeEffectProvider");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UUsabilityDataSelection.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UUsabilityDataSelection::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.UsabilityDataSelection");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UUsableTypeDefinition.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UUsableTypeDefinition::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.UsableTypeDefinition");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E81970
	 * 		Name   -> Function GbxGameSystemCore.UserStatesInterface.HasEnableConditionsSetForAnyUserState
	 * 		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool UUserStatesInterface::HasEnableConditionsSetForAnyUserState()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.UserStatesInterface.HasEnableConditionsSetForAnyUserState");
		
		UUserStatesInterface_HasEnableConditionsSetForAnyUserState_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0178F8F0
	 * 		Name   -> Function GbxGameSystemCore.UserStatesInterface.BlueprintStateHandler
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		bool                                               bFromLoad                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UUserStatesInterface::BlueprintStateHandler(bool bFromLoad)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.UserStatesInterface.BlueprintStateHandler");
		
		UUserStatesInterface_BlueprintStateHandler_Params params {};
		params.bFromLoad = bFromLoad;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UUserStatesInterface.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UUserStatesInterface::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.UserStatesInterface");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E819A0
	 * 		Name   -> Function GbxGameSystemCore.UserStatesFunctionLibrary.HasEnableConditionsSetForSpecificUserState
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class UObject*                                     Context                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FName                                        UserStateProperty                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UUserStatesFunctionLibrary::STATIC_HasEnableConditionsSetForSpecificUserState(class UObject* Context, const class FName& UserStateProperty)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.UserStatesFunctionLibrary.HasEnableConditionsSetForSpecificUserState");
		
		UUserStatesFunctionLibrary_HasEnableConditionsSetForSpecificUserState_Params params {};
		params.Context = Context;
		params.UserStateProperty = UserStateProperty;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UUserStatesFunctionLibrary.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UUserStatesFunctionLibrary::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.UserStatesFunctionLibrary");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E81E10
	 * 		Name   -> Function GbxGameSystemCore.UseSystemFunctionLibrary.SetIsUsable
	 * 		Flags  -> (Final, BlueprintAuthorityOnly, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class AActor*                                      Actor                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bNewIsUsable                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UUseSystemFunctionLibrary::STATIC_SetIsUsable(class AActor* Actor, bool bNewIsUsable)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.UseSystemFunctionLibrary.SetIsUsable");
		
		UUseSystemFunctionLibrary_SetIsUsable_Params params {};
		params.Actor = Actor;
		params.bNewIsUsable = bNewIsUsable;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02E81A60
	 * 		Name   -> Function GbxGameSystemCore.UseSystemFunctionLibrary.ResetUseCount
	 * 		Flags  -> (Final, BlueprintAuthorityOnly, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class AActor*                                      Actor                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UUseSystemFunctionLibrary::STATIC_ResetUseCount(class AActor* Actor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function GbxGameSystemCore.UseSystemFunctionLibrary.ResetUseCount");
		
		UUseSystemFunctionLibrary_ResetUseCount_Params params {};
		params.Actor = Actor;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UUseSystemFunctionLibrary.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UUseSystemFunctionLibrary::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.UseSystemFunctionLibrary");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UWeaponInterface.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UWeaponInterface::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.WeaponInterface");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UWeaponUserInterface.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UWeaponUserInterface::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.WeaponUserInterface");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UWeatherTemplate.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UWeatherTemplate::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class GbxGameSystemCore.WeatherTemplate");
		return ptr;
	}

}


