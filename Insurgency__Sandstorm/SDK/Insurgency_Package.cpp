/**
 * Name: Insurgency__Sandstorm
 * Version: 8846794
 */

#include "../SDK.h"

namespace CG
{
	// --------------------------------------------------
	// # Structs Functions
	// --------------------------------------------------
	/**
	 * Function:
	 * 		RVA    -> 0x04DB4AC0
	 * 		Name   -> Function Insurgency.DynamicNavModifierVolume.ActivateNavModifer
	 * 		Flags  -> (Native, Protected, BlueprintCallable)
	 */
	void ADynamicNavModifierVolume::ActivateNavModifer()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.DynamicNavModifierVolume.ActivateNavModifer");
		
		ADynamicNavModifierVolume_ActivateNavModifer_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ADynamicNavModifierVolume.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ADynamicNavModifierVolume::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.DynamicNavModifierVolume");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AAccurateDynamicNavModifierVolume.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AAccurateDynamicNavModifierVolume::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.AccurateDynamicNavModifierVolume");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UAchievementDataAsset.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UAchievementDataAsset::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.AchievementDataAsset");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0561D8E0
	 * 		Name   -> Function Insurgency.ActiveObjectiveDisplay.UpdatePlayersOnObjective
	 * 		Flags  -> (Final, Native, Protected, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bObjectiveChanged                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UActiveObjectiveDisplay::UpdatePlayersOnObjective(bool bObjectiveChanged)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ActiveObjectiveDisplay.UpdatePlayersOnObjective");
		
		UActiveObjectiveDisplay_UpdatePlayersOnObjective_Params params {};
		params.bObjectiveChanged = bObjectiveChanged;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0561D860
	 * 		Name   -> Function Insurgency.ActiveObjectiveDisplay.OnSetViewTarget
	 * 		Flags  -> (Final, Native, Protected)
	 * Parameters:
	 * 		class AActor*                                      NewViewTarget                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UActiveObjectiveDisplay::OnSetViewTarget(class AActor* NewViewTarget)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ActiveObjectiveDisplay.OnSetViewTarget");
		
		UActiveObjectiveDisplay_OnSetViewTarget_Params params {};
		params.NewViewTarget = NewViewTarget;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0561D840
	 * 		Name   -> Function Insurgency.ActiveObjectiveDisplay.OnRoundReset
	 * 		Flags  -> (Final, Native, Protected)
	 */
	void UActiveObjectiveDisplay::OnRoundReset()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ActiveObjectiveDisplay.OnRoundReset");
		
		UActiveObjectiveDisplay_OnRoundReset_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0561D6B0
	 * 		Name   -> Function Insurgency.ActiveObjectiveDisplay.OnRoundOver
	 * 		Flags  -> (Final, Native, Protected, HasOutParms)
	 * Parameters:
	 * 		struct FPlayerRoundOverData                        UIData                                                     (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UActiveObjectiveDisplay::OnRoundOver(const struct FPlayerRoundOverData& UIData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ActiveObjectiveDisplay.OnRoundOver");
		
		UActiveObjectiveDisplay_OnRoundOver_Params params {};
		params.UIData = UIData;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0561D690
	 * 		Name   -> Function Insurgency.ActiveObjectiveDisplay.OnPlayerObjectiveStateChanged
	 * 		Flags  -> (Final, Native, Protected, BlueprintCallable)
	 */
	void UActiveObjectiveDisplay::OnPlayerObjectiveStateChanged()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ActiveObjectiveDisplay.OnPlayerObjectiveStateChanged");
		
		UActiveObjectiveDisplay_OnPlayerObjectiveStateChanged_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0561D550
	 * 		Name   -> Function Insurgency.ActiveObjectiveDisplay.OnOwnerChanged
	 * 		Flags  -> (Final, Native, Protected)
	 * Parameters:
	 * 		class AObjectiveBase*                              Objective                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		unsigned char                                      NewOwners                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UActiveObjectiveDisplay::OnOwnerChanged(class AObjectiveBase* Objective, unsigned char NewOwners)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ActiveObjectiveDisplay.OnOwnerChanged");
		
		UActiveObjectiveDisplay_OnOwnerChanged_Params params {};
		params.Objective = Objective;
		params.NewOwners = NewOwners;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0561D610
	 * 		Name   -> Function Insurgency.ActiveObjectiveDisplay.OnObjectiveChanged
	 * 		Flags  -> (Final, Native, Protected, BlueprintCallable)
	 * Parameters:
	 * 		class AObjectiveBase*                              NewObjective                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UActiveObjectiveDisplay::OnObjectiveChanged(class AObjectiveBase* NewObjective)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ActiveObjectiveDisplay.OnObjectiveChanged");
		
		UActiveObjectiveDisplay_OnObjectiveChanged_Params params {};
		params.NewObjective = NewObjective;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> Function Insurgency.ActiveObjectiveDisplay.OnNumCapturersChanged
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 */
	void UActiveObjectiveDisplay::OnNumCapturersChanged()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ActiveObjectiveDisplay.OnNumCapturersChanged");
		
		UActiveObjectiveDisplay_OnNumCapturersChanged_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0561D550
	 * 		Name   -> Function Insurgency.ActiveObjectiveDisplay.OnCapturingTeamChanged
	 * 		Flags  -> (Final, Native, Protected)
	 * Parameters:
	 * 		class AObjectiveBase*                              Objective                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		unsigned char                                      NewOwners                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UActiveObjectiveDisplay::OnCapturingTeamChanged(class AObjectiveBase* Objective, unsigned char NewOwners)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ActiveObjectiveDisplay.OnCapturingTeamChanged");
		
		UActiveObjectiveDisplay_OnCapturingTeamChanged_Params params {};
		params.Objective = Objective;
		params.NewOwners = NewOwners;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0561D490
	 * 		Name   -> Function Insurgency.ActiveObjectiveDisplay.OnActiveObjectiveChanged
	 * 		Flags  -> (Final, Native, Protected)
	 * Parameters:
	 * 		class AINSPlayerState*                             PlayerState                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AObjectiveBase*                              NewActiveObjective                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UActiveObjectiveDisplay::OnActiveObjectiveChanged(class AINSPlayerState* PlayerState, class AObjectiveBase* NewActiveObjective)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ActiveObjectiveDisplay.OnActiveObjectiveChanged");
		
		UActiveObjectiveDisplay_OnActiveObjectiveChanged_Params params {};
		params.PlayerState = PlayerState;
		params.NewActiveObjective = NewActiveObjective;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0561D3D0
	 * 		Name   -> Function Insurgency.ActiveObjectiveDisplay.OnActiveChanged
	 * 		Flags  -> (Final, Native, Protected)
	 * Parameters:
	 * 		bool                                               bNewActiveState                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AObjectiveBase*                              Objective                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UActiveObjectiveDisplay::OnActiveChanged(bool bNewActiveState, class AObjectiveBase* Objective)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ActiveObjectiveDisplay.OnActiveChanged");
		
		UActiveObjectiveDisplay_OnActiveChanged_Params params {};
		params.bNewActiveState = bNewActiveState;
		params.Objective = Objective;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0561D330
	 * 		Name   -> Function Insurgency.ActiveObjectiveDisplay.GetObjectiveDescription
	 * 		Flags  -> (Final, Native, Protected, BlueprintCallable)
	 */
	class FText UActiveObjectiveDisplay::GetObjectiveDescription()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ActiveObjectiveDisplay.GetObjectiveDescription");
		
		UActiveObjectiveDisplay_GetObjectiveDescription_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UActiveObjectiveDisplay.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UActiveObjectiveDisplay::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.ActiveObjectiveDisplay");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AAIHelicopterController.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AAIHelicopterController::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.AIHelicopterController");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UAimAssistComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UAimAssistComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.AimAssistComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UAimAssistTargetComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UAimAssistTargetComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.AimAssistTargetComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0561E160
	 * 		Name   -> Function Insurgency.AircraftBase.SetGroundTarget
	 * 		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FVector                                     InGroundTarget                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              InMaxDiveAltitude                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AAircraftBase::SetGroundTarget(const struct FVector& InGroundTarget, float InMaxDiveAltitude)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.AircraftBase.SetGroundTarget");
		
		AAircraftBase_SetGroundTarget_Params params {};
		params.InGroundTarget = InGroundTarget;
		params.InMaxDiveAltitude = InMaxDiveAltitude;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0561E070
	 * 		Name   -> Function Insurgency.AircraftBase.BroadcastPayloadDrop
	 * 		Flags  -> (Net, NetReliable, Native, Event, NetMulticast, Protected)
	 * Parameters:
	 * 		struct FAircraftPayload                            Payload                                                    (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void AAircraftBase::BroadcastPayloadDrop(const struct FAircraftPayload& Payload)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.AircraftBase.BroadcastPayloadDrop");
		
		AAircraftBase_BroadcastPayloadDrop_Params params {};
		params.Payload = Payload;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AAircraftBase.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AAircraftBase::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.AircraftBase");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0561E4A0
	 * 		Name   -> Function Insurgency.AircraftMovementComponent.SetTargetLocation
	 * 		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FVector                                     InTarget                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UAircraftMovementComponent::SetTargetLocation(const struct FVector& InTarget)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.AircraftMovementComponent.SetTargetLocation");
		
		UAircraftMovementComponent_SetTargetLocation_Params params {};
		params.InTarget = InTarget;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0561E3F0
	 * 		Name   -> Function Insurgency.AircraftMovementComponent.LimitVelocity
	 * 		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		struct FVector                                     NewVelocity                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FVector UAircraftMovementComponent::LimitVelocity(const struct FVector& NewVelocity)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.AircraftMovementComponent.LimitVelocity");
		
		UAircraftMovementComponent_LimitVelocity_Params params {};
		params.NewVelocity = NewVelocity;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UAircraftMovementComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UAircraftMovementComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.AircraftMovementComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x009DAA00
	 * 		Name   -> Function Insurgency.AircraftStrafing.MulticastBeginStrafe
	 * 		Flags  -> (Net, NetReliable, Native, Event, NetMulticast, Public)
	 */
	void AAircraftStrafing::MulticastBeginStrafe()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.AircraftStrafing.MulticastBeginStrafe");
		
		AAircraftStrafing_MulticastBeginStrafe_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AAircraftStrafing.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AAircraftStrafing::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.AircraftStrafing");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UAISenseConfig_INSHearing.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UAISenseConfig_INSHearing::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.AISenseConfig_INSHearing");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UAISenseEvent_INSHearing.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UAISenseEvent_INSHearing::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.AISenseEvent_INSHearing");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0561EC50
	 * 		Name   -> Function Insurgency.AISense_INSHearing.ReportNoiseEvent
	 * 		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     NoiseLocation                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Loudness                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      Instigator                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              MaxRange                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FName                                        Tag                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UAISense_INSHearing::STATIC_ReportNoiseEvent(class UObject* WorldContextObject, const struct FVector& NoiseLocation, float Loudness, class AActor* Instigator, float MaxRange, const class FName& Tag)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.AISense_INSHearing.ReportNoiseEvent");
		
		UAISense_INSHearing_ReportNoiseEvent_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.NoiseLocation = NoiseLocation;
		params.Loudness = Loudness;
		params.Instigator = Instigator;
		params.MaxRange = MaxRange;
		params.Tag = Tag;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UAISense_INSHearing.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UAISense_INSHearing::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.AISense_INSHearing");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0561F0E0
	 * 		Name   -> Function Insurgency.AlarmComponent.StartAlarm
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		float                                              Duration                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UAlarmComponent::StartAlarm(float Duration)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.AlarmComponent.StartAlarm");
		
		UAlarmComponent_StartAlarm_Params params {};
		params.Duration = Duration;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0561F060
	 * 		Name   -> Function Insurgency.AlarmComponent.MulticastStartAlarm
	 * 		Flags  -> (Net, NetReliable, Native, Event, NetMulticast, Protected)
	 * Parameters:
	 * 		float                                              Duration                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UAlarmComponent::MulticastStartAlarm(float Duration)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.AlarmComponent.MulticastStartAlarm");
		
		UAlarmComponent_MulticastStartAlarm_Params params {};
		params.Duration = Duration;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0561F040
	 * 		Name   -> Function Insurgency.AlarmComponent.EndAlarm
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void UAlarmComponent::EndAlarm()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.AlarmComponent.EndAlarm");
		
		UAlarmComponent_EndAlarm_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UAlarmComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UAlarmComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.AlarmComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0561F510
	 * 		Name   -> Function Insurgency.AlignedWrapBox.SetVerticalAlignment
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		EVerticalAlignment                                 InVerticalAlignment                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UAlignedWrapBox::SetVerticalAlignment(EVerticalAlignment InVerticalAlignment)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.AlignedWrapBox.SetVerticalAlignment");
		
		UAlignedWrapBox_SetVerticalAlignment_Params params {};
		params.InVerticalAlignment = InVerticalAlignment;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0561F490
	 * 		Name   -> Function Insurgency.AlignedWrapBox.SetInnerSlotPadding
	 * 		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FVector2D                                   InPadding                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UAlignedWrapBox::SetInnerSlotPadding(const struct FVector2D& InPadding)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.AlignedWrapBox.SetInnerSlotPadding");
		
		UAlignedWrapBox_SetInnerSlotPadding_Params params {};
		params.InPadding = InPadding;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0561F410
	 * 		Name   -> Function Insurgency.AlignedWrapBox.SetHorizontalAlignment
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		EHorizontalAlignment                               InHorizontalAlignment                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UAlignedWrapBox::SetHorizontalAlignment(EHorizontalAlignment InHorizontalAlignment)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.AlignedWrapBox.SetHorizontalAlignment");
		
		UAlignedWrapBox_SetHorizontalAlignment_Params params {};
		params.InHorizontalAlignment = InHorizontalAlignment;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0561F380
	 * 		Name   -> Function Insurgency.AlignedWrapBox.AddChildWrapBox
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UWidget*                                     Content                                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UAlignedWrapBoxSlot* UAlignedWrapBox::AddChildWrapBox(class UWidget* Content)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.AlignedWrapBox.AddChildWrapBox");
		
		UAlignedWrapBox_AddChildWrapBox_Params params {};
		params.Content = Content;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UAlignedWrapBox.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UAlignedWrapBox::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.AlignedWrapBox");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0561F9F0
	 * 		Name   -> Function Insurgency.AlignedWrapBoxSlot.SetVerticalAlignment
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		EVerticalAlignment                                 InVerticalAlignment                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UAlignedWrapBoxSlot::SetVerticalAlignment(EVerticalAlignment InVerticalAlignment)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.AlignedWrapBoxSlot.SetVerticalAlignment");
		
		UAlignedWrapBoxSlot_SetVerticalAlignment_Params params {};
		params.InVerticalAlignment = InVerticalAlignment;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0561F960
	 * 		Name   -> Function Insurgency.AlignedWrapBoxSlot.SetPadding
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		struct FMargin                                     InPadding                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UAlignedWrapBoxSlot::SetPadding(const struct FMargin& InPadding)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.AlignedWrapBoxSlot.SetPadding");
		
		UAlignedWrapBoxSlot_SetPadding_Params params {};
		params.InPadding = InPadding;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0561F8E0
	 * 		Name   -> Function Insurgency.AlignedWrapBoxSlot.SetHorizontalAlignment
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		EHorizontalAlignment                               InHorizontalAlignment                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UAlignedWrapBoxSlot::SetHorizontalAlignment(EHorizontalAlignment InHorizontalAlignment)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.AlignedWrapBoxSlot.SetHorizontalAlignment");
		
		UAlignedWrapBoxSlot_SetHorizontalAlignment_Params params {};
		params.InHorizontalAlignment = InHorizontalAlignment;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0561F860
	 * 		Name   -> Function Insurgency.AlignedWrapBoxSlot.SetFillSpanWhenLessThan
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		float                                              InFillSpanWhenLessThan                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UAlignedWrapBoxSlot::SetFillSpanWhenLessThan(float InFillSpanWhenLessThan)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.AlignedWrapBoxSlot.SetFillSpanWhenLessThan");
		
		UAlignedWrapBoxSlot_SetFillSpanWhenLessThan_Params params {};
		params.InFillSpanWhenLessThan = InFillSpanWhenLessThan;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0561F7D0
	 * 		Name   -> Function Insurgency.AlignedWrapBoxSlot.SetFillEmptySpace
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               InbFillEmptySpace                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UAlignedWrapBoxSlot::SetFillEmptySpace(bool InbFillEmptySpace)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.AlignedWrapBoxSlot.SetFillEmptySpace");
		
		UAlignedWrapBoxSlot_SetFillEmptySpace_Params params {};
		params.InbFillEmptySpace = InbFillEmptySpace;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UAlignedWrapBoxSlot.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UAlignedWrapBoxSlot::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.AlignedWrapBoxSlot");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056FCF80
	 * 		Name   -> Function Insurgency.ObjectiveBase.SetSpawnsEnabled
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bNewActiveState                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	int32_t AObjectiveBase::SetSpawnsEnabled(bool bNewActiveState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ObjectiveBase.SetSpawnsEnabled");
		
		AObjectiveBase_SetSpawnsEnabled_Params params {};
		params.bNewActiveState = bNewActiveState;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056FCF00
	 * 		Name   -> Function Insurgency.ObjectiveBase.SetOwningTeam
	 * 		Flags  -> (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		unsigned char                                      NewOwner                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AObjectiveBase::SetOwningTeam(unsigned char NewOwner)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ObjectiveBase.SetOwningTeam");
		
		AObjectiveBase_SetOwningTeam_Params params {};
		params.NewOwner = NewOwner;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056FCE70
	 * 		Name   -> Function Insurgency.ObjectiveBase.SetObjectiveVisibleOnHUD
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bNewVisibility                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AObjectiveBase::SetObjectiveVisibleOnHUD(bool bNewVisibility)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ObjectiveBase.SetObjectiveVisibleOnHUD");
		
		AObjectiveBase_SetObjectiveVisibleOnHUD_Params params {};
		params.bNewVisibility = bNewVisibility;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056FCDE0
	 * 		Name   -> Function Insurgency.ObjectiveBase.SetObjectiveIsBeingCounterAttacked
	 * 		Flags  -> (Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bNewCounterAttackState                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AObjectiveBase::SetObjectiveIsBeingCounterAttacked(bool bNewCounterAttackState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ObjectiveBase.SetObjectiveIsBeingCounterAttacked");
		
		AObjectiveBase_SetObjectiveIsBeingCounterAttacked_Params params {};
		params.bNewCounterAttackState = bNewCounterAttackState;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056FCD50
	 * 		Name   -> Function Insurgency.ObjectiveBase.SetObjectiveActive
	 * 		Flags  -> (Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bNewActiveState                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AObjectiveBase::SetObjectiveActive(bool bNewActiveState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ObjectiveBase.SetObjectiveActive");
		
		AObjectiveBase_SetObjectiveActive_Params params {};
		params.bNewActiveState = bNewActiveState;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056FCD30
	 * 		Name   -> Function Insurgency.ObjectiveBase.SetNeutralOwningTeam
	 * 		Flags  -> (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
	 */
	void AObjectiveBase::SetNeutralOwningTeam()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ObjectiveBase.SetNeutralOwningTeam");
		
		AObjectiveBase_SetNeutralOwningTeam_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056FCC60
	 * 		Name   -> Function Insurgency.ObjectiveBase.SetLockedForTeam
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		unsigned char                                      InTeamId                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               Blocked                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AObjectiveBase::SetLockedForTeam(unsigned char InTeamId, bool Blocked)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ObjectiveBase.SetLockedForTeam");
		
		AObjectiveBase_SetLockedForTeam_Params params {};
		params.InTeamId = InTeamId;
		params.Blocked = Blocked;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056FCBE0
	 * 		Name   -> Function Insurgency.ObjectiveBase.SetCapturingTeam
	 * 		Flags  -> (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		unsigned char                                      NewCapturingTeam                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AObjectiveBase::SetCapturingTeam(unsigned char NewCapturingTeam)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ObjectiveBase.SetCapturingTeam");
		
		AObjectiveBase_SetCapturingTeam_Params params {};
		params.NewCapturingTeam = NewCapturingTeam;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056FCBC0
	 * 		Name   -> Function Insurgency.ObjectiveBase.ResetCapturingTeam
	 * 		Flags  -> (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
	 */
	void AObjectiveBase::ResetCapturingTeam()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ObjectiveBase.ResetCapturingTeam");
		
		AObjectiveBase_ResetCapturingTeam_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056FCB60
	 * 		Name   -> Function Insurgency.ObjectiveBase.OnRep_OwningTeamId
	 * 		Flags  -> (Final, Native, Public)
	 */
	void AObjectiveBase::OnRep_OwningTeamId()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ObjectiveBase.OnRep_OwningTeamId");
		
		AObjectiveBase_OnRep_OwningTeamId_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056FCB40
	 * 		Name   -> Function Insurgency.ObjectiveBase.OnRep_ObjectiveId
	 * 		Flags  -> (Final, Native, Private)
	 */
	void AObjectiveBase::OnRep_ObjectiveId()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ObjectiveBase.OnRep_ObjectiveId");
		
		AObjectiveBase_OnRep_ObjectiveId_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056FCB20
	 * 		Name   -> Function Insurgency.ObjectiveBase.OnRep_LockedTeams
	 * 		Flags  -> (Final, Native, Private)
	 */
	void AObjectiveBase::OnRep_LockedTeams()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ObjectiveBase.OnRep_LockedTeams");
		
		AObjectiveBase_OnRep_LockedTeams_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056FCB00
	 * 		Name   -> Function Insurgency.ObjectiveBase.OnRep_CapturingTeamId
	 * 		Flags  -> (Final, Native, Private)
	 */
	void AObjectiveBase::OnRep_CapturingTeamId()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ObjectiveBase.OnRep_CapturingTeamId");
		
		AObjectiveBase_OnRep_CapturingTeamId_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056FCBA0
	 * 		Name   -> Function Insurgency.ObjectiveBase.OnRep_bIsBeingCounterAttack
	 * 		Flags  -> (Final, Native, Private)
	 */
	void AObjectiveBase::OnRep_bIsBeingCounterAttack()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ObjectiveBase.OnRep_bIsBeingCounterAttack");
		
		AObjectiveBase_OnRep_bIsBeingCounterAttack_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056FCB80
	 * 		Name   -> Function Insurgency.ObjectiveBase.OnRep_bActive
	 * 		Flags  -> (Final, Native, Private)
	 */
	void AObjectiveBase::OnRep_bActive()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ObjectiveBase.OnRep_bActive");
		
		AObjectiveBase_OnRep_bActive_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056FCA40
	 * 		Name   -> Function Insurgency.ObjectiveBase.OnOwningTeamChanged
	 * 		Flags  -> (Native, Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		unsigned char                                      PreviousOwner                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		unsigned char                                      NewOwner                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AObjectiveBase::OnOwningTeamChanged(unsigned char PreviousOwner, unsigned char NewOwner)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ObjectiveBase.OnOwningTeamChanged");
		
		AObjectiveBase_OnOwningTeamChanged_Params params {};
		params.PreviousOwner = PreviousOwner;
		params.NewOwner = NewOwner;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> DelegateFunction Insurgency.ObjectiveBase.OnObjectiveLockedTeamsChangedDelegate__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 * Parameters:
	 * 		class AObjectiveBase*                              Objective                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		unsigned char                                      NewLockedTeamsBitMask                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AObjectiveBase::OnObjectiveLockedTeamsChangedDelegate__DelegateSignature(class AObjectiveBase* Objective, unsigned char NewLockedTeamsBitMask)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction Insurgency.ObjectiveBase.OnObjectiveLockedTeamsChangedDelegate__DelegateSignature");
		
		AObjectiveBase_OnObjectiveLockedTeamsChangedDelegate__DelegateSignature_Params params {};
		params.Objective = Objective;
		params.NewLockedTeamsBitMask = NewLockedTeamsBitMask;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> DelegateFunction Insurgency.ObjectiveBase.OnObjectiveIsBeingCounterattackedDelegate__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 * Parameters:
	 * 		bool                                               bNewCounterAttackState                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AObjectiveBase*                              Objective                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AObjectiveBase::OnObjectiveIsBeingCounterattackedDelegate__DelegateSignature(bool bNewCounterAttackState, class AObjectiveBase* Objective)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction Insurgency.ObjectiveBase.OnObjectiveIsBeingCounterattackedDelegate__DelegateSignature");
		
		AObjectiveBase_OnObjectiveIsBeingCounterattackedDelegate__DelegateSignature_Params params {};
		params.bNewCounterAttackState = bNewCounterAttackState;
		params.Objective = Objective;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x04DB39A0
	 * 		Name   -> Function Insurgency.ObjectiveBase.OnObjectiveInitialized
	 * 		Flags  -> (Native, Event, Public, BlueprintEvent)
	 */
	void AObjectiveBase::OnObjectiveInitialized()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ObjectiveBase.OnObjectiveInitialized");
		
		AObjectiveBase_OnObjectiveInitialized_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> DelegateFunction Insurgency.ObjectiveBase.OnObjectiveChangeOwnerDelegate__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 * Parameters:
	 * 		class AObjectiveBase*                              Objective                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		unsigned char                                      NewOwners                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AObjectiveBase::OnObjectiveChangeOwnerDelegate__DelegateSignature(class AObjectiveBase* Objective, unsigned char NewOwners)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction Insurgency.ObjectiveBase.OnObjectiveChangeOwnerDelegate__DelegateSignature");
		
		AObjectiveBase_OnObjectiveChangeOwnerDelegate__DelegateSignature_Params params {};
		params.Objective = Objective;
		params.NewOwners = NewOwners;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> DelegateFunction Insurgency.ObjectiveBase.OnObjectiveActiveDelegate__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 * Parameters:
	 * 		bool                                               bNewActiveState                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AObjectiveBase*                              Objective                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AObjectiveBase::OnObjectiveActiveDelegate__DelegateSignature(bool bNewActiveState, class AObjectiveBase* Objective)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction Insurgency.ObjectiveBase.OnObjectiveActiveDelegate__DelegateSignature");
		
		AObjectiveBase_OnObjectiveActiveDelegate__DelegateSignature_Params params {};
		params.bNewActiveState = bNewActiveState;
		params.Objective = Objective;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056FC9C0
	 * 		Name   -> Function Insurgency.ObjectiveBase.OnCapturingTeamChanged
	 * 		Flags  -> (Native, Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		unsigned char                                      NewCapturingTeam                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AObjectiveBase::OnCapturingTeamChanged(unsigned char NewCapturingTeam)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ObjectiveBase.OnCapturingTeamChanged");
		
		AObjectiveBase_OnCapturingTeamChanged_Params params {};
		params.NewCapturingTeam = NewCapturingTeam;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056FC990
	 * 		Name   -> Function Insurgency.ObjectiveBase.IsOwningTeamValid
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AObjectiveBase::IsOwningTeamValid()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ObjectiveBase.IsOwningTeamValid");
		
		AObjectiveBase_IsOwningTeamValid_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056FC960
	 * 		Name   -> Function Insurgency.ObjectiveBase.IsOwnedAndSafe
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AObjectiveBase::IsOwnedAndSafe()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ObjectiveBase.IsOwnedAndSafe");
		
		AObjectiveBase_IsOwnedAndSafe_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056FC930
	 * 		Name   -> Function Insurgency.ObjectiveBase.IsObjectiveActiveInRound
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AObjectiveBase::IsObjectiveActiveInRound()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ObjectiveBase.IsObjectiveActiveInRound");
		
		AObjectiveBase_IsObjectiveActiveInRound_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056FC900
	 * 		Name   -> Function Insurgency.ObjectiveBase.IsObjectiveActive
	 * 		Flags  -> (Native, Event, Public, BlueprintEvent, Const)
	 */
	bool AObjectiveBase::IsObjectiveActive()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ObjectiveBase.IsObjectiveActive");
		
		AObjectiveBase_IsObjectiveActive_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056FC8D0
	 * 		Name   -> Function Insurgency.ObjectiveBase.IsObjective
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AObjectiveBase::IsObjective()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ObjectiveBase.IsObjective");
		
		AObjectiveBase_IsObjective_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056FC8A0
	 * 		Name   -> Function Insurgency.ObjectiveBase.IsNeutralObjective
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AObjectiveBase::IsNeutralObjective()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ObjectiveBase.IsNeutralObjective");
		
		AObjectiveBase_IsNeutralObjective_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056FC810
	 * 		Name   -> Function Insurgency.ObjectiveBase.IsLockedForTeam
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		unsigned char                                      CheckTeamId                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool AObjectiveBase::IsLockedForTeam(unsigned char CheckTeamId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ObjectiveBase.IsLockedForTeam");
		
		AObjectiveBase_IsLockedForTeam_Params params {};
		params.CheckTeamId = CheckTeamId;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056FC7E0
	 * 		Name   -> Function Insurgency.ObjectiveBase.IsLockedForAnyTeam
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AObjectiveBase::IsLockedForAnyTeam()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ObjectiveBase.IsLockedForAnyTeam");
		
		AObjectiveBase_IsLockedForAnyTeam_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056FC7B0
	 * 		Name   -> Function Insurgency.ObjectiveBase.IsCapturingTeamValid
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AObjectiveBase::IsCapturingTeamValid()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ObjectiveBase.IsCapturingTeamValid");
		
		AObjectiveBase_IsCapturingTeamValid_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056FC720
	 * 		Name   -> Function Insurgency.ObjectiveBase.IsActiveObjectiveForSoldier
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		class AINSSoldier*                                 Soldier                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool AObjectiveBase::IsActiveObjectiveForSoldier(class AINSSoldier* Soldier)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ObjectiveBase.IsActiveObjectiveForSoldier");
		
		AObjectiveBase_IsActiveObjectiveForSoldier_Params params {};
		params.Soldier = Soldier;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056FC6A0
	 * 		Name   -> Function Insurgency.ObjectiveBase.InitializeObjective
	 * 		Flags  -> (BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		unsigned char                                      ID                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AObjectiveBase::InitializeObjective(unsigned char ID)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ObjectiveBase.InitializeObjective");
		
		AObjectiveBase_InitializeObjective_Params params {};
		params.ID = ID;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056FC670
	 * 		Name   -> Function Insurgency.ObjectiveBase.GetRandomBotCaptureLocation
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
	 */
	class UCoverComponent* AObjectiveBase::GetRandomBotCaptureLocation()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ObjectiveBase.GetRandomBotCaptureLocation");
		
		AObjectiveBase_GetRandomBotCaptureLocation_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056FC5D0
	 * 		Name   -> Function Insurgency.ObjectiveBase.GetObjectiveLetter
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	class FText AObjectiveBase::GetObjectiveLetter()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ObjectiveBase.GetObjectiveLetter");
		
		AObjectiveBase_GetObjectiveLetter_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056FC4D0
	 * 		Name   -> Function Insurgency.ObjectiveBase.GetDescriptionForActiveObjective
	 * 		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		class AINSSoldier*                                 Soldier                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class FText AObjectiveBase::GetDescriptionForActiveObjective(class AINSSoldier* Soldier)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ObjectiveBase.GetDescriptionForActiveObjective");
		
		AObjectiveBase_GetDescriptionForActiveObjective_Params params {};
		params.Soldier = Soldier;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056FC490
	 * 		Name   -> Function Insurgency.ObjectiveBase.GetCaptureProgress
	 * 		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	float AObjectiveBase::GetCaptureProgress()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ObjectiveBase.GetCaptureProgress");
		
		AObjectiveBase_GetCaptureProgress_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056FC3D0
	 * 		Name   -> Function Insurgency.ObjectiveBase.GetAllBotCaptureLocations
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
	 */
	TArray<class UCoverComponent*> AObjectiveBase::GetAllBotCaptureLocations()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ObjectiveBase.GetAllBotCaptureLocations");
		
		AObjectiveBase_GetAllBotCaptureLocations_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056FC3A0
	 * 		Name   -> Function Insurgency.ObjectiveBase.GetActive
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AObjectiveBase::GetActive()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ObjectiveBase.GetActive");
		
		AObjectiveBase_GetActive_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056FC380
	 * 		Name   -> Function Insurgency.ObjectiveBase.ClearLockedTeams
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void AObjectiveBase::ClearLockedTeams()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ObjectiveBase.ClearLockedTeams");
		
		AObjectiveBase_ClearLockedTeams_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AObjectiveBase.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AObjectiveBase::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.ObjectiveBase");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056FE7D0
	 * 		Name   -> Function Insurgency.ObjectiveCapturable.TeamCanCapture
	 * 		Flags  -> (Native, Event, Public, BlueprintEvent, Const)
	 * Parameters:
	 * 		unsigned char                                      TeamId                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool AObjectiveCapturable::TeamCanCapture(unsigned char TeamId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ObjectiveCapturable.TeamCanCapture");
		
		AObjectiveCapturable_TeamCanCapture_Params params {};
		params.TeamId = TeamId;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056FE750
	 * 		Name   -> Function Insurgency.ObjectiveCapturable.StartCapture
	 * 		Flags  -> (Native, Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		unsigned char                                      NewCapturingTeamId                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AObjectiveCapturable::StartCapture(unsigned char NewCapturingTeamId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ObjectiveCapturable.StartCapture");
		
		AObjectiveCapturable_StartCapture_Params params {};
		params.NewCapturingTeamId = NewCapturingTeamId;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056FE730
	 * 		Name   -> Function Insurgency.ObjectiveCapturable.OnRep_CaptureState
	 * 		Flags  -> (Final, Native, Private)
	 */
	void AObjectiveCapturable::OnRep_CaptureState()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ObjectiveCapturable.OnRep_CaptureState");
		
		AObjectiveCapturable_OnRep_CaptureState_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056FE710
	 * 		Name   -> Function Insurgency.ObjectiveCapturable.OnRep_BlockingObjectiveId
	 * 		Flags  -> (Final, Native, Private)
	 */
	void AObjectiveCapturable::OnRep_BlockingObjectiveId()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ObjectiveCapturable.OnRep_BlockingObjectiveId");
		
		AObjectiveCapturable_OnRep_BlockingObjectiveId_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056FE500
	 * 		Name   -> Function Insurgency.ObjectiveCapturable.OnBeginObjectiveOverlap
	 * 		Flags  -> (Final, Native, Private, HasOutParms)
	 * Parameters:
	 * 		class UPrimitiveComponent*                         OverlappedComponent                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      OtherActor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UPrimitiveComponent*                         OtherComp                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            OtherBodyIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bFromSweep                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FHitResult                                  SweepResult                                                (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	void AObjectiveCapturable::OnBeginObjectiveOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32_t OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ObjectiveCapturable.OnBeginObjectiveOverlap");
		
		AObjectiveCapturable_OnBeginObjectiveOverlap_Params params {};
		params.OverlappedComponent = OverlappedComponent;
		params.OtherActor = OtherActor;
		params.OtherComp = OtherComp;
		params.OtherBodyIndex = OtherBodyIndex;
		params.bFromSweep = bFromSweep;
		params.SweepResult = SweepResult;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056FE440
	 * 		Name   -> Function Insurgency.ObjectiveCapturable.IsSoldierTouchingZone
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		class AINSSoldier*                                 Soldier                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class ACaptureZone*                                IgnoreZone                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool AObjectiveCapturable::IsSoldierTouchingZone(class AINSSoldier* Soldier, class ACaptureZone* IgnoreZone)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ObjectiveCapturable.IsSoldierTouchingZone");
		
		AObjectiveCapturable_IsSoldierTouchingZone_Params params {};
		params.Soldier = Soldier;
		params.IgnoreZone = IgnoreZone;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056FE3A0
	 * 		Name   -> Function Insurgency.ObjectiveCapturable.IsPointOnObjective
	 * 		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		struct FVector                                     Point                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool AObjectiveCapturable::IsPointOnObjective(const struct FVector& Point)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ObjectiveCapturable.IsPointOnObjective");
		
		AObjectiveCapturable_IsPointOnObjective_Params params {};
		params.Point = Point;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056FE370
	 * 		Name   -> Function Insurgency.ObjectiveCapturable.IsPlayerRequirementMet
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AObjectiveCapturable::IsPlayerRequirementMet()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ObjectiveCapturable.IsPlayerRequirementMet");
		
		AObjectiveCapturable_IsPlayerRequirementMet_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056FE0B0
	 * 		Name   -> Function Insurgency.ObjectiveCapturable.GetPlayerStatesInCaptureAreaOwningTeam
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		TArray<class AINSPlayerState*>                     OutPlayers                                                 (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AObjectiveCapturable::GetPlayerStatesInCaptureAreaOwningTeam(TArray<class AINSPlayerState*>* OutPlayers)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ObjectiveCapturable.GetPlayerStatesInCaptureAreaOwningTeam");
		
		AObjectiveCapturable_GetPlayerStatesInCaptureAreaOwningTeam_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutPlayers != nullptr)
			*OutPlayers = params.OutPlayers;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056FE000
	 * 		Name   -> Function Insurgency.ObjectiveCapturable.GetPlayerStatesInCaptureAreaCapturingTeam
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		TArray<class AINSPlayerState*>                     OutPlayers                                                 (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AObjectiveCapturable::GetPlayerStatesInCaptureAreaCapturingTeam(TArray<class AINSPlayerState*>* OutPlayers)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ObjectiveCapturable.GetPlayerStatesInCaptureAreaCapturingTeam");
		
		AObjectiveCapturable_GetPlayerStatesInCaptureAreaCapturingTeam_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutPlayers != nullptr)
			*OutPlayers = params.OutPlayers;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056FDF50
	 * 		Name   -> Function Insurgency.ObjectiveCapturable.GetPlayerStatesInCaptureArea
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		TArray<class AINSPlayerState*>                     OutPlayers                                                 (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AObjectiveCapturable::GetPlayerStatesInCaptureArea(TArray<class AINSPlayerState*>* OutPlayers)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ObjectiveCapturable.GetPlayerStatesInCaptureArea");
		
		AObjectiveCapturable_GetPlayerStatesInCaptureArea_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutPlayers != nullptr)
			*OutPlayers = params.OutPlayers;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056FE2C0
	 * 		Name   -> Function Insurgency.ObjectiveCapturable.GetPlayersInCaptureAreaOwningTeam
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		TArray<class AINSSoldier*>                         OutPlayers                                                 (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AObjectiveCapturable::GetPlayersInCaptureAreaOwningTeam(TArray<class AINSSoldier*>* OutPlayers)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ObjectiveCapturable.GetPlayersInCaptureAreaOwningTeam");
		
		AObjectiveCapturable_GetPlayersInCaptureAreaOwningTeam_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutPlayers != nullptr)
			*OutPlayers = params.OutPlayers;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056FE210
	 * 		Name   -> Function Insurgency.ObjectiveCapturable.GetPlayersInCaptureAreaCapturingTeam
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		TArray<class AINSSoldier*>                         OutPlayers                                                 (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AObjectiveCapturable::GetPlayersInCaptureAreaCapturingTeam(TArray<class AINSSoldier*>* OutPlayers)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ObjectiveCapturable.GetPlayersInCaptureAreaCapturingTeam");
		
		AObjectiveCapturable_GetPlayersInCaptureAreaCapturingTeam_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutPlayers != nullptr)
			*OutPlayers = params.OutPlayers;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056FE160
	 * 		Name   -> Function Insurgency.ObjectiveCapturable.GetPlayersInCaptureArea
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		TArray<class AINSSoldier*>                         OutPlayers                                                 (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AObjectiveCapturable::GetPlayersInCaptureArea(TArray<class AINSSoldier*>* OutPlayers)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ObjectiveCapturable.GetPlayersInCaptureArea");
		
		AObjectiveCapturable_GetPlayersInCaptureArea_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutPlayers != nullptr)
			*OutPlayers = params.OutPlayers;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x04DB44A0
	 * 		Name   -> Function Insurgency.ObjectiveCapturable.EndCapture
	 * 		Flags  -> (Native, Event, Public, BlueprintEvent)
	 */
	void AObjectiveCapturable::EndCapture()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ObjectiveCapturable.EndCapture");
		
		AObjectiveCapturable_EndCapture_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056FDEC0
	 * 		Name   -> Function Insurgency.ObjectiveCapturable.BreakCapture
	 * 		Flags  -> (Native, Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		bool                                               bTriggerEvents                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AObjectiveCapturable::BreakCapture(bool bTriggerEvents)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ObjectiveCapturable.BreakCapture");
		
		AObjectiveCapturable_BreakCapture_Params params {};
		params.bTriggerEvents = bTriggerEvents;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AObjectiveCapturable.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AObjectiveCapturable::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.ObjectiveCapturable");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AAmbushObjective.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AAmbushObjective::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.AmbushObjective");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction USequenceHelperBase.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* USequenceHelperBase::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.SequenceHelperBase");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction USequenceHelperAmbush.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* USequenceHelperAmbush::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.SequenceHelperAmbush");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGameModeScenarioData.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGameModeScenarioData::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.GameModeScenarioData");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UAmbushScenarioData.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UAmbushScenarioData::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.AmbushScenarioData");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05620B30
	 * 		Name   -> Function Insurgency.AmmoContainer.UsesSubContainers
	 * 		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool UAmmoContainer::UsesSubContainers()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.AmmoContainer.UsesSubContainers");
		
		UAmmoContainer_UsesSubContainers_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x050F6F80
	 * 		Name   -> Function Insurgency.AmmoContainer.UsesMagazineReloads
	 * 		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool UAmmoContainer::UsesMagazineReloads()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.AmmoContainer.UsesMagazineReloads");
		
		UAmmoContainer_UsesMagazineReloads_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05620B00
	 * 		Name   -> Function Insurgency.AmmoContainer.IsValidContainer
	 * 		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool UAmmoContainer::IsValidContainer()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.AmmoContainer.IsValidContainer");
		
		UAmmoContainer_IsValidContainer_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05620A70
	 * 		Name   -> Function Insurgency.AmmoContainer.IsAmmoSupported
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		class UClass*                                      AmmoType                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UAmmoContainer::IsAmmoSupported(class UClass* AmmoType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.AmmoContainer.IsAmmoSupported");
		
		UAmmoContainer_IsAmmoSupported_Params params {};
		params.AmmoType = AmmoType;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05620A30
	 * 		Name   -> Function Insurgency.AmmoContainer.GetFullWeight
	 * 		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	float UAmmoContainer::GetFullWeight()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.AmmoContainer.GetFullWeight");
		
		UAmmoContainer_GetFullWeight_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05620990
	 * 		Name   -> Function Insurgency.AmmoContainer.GetCapacityOfSubContainer
	 * 		Flags  -> (Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		int32_t                                            ContainerIndex                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	int32_t UAmmoContainer::GetCapacityOfSubContainer(int32_t ContainerIndex)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.AmmoContainer.GetCapacityOfSubContainer");
		
		UAmmoContainer_GetCapacityOfSubContainer_Params params {};
		params.ContainerIndex = ContainerIndex;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05620910
	 * 		Name   -> Function Insurgency.AmmoContainer.GetCapacitiesOfSubContainers
	 * 		Flags  -> (Native, Public, BlueprintCallable)
	 */
	TArray<int32_t> UAmmoContainer::GetCapacitiesOfSubContainers()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.AmmoContainer.GetCapacitiesOfSubContainers");
		
		UAmmoContainer_GetCapacitiesOfSubContainers_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056208E0
	 * 		Name   -> Function Insurgency.AmmoContainer.GetAmountOfSubContainers
	 * 		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	int32_t UAmmoContainer::GetAmountOfSubContainers()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.AmmoContainer.GetAmountOfSubContainers");
		
		UAmmoContainer_GetAmountOfSubContainers_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UAmmoContainer.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UAmmoContainer::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.AmmoContainer");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UAmmoContainerMagazine.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UAmmoContainerMagazine::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.AmmoContainerMagazine");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UAmmoContainerWithSubContainers.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UAmmoContainerWithSubContainers::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.AmmoContainerWithSubContainers");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UAmmoType.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UAmmoType::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.AmmoType");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UAmmoTypeBallistic.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UAmmoTypeBallistic::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.AmmoTypeBallistic");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05621530
	 * 		Name   -> Function Insurgency.AnalyticsSubsystem.RecordOutboundLinkClicked
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class FString                                      InUrl                                                      (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FString                                      InContext                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UAnalyticsSubsystem::RecordOutboundLinkClicked(const class FString& InUrl, const class FString& InContext)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.AnalyticsSubsystem.RecordOutboundLinkClicked");
		
		UAnalyticsSubsystem_RecordOutboundLinkClicked_Params params {};
		params.InUrl = InUrl;
		params.InContext = InContext;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05621460
	 * 		Name   -> Function Insurgency.AnalyticsSubsystem.RecordAnnouncementPopupDismissed
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bClickedLink                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              TimeOnScreen                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UAnalyticsSubsystem::RecordAnnouncementPopupDismissed(bool bClickedLink, float TimeOnScreen)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.AnalyticsSubsystem.RecordAnnouncementPopupDismissed");
		
		UAnalyticsSubsystem_RecordAnnouncementPopupDismissed_Params params {};
		params.bClickedLink = bClickedLink;
		params.TimeOnScreen = TimeOnScreen;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056213E0
	 * 		Name   -> Function Insurgency.AnalyticsSubsystem.OnPlayerClassChanged
	 * 		Flags  -> (Final, Native, Protected)
	 * Parameters:
	 * 		class UPlayerClass*                                PlayerClass                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UAnalyticsSubsystem::OnPlayerClassChanged(class UPlayerClass* PlayerClass)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.AnalyticsSubsystem.OnPlayerClassChanged");
		
		UAnalyticsSubsystem_OnPlayerClassChanged_Params params {};
		params.PlayerClass = PlayerClass;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056213C0
	 * 		Name   -> Function Insurgency.AnalyticsSubsystem.OnOwnedItemsLoadingComplete
	 * 		Flags  -> (Final, Native, Protected)
	 */
	void UAnalyticsSubsystem::OnOwnedItemsLoadingComplete()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.AnalyticsSubsystem.OnOwnedItemsLoadingComplete");
		
		UAnalyticsSubsystem_OnOwnedItemsLoadingComplete_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05621300
	 * 		Name   -> Function Insurgency.AnalyticsSubsystem.OnMatchEnd
	 * 		Flags  -> (Final, Native, Protected)
	 * Parameters:
	 * 		unsigned char                                      WinningFaction                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UClass*                                      GameMode                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UAnalyticsSubsystem::OnMatchEnd(unsigned char WinningFaction, class UClass* GameMode)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.AnalyticsSubsystem.OnMatchEnd");
		
		UAnalyticsSubsystem_OnMatchEnd_Params params {};
		params.WinningFaction = WinningFaction;
		params.GameMode = GameMode;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056211F0
	 * 		Name   -> Function Insurgency.AnalyticsSubsystem.OnBackendRewardsReceived
	 * 		Flags  -> (Final, Native, Protected, HasOutParms)
	 * Parameters:
	 * 		int32_t                                            RoundNumber                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FGameStatsRoundReward                       Rewards                                                    (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UAnalyticsSubsystem::OnBackendRewardsReceived(int32_t RoundNumber, const struct FGameStatsRoundReward& Rewards)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.AnalyticsSubsystem.OnBackendRewardsReceived");
		
		UAnalyticsSubsystem_OnBackendRewardsReceived_Params params {};
		params.RoundNumber = RoundNumber;
		params.Rewards = Rewards;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05621170
	 * 		Name   -> Function Insurgency.AnalyticsSubsystem.LogTelemetryEvent
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		ETelemetryEvent                                    EventType                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UAnalyticsSubsystem::LogTelemetryEvent(ETelemetryEvent EventType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.AnalyticsSubsystem.LogTelemetryEvent");
		
		UAnalyticsSubsystem_LogTelemetryEvent_Params params {};
		params.EventType = EventType;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05621090
	 * 		Name   -> Function Insurgency.AnalyticsSubsystem.LogTelemetryCustomEvent
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		ETelemetryEvent                                    EventType                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FString                                      Content                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UAnalyticsSubsystem::LogTelemetryCustomEvent(ETelemetryEvent EventType, const class FString& Content)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.AnalyticsSubsystem.LogTelemetryCustomEvent");
		
		UAnalyticsSubsystem_LogTelemetryCustomEvent_Params params {};
		params.EventType = EventType;
		params.Content = Content;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05621070
	 * 		Name   -> Function Insurgency.AnalyticsSubsystem.ClearQueriedEvents
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void UAnalyticsSubsystem::ClearQueriedEvents()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.AnalyticsSubsystem.ClearQueriedEvents");
		
		UAnalyticsSubsystem_ClearQueriedEvents_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UAnalyticsSubsystem.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UAnalyticsSubsystem::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.AnalyticsSubsystem");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056233F0
	 * 		Name   -> Function Insurgency.AnimationStatics.GetWeaponReadyTimeFromSequence
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class UAnimSequenceBase*                           Sequence                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	float UAnimationStatics::STATIC_GetWeaponReadyTimeFromSequence(class UAnimSequenceBase* Sequence)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.AnimationStatics.GetWeaponReadyTimeFromSequence");
		
		UAnimationStatics_GetWeaponReadyTimeFromSequence_Params params {};
		params.Sequence = Sequence;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05623330
	 * 		Name   -> Function Insurgency.AnimationStatics.GetWeaponReadyTimeFromMontageSection
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class UAnimMontage*                                Montage                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            SectionIndex                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	float UAnimationStatics::STATIC_GetWeaponReadyTimeFromMontageSection(class UAnimMontage* Montage, int32_t SectionIndex)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.AnimationStatics.GetWeaponReadyTimeFromMontageSection");
		
		UAnimationStatics_GetWeaponReadyTimeFromMontageSection_Params params {};
		params.Montage = Montage;
		params.SectionIndex = SectionIndex;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056231F0
	 * 		Name   -> Function Insurgency.AnimationStatics.GetRandomSequenceStrengthPair
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		struct FMultiAnimationStrengthPair                 MultiAnimPair                                              (Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		int32_t                                            OutChosenIndex                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UAnimSequence* UAnimationStatics::STATIC_GetRandomSequenceStrengthPair(struct FMultiAnimationStrengthPair* MultiAnimPair, int32_t* OutChosenIndex)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.AnimationStatics.GetRandomSequenceStrengthPair");
		
		UAnimationStatics_GetRandomSequenceStrengthPair_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (MultiAnimPair != nullptr)
			*MultiAnimPair = params.MultiAnimPair;
		if (OutChosenIndex != nullptr)
			*OutChosenIndex = params.OutChosenIndex;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05623060
	 * 		Name   -> Function Insurgency.AnimationStatics.GetRandomSequence
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		struct FAnimSequenceRandom                         AnimSequenceRandom                                         (Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		int32_t                                            OutChosenIndex                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bNoRepeats                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UAnimSequence* UAnimationStatics::STATIC_GetRandomSequence(struct FAnimSequenceRandom* AnimSequenceRandom, int32_t* OutChosenIndex, bool bNoRepeats)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.AnimationStatics.GetRandomSequence");
		
		UAnimationStatics_GetRandomSequence_Params params {};
		params.bNoRepeats = bNoRepeats;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (AnimSequenceRandom != nullptr)
			*AnimSequenceRandom = params.AnimSequenceRandom;
		if (OutChosenIndex != nullptr)
			*OutChosenIndex = params.OutChosenIndex;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05622FE0
	 * 		Name   -> Function Insurgency.AnimationStatics.GetLODLevelForMesh
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class USkeletalMeshComponent*                      SkelMeshComp                                               (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	int32_t UAnimationStatics::STATIC_GetLODLevelForMesh(class USkeletalMeshComponent* SkelMeshComp)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.AnimationStatics.GetLODLevelForMesh");
		
		UAnimationStatics_GetLODLevelForMesh_Params params {};
		params.SkelMeshComp = SkelMeshComp;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05622DC0
	 * 		Name   -> Function Insurgency.AnimationStatics.GetAnimBoneTransformFromSkeletalMesh
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		class UAnimSequence*                               Sequence                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class USkeletalMesh*                               SkelMesh                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FName                                        BoneName                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Time                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FTransform                                  OutTransform                                               (Parm, OutParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		bool                                               ReturnInParentBoneSpace                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UAnimationStatics::STATIC_GetAnimBoneTransformFromSkeletalMesh(class UAnimSequence* Sequence, class USkeletalMesh* SkelMesh, const class FName& BoneName, float Time, struct FTransform* OutTransform, bool ReturnInParentBoneSpace)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.AnimationStatics.GetAnimBoneTransformFromSkeletalMesh");
		
		UAnimationStatics_GetAnimBoneTransformFromSkeletalMesh_Params params {};
		params.Sequence = Sequence;
		params.SkelMesh = SkelMesh;
		params.BoneName = BoneName;
		params.Time = Time;
		params.ReturnInParentBoneSpace = ReturnInParentBoneSpace;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutTransform != nullptr)
			*OutTransform = params.OutTransform;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05622BA0
	 * 		Name   -> Function Insurgency.AnimationStatics.GetAnimBoneTransform
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		class UAnimSequence*                               Sequence                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class USkeletalMeshComponent*                      SkelMeshComp                                               (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FName                                        BoneName                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Time                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FTransform                                  OutTransform                                               (Parm, OutParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		bool                                               ReturnInParentBoneSpace                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UAnimationStatics::STATIC_GetAnimBoneTransform(class UAnimSequence* Sequence, class USkeletalMeshComponent* SkelMeshComp, const class FName& BoneName, float Time, struct FTransform* OutTransform, bool ReturnInParentBoneSpace)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.AnimationStatics.GetAnimBoneTransform");
		
		UAnimationStatics_GetAnimBoneTransform_Params params {};
		params.Sequence = Sequence;
		params.SkelMeshComp = SkelMeshComp;
		params.BoneName = BoneName;
		params.Time = Time;
		params.ReturnInParentBoneSpace = ReturnInParentBoneSpace;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutTransform != nullptr)
			*OutTransform = params.OutTransform;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056229F0
	 * 		Name   -> Function Insurgency.AnimationStatics.FindAnimNotifyTimeMontageByName
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		class UAnimMontage*                                Montage                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FName                                        NotifyName                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bScaleByPlayRate                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              OutTime                                                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            SectionIndex                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UAnimNotify* UAnimationStatics::STATIC_FindAnimNotifyTimeMontageByName(class UAnimMontage* Montage, const class FName& NotifyName, bool bScaleByPlayRate, float* OutTime, int32_t SectionIndex)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.AnimationStatics.FindAnimNotifyTimeMontageByName");
		
		UAnimationStatics_FindAnimNotifyTimeMontageByName_Params params {};
		params.Montage = Montage;
		params.NotifyName = NotifyName;
		params.bScaleByPlayRate = bScaleByPlayRate;
		params.SectionIndex = SectionIndex;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutTime != nullptr)
			*OutTime = params.OutTime;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05622840
	 * 		Name   -> Function Insurgency.AnimationStatics.FindAnimNotifyTimeMontageByClass
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		class UAnimMontage*                                Montage                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UClass*                                      NotifyClass                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bScaleByPlayRate                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              OutTime                                                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            SectionIndex                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UAnimNotify* UAnimationStatics::STATIC_FindAnimNotifyTimeMontageByClass(class UAnimMontage* Montage, class UClass* NotifyClass, bool bScaleByPlayRate, float* OutTime, int32_t SectionIndex)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.AnimationStatics.FindAnimNotifyTimeMontageByClass");
		
		UAnimationStatics_FindAnimNotifyTimeMontageByClass_Params params {};
		params.Montage = Montage;
		params.NotifyClass = NotifyClass;
		params.bScaleByPlayRate = bScaleByPlayRate;
		params.SectionIndex = SectionIndex;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutTime != nullptr)
			*OutTime = params.OutTime;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05622670
	 * 		Name   -> Function Insurgency.AnimationStatics.FindAnimNotifyTimeMontage
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		class UAnimMontage*                                Montage                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FName                                        NotifyName                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UClass*                                      NotifyClass                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bScaleByPlayRate                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              OutTime                                                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            SectionIndex                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UAnimNotify* UAnimationStatics::STATIC_FindAnimNotifyTimeMontage(class UAnimMontage* Montage, const class FName& NotifyName, class UClass* NotifyClass, bool bScaleByPlayRate, float* OutTime, int32_t SectionIndex)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.AnimationStatics.FindAnimNotifyTimeMontage");
		
		UAnimationStatics_FindAnimNotifyTimeMontage_Params params {};
		params.Montage = Montage;
		params.NotifyName = NotifyName;
		params.NotifyClass = NotifyClass;
		params.bScaleByPlayRate = bScaleByPlayRate;
		params.SectionIndex = SectionIndex;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutTime != nullptr)
			*OutTime = params.OutTime;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05622510
	 * 		Name   -> Function Insurgency.AnimationStatics.FindAnimNotifyTimeByName
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		class UAnimSequenceBase*                           Sequence                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FName                                        NotifyName                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bScaleByPlayRate                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              OutTime                                                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UAnimNotify* UAnimationStatics::STATIC_FindAnimNotifyTimeByName(class UAnimSequenceBase* Sequence, const class FName& NotifyName, bool bScaleByPlayRate, float* OutTime)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.AnimationStatics.FindAnimNotifyTimeByName");
		
		UAnimationStatics_FindAnimNotifyTimeByName_Params params {};
		params.Sequence = Sequence;
		params.NotifyName = NotifyName;
		params.bScaleByPlayRate = bScaleByPlayRate;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutTime != nullptr)
			*OutTime = params.OutTime;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056223B0
	 * 		Name   -> Function Insurgency.AnimationStatics.FindAnimNotifyTimeByClass
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		class UAnimSequenceBase*                           Sequence                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UClass*                                      NotifyClass                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bScaleByPlayRate                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              OutTime                                                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UAnimNotify* UAnimationStatics::STATIC_FindAnimNotifyTimeByClass(class UAnimSequenceBase* Sequence, class UClass* NotifyClass, bool bScaleByPlayRate, float* OutTime)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.AnimationStatics.FindAnimNotifyTimeByClass");
		
		UAnimationStatics_FindAnimNotifyTimeByClass_Params params {};
		params.Sequence = Sequence;
		params.NotifyClass = NotifyClass;
		params.bScaleByPlayRate = bScaleByPlayRate;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutTime != nullptr)
			*OutTime = params.OutTime;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05622210
	 * 		Name   -> Function Insurgency.AnimationStatics.FindAnimNotifyTime
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		class UAnimSequenceBase*                           Sequence                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FName                                        NotifyName                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UClass*                                      NotifyClass                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bScaleByPlayRate                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              OutTime                                                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UAnimNotify* UAnimationStatics::STATIC_FindAnimNotifyTime(class UAnimSequenceBase* Sequence, const class FName& NotifyName, class UClass* NotifyClass, bool bScaleByPlayRate, float* OutTime)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.AnimationStatics.FindAnimNotifyTime");
		
		UAnimationStatics_FindAnimNotifyTime_Params params {};
		params.Sequence = Sequence;
		params.NotifyName = NotifyName;
		params.NotifyClass = NotifyClass;
		params.bScaleByPlayRate = bScaleByPlayRate;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutTime != nullptr)
			*OutTime = params.OutTime;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UAnimationStatics.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UAnimationStatics::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.AnimationStatics");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05623B20
	 * 		Name   -> Function Insurgency.AnimNotifyWeapon.GetOuterWeapon
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		class USkeletalMeshComponent*                      ContextMeshComp                                            (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class AItemWeapon* UAnimNotifyWeapon::GetOuterWeapon(class USkeletalMeshComponent* ContextMeshComp)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.AnimNotifyWeapon.GetOuterWeapon");
		
		UAnimNotifyWeapon_GetOuterWeapon_Params params {};
		params.ContextMeshComp = ContextMeshComp;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05623A90
	 * 		Name   -> Function Insurgency.AnimNotifyWeapon.GetOuterSoldier
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		class USkeletalMeshComponent*                      ContextMeshComp                                            (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class AINSSoldier* UAnimNotifyWeapon::GetOuterSoldier(class USkeletalMeshComponent* ContextMeshComp)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.AnimNotifyWeapon.GetOuterSoldier");
		
		UAnimNotifyWeapon_GetOuterSoldier_Params params {};
		params.ContextMeshComp = ContextMeshComp;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05623A00
	 * 		Name   -> Function Insurgency.AnimNotifyWeapon.GetOuterFirearm
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		class USkeletalMeshComponent*                      ContextMeshComp                                            (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class AItemFirearm* UAnimNotifyWeapon::GetOuterFirearm(class USkeletalMeshComponent* ContextMeshComp)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.AnimNotifyWeapon.GetOuterFirearm");
		
		UAnimNotifyWeapon_GetOuterFirearm_Params params {};
		params.ContextMeshComp = ContextMeshComp;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05623970
	 * 		Name   -> Function Insurgency.AnimNotifyWeapon.GetOuterEquipable
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		class USkeletalMeshComponent*                      ContextMeshComp                                            (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class AItemEquipable* UAnimNotifyWeapon::GetOuterEquipable(class USkeletalMeshComponent* ContextMeshComp)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.AnimNotifyWeapon.GetOuterEquipable");
		
		UAnimNotifyWeapon_GetOuterEquipable_Params params {};
		params.ContextMeshComp = ContextMeshComp;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UAnimNotifyWeapon.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UAnimNotifyWeapon::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.AnimNotifyWeapon");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UAnimNotify_BipodSurfaceReaction.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UAnimNotify_BipodSurfaceReaction::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.AnimNotify_BipodSurfaceReaction");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UAnimNotify_BoltCycled.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UAnimNotify_BoltCycled::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.AnimNotify_BoltCycled");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UAnimNotify_ChamberRound.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UAnimNotify_ChamberRound::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.AnimNotify_ChamberRound");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UAnimNotify_ChangeBipodLegsState.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UAnimNotify_ChangeBipodLegsState::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.AnimNotify_ChangeBipodLegsState");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UAnimNotify_ChangeBipodState.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UAnimNotify_ChangeBipodState::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.AnimNotify_ChangeBipodState");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UAnimNotify_CheckPendingAmmo.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UAnimNotify_CheckPendingAmmo::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.AnimNotify_CheckPendingAmmo");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UAnimNotify_DisallowCancel.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UAnimNotify_DisallowCancel::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.AnimNotify_DisallowCancel");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UAnimNotify_FireProjectile.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UAnimNotify_FireProjectile::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.AnimNotify_FireProjectile");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UAnimNotify_Footstep.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UAnimNotify_Footstep::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.AnimNotify_Footstep");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UAnimNotify_GrenadePullPin.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UAnimNotify_GrenadePullPin::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.AnimNotify_GrenadePullPin");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UAnimNotify_GrenadeRelease.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UAnimNotify_GrenadeRelease::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.AnimNotify_GrenadeRelease");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UAnimNotify_GrenadeSpoonRelease.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UAnimNotify_GrenadeSpoonRelease::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.AnimNotify_GrenadeSpoonRelease");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UAnimNotify_KickDoor.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UAnimNotify_KickDoor::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.AnimNotify_KickDoor");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UAnimNotify_LastRoundEject.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UAnimNotify_LastRoundEject::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.AnimNotify_LastRoundEject");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UAnimNotify_MagIn.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UAnimNotify_MagIn::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.AnimNotify_MagIn");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UAnimNotify_MagOut.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UAnimNotify_MagOut::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.AnimNotify_MagOut");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UAnimNotify_PlayLoopingSound.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UAnimNotify_PlayLoopingSound::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.AnimNotify_PlayLoopingSound");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UAnimNotify_RoundIn.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UAnimNotify_RoundIn::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.AnimNotify_RoundIn");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UAnimNotify_ShowAmmoInfo.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UAnimNotify_ShowAmmoInfo::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.AnimNotify_ShowAmmoInfo");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UAnimNotify_SpawnBrass.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UAnimNotify_SpawnBrass::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.AnimNotify_SpawnBrass");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UAnimNotify_SpawnEjectedMag.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UAnimNotify_SpawnEjectedMag::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.AnimNotify_SpawnEjectedMag");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UAnimNotify_StopLoopingSound.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UAnimNotify_StopLoopingSound::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.AnimNotify_StopLoopingSound");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UAnimNotify_StoreAmmo.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UAnimNotify_StoreAmmo::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.AnimNotify_StoreAmmo");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UAnimNotify_WeaponReady.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UAnimNotify_WeaponReady::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.AnimNotify_WeaponReady");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UAnimNotify_WeaponSound.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UAnimNotify_WeaponSound::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.AnimNotify_WeaponSound");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05625B60
	 * 		Name   -> Function Insurgency.ArtillerySite.IsFireSupportWhitelisted
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		class UClass*                                      FireSupportClass                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool AArtillerySite::IsFireSupportWhitelisted(class UClass* FireSupportClass)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ArtillerySite.IsFireSupportWhitelisted");
		
		AArtillerySite_IsFireSupportWhitelisted_Params params {};
		params.FireSupportClass = FireSupportClass;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AArtillerySite.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AArtillerySite::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.ArtillerySite");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05626290
	 * 		Name   -> Function Insurgency.AudioBlueprintLibrary.PlayUISound
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		EUISound                                           Sound                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UAudioBlueprintLibrary::STATIC_PlayUISound(EUISound Sound)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.AudioBlueprintLibrary.PlayUISound");
		
		UAudioBlueprintLibrary_PlayUISound_Params params {};
		params.Sound = Sound;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05626220
	 * 		Name   -> Function Insurgency.AudioBlueprintLibrary.PlayUILoadoutSound
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		EUILoadoutSound                                    Sound                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UAudioBlueprintLibrary::STATIC_PlayUILoadoutSound(EUILoadoutSound Sound)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.AudioBlueprintLibrary.PlayUILoadoutSound");
		
		UAudioBlueprintLibrary_PlayUILoadoutSound_Params params {};
		params.Sound = Sound;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056261B0
	 * 		Name   -> Function Insurgency.AudioBlueprintLibrary.PlayUIHUDSound
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		EUIHUDSound                                        Sound                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UAudioBlueprintLibrary::STATIC_PlayUIHUDSound(EUIHUDSound Sound)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.AudioBlueprintLibrary.PlayUIHUDSound");
		
		UAudioBlueprintLibrary_PlayUIHUDSound_Params params {};
		params.Sound = Sound;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UAudioBlueprintLibrary.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UAudioBlueprintLibrary::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.AudioBlueprintLibrary");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> Function Insurgency.MainMenuPanelWidget.UpdateLicenseAgreementDialogBP
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 */
	void UMainMenuPanelWidget::UpdateLicenseAgreementDialogBP()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.MainMenuPanelWidget.UpdateLicenseAgreementDialogBP");
		
		UMainMenuPanelWidget_UpdateLicenseAgreementDialogBP_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00C76AB0
	 * 		Name   -> Function Insurgency.MainMenuPanelWidget.TryEnterMiltiplayerGame
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void UMainMenuPanelWidget::TryEnterMiltiplayerGame()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.MainMenuPanelWidget.TryEnterMiltiplayerGame");
		
		UMainMenuPanelWidget_TryEnterMiltiplayerGame_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056EC330
	 * 		Name   -> Function Insurgency.MainMenuPanelWidget.SetTutorialPromptResult
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bOpeningTutorial                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UMainMenuPanelWidget::SetTutorialPromptResult(bool bOpeningTutorial)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.MainMenuPanelWidget.SetTutorialPromptResult");
		
		UMainMenuPanelWidget_SetTutorialPromptResult_Params params {};
		params.bOpeningTutorial = bOpeningTutorial;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056EC2B0
	 * 		Name   -> Function Insurgency.MainMenuPanelWidget.SetActiveMapPageSelect
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		int32_t                                            InValue                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UMainMenuPanelWidget::SetActiveMapPageSelect(int32_t InValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.MainMenuPanelWidget.SetActiveMapPageSelect");
		
		UMainMenuPanelWidget_SetActiveMapPageSelect_Params params {};
		params.InValue = InValue;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056EC190
	 * 		Name   -> Function Insurgency.MainMenuPanelWidget.OnRequestNavigateBack
	 * 		Flags  -> (Native, Event, Public, BlueprintCallable, BlueprintEvent)
	 */
	bool UMainMenuPanelWidget::OnRequestNavigateBack()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.MainMenuPanelWidget.OnRequestNavigateBack");
		
		UMainMenuPanelWidget_OnRequestNavigateBack_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> Function Insurgency.MainMenuPanelWidget.OnPanelOpened
	 * 		Flags  -> (Event, Public, BlueprintCallable, BlueprintEvent)
	 */
	void UMainMenuPanelWidget::OnPanelOpened()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.MainMenuPanelWidget.OnPanelOpened");
		
		UMainMenuPanelWidget_OnPanelOpened_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> Function Insurgency.MainMenuPanelWidget.OnPanelClosed
	 * 		Flags  -> (Event, Public, BlueprintCallable, BlueprintEvent)
	 */
	void UMainMenuPanelWidget::OnPanelClosed()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.MainMenuPanelWidget.OnPanelClosed");
		
		UMainMenuPanelWidget_OnPanelClosed_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> DelegateFunction Insurgency.MainMenuPanelWidget.OnLicenseDialogToggleDelegate__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 * Parameters:
	 * 		bool                                               bHasOpened                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UMainMenuPanelWidget::OnLicenseDialogToggleDelegate__DelegateSignature(bool bHasOpened)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction Insurgency.MainMenuPanelWidget.OnLicenseDialogToggleDelegate__DelegateSignature");
		
		UMainMenuPanelWidget_OnLicenseDialogToggleDelegate__DelegateSignature_Params params {};
		params.bHasOpened = bHasOpened;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056EC160
	 * 		Name   -> Function Insurgency.MainMenuPanelWidget.HasUserConfirmedLicense
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool UMainMenuPanelWidget::HasUserConfirmedLicense()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.MainMenuPanelWidget.HasUserConfirmedLicense");
		
		UMainMenuPanelWidget_HasUserConfirmedLicense_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056EC130
	 * 		Name   -> Function Insurgency.MainMenuPanelWidget.GetLessonList
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	class UTutorialList* UMainMenuPanelWidget::GetLessonList()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.MainMenuPanelWidget.GetLessonList");
		
		UMainMenuPanelWidget_GetLessonList_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> Function Insurgency.MainMenuPanelWidget.DisplayRestrictionDialog
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		EUserPrivilegeResult                               PrivilageRestriction                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UMainMenuPanelWidget::DisplayRestrictionDialog(EUserPrivilegeResult PrivilageRestriction)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.MainMenuPanelWidget.DisplayRestrictionDialog");
		
		UMainMenuPanelWidget_DisplayRestrictionDialog_Params params {};
		params.PrivilageRestriction = PrivilageRestriction;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056EC100
	 * 		Name   -> Function Insurgency.MainMenuPanelWidget.CreateLicenseAgreementDialog
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	bool UMainMenuPanelWidget::CreateLicenseAgreementDialog()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.MainMenuPanelWidget.CreateLicenseAgreementDialog");
		
		UMainMenuPanelWidget_CreateLicenseAgreementDialog_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056EC0D0
	 * 		Name   -> Function Insurgency.MainMenuPanelWidget.BPGetINSWorldSetting
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	class AINSWorldSettings* UMainMenuPanelWidget::BPGetINSWorldSetting()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.MainMenuPanelWidget.BPGetINSWorldSetting");
		
		UMainMenuPanelWidget_BPGetINSWorldSetting_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMainMenuPanelWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMainMenuPanelWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.MainMenuPanelWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056EC3C0
	 * 		Name   -> Function Insurgency.MainMenuPanelWidgetWithStore.UpdateStoreNotification
	 * 		Flags  -> (Native, Event, Protected, BlueprintEvent)
	 * Parameters:
	 * 		bool                                               bInHasNewItems                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bInHasSales                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UMainMenuPanelWidgetWithStore::UpdateStoreNotification(bool bInHasNewItems, bool bInHasSales)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.MainMenuPanelWidgetWithStore.UpdateStoreNotification");
		
		UMainMenuPanelWidgetWithStore_UpdateStoreNotification_Params params {};
		params.bInHasNewItems = bInHasNewItems;
		params.bInHasSales = bInHasSales;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056EC290
	 * 		Name   -> Function Insurgency.MainMenuPanelWidgetWithStore.OnUnviewedStoreItemViewed
	 * 		Flags  -> (Final, Native, Private)
	 */
	void UMainMenuPanelWidgetWithStore::OnUnviewedStoreItemViewed()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.MainMenuPanelWidgetWithStore.OnUnviewedStoreItemViewed");
		
		UMainMenuPanelWidgetWithStore_OnUnviewedStoreItemViewed_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056EC1C0
	 * 		Name   -> Function Insurgency.MainMenuPanelWidgetWithStore.OnStoreItemsFlagsUpdated
	 * 		Flags  -> (Final, Native, Private)
	 * Parameters:
	 * 		bool                                               bInHasNewItems                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bInHasSales                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UMainMenuPanelWidgetWithStore::OnStoreItemsFlagsUpdated(bool bInHasNewItems, bool bInHasSales)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.MainMenuPanelWidgetWithStore.OnStoreItemsFlagsUpdated");
		
		UMainMenuPanelWidgetWithStore_OnStoreItemsFlagsUpdated_Params params {};
		params.bInHasNewItems = bInHasNewItems;
		params.bInHasSales = bInHasSales;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMainMenuPanelWidgetWithStore.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMainMenuPanelWidgetWithStore::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.MainMenuPanelWidgetWithStore");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056270C0
	 * 		Name   -> Function Insurgency.BaseOnlineStore.TryPurchaseItem
	 * 		Flags  -> (Final, Native, Protected, BlueprintCallable)
	 * Parameters:
	 * 		class UStoreItem*                                  PurchasedItem                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UBaseOnlineStore::TryPurchaseItem(class UStoreItem* PurchasedItem)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.BaseOnlineStore.TryPurchaseItem");
		
		UBaseOnlineStore_TryPurchaseItem_Params params {};
		params.PurchasedItem = PurchasedItem;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05627040
	 * 		Name   -> Function Insurgency.BaseOnlineStore.SetItemIsShown
	 * 		Flags  -> (Final, Native, Protected, BlueprintCallable)
	 * Parameters:
	 * 		class UStoreItem*                                  PurchasedItem                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UBaseOnlineStore::SetItemIsShown(class UStoreItem* PurchasedItem)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.BaseOnlineStore.SetItemIsShown");
		
		UBaseOnlineStore_SetItemIsShown_Params params {};
		params.PurchasedItem = PurchasedItem;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05627020
	 * 		Name   -> Function Insurgency.BaseOnlineStore.SetAllItemsIsShown
	 * 		Flags  -> (Final, Native, Protected, BlueprintCallable)
	 */
	void UBaseOnlineStore::SetAllItemsIsShown()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.BaseOnlineStore.SetAllItemsIsShown");
		
		UBaseOnlineStore_SetAllItemsIsShown_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> Function Insurgency.BaseOnlineStore.OnStoreItemListUpdated
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 */
	void UBaseOnlineStore::OnStoreItemListUpdated()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.BaseOnlineStore.OnStoreItemListUpdated");
		
		UBaseOnlineStore_OnStoreItemListUpdated_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05626F70
	 * 		Name   -> Function Insurgency.BaseOnlineStore.OnPurchaseStoreItemSuccess
	 * 		Flags  -> (Final, Native, Private, HasOutParms)
	 * Parameters:
	 * 		TArray<class FName>                                PurchasedItemIds                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UBaseOnlineStore::OnPurchaseStoreItemSuccess(TArray<class FName> PurchasedItemIds)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.BaseOnlineStore.OnPurchaseStoreItemSuccess");
		
		UBaseOnlineStore_OnPurchaseStoreItemSuccess_Params params {};
		params.PurchasedItemIds = PurchasedItemIds;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> Function Insurgency.BaseOnlineStore.OnHasSalesChanged
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 */
	void UBaseOnlineStore::OnHasSalesChanged()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.BaseOnlineStore.OnHasSalesChanged");
		
		UBaseOnlineStore_OnHasSalesChanged_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05626F50
	 * 		Name   -> Function Insurgency.BaseOnlineStore.InitStoreItems
	 * 		Flags  -> (Final, Native, Protected, BlueprintCallable)
	 */
	void UBaseOnlineStore::InitStoreItems()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.BaseOnlineStore.InitStoreItems");
		
		UBaseOnlineStore_InitStoreItems_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05626E70
	 * 		Name   -> Function Insurgency.BaseOnlineStore.HasNewStoreItemsByOperationName
	 * 		Flags  -> (Final, Native, Protected, HasOutParms, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class FName                                        InOperationName                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bOutHasNew                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UBaseOnlineStore::HasNewStoreItemsByOperationName(const class FName& InOperationName, bool* bOutHasNew)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.BaseOnlineStore.HasNewStoreItemsByOperationName");
		
		UBaseOnlineStore_HasNewStoreItemsByOperationName_Params params {};
		params.InOperationName = InOperationName;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (bOutHasNew != nullptr)
			*bOutHasNew = params.bOutHasNew;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05626D90
	 * 		Name   -> Function Insurgency.BaseOnlineStore.HasNewStoreItemsByCategory
	 * 		Flags  -> (Final, Native, Protected, HasOutParms, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		EStoreItemCategory                                 InCategory                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bOutHasNew                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UBaseOnlineStore::HasNewStoreItemsByCategory(EStoreItemCategory InCategory, bool* bOutHasNew)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.BaseOnlineStore.HasNewStoreItemsByCategory");
		
		UBaseOnlineStore_HasNewStoreItemsByCategory_Params params {};
		params.InCategory = InCategory;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (bOutHasNew != nullptr)
			*bOutHasNew = params.bOutHasNew;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05626D00
	 * 		Name   -> Function Insurgency.BaseOnlineStore.HasNewStoreItems
	 * 		Flags  -> (Final, Native, Protected, HasOutParms, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		bool                                               bOutHasNew                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UBaseOnlineStore::HasNewStoreItems(bool* bOutHasNew)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.BaseOnlineStore.HasNewStoreItems");
		
		UBaseOnlineStore_HasNewStoreItems_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (bOutHasNew != nullptr)
			*bOutHasNew = params.bOutHasNew;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05626BC0
	 * 		Name   -> Function Insurgency.BaseOnlineStore.GetStoreItemsByOperationName
	 * 		Flags  -> (Final, Native, Protected, HasOutParms, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		TArray<class UStoreItem*>                          OutResults                                                 (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FName                                        InOperationName                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bInShowOwned                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UBaseOnlineStore::GetStoreItemsByOperationName(TArray<class UStoreItem*>* OutResults, const class FName& InOperationName, bool bInShowOwned)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.BaseOnlineStore.GetStoreItemsByOperationName");
		
		UBaseOnlineStore_GetStoreItemsByOperationName_Params params {};
		params.InOperationName = InOperationName;
		params.bInShowOwned = bInShowOwned;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutResults != nullptr)
			*OutResults = params.OutResults;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05626AC0
	 * 		Name   -> Function Insurgency.BaseOnlineStore.GetStoreItemsByDiscount
	 * 		Flags  -> (Final, Native, Protected, HasOutParms, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		TArray<class UStoreItem*>                          OutResults                                                 (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bInShowOwned                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UBaseOnlineStore::GetStoreItemsByDiscount(TArray<class UStoreItem*>* OutResults, bool bInShowOwned)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.BaseOnlineStore.GetStoreItemsByDiscount");
		
		UBaseOnlineStore_GetStoreItemsByDiscount_Params params {};
		params.bInShowOwned = bInShowOwned;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutResults != nullptr)
			*OutResults = params.OutResults;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05626980
	 * 		Name   -> Function Insurgency.BaseOnlineStore.GetStoreItemsByCategory
	 * 		Flags  -> (Final, Native, Protected, HasOutParms, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		TArray<class UStoreItem*>                          OutResults                                                 (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EStoreItemCategory                                 InCategory                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bInShowOwned                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UBaseOnlineStore::GetStoreItemsByCategory(TArray<class UStoreItem*>* OutResults, EStoreItemCategory InCategory, bool bInShowOwned)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.BaseOnlineStore.GetStoreItemsByCategory");
		
		UBaseOnlineStore_GetStoreItemsByCategory_Params params {};
		params.InCategory = InCategory;
		params.bInShowOwned = bInShowOwned;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutResults != nullptr)
			*OutResults = params.OutResults;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05626880
	 * 		Name   -> Function Insurgency.BaseOnlineStore.GetStoreItems
	 * 		Flags  -> (Final, Native, Protected, HasOutParms, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		TArray<class UStoreItem*>                          OutResults                                                 (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bInShowOwned                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UBaseOnlineStore::GetStoreItems(TArray<class UStoreItem*>* OutResults, bool bInShowOwned)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.BaseOnlineStore.GetStoreItems");
		
		UBaseOnlineStore_GetStoreItems_Params params {};
		params.bInShowOwned = bInShowOwned;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutResults != nullptr)
			*OutResults = params.OutResults;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05626860
	 * 		Name   -> Function Insurgency.BaseOnlineStore.Debug_ResetLocalProfileLists
	 * 		Flags  -> (Final, Native, Protected, BlueprintCallable)
	 */
	void UBaseOnlineStore::Debug_ResetLocalProfileLists()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.BaseOnlineStore.Debug_ResetLocalProfileLists");
		
		UBaseOnlineStore_Debug_ResetLocalProfileLists_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UBaseOnlineStore.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UBaseOnlineStore::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.BaseOnlineStore");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05627D30
	 * 		Name   -> Function Insurgency.BloodSplatterData.GetMaterialFromBloodSplatter
	 * 		Flags  -> (Final, Native, Private, HasOutParms, HasDefaults, Const)
	 * Parameters:
	 * 		struct FBloodSplatter                              BloodSplatter                                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     MinSize                                                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     MaxSize                                                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UMaterialInterface* UBloodSplatterData::GetMaterialFromBloodSplatter(const struct FBloodSplatter& BloodSplatter, struct FVector* MinSize, struct FVector* MaxSize)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.BloodSplatterData.GetMaterialFromBloodSplatter");
		
		UBloodSplatterData_GetMaterialFromBloodSplatter_Params params {};
		params.BloodSplatter = BloodSplatter;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (MinSize != nullptr)
			*MinSize = params.MinSize;
		if (MaxSize != nullptr)
			*MaxSize = params.MaxSize;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05627AD0
	 * 		Name   -> Function Insurgency.BloodSplatterData.DetermineSplatterContext
	 * 		Flags  -> (Final, Native, Public, HasOutParms, HasDefaults)
	 * Parameters:
	 * 		struct FBloodSplatterContext                       SplatterContext                                            (Parm, OutParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 * 		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     HitPosition                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     HitDirection                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bHeadshot                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bLethal                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      IgnoredActor                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UBloodSplatterData::DetermineSplatterContext(struct FBloodSplatterContext* SplatterContext, class UObject* WorldContextObject, const struct FVector& HitPosition, const struct FVector& HitDirection, bool bHeadshot, bool bLethal, class AActor* IgnoredActor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.BloodSplatterData.DetermineSplatterContext");
		
		UBloodSplatterData_DetermineSplatterContext_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.HitPosition = HitPosition;
		params.HitDirection = HitDirection;
		params.bHeadshot = bHeadshot;
		params.bLethal = bLethal;
		params.IgnoredActor = IgnoredActor;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (SplatterContext != nullptr)
			*SplatterContext = params.SplatterContext;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056278B0
	 * 		Name   -> Function Insurgency.BloodSplatterData.CreateBloodSplatter
	 * 		Flags  -> (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     DecalPosition                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FRotator                                    DecalRotation                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		class USceneComponent*                             AttachComponent                                            (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EPhysicalSurface                                   PhysicalSurface                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EBloodSplatterType                                 BloodSplatterType                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bKillShot                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UBloodSplatterData::CreateBloodSplatter(class UObject* WorldContextObject, const struct FVector& DecalPosition, const struct FRotator& DecalRotation, class USceneComponent* AttachComponent, EPhysicalSurface PhysicalSurface, EBloodSplatterType BloodSplatterType, bool bKillShot)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.BloodSplatterData.CreateBloodSplatter");
		
		UBloodSplatterData_CreateBloodSplatter_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.DecalPosition = DecalPosition;
		params.DecalRotation = DecalRotation;
		params.AttachComponent = AttachComponent;
		params.PhysicalSurface = PhysicalSurface;
		params.BloodSplatterType = BloodSplatterType;
		params.bKillShot = bKillShot;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05627790
	 * 		Name   -> Function Insurgency.BloodSplatterData.CreateBloodPool
	 * 		Flags  -> (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     Position                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      IgnoredActor                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UDecalComponent* UBloodSplatterData::CreateBloodPool(class UObject* WorldContextObject, const struct FVector& Position, class AActor* IgnoredActor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.BloodSplatterData.CreateBloodPool");
		
		UBloodSplatterData_CreateBloodPool_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.Position = Position;
		params.IgnoredActor = IgnoredActor;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UBloodSplatterData.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UBloodSplatterData::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.BloodSplatterData");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05629180
	 * 		Name   -> Function Insurgency.BlueprintUsableActor.EventTryUse
	 * 		Flags  -> (Native, Event, Public, HasOutParms, BlueprintEvent)
	 * Parameters:
	 * 		class AINSSoldier*                                 Pawn                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FHitResult                                  HitResult                                                  (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	EUseResponse ABlueprintUsableActor::EventTryUse(class AINSSoldier* Pawn, const struct FHitResult& HitResult)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.BlueprintUsableActor.EventTryUse");
		
		ABlueprintUsableActor_EventTryUse_Params params {};
		params.Pawn = Pawn;
		params.HitResult = HitResult;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056290B0
	 * 		Name   -> Function Insurgency.BlueprintUsableActor.EventOnUseKeyReleased
	 * 		Flags  -> (Native, Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		class AINSSoldier*                                 Pawn                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              ElapsedTime                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	EUseResponse ABlueprintUsableActor::EventOnUseKeyReleased(class AINSSoldier* Pawn, float ElapsedTime)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.BlueprintUsableActor.EventOnUseKeyReleased");
		
		ABlueprintUsableActor_EventOnUseKeyReleased_Params params {};
		params.Pawn = Pawn;
		params.ElapsedTime = ElapsedTime;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00CF51C0
	 * 		Name   -> Function Insurgency.BlueprintUsableActor.EventOnUseComplete
	 * 		Flags  -> (Native, Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		class AINSSoldier*                                 Pawn                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ABlueprintUsableActor::EventOnUseComplete(class AINSSoldier* Pawn)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.BlueprintUsableActor.EventOnUseComplete");
		
		ABlueprintUsableActor_EventOnUseComplete_Params params {};
		params.Pawn = Pawn;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x04E16250
	 * 		Name   -> Function Insurgency.BlueprintUsableActor.EventOnUseCancelled
	 * 		Flags  -> (Native, Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		class AINSSoldier*                                 Pawn                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ABlueprintUsableActor::EventOnUseCancelled(class AINSSoldier* Pawn)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.BlueprintUsableActor.EventOnUseCancelled");
		
		ABlueprintUsableActor_EventOnUseCancelled_Params params {};
		params.Pawn = Pawn;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05629010
	 * 		Name   -> Function Insurgency.BlueprintUsableActor.EventGetUseTimeoutFraction
	 * 		Flags  -> (Native, Event, Public, BlueprintEvent, Const)
	 * Parameters:
	 * 		class AINSSoldier*                                 Pawn                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	float ABlueprintUsableActor::EventGetUseTimeoutFraction(class AINSSoldier* Pawn)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.BlueprintUsableActor.EventGetUseTimeoutFraction");
		
		ABlueprintUsableActor_EventGetUseTimeoutFraction_Params params {};
		params.Pawn = Pawn;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05628E20
	 * 		Name   -> Function Insurgency.BlueprintUsableActor.EventGetUseImage
	 * 		Flags  -> (Native, Event, Public, HasOutParms, BlueprintEvent)
	 * Parameters:
	 * 		class AINSPlayerController*                        Controller                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bInProgress                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FHitResult                                  UseHitResult                                               (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 * 		class FText                                        OutAdditonalText                                           (Parm, OutParm, NativeAccessSpecifierPublic)
	 */
	class UTexture2D* ABlueprintUsableActor::EventGetUseImage(class AINSPlayerController* Controller, bool bInProgress, const struct FHitResult& UseHitResult, class FText* OutAdditonalText)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.BlueprintUsableActor.EventGetUseImage");
		
		ABlueprintUsableActor_EventGetUseImage_Params params {};
		params.Controller = Controller;
		params.bInProgress = bInProgress;
		params.UseHitResult = UseHitResult;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutAdditonalText != nullptr)
			*OutAdditonalText = params.OutAdditonalText;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05628D80
	 * 		Name   -> Function Insurgency.BlueprintUsableActor.EventGetSubUseTimeoutFraction
	 * 		Flags  -> (Native, Event, Public, BlueprintEvent, Const)
	 * Parameters:
	 * 		class AINSSoldier*                                 Pawn                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	float ABlueprintUsableActor::EventGetSubUseTimeoutFraction(class AINSSoldier* Pawn)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.BlueprintUsableActor.EventGetSubUseTimeoutFraction");
		
		ABlueprintUsableActor_EventGetSubUseTimeoutFraction_Params params {};
		params.Pawn = Pawn;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05628B90
	 * 		Name   -> Function Insurgency.BlueprintUsableActor.EventGetSubUseImage
	 * 		Flags  -> (Native, Event, Public, HasOutParms, BlueprintEvent)
	 * Parameters:
	 * 		class AINSPlayerController*                        Controller                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bInProgress                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FHitResult                                  UseHitResult                                               (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 * 		class FText                                        OutAdditonalText                                           (Parm, OutParm, NativeAccessSpecifierPublic)
	 */
	class UTexture2D* ABlueprintUsableActor::EventGetSubUseImage(class AINSPlayerController* Controller, bool bInProgress, const struct FHitResult& UseHitResult, class FText* OutAdditonalText)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.BlueprintUsableActor.EventGetSubUseImage");
		
		ABlueprintUsableActor_EventGetSubUseImage_Params params {};
		params.Controller = Controller;
		params.bInProgress = bInProgress;
		params.UseHitResult = UseHitResult;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutAdditonalText != nullptr)
			*OutAdditonalText = params.OutAdditonalText;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05628A40
	 * 		Name   -> Function Insurgency.BlueprintUsableActor.EventGetDynamicHintLocation
	 * 		Flags  -> (Native, Event, Public, HasOutParms, HasDefaults, BlueprintEvent)
	 * Parameters:
	 * 		class AINSSoldier*                                 Pawn                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FHitResult                                  Hit                                                        (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	struct FVector ABlueprintUsableActor::EventGetDynamicHintLocation(class AINSSoldier* Pawn, const struct FHitResult& Hit)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.BlueprintUsableActor.EventGetDynamicHintLocation");
		
		ABlueprintUsableActor_EventGetDynamicHintLocation_Params params {};
		params.Pawn = Pawn;
		params.Hit = Hit;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056289A0
	 * 		Name   -> Function Insurgency.BlueprintUsableActor.EventCanUse
	 * 		Flags  -> (Native, Event, Public, BlueprintEvent, Const)
	 * Parameters:
	 * 		class AINSSoldier*                                 User                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool ABlueprintUsableActor::EventCanUse(class AINSSoldier* User)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.BlueprintUsableActor.EventCanUse");
		
		ABlueprintUsableActor_EventCanUse_Params params {};
		params.User = User;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05628900
	 * 		Name   -> Function Insurgency.BlueprintUsableActor.EventCanContinueUse
	 * 		Flags  -> (Native, Event, Public, BlueprintEvent, Const)
	 * Parameters:
	 * 		class AINSSoldier*                                 User                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool ABlueprintUsableActor::EventCanContinueUse(class AINSSoldier* User)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.BlueprintUsableActor.EventCanContinueUse");
		
		ABlueprintUsableActor_EventCanContinueUse_Params params {};
		params.User = User;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ABlueprintUsableActor.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ABlueprintUsableActor::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.BlueprintUsableActor");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056295D0
	 * 		Name   -> Function Insurgency.BotBehavior.GetTimeSinceBehaviorStarted
	 * 		Flags  -> (Final, Native, Protected, BlueprintCallable, BlueprintPure)
	 */
	float UBotBehavior::GetTimeSinceBehaviorStarted()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.BotBehavior.GetTimeSinceBehaviorStarted");
		
		UBotBehavior_GetTimeSinceBehaviorStarted_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056295A0
	 * 		Name   -> Function Insurgency.BotBehavior.GetPriority
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	EBotBehaviorPriority UBotBehavior::GetPriority()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.BotBehavior.GetPriority");
		
		UBotBehavior_GetPriority_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05629560
	 * 		Name   -> Function Insurgency.BotBehavior.GetBehaviorName
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	class FName UBotBehavior::GetBehaviorName()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.BotBehavior.GetBehaviorName");
		
		UBotBehavior_GetBehaviorName_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UBotBehavior.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UBotBehavior::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.BotBehavior");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0562E1F0
	 * 		Name   -> Function Insurgency.BotHandler.GetController
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	class AINSAISoldierController* UBotHandler::GetController()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.BotHandler.GetController");
		
		UBotHandler_GetController_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UBotHandler.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UBotHandler::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.BotHandler");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056297E0
	 * 		Name   -> Function Insurgency.BotBehaviorHandler.GetBehaviors
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	TArray<class UBotBehavior*> UBotBehaviorHandler::GetBehaviors()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.BotBehaviorHandler.GetBehaviors");
		
		UBotBehaviorHandler_GetBehaviors_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056297B0
	 * 		Name   -> Function Insurgency.BotBehaviorHandler.GetActiveBehavior
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	class UBotBehavior* UBotBehaviorHandler::GetActiveBehavior()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.BotBehaviorHandler.GetActiveBehavior");
		
		UBotBehaviorHandler_GetActiveBehavior_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UBotBehaviorHandler.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UBotBehaviorHandler::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.BotBehaviorHandler");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UBotFirearmBehavior.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UBotFirearmBehavior::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.BotFirearmBehavior");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UBotBehavior_ADSWithPrimary.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UBotBehavior_ADSWithPrimary::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.BotBehavior_ADSWithPrimary");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UBotBehavior_ADSWithSecondary.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UBotBehavior_ADSWithSecondary::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.BotBehavior_ADSWithSecondary");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UBotBehavior_Ambush.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UBotBehavior_Ambush::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.BotBehavior_Ambush");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UBotBehavior_AttackMelee.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UBotBehavior_AttackMelee::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.BotBehavior_AttackMelee");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UBotBehavior_AttackRanged.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UBotBehavior_AttackRanged::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.BotBehavior_AttackRanged");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UBotBlinkConfig.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UBotBlinkConfig::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.BotBlinkConfig");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UBotBehavior_Blink.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UBotBehavior_Blink::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.BotBehavior_Blink");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0562A680
	 * 		Name   -> Function Insurgency.BotBehavior_Blueprint.BlueprintUpdate
	 * 		Flags  -> (Native, Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		class AINSAISoldierController*                     Me                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	EBotBehaviorReturnResult UBotBehavior_Blueprint::BlueprintUpdate(class AINSAISoldierController* Me)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.BotBehavior_Blueprint.BlueprintUpdate");
		
		UBotBehavior_Blueprint_BlueprintUpdate_Params params {};
		params.Me = Me;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> Function Insurgency.BotBehavior_Blueprint.BlueprintReset
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 */
	void UBotBehavior_Blueprint::BlueprintReset()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.BotBehavior_Blueprint.BlueprintReset");
		
		UBotBehavior_Blueprint_BlueprintReset_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0562A5E0
	 * 		Name   -> Function Insurgency.BotBehavior_Blueprint.BlueprintOnStart
	 * 		Flags  -> (Native, Event, Public, BlueprintEvent, Const)
	 * Parameters:
	 * 		class AINSAISoldierController*                     Me                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	EBotBehaviorReturnResult UBotBehavior_Blueprint::BlueprintOnStart(class AINSAISoldierController* Me)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.BotBehavior_Blueprint.BlueprintOnStart");
		
		UBotBehavior_Blueprint_BlueprintOnStart_Params params {};
		params.Me = Me;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> Function Insurgency.BotBehavior_Blueprint.BlueprintOnOtherSoldierKilled
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		class AINSSoldier*                                 Soldier                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              DistanceToVictim                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Damage                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AController*                                 Killer                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      DamageCauser                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UBotBehavior_Blueprint::BlueprintOnOtherSoldierKilled(class AINSSoldier* Soldier, float DistanceToVictim, float Damage, class AController* Killer, class AActor* DamageCauser)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.BotBehavior_Blueprint.BlueprintOnOtherSoldierKilled");
		
		UBotBehavior_Blueprint_BlueprintOnOtherSoldierKilled_Params params {};
		params.Soldier = Soldier;
		params.DistanceToVictim = DistanceToVictim;
		params.Damage = Damage;
		params.Killer = Killer;
		params.DamageCauser = DamageCauser;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> Function Insurgency.BotBehavior_Blueprint.BlueprintOnMoveCompleted
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		class AINSAISoldierController*                     Me                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FAIRequestID                                RequestID                                                  (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bSuccess                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bInterrupted                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UBotBehavior_Blueprint::BlueprintOnMoveCompleted(class AINSAISoldierController* Me, const struct FAIRequestID& RequestID, bool bSuccess, bool bInterrupted)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.BotBehavior_Blueprint.BlueprintOnMoveCompleted");
		
		UBotBehavior_Blueprint_BlueprintOnMoveCompleted_Params params {};
		params.Me = Me;
		params.RequestID = RequestID;
		params.bSuccess = bSuccess;
		params.bInterrupted = bInterrupted;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> Function Insurgency.BotBehavior_Blueprint.BlueprintOnHeardEnemySound
	 * 		Flags  -> (Event, Public, HasOutParms, HasDefaults, BlueprintEvent)
	 * Parameters:
	 * 		class AINSAISoldierController*                     Me                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      Emitter                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     Position                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bHasLOS                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UBotBehavior_Blueprint::BlueprintOnHeardEnemySound(class AINSAISoldierController* Me, class AActor* Emitter, const struct FVector& Position, bool bHasLOS)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.BotBehavior_Blueprint.BlueprintOnHeardEnemySound");
		
		UBotBehavior_Blueprint_BlueprintOnHeardEnemySound_Params params {};
		params.Me = Me;
		params.Emitter = Emitter;
		params.Position = Position;
		params.bHasLOS = bHasLOS;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x04F3A920
	 * 		Name   -> Function Insurgency.BotBehavior_Blueprint.BlueprintOnFinish
	 * 		Flags  -> (Native, Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		class AINSAISoldierController*                     Me                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UBotBehavior_Blueprint::BlueprintOnFinish(class AINSAISoldierController* Me)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.BotBehavior_Blueprint.BlueprintOnFinish");
		
		UBotBehavior_Blueprint_BlueprintOnFinish_Params params {};
		params.Me = Me;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0562A540
	 * 		Name   -> Function Insurgency.BotBehavior_Blueprint.BlueprintCanEnter
	 * 		Flags  -> (Native, Event, Public, BlueprintEvent, Const)
	 * Parameters:
	 * 		class AINSAISoldierController*                     Me                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UBotBehavior_Blueprint::BlueprintCanEnter(class AINSAISoldierController* Me)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.BotBehavior_Blueprint.BlueprintCanEnter");
		
		UBotBehavior_Blueprint_BlueprintCanEnter_Params params {};
		params.Me = Me;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UBotBehavior_Blueprint.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UBotBehavior_Blueprint::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.BotBehavior_Blueprint");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UBotBehavior_ClearObjective.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UBotBehavior_ClearObjective::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.BotBehavior_ClearObjective");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UBotBehavior_DestroyObjective.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UBotBehavior_DestroyObjective::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.BotBehavior_DestroyObjective");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UBotBehavior_Example_ShootAtTarget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UBotBehavior_Example_ShootAtTarget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.BotBehavior_Example_ShootAtTarget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UBotBehavior_Example_Wander.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UBotBehavior_Example_Wander::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.BotBehavior_Example_Wander");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UBotBehavior_FireRocket.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UBotBehavior_FireRocket::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.BotBehavior_FireRocket");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UBotBehavior_FleeGrenade.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UBotBehavior_FleeGrenade::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.BotBehavior_FleeGrenade");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UBotBehavior_FlushTarget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UBotBehavior_FlushTarget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.BotBehavior_FlushTarget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UBotBehavior_FollowSquadLeader.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UBotBehavior_FollowSquadLeader::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.BotBehavior_FollowSquadLeader");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UBotBehavior_HipFireWithPrimary.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UBotBehavior_HipFireWithPrimary::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.BotBehavior_HipFireWithPrimary");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UBotBehavior_Investigate.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UBotBehavior_Investigate::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.BotBehavior_Investigate");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UBotBehavior_MoveToObjective.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UBotBehavior_MoveToObjective::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.BotBehavior_MoveToObjective");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UBotBehavior_MoveToSeat.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UBotBehavior_MoveToSeat::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.BotBehavior_MoveToSeat");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UBotBehavior_OutpostPrepare.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UBotBehavior_OutpostPrepare::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.BotBehavior_OutpostPrepare");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UBotBehavior_Pursue.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UBotBehavior_Pursue::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.BotBehavior_Pursue");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UBotBehavior_ReloadBackupWeapon.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UBotBehavior_ReloadBackupWeapon::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.BotBehavior_ReloadBackupWeapon");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UBotBehavior_ReloadEquippedWeapon.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UBotBehavior_ReloadEquippedWeapon::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.BotBehavior_ReloadEquippedWeapon");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UBotBehavior_RequestFireSupport.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UBotBehavior_RequestFireSupport::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.BotBehavior_RequestFireSupport");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UBotBehavior_Retreat.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UBotBehavior_Retreat::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.BotBehavior_Retreat");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UBotBehavior_SeekAndDestroy.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UBotBehavior_SeekAndDestroy::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.BotBehavior_SeekAndDestroy");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UBotSuicideBomberConfig.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UBotSuicideBomberConfig::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.BotSuicideBomberConfig");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UBotBehavior_SuicideBomb.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UBotBehavior_SuicideBomb::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.BotBehavior_SuicideBomb");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UBotBehavior_SuppressTarget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UBotBehavior_SuppressTarget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.BotBehavior_SuppressTarget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UBotBehavior_TacticalMoveToObjective.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UBotBehavior_TacticalMoveToObjective::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.BotBehavior_TacticalMoveToObjective");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UBotBehavior_ThrowBackGrenade.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UBotBehavior_ThrowBackGrenade::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.BotBehavior_ThrowBackGrenade");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UBotBehavior_ThrowGrenade.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UBotBehavior_ThrowGrenade::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.BotBehavior_ThrowGrenade");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UBotBehavior_ThrowGrenadeAtWindows.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UBotBehavior_ThrowGrenadeAtWindows::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.BotBehavior_ThrowGrenadeAtWindows");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UBotBehavior_ThrowSmokeGrenade.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UBotBehavior_ThrowSmokeGrenade::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.BotBehavior_ThrowSmokeGrenade");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UBotBehavior_UseSmartActor.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UBotBehavior_UseSmartActor::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.BotBehavior_UseSmartActor");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UBotBehavior_Vehicle.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UBotBehavior_Vehicle::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.BotBehavior_Vehicle");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UBotBehavior_Wander.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UBotBehavior_Wander::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.BotBehavior_Wander");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UBotSkillConfig.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UBotSkillConfig::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.BotSkillConfig");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0562DED0
	 * 		Name   -> Function Insurgency.BotCombatHandler.WantsToReload
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bTakeIntoAccountReloadPossibility                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UBotCombatHandler::WantsToReload(bool bTakeIntoAccountReloadPossibility)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.BotCombatHandler.WantsToReload");
		
		UBotCombatHandler_WantsToReload_Params params {};
		params.bTakeIntoAccountReloadPossibility = bTakeIntoAccountReloadPossibility;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0562DE40
	 * 		Name   -> Function Insurgency.BotCombatHandler.SwitchWeapon
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		EItemSlot                                          Slot                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UBotCombatHandler::SwitchWeapon(EItemSlot Slot)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.BotCombatHandler.SwitchWeapon");
		
		UBotCombatHandler_SwitchWeapon_Params params {};
		params.Slot = Slot;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0562DE10
	 * 		Name   -> Function Insurgency.BotCombatHandler.ShouldWearGasMask
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool UBotCombatHandler::ShouldWearGasMask()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.BotCombatHandler.ShouldWearGasMask");
		
		UBotCombatHandler_ShouldWearGasMask_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0562DDE0
	 * 		Name   -> Function Insurgency.BotCombatHandler.ShouldSpeakReactions
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
	 */
	bool UBotCombatHandler::ShouldSpeakReactions()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.BotCombatHandler.ShouldSpeakReactions");
		
		UBotCombatHandler_ShouldSpeakReactions_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0562DD60
	 * 		Name   -> Function Insurgency.BotCombatHandler.SetTargetSeat
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UVehicleSeatComponent*                       Seat                                                       (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UBotCombatHandler::SetTargetSeat(class UVehicleSeatComponent* Seat)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.BotCombatHandler.SetTargetSeat");
		
		UBotCombatHandler_SetTargetSeat_Params params {};
		params.Seat = Seat;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0562DCD0
	 * 		Name   -> Function Insurgency.BotCombatHandler.SetSuppressing
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bState                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UBotCombatHandler::SetSuppressing(bool bState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.BotCombatHandler.SetSuppressing");
		
		UBotCombatHandler_SetSuppressing_Params params {};
		params.bState = bState;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0562DC50
	 * 		Name   -> Function Insurgency.BotCombatHandler.SetSpeakReactions
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bShouldSpeak                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UBotCombatHandler::SetSpeakReactions(bool bShouldSpeak)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.BotCombatHandler.SetSpeakReactions");
		
		UBotCombatHandler_SetSpeakReactions_Params params {};
		params.bShouldSpeak = bShouldSpeak;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0562DBB0
	 * 		Name   -> Function Insurgency.BotCombatHandler.SetLocationToTakeCoverFrom
	 * 		Flags  -> (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FVector                                     Location                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UBotCombatHandler::SetLocationToTakeCoverFrom(const struct FVector& Location)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.BotCombatHandler.SetLocationToTakeCoverFrom");
		
		UBotCombatHandler_SetLocationToTakeCoverFrom_Params params {};
		params.Location = Location;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0562DB30
	 * 		Name   -> Function Insurgency.BotCombatHandler.SetDesiredFiremode
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		EFirearmFiremode                                   NewFiremode                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UBotCombatHandler::SetDesiredFiremode(EFirearmFiremode NewFiremode)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.BotCombatHandler.SetDesiredFiremode");
		
		UBotCombatHandler_SetDesiredFiremode_Params params {};
		params.NewFiremode = NewFiremode;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0562DAA0
	 * 		Name   -> Function Insurgency.BotCombatHandler.SetAttackState
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bShouldFire                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UBotCombatHandler::SetAttackState(bool bShouldFire)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.BotCombatHandler.SetAttackState");
		
		UBotCombatHandler_SetAttackState_Params params {};
		params.bShouldFire = bShouldFire;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0562DA80
	 * 		Name   -> Function Insurgency.BotCombatHandler.SelectBestWeapon
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void UBotCombatHandler::SelectBestWeapon()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.BotCombatHandler.SelectBestWeapon");
		
		UBotCombatHandler_SelectBestWeapon_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0562DA50
	 * 		Name   -> Function Insurgency.BotCombatHandler.Reload
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	bool UBotCombatHandler::Reload()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.BotCombatHandler.Reload");
		
		UBotCombatHandler_Reload_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0562D9C0
	 * 		Name   -> Function Insurgency.BotCombatHandler.IsWeaponEmpty
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		EItemSlot                                          Slot                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UBotCombatHandler::IsWeaponEmpty(EItemSlot Slot)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.BotCombatHandler.IsWeaponEmpty");
		
		UBotCombatHandler_IsWeaponEmpty_Params params {};
		params.Slot = Slot;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0562D930
	 * 		Name   -> Function Insurgency.BotCombatHandler.IsValidSeat
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class UVehicleSeatComponent*                       Seat                                                       (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UBotCombatHandler::IsValidSeat(class UVehicleSeatComponent* Seat)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.BotCombatHandler.IsValidSeat");
		
		UBotCombatHandler_IsValidSeat_Params params {};
		params.Seat = Seat;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0562D8A0
	 * 		Name   -> Function Insurgency.BotCombatHandler.IsThreatAimingTowardMe
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		class AINSSoldier*                                 Threat                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UBotCombatHandler::IsThreatAimingTowardMe(class AINSSoldier* Threat)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.BotCombatHandler.IsThreatAimingTowardMe");
		
		UBotCombatHandler_IsThreatAimingTowardMe_Params params {};
		params.Threat = Threat;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0562D870
	 * 		Name   -> Function Insurgency.BotCombatHandler.IsSwitchingWeapon
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool UBotCombatHandler::IsSwitchingWeapon()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.BotCombatHandler.IsSwitchingWeapon");
		
		UBotCombatHandler_IsSwitchingWeapon_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0562D850
	 * 		Name   -> Function Insurgency.BotCombatHandler.IsSuppressing
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool UBotCombatHandler::IsSuppressing()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.BotCombatHandler.IsSuppressing");
		
		UBotCombatHandler_IsSuppressing_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0562D750
	 * 		Name   -> Function Insurgency.BotCombatHandler.GetTurnSpeed
	 * 		Flags  -> (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		struct FRotator                                    OldRotaton                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		struct FRotator                                    NewRotation                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	float UBotCombatHandler::GetTurnSpeed(const struct FRotator& OldRotaton, const struct FRotator& NewRotation)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.BotCombatHandler.GetTurnSpeed");
		
		UBotCombatHandler_GetTurnSpeed_Params params {};
		params.OldRotaton = OldRotaton;
		params.NewRotation = NewRotation;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0562D730
	 * 		Name   -> Function Insurgency.BotCombatHandler.GetTargetSeat
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	class UVehicleSeatComponent* UBotCombatHandler::GetTargetSeat()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.BotCombatHandler.GetTargetSeat");
		
		UBotCombatHandler_GetTargetSeat_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0519FD70
	 * 		Name   -> Function Insurgency.BotCombatHandler.GetMorale
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
	 */
	float UBotCombatHandler::GetMorale()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.BotCombatHandler.GetMorale");
		
		UBotCombatHandler_GetMorale_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0562D700
	 * 		Name   -> Function Insurgency.BotCombatHandler.GetLocationToTakeCoverFrom
	 * 		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure)
	 */
	struct FVector UBotCombatHandler::GetLocationToTakeCoverFrom()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.BotCombatHandler.GetLocationToTakeCoverFrom");
		
		UBotCombatHandler_GetLocationToTakeCoverFrom_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0562D6E0
	 * 		Name   -> Function Insurgency.BotCombatHandler.GetLastMoraleDecreaseReason
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	EMoraleAdjustmentReason UBotCombatHandler::GetLastMoraleDecreaseReason()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.BotCombatHandler.GetLastMoraleDecreaseReason");
		
		UBotCombatHandler_GetLastMoraleDecreaseReason_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0562D6C0
	 * 		Name   -> Function Insurgency.BotCombatHandler.GetGrenadeThrowbackRadius
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	float UBotCombatHandler::GetGrenadeThrowbackRadius()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.BotCombatHandler.GetGrenadeThrowbackRadius");
		
		UBotCombatHandler_GetGrenadeThrowbackRadius_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0562D600
	 * 		Name   -> Function Insurgency.BotCombatHandler.GetFirearmCategoryConfig
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		class AItemFirearm*                                Firearm                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FFirearmAIConfig UBotCombatHandler::GetFirearmCategoryConfig(class AItemFirearm* Firearm)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.BotCombatHandler.GetFirearmCategoryConfig");
		
		UBotCombatHandler_GetFirearmCategoryConfig_Params params {};
		params.Firearm = Firearm;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0562D560
	 * 		Name   -> Function Insurgency.BotCombatHandler.GetCurrentPriorityTarget
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		bool                                               bVisibleOnly                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UBotKnownTargetMemory* UBotCombatHandler::GetCurrentPriorityTarget(bool bVisibleOnly)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.BotCombatHandler.GetCurrentPriorityTarget");
		
		UBotCombatHandler_GetCurrentPriorityTarget_Params params {};
		params.bVisibleOnly = bVisibleOnly;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0562D540
	 * 		Name   -> Function Insurgency.BotCombatHandler.GetCover
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	class UCoverComponent* UBotCombatHandler::GetCover()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.BotCombatHandler.GetCover");
		
		UBotCombatHandler_GetCover_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0562D4A0
	 * 		Name   -> Function Insurgency.BotCombatHandler.GetChanceToSpotTarget
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		class UBotKnownTargetMemory*                       Target                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	float UBotCombatHandler::GetChanceToSpotTarget(class UBotKnownTargetMemory* Target)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.BotCombatHandler.GetChanceToSpotTarget");
		
		UBotCombatHandler_GetChanceToSpotTarget_Params params {};
		params.Target = Target;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0562D470
	 * 		Name   -> Function Insurgency.BotCombatHandler.GetAttackDelay
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	float UBotCombatHandler::GetAttackDelay()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.BotCombatHandler.GetAttackDelay");
		
		UBotCombatHandler_GetAttackDelay_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0562D3C0
	 * 		Name   -> Function Insurgency.BotCombatHandler.GetAimOffsetForGrenade
	 * 		Flags  -> (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		struct FVector                                     TargetLocation                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FVector2D UBotCombatHandler::GetAimOffsetForGrenade(const struct FVector& TargetLocation)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.BotCombatHandler.GetAimOffsetForGrenade");
		
		UBotCombatHandler_GetAimOffsetForGrenade_Params params {};
		params.TargetLocation = TargetLocation;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0562D320
	 * 		Name   -> Function Insurgency.BotCombatHandler.GetAimLocationOnTarget
	 * 		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		class UBotKnownTargetMemory*                       MyCurrentTarget                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FVector UBotCombatHandler::GetAimLocationOnTarget(class UBotKnownTargetMemory* MyCurrentTarget)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.BotCombatHandler.GetAimLocationOnTarget");
		
		UBotCombatHandler_GetAimLocationOnTarget_Params params {};
		params.MyCurrentTarget = MyCurrentTarget;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0562D300
	 * 		Name   -> Function Insurgency.BotCombatHandler.ClearPriorityTargets
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void UBotCombatHandler::ClearPriorityTargets()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.BotCombatHandler.ClearPriorityTargets");
		
		UBotCombatHandler_ClearPriorityTargets_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0562D240
	 * 		Name   -> Function Insurgency.BotCombatHandler.AddMoraleWithReason
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		float                                              Amount                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EMoraleAdjustmentReason                            Reason                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UBotCombatHandler::AddMoraleWithReason(float Amount, EMoraleAdjustmentReason Reason)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.BotCombatHandler.AddMoraleWithReason");
		
		UBotCombatHandler_AddMoraleWithReason_Params params {};
		params.Amount = Amount;
		params.Reason = Reason;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0562D1C0
	 * 		Name   -> Function Insurgency.BotCombatHandler.AddMorale
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		float                                              Amount                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UBotCombatHandler::AddMorale(float Amount)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.BotCombatHandler.AddMorale");
		
		UBotCombatHandler_AddMorale_Params params {};
		params.Amount = Amount;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UBotCombatHandler.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UBotCombatHandler::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.BotCombatHandler");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0562E3F0
	 * 		Name   -> Function Insurgency.BotInteractComponent.SetEnabled
	 * 		Flags  -> (Final, Native, Protected, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bNewEnabled                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UBotInteractComponent::SetEnabled(bool bNewEnabled)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.BotInteractComponent.SetEnabled");
		
		UBotInteractComponent_SetEnabled_Params params {};
		params.bNewEnabled = bNewEnabled;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UBotInteractComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UBotInteractComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.BotInteractComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0562FA40
	 * 		Name   -> Function Insurgency.BotKnownTargetMemory.WasVisibleRecently
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool UBotKnownTargetMemory::WasVisibleRecently()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.BotKnownTargetMemory.WasVisibleRecently");
		
		UBotKnownTargetMemory_WasVisibleRecently_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0562F9C0
	 * 		Name   -> Function Insurgency.BotKnownTargetMemory.SetThreatRanking
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		float                                              NewThreatRanking                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UBotKnownTargetMemory::SetThreatRanking(float NewThreatRanking)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.BotKnownTargetMemory.SetThreatRanking");
		
		UBotKnownTargetMemory_SetThreatRanking_Params params {};
		params.NewThreatRanking = NewThreatRanking;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0562F9A0
	 * 		Name   -> Function Insurgency.BotKnownTargetMemory.MarkTargetAsDead
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void UBotKnownTargetMemory::MarkTargetAsDead()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.BotKnownTargetMemory.MarkTargetAsDead");
		
		UBotKnownTargetMemory_MarkTargetAsDead_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0562F980
	 * 		Name   -> Function Insurgency.BotKnownTargetMemory.MarkStartedEngaging
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void UBotKnownTargetMemory::MarkStartedEngaging()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.BotKnownTargetMemory.MarkStartedEngaging");
		
		UBotKnownTargetMemory_MarkStartedEngaging_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0562F960
	 * 		Name   -> Function Insurgency.BotKnownTargetMemory.MarkFinishedEngaging
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void UBotKnownTargetMemory::MarkFinishedEngaging()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.BotKnownTargetMemory.MarkFinishedEngaging");
		
		UBotKnownTargetMemory_MarkFinishedEngaging_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0562F8D0
	 * 		Name   -> Function Insurgency.BotKnownTargetMemory.MarkBloatBoxUpdated
	 * 		Flags  -> (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FVector2D                                   NewBloatBox                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UBotKnownTargetMemory::MarkBloatBoxUpdated(const struct FVector2D& NewBloatBox)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.BotKnownTargetMemory.MarkBloatBoxUpdated");
		
		UBotKnownTargetMemory_MarkBloatBoxUpdated_Params params {};
		params.NewBloatBox = NewBloatBox;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0562F840
	 * 		Name   -> Function Insurgency.BotKnownTargetMemory.MakeAwareOfTargetAtLocation
	 * 		Flags  -> (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FVector                                     Location                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UBotKnownTargetMemory::MakeAwareOfTargetAtLocation(const struct FVector& Location)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.BotKnownTargetMemory.MakeAwareOfTargetAtLocation");
		
		UBotKnownTargetMemory_MakeAwareOfTargetAtLocation_Params params {};
		params.Location = Location;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0562F820
	 * 		Name   -> Function Insurgency.BotKnownTargetMemory.MakeAwareOfTarget
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void UBotKnownTargetMemory::MakeAwareOfTarget()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.BotKnownTargetMemory.MakeAwareOfTarget");
		
		UBotKnownTargetMemory_MakeAwareOfTarget_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0562F7E0
	 * 		Name   -> Function Insurgency.BotKnownTargetMemory.IsValidCombatTarget
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool UBotKnownTargetMemory::IsValidCombatTarget()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.BotKnownTargetMemory.IsValidCombatTarget");
		
		UBotKnownTargetMemory_IsValidCombatTarget_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0562F7C0
	 * 		Name   -> Function Insurgency.BotKnownTargetMemory.IsUnreachable
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
	 */
	bool UBotKnownTargetMemory::IsUnreachable()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.BotKnownTargetMemory.IsUnreachable");
		
		UBotKnownTargetMemory_IsUnreachable_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0562F7A0
	 * 		Name   -> Function Insurgency.BotKnownTargetMemory.IsTargetAlive
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool UBotKnownTargetMemory::IsTargetAlive()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.BotKnownTargetMemory.IsTargetAlive");
		
		UBotKnownTargetMemory_IsTargetAlive_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0562F780
	 * 		Name   -> Function Insurgency.BotKnownTargetMemory.IsLookingAtMe
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool UBotKnownTargetMemory::IsLookingAtMe()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.BotKnownTargetMemory.IsLookingAtMe");
		
		UBotKnownTargetMemory_IsLookingAtMe_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0562F750
	 * 		Name   -> Function Insurgency.BotKnownTargetMemory.IsEngaging
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool UBotKnownTargetMemory::IsEngaging()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.BotKnownTargetMemory.IsEngaging");
		
		UBotKnownTargetMemory_IsEngaging_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0562F730
	 * 		Name   -> Function Insurgency.BotKnownTargetMemory.IsBlindingMe
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool UBotKnownTargetMemory::IsBlindingMe()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.BotKnownTargetMemory.IsBlindingMe");
		
		UBotKnownTargetMemory_IsBlindingMe_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0562F710
	 * 		Name   -> Function Insurgency.BotKnownTargetMemory.IsAwareOfTarget
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool UBotKnownTargetMemory::IsAwareOfTarget()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.BotKnownTargetMemory.IsAwareOfTarget");
		
		UBotKnownTargetMemory_IsAwareOfTarget_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0562F6F0
	 * 		Name   -> Function Insurgency.BotKnownTargetMemory.HasLOS
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool UBotKnownTargetMemory::HasLOS()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.BotKnownTargetMemory.HasLOS");
		
		UBotKnownTargetMemory_HasLOS_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0562F660
	 * 		Name   -> Function Insurgency.BotKnownTargetMemory.HasBeenInMeleeFor
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		float                                              Duration                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UBotKnownTargetMemory::HasBeenInMeleeFor(float Duration)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.BotKnownTargetMemory.HasBeenInMeleeFor");
		
		UBotKnownTargetMemory_HasBeenInMeleeFor_Params params {};
		params.Duration = Duration;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0562F640
	 * 		Name   -> Function Insurgency.BotKnownTargetMemory.GetTotalTimeVisible
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	float UBotKnownTargetMemory::GetTotalTimeVisible()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.BotKnownTargetMemory.GetTotalTimeVisible");
		
		UBotKnownTargetMemory_GetTotalTimeVisible_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0562F610
	 * 		Name   -> Function Insurgency.BotKnownTargetMemory.GetTimeSinceStartedEngaging
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	float UBotKnownTargetMemory::GetTimeSinceStartedEngaging()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.BotKnownTargetMemory.GetTimeSinceStartedEngaging");
		
		UBotKnownTargetMemory_GetTimeSinceStartedEngaging_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0562F5E0
	 * 		Name   -> Function Insurgency.BotKnownTargetMemory.GetTimeSinceRegainedLoS
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	float UBotKnownTargetMemory::GetTimeSinceRegainedLoS()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.BotKnownTargetMemory.GetTimeSinceRegainedLoS");
		
		UBotKnownTargetMemory_GetTimeSinceRegainedLoS_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0562F5B0
	 * 		Name   -> Function Insurgency.BotKnownTargetMemory.GetTimeSinceLastSeen
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	float UBotKnownTargetMemory::GetTimeSinceLastSeen()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.BotKnownTargetMemory.GetTimeSinceLastSeen");
		
		UBotKnownTargetMemory_GetTimeSinceLastSeen_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0562F580
	 * 		Name   -> Function Insurgency.BotKnownTargetMemory.GetTimeSinceLastKnown
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	float UBotKnownTargetMemory::GetTimeSinceLastKnown()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.BotKnownTargetMemory.GetTimeSinceLastKnown");
		
		UBotKnownTargetMemory_GetTimeSinceLastKnown_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0562F550
	 * 		Name   -> Function Insurgency.BotKnownTargetMemory.GetTimeSinceLastBloatBoxUpdate
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	float UBotKnownTargetMemory::GetTimeSinceLastBloatBoxUpdate()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.BotKnownTargetMemory.GetTimeSinceLastBloatBoxUpdate");
		
		UBotKnownTargetMemory_GetTimeSinceLastBloatBoxUpdate_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0562F520
	 * 		Name   -> Function Insurgency.BotKnownTargetMemory.GetTimeSinceAwareOfTarget
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	float UBotKnownTargetMemory::GetTimeSinceAwareOfTarget()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.BotKnownTargetMemory.GetTimeSinceAwareOfTarget");
		
		UBotKnownTargetMemory_GetTimeSinceAwareOfTarget_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0562F500
	 * 		Name   -> Function Insurgency.BotKnownTargetMemory.GetThreatRanking
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	float UBotKnownTargetMemory::GetThreatRanking()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.BotKnownTargetMemory.GetThreatRanking");
		
		UBotKnownTargetMemory_GetThreatRanking_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0562F4D0
	 * 		Name   -> Function Insurgency.BotKnownTargetMemory.GetTargetPawn
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	class APawn* UBotKnownTargetMemory::GetTargetPawn()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.BotKnownTargetMemory.GetTargetPawn");
		
		UBotKnownTargetMemory_GetTargetPawn_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0562F410
	 * 		Name   -> Function Insurgency.BotKnownTargetMemory.GetPreviousBloatBox
	 * 		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
	 */
	struct FVector2D UBotKnownTargetMemory::GetPreviousBloatBox()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.BotKnownTargetMemory.GetPreviousBloatBox");
		
		UBotKnownTargetMemory_GetPreviousBloatBox_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0562F3E0
	 * 		Name   -> Function Insurgency.BotKnownTargetMemory.GetLastSeenPosition
	 * 		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
	 */
	struct FVector UBotKnownTargetMemory::GetLastSeenPosition()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.BotKnownTargetMemory.GetLastSeenPosition");
		
		UBotKnownTargetMemory_GetLastSeenPosition_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0562F3B0
	 * 		Name   -> Function Insurgency.BotKnownTargetMemory.GetLastKnownVelocity
	 * 		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
	 */
	struct FVector UBotKnownTargetMemory::GetLastKnownVelocity()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.BotKnownTargetMemory.GetLastKnownVelocity");
		
		UBotKnownTargetMemory_GetLastKnownVelocity_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0562F380
	 * 		Name   -> Function Insurgency.BotKnownTargetMemory.GetLastKnownPosition
	 * 		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
	 */
	struct FVector UBotKnownTargetMemory::GetLastKnownPosition()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.BotKnownTargetMemory.GetLastKnownPosition");
		
		UBotKnownTargetMemory_GetLastKnownPosition_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0562F070
	 * 		Name   -> Function Insurgency.BotKnownTargetMemory.GetCurrentBloatBox
	 * 		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
	 */
	struct FVector2D UBotKnownTargetMemory::GetCurrentBloatBox()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.BotKnownTargetMemory.GetCurrentBloatBox");
		
		UBotKnownTargetMemory_GetCurrentBloatBox_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0562F030
	 * 		Name   -> Function Insurgency.BotKnownTargetMemory.EverHadLOS
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool UBotKnownTargetMemory::EverHadLOS()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.BotKnownTargetMemory.EverHadLOS");
		
		UBotKnownTargetMemory_EverHadLOS_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UBotKnownTargetMemory.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UBotKnownTargetMemory::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.BotKnownTargetMemory");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0562F440
	 * 		Name   -> Function Insurgency.BotMemoryHandler.GetTargetMemoryForPawn
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class APawn*                                       Pawn                                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UBotKnownTargetMemory* UBotMemoryHandler::GetTargetMemoryForPawn(class APawn* Pawn)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.BotMemoryHandler.GetTargetMemoryForPawn");
		
		UBotMemoryHandler_GetTargetMemoryForPawn_Params params {};
		params.Pawn = Pawn;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0562F1B0
	 * 		Name   -> Function Insurgency.BotMemoryHandler.GetKnownTargets
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		EBotKnownQuery                                     QueryType                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		TArray<class UBotKnownTargetMemory*>               KnownTargetArray                                           (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bVisibleOnly                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              MaxTimeSinceLastKnown                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bIgnoreAwareness                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UBotMemoryHandler::GetKnownTargets(EBotKnownQuery QueryType, TArray<class UBotKnownTargetMemory*>* KnownTargetArray, bool bVisibleOnly, float MaxTimeSinceLastKnown, bool bIgnoreAwareness)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.BotMemoryHandler.GetKnownTargets");
		
		UBotMemoryHandler_GetKnownTargets_Params params {};
		params.QueryType = QueryType;
		params.bVisibleOnly = bVisibleOnly;
		params.MaxTimeSinceLastKnown = MaxTimeSinceLastKnown;
		params.bIgnoreAwareness = bIgnoreAwareness;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (KnownTargetArray != nullptr)
			*KnownTargetArray = params.KnownTargetArray;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0562F0A0
	 * 		Name   -> Function Insurgency.BotMemoryHandler.GetKnownCount
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		EBotKnownQuery                                     QueryType                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bVisibleOnly                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              MaxTimeSinceLastKnown                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	int32_t UBotMemoryHandler::GetKnownCount(EBotKnownQuery QueryType, bool bVisibleOnly, float MaxTimeSinceLastKnown)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.BotMemoryHandler.GetKnownCount");
		
		UBotMemoryHandler_GetKnownCount_Params params {};
		params.QueryType = QueryType;
		params.bVisibleOnly = bVisibleOnly;
		params.MaxTimeSinceLastKnown = MaxTimeSinceLastKnown;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0562EFB0
	 * 		Name   -> Function Insurgency.BotMemoryHandler.AddOrUpdateVisiblePawn
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class APawn*                                       SeenPawn                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UBotMemoryHandler::AddOrUpdateVisiblePawn(class APawn* SeenPawn)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.BotMemoryHandler.AddOrUpdateVisiblePawn");
		
		UBotMemoryHandler_AddOrUpdateVisiblePawn_Params params {};
		params.SeenPawn = SeenPawn;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0562EE40
	 * 		Name   -> Function Insurgency.BotMemoryHandler.AddOrUpdateSound
	 * 		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		class APawn*                                       HeardPawn                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     Location                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Distance                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bHasLOS                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UBotMemoryHandler::AddOrUpdateSound(class APawn* HeardPawn, const struct FVector& Location, float Distance, bool bHasLOS)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.BotMemoryHandler.AddOrUpdateSound");
		
		UBotMemoryHandler_AddOrUpdateSound_Params params {};
		params.HeardPawn = HeardPawn;
		params.Location = Location;
		params.Distance = Distance;
		params.bHasLOS = bHasLOS;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UBotMemoryHandler.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UBotMemoryHandler::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.BotMemoryHandler");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0562FDB0
	 * 		Name   -> Function Insurgency.BotMoodHandler.GetMood
	 * 		Flags  -> (Final, Native, Private, BlueprintCallable, BlueprintPure, Const)
	 */
	EBotAIMood UBotMoodHandler::GetMood()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.BotMoodHandler.GetMood");
		
		UBotMoodHandler_GetMood_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0562FD80
	 * 		Name   -> Function Insurgency.BotMoodHandler.GetCombatIntensity
	 * 		Flags  -> (Final, Native, Private, BlueprintCallable, BlueprintPure, Const)
	 */
	float UBotMoodHandler::GetCombatIntensity()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.BotMoodHandler.GetCombatIntensity");
		
		UBotMoodHandler_GetCombatIntensity_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0562FD00
	 * 		Name   -> Function Insurgency.BotMoodHandler.AddCombatIntensity
	 * 		Flags  -> (Final, Native, Private, BlueprintCallable)
	 * Parameters:
	 * 		float                                              Amount                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UBotMoodHandler::AddCombatIntensity(float Amount)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.BotMoodHandler.AddCombatIntensity");
		
		UBotMoodHandler_AddCombatIntensity_Params params {};
		params.Amount = Amount;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UBotMoodHandler.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UBotMoodHandler::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.BotMoodHandler");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UBotMovementHandler.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UBotMovementHandler::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.BotMovementHandler");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05630130
	 * 		Name   -> Function Insurgency.BotObjectiveHandler.HasArrivedAtObjectiveEntrance
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
	 */
	bool UBotObjectiveHandler::HasArrivedAtObjectiveEntrance()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.BotObjectiveHandler.HasArrivedAtObjectiveEntrance");
		
		UBotObjectiveHandler_HasArrivedAtObjectiveEntrance_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05630100
	 * 		Name   -> Function Insurgency.BotObjectiveHandler.HasArrivedAtObjective
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
	 */
	bool UBotObjectiveHandler::HasArrivedAtObjective()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.BotObjectiveHandler.HasArrivedAtObjective");
		
		UBotObjectiveHandler_HasArrivedAtObjective_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056300D0
	 * 		Name   -> Function Insurgency.BotObjectiveHandler.GetDesiredObjective
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	class AObjectiveBase* UBotObjectiveHandler::GetDesiredObjective()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.BotObjectiveHandler.GetDesiredObjective");
		
		UBotObjectiveHandler_GetDesiredObjective_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UBotObjectiveHandler.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UBotObjectiveHandler::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.BotObjectiveHandler");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UBrassManager.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UBrassManager::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.BrassManager");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05630B20
	 * 		Name   -> Function Insurgency.BreakableComponent.SetBrokenMaterials
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void UBreakableComponent::SetBrokenMaterials()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.BreakableComponent.SetBrokenMaterials");
		
		UBreakableComponent_SetBrokenMaterials_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x04DB4160
	 * 		Name   -> Function Insurgency.BreakableComponent.ResetBreakable
	 * 		Flags  -> (Native, Public, BlueprintCallable)
	 */
	void UBreakableComponent::ResetBreakable()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.BreakableComponent.ResetBreakable");
		
		UBreakableComponent_ResetBreakable_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05630B00
	 * 		Name   -> Function Insurgency.BreakableComponent.RemoveChildDecals
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void UBreakableComponent::RemoveChildDecals()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.BreakableComponent.RemoveChildDecals");
		
		UBreakableComponent_RemoveChildDecals_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> Function Insurgency.BreakableComponent.OnReset
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 */
	void UBreakableComponent::OnReset()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.BreakableComponent.OnReset");
		
		UBreakableComponent_OnReset_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05630AE0
	 * 		Name   -> Function Insurgency.BreakableComponent.OnRep_Health
	 * 		Flags  -> (Final, Native, Private)
	 */
	void UBreakableComponent::OnRep_Health()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.BreakableComponent.OnRep_Health");
		
		UBreakableComponent_OnRep_Health_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x04DB4540
	 * 		Name   -> Function Insurgency.BreakableComponent.OnRep_bBrokenAuthority
	 * 		Flags  -> (Native, Public)
	 */
	void UBreakableComponent::OnRep_bBrokenAuthority()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.BreakableComponent.OnRep_bBrokenAuthority");
		
		UBreakableComponent_OnRep_bBrokenAuthority_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x04DB4B20
	 * 		Name   -> Function Insurgency.BreakableComponent.MulticastBreak
	 * 		Flags  -> (Net, Native, Event, NetMulticast, Public)
	 */
	void UBreakableComponent::MulticastBreak()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.BreakableComponent.MulticastBreak");
		
		UBreakableComponent_MulticastBreak_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05630AB0
	 * 		Name   -> Function Insurgency.BreakableComponent.IsBroken
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool UBreakableComponent::IsBroken()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.BreakableComponent.IsBroken");
		
		UBreakableComponent_IsBroken_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05630A90
	 * 		Name   -> Function Insurgency.BreakableComponent.ChangeMesh
	 * 		Flags  -> (Final, Native, Private)
	 */
	void UBreakableComponent::ChangeMesh()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.BreakableComponent.ChangeMesh");
		
		UBreakableComponent_ChangeMesh_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05630A60
	 * 		Name   -> Function Insurgency.BreakableComponent.CanBreakThrough
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool UBreakableComponent::CanBreakThrough()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.BreakableComponent.CanBreakThrough");
		
		UBreakableComponent_CanBreakThrough_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056308D0
	 * 		Name   -> Function Insurgency.BreakableComponent.Break
	 * 		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FVector                                     HitLocation                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     ShotDirection                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              DamageImpulse                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FName                                        BoneName                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UBreakableComponent::Break(const struct FVector& HitLocation, const struct FVector& ShotDirection, float DamageImpulse, const class FName& BoneName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.BreakableComponent.Break");
		
		UBreakableComponent_Break_Params params {};
		params.HitLocation = HitLocation;
		params.ShotDirection = ShotDirection;
		params.DamageImpulse = DamageImpulse;
		params.BoneName = BoneName;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> Function Insurgency.BreakableComponent.BlueprintOnHealthChanged
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 */
	void UBreakableComponent::BlueprintOnHealthChanged()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.BreakableComponent.BlueprintOnHealthChanged");
		
		UBreakableComponent_BlueprintOnHealthChanged_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UBreakableComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UBreakableComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.BreakableComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05630E50
	 * 		Name   -> Function Insurgency.BulletManager.SetDebugTraces
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bState                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ABulletManager::SetDebugTraces(bool bState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.BulletManager.SetDebugTraces");
		
		ABulletManager_SetDebugTraces_Params params {};
		params.bState = bState;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05630E50
	 * 		Name   -> Function Insurgency.BulletManager.SetDebugImpacts
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bState                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ABulletManager::SetDebugImpacts(bool bState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.BulletManager.SetDebugImpacts");
		
		ABulletManager_SetDebugImpacts_Params params {};
		params.bState = bState;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05630E20
	 * 		Name   -> Function Insurgency.BulletManager.GetPresimulatedTime
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	float ABulletManager::GetPresimulatedTime()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.BulletManager.GetPresimulatedTime");
		
		ABulletManager_GetPresimulatedTime_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05630D50
	 * 		Name   -> Function Insurgency.BulletManager.AddBullet
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		struct FSimulatedBullet                            InBullet                                                   (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	void ABulletManager::AddBullet(const struct FSimulatedBullet& InBullet)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.BulletManager.AddBullet");
		
		ABulletManager_AddBullet_Params params {};
		params.InBullet = InBullet;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ABulletManager.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ABulletManager::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.BulletManager");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05631C50
	 * 		Name   -> Function Insurgency.BulletPenetrationSettings.GetBulletPenetrationValuesForSurface
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		EPhysicalSurface                                   SurfaceType                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FBulletPenetrationPowerValues UBulletPenetrationSettings::GetBulletPenetrationValuesForSurface(EPhysicalSurface* SurfaceType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.BulletPenetrationSettings.GetBulletPenetrationValuesForSurface");
		
		UBulletPenetrationSettings_GetBulletPenetrationValuesForSurface_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (SurfaceType != nullptr)
			*SurfaceType = params.SurfaceType;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UBulletPenetrationSettings.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UBulletPenetrationSettings::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.BulletPenetrationSettings");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05632320
	 * 		Name   -> Function Insurgency.CaptureZone.OnEndObjectiveOverlap
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		class UPrimitiveComponent*                         OverlappedComponent                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      OtherActor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UPrimitiveComponent*                         OtherComp                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            OtherBodyIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ACaptureZone::OnEndObjectiveOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32_t OtherBodyIndex)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.CaptureZone.OnEndObjectiveOverlap");
		
		ACaptureZone_OnEndObjectiveOverlap_Params params {};
		params.OverlappedComponent = OverlappedComponent;
		params.OtherActor = OtherActor;
		params.OtherComp = OtherComp;
		params.OtherBodyIndex = OtherBodyIndex;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05632110
	 * 		Name   -> Function Insurgency.CaptureZone.OnBeginObjectiveOverlap
	 * 		Flags  -> (Final, Native, Public, HasOutParms)
	 * Parameters:
	 * 		class UPrimitiveComponent*                         OverlappedComponent                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      OtherActor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UPrimitiveComponent*                         OtherComp                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            OtherBodyIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bFromSweep                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FHitResult                                  SweepResult                                                (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	void ACaptureZone::OnBeginObjectiveOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32_t OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.CaptureZone.OnBeginObjectiveOverlap");
		
		ACaptureZone_OnBeginObjectiveOverlap_Params params {};
		params.OverlappedComponent = OverlappedComponent;
		params.OtherActor = OtherActor;
		params.OtherComp = OtherComp;
		params.OtherBodyIndex = OtherBodyIndex;
		params.bFromSweep = bFromSweep;
		params.SweepResult = SweepResult;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ACaptureZone.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ACaptureZone::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.CaptureZone");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00DE30E0
	 * 		Name   -> Function Insurgency.CharacterDialogueComponent.StopActiveDialogue
	 * 		Flags  -> (Native, Public, BlueprintCallable)
	 */
	void UCharacterDialogueComponent::StopActiveDialogue()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.CharacterDialogueComponent.StopActiveDialogue");
		
		UCharacterDialogueComponent_StopActiveDialogue_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056367F0
	 * 		Name   -> Function Insurgency.CharacterDialogueComponent.PlayDialogue
	 * 		Flags  -> (Final, Native, Private, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		struct FCharacterResponseRequest                   SpeakRequest                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		int32_t                                            Seed                                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UCharacterDialogueComponent::PlayDialogue(const struct FCharacterResponseRequest& SpeakRequest, int32_t Seed)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.CharacterDialogueComponent.PlayDialogue");
		
		UCharacterDialogueComponent_PlayDialogue_Params params {};
		params.SpeakRequest = SpeakRequest;
		params.Seed = Seed;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056367D0
	 * 		Name   -> Function Insurgency.CharacterDialogueComponent.OnDialogueFinished
	 * 		Flags  -> (Final, Native, Private)
	 */
	void UCharacterDialogueComponent::OnDialogueFinished()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.CharacterDialogueComponent.OnDialogueFinished");
		
		UCharacterDialogueComponent_OnDialogueFinished_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056367A0
	 * 		Name   -> Function Insurgency.CharacterDialogueComponent.IsPlayingDialogue
	 * 		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure)
	 */
	bool UCharacterDialogueComponent::IsPlayingDialogue()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.CharacterDialogueComponent.IsPlayingDialogue");
		
		UCharacterDialogueComponent_IsPlayingDialogue_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05636760
	 * 		Name   -> Function Insurgency.CharacterDialogueComponent.GetTimeSinceLastSound
	 * 		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure)
	 */
	float UCharacterDialogueComponent::GetTimeSinceLastSound()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.CharacterDialogueComponent.GetTimeSinceLastSound");
		
		UCharacterDialogueComponent_GetTimeSinceLastSound_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UCharacterDialogueComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UCharacterDialogueComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.CharacterDialogueComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UCharacterDialogueDictionary.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UCharacterDialogueDictionary::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.CharacterDialogueDictionary");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UCharacterDialogueStringTable.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UCharacterDialogueStringTable::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.CharacterDialogueStringTable");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05638E30
	 * 		Name   -> Function Insurgency.ChatBox.StartChatInput
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bForTeamOnly                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UChatBox::StartChatInput(bool bForTeamOnly)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ChatBox.StartChatInput");
		
		UChatBox_StartChatInput_Params params {};
		params.bForTeamOnly = bForTeamOnly;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05638D50
	 * 		Name   -> Function Insurgency.ChatBox.SendChatMessage
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class FText                                        Message                                                    (Parm, NativeAccessSpecifierPublic)
	 */
	void UChatBox::SendChatMessage(const class FText& Message)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ChatBox.SendChatMessage");
		
		UChatBox_SendChatMessage_Params params {};
		params.Message = Message;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05638D30
	 * 		Name   -> Function Insurgency.ChatBox.ReduceMessagesSentCount
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void UChatBox::ReduceMessagesSentCount()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ChatBox.ReduceMessagesSentCount");
		
		UChatBox_ReduceMessagesSentCount_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05638C60
	 * 		Name   -> Function Insurgency.ChatBox.OnChatMessageRecieved
	 * 		Flags  -> (Native, Event, Public, HasOutParms, BlueprintEvent)
	 * Parameters:
	 * 		class FText                                        Message                                                    (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UChatBox::OnChatMessageRecieved(const class FText& Message)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ChatBox.OnChatMessageRecieved");
		
		UChatBox_OnChatMessageRecieved_Params params {};
		params.Message = Message;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> Function Insurgency.ChatBox.OnChatInputStarted
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 */
	void UChatBox::OnChatInputStarted()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ChatBox.OnChatInputStarted");
		
		UChatBox_OnChatInputStarted_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> Function Insurgency.ChatBox.OnChatInputEnded
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 */
	void UChatBox::OnChatInputEnded()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ChatBox.OnChatInputEnded");
		
		UChatBox_OnChatInputEnded_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05638C30
	 * 		Name   -> Function Insurgency.ChatBox.IsChatRestricted
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool UChatBox::IsChatRestricted()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ChatBox.IsChatRestricted");
		
		UChatBox_IsChatRestricted_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05638B60
	 * 		Name   -> Function Insurgency.ChatBox.HoldMessage
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		class FText                                        Message                                                    (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UChatBox::HoldMessage(const class FText& Message)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ChatBox.HoldMessage");
		
		UChatBox_HoldMessage_Params params {};
		params.Message = Message;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05638AC0
	 * 		Name   -> Function Insurgency.ChatBox.GetChatBody
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
	 */
	class FText UChatBox::GetChatBody()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ChatBox.GetChatBody");
		
		UChatBox_GetChatBody_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05638AA0
	 * 		Name   -> Function Insurgency.ChatBox.EndChatInput
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void UChatBox::EndChatInput()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ChatBox.EndChatInput");
		
		UChatBox_EndChatInput_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05638A70
	 * 		Name   -> Function Insurgency.ChatBox.AtMaxSendLimit
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
	 */
	bool UChatBox::AtMaxSendLimit()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ChatBox.AtMaxSendLimit");
		
		UChatBox_AtMaxSendLimit_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UChatBox.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UChatBox::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.ChatBox");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05639160
	 * 		Name   -> Function Insurgency.Collectible.GetTokenValueText
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	class FText UCollectible::GetTokenValueText()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.Collectible.GetTokenValueText");
		
		UCollectible_GetTokenValueText_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056390B0
	 * 		Name   -> Function Insurgency.Collectible.GetTokenCostText
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	class FText UCollectible::GetTokenCostText()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.Collectible.GetTokenCostText");
		
		UCollectible_GetTokenCostText_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UCollectible.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UCollectible::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.Collectible");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UCollectibleBundle.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UCollectibleBundle::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.CollectibleBundle");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> Function Insurgency.CompassHUD.UpdateMarkerAngle
	 * 		Flags  -> (Event, Public, HasOutParms, HasDefaults, BlueprintEvent)
	 * Parameters:
	 * 		struct FVector                                     CameraLocation                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FRotator                                    CameraRotation                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UCompassHUD::UpdateMarkerAngle(const struct FVector& CameraLocation, const struct FRotator& CameraRotation)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.CompassHUD.UpdateMarkerAngle");
		
		UCompassHUD_UpdateMarkerAngle_Params params {};
		params.CameraLocation = CameraLocation;
		params.CameraRotation = CameraRotation;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0563A640
	 * 		Name   -> Function Insurgency.CompassHUD.UpdateAlwaysVisible
	 * 		Flags  -> (Final, Native, Private)
	 */
	void UCompassHUD::UpdateAlwaysVisible()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.CompassHUD.UpdateAlwaysVisible");
		
		UCompassHUD_UpdateAlwaysVisible_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0563A5B0
	 * 		Name   -> Function Insurgency.CompassHUD.SetDisplayingMarkers
	 * 		Flags  -> (Final, Native, Protected, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bHasMarkers                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UCompassHUD::SetDisplayingMarkers(bool bHasMarkers)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.CompassHUD.SetDisplayingMarkers");
		
		UCompassHUD_SetDisplayingMarkers_Params params {};
		params.bHasMarkers = bHasMarkers;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0563A530
	 * 		Name   -> Function Insurgency.CompassHUD.OnShowRadialMenu
	 * 		Flags  -> (Final, Native, Private)
	 * Parameters:
	 * 		class UUserWidget*                                 Widget                                                     (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UCompassHUD::OnShowRadialMenu(class UUserWidget* Widget)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.CompassHUD.OnShowRadialMenu");
		
		UCompassHUD_OnShowRadialMenu_Params params {};
		params.Widget = Widget;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0563A510
	 * 		Name   -> Function Insurgency.CompassHUD.OnRoundReset
	 * 		Flags  -> (Final, Native, Protected)
	 */
	void UCompassHUD::OnRoundReset()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.CompassHUD.OnRoundReset");
		
		UCompassHUD_OnRoundReset_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0563A3E0
	 * 		Name   -> Function Insurgency.CompassHUD.OnRoundEnd
	 * 		Flags  -> (Final, Native, Protected, HasOutParms)
	 * Parameters:
	 * 		ERoundConclusion                                   RoundEndReason                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		unsigned char                                      WinningFaction                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		TArray<struct FOtherPlayerAwardedTagline>          Taglines                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UCompassHUD::OnRoundEnd(ERoundConclusion RoundEndReason, unsigned char WinningFaction, TArray<struct FOtherPlayerAwardedTagline> Taglines)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.CompassHUD.OnRoundEnd");
		
		UCompassHUD_OnRoundEnd_Params params {};
		params.RoundEndReason = RoundEndReason;
		params.WinningFaction = WinningFaction;
		params.Taglines = Taglines;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0563A320
	 * 		Name   -> Function Insurgency.CompassHUD.OnPlayerKilled
	 * 		Flags  -> (Final, Native, Private, HasOutParms)
	 * Parameters:
	 * 		struct FPlayerKillNotice                           KillNotice                                                 (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UCompassHUD::OnPlayerKilled(const struct FPlayerKillNotice& KillNotice)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.CompassHUD.OnPlayerKilled");
		
		UCompassHUD_OnPlayerKilled_Params params {};
		params.KillNotice = KillNotice;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0563A2A0
	 * 		Name   -> Function Insurgency.CompassHUD.OnHideRadialMenu
	 * 		Flags  -> (Final, Native, Private)
	 * Parameters:
	 * 		class UUserWidget*                                 Widget                                                     (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UCompassHUD::OnHideRadialMenu(class UUserWidget* Widget)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.CompassHUD.OnHideRadialMenu");
		
		UCompassHUD_OnHideRadialMenu_Params params {};
		params.Widget = Widget;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0563A210
	 * 		Name   -> Function Insurgency.CompassHUD.OnCompassToggledByUser
	 * 		Flags  -> (Final, Native, Private)
	 * Parameters:
	 * 		bool                                               bVisible                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UCompassHUD::OnCompassToggledByUser(bool bVisible)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.CompassHUD.OnCompassToggledByUser");
		
		UCompassHUD_OnCompassToggledByUser_Params params {};
		params.bVisible = bVisible;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0563A1E0
	 * 		Name   -> Function Insurgency.CompassHUD.CanFadeOutCompass
	 * 		Flags  -> (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
	 */
	bool UCompassHUD::CanFadeOutCompass()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.CompassHUD.CanFadeOutCompass");
		
		UCompassHUD_CanFadeOutCompass_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0563A160
	 * 		Name   -> Function Insurgency.CompassHUD.BindGameStateEvent
	 * 		Flags  -> (Final, Native, Protected)
	 * Parameters:
	 * 		class AGameStateBase*                              GameState                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UCompassHUD::BindGameStateEvent(class AGameStateBase* GameState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.CompassHUD.BindGameStateEvent");
		
		UCompassHUD_BindGameStateEvent_Params params {};
		params.GameState = GameState;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UCompassHUD.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UCompassHUD::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.CompassHUD");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UCompetitiveLeaverPenaltyMessage.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UCompetitiveLeaverPenaltyMessage::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.CompetitiveLeaverPenaltyMessage");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0563ABB0
	 * 		Name   -> Function Insurgency.ConsumeItemProxy.ConsumeEntitlement
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FString                                      EntitlementId                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            UserIndex                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UConsumeItemProxy* UConsumeItemProxy::STATIC_ConsumeEntitlement(class UObject* WorldContextObject, const class FString& EntitlementId, int32_t UserIndex)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ConsumeItemProxy.ConsumeEntitlement");
		
		UConsumeItemProxy_ConsumeEntitlement_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.EntitlementId = EntitlementId;
		params.UserIndex = UserIndex;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UConsumeItemProxy.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UConsumeItemProxy::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.ConsumeItemProxy");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0563B250
	 * 		Name   -> Function Insurgency.ControllerLayout.ApplyToProfile
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UINSPlayerLocalProfile*                      Profile                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UControllerLayout::ApplyToProfile(class UINSPlayerLocalProfile* Profile)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ControllerLayout.ApplyToProfile");
		
		UControllerLayout_ApplyToProfile_Params params {};
		params.Profile = Profile;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UControllerLayout.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UControllerLayout::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.ControllerLayout");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0563B750
	 * 		Name   -> Function Insurgency.CopyPoseAnimInstance.SetFollowedSkeletalMesh
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class USkeletalMeshComponent*                      MeshComponent                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UCopyPoseAnimInstance::SetFollowedSkeletalMesh(class USkeletalMeshComponent* MeshComponent)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.CopyPoseAnimInstance.SetFollowedSkeletalMesh");
		
		UCopyPoseAnimInstance_SetFollowedSkeletalMesh_Params params {};
		params.MeshComponent = MeshComponent;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0563B730
	 * 		Name   -> Function Insurgency.CopyPoseAnimInstance.ApplyMorphTargets
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void UCopyPoseAnimInstance::ApplyMorphTargets()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.CopyPoseAnimInstance.ApplyMorphTargets");
		
		UCopyPoseAnimInstance_ApplyMorphTargets_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UCopyPoseAnimInstance.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UCopyPoseAnimInstance::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.CopyPoseAnimInstance");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0563C420
	 * 		Name   -> Function Insurgency.CosmeticCache.SetMergedMeshOnObject
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		class UObject*                                     Object                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UCosmeticCache::SetMergedMeshOnObject(class UObject* Object)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.CosmeticCache.SetMergedMeshOnObject");
		
		UCosmeticCache_SetMergedMeshOnObject_Params params {};
		params.Object = Object;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0563C400
	 * 		Name   -> Function Insurgency.CosmeticCache.PrintCache
	 * 		Flags  -> (Final, Native, Public)
	 */
	void UCosmeticCache::PrintCache()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.CosmeticCache.PrintCache");
		
		UCosmeticCache_PrintCache_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0563C3E0
	 * 		Name   -> Function Insurgency.CosmeticCache.OnSkeletalMeshMergeCompleted
	 * 		Flags  -> (Final, Native, Public)
	 */
	void UCosmeticCache::OnSkeletalMeshMergeCompleted()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.CosmeticCache.OnSkeletalMeshMergeCompleted");
		
		UCosmeticCache_OnSkeletalMeshMergeCompleted_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0563C360
	 * 		Name   -> Function Insurgency.CosmeticCache.OnCosmeticLoaded
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		class UCosmeticItem*                               Cosmetic                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UCosmeticCache::OnCosmeticLoaded(class UCosmeticItem* Cosmetic)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.CosmeticCache.OnCosmeticLoaded");
		
		UCosmeticCache_OnCosmeticLoaded_Params params {};
		params.Cosmetic = Cosmetic;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0563C340
	 * 		Name   -> Function Insurgency.CosmeticCache.Merge
	 * 		Flags  -> (Final, Native, Private)
	 */
	void UCosmeticCache::Merge()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.CosmeticCache.Merge");
		
		UCosmeticCache_Merge_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0563C2C0
	 * 		Name   -> Function Insurgency.CosmeticCache.MarkCosmeticsSet
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		class UObject*                                     Object                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UCosmeticCache::MarkCosmeticsSet(class UObject* Object)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.CosmeticCache.MarkCosmeticsSet");
		
		UCosmeticCache_MarkCosmeticsSet_Params params {};
		params.Object = Object;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0563C230
	 * 		Name   -> Function Insurgency.CosmeticCache.GetMergedMesh
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		class UObject*                                     Object                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UCosmeticItem* UCosmeticCache::GetMergedMesh(class UObject* Object)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.CosmeticCache.GetMergedMesh");
		
		UCosmeticCache_GetMergedMesh_Params params {};
		params.Object = Object;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0563C130
	 * 		Name   -> Function Insurgency.CosmeticCache.GetCosmeticFromCache
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		ECharacterAppearanceSlot                           Slot                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            SubSlot                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UObject*                                     Object                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UCosmeticItem* UCosmeticCache::GetCosmeticFromCache(ECharacterAppearanceSlot Slot, int32_t SubSlot, class UObject* Object)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.CosmeticCache.GetCosmeticFromCache");
		
		UCosmeticCache_GetCosmeticFromCache_Params params {};
		params.Slot = Slot;
		params.SubSlot = SubSlot;
		params.Object = Object;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0563C030
	 * 		Name   -> Function Insurgency.CosmeticCache.CreateNewCosmetic
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		class UClass*                                      CosmeticClass                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UObject*                                     Object                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class USharedCosmeticState*                        SharedState                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UCosmeticItem* UCosmeticCache::CreateNewCosmetic(class UClass* CosmeticClass, class UObject* Object, class USharedCosmeticState* SharedState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.CosmeticCache.CreateNewCosmetic");
		
		UCosmeticCache_CreateNewCosmetic_Params params {};
		params.CosmeticClass = CosmeticClass;
		params.Object = Object;
		params.SharedState = SharedState;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0563BFA0
	 * 		Name   -> Function Insurgency.CosmeticCache.ClearCosmeticCache
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		bool                                               bSwitchedTeams                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UCosmeticCache::ClearCosmeticCache(bool bSwitchedTeams)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.CosmeticCache.ClearCosmeticCache");
		
		UCosmeticCache_ClearCosmeticCache_Params params {};
		params.bSwitchedTeams = bSwitchedTeams;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0563BF20
	 * 		Name   -> Function Insurgency.CosmeticCache.CheckAllMeshesLoaded
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		class UObject*                                     Object                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UCosmeticCache::CheckAllMeshesLoaded(class UObject* Object)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.CosmeticCache.CheckAllMeshesLoaded");
		
		UCosmeticCache_CheckAllMeshesLoaded_Params params {};
		params.Object = Object;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0563BE00
	 * 		Name   -> Function Insurgency.CosmeticCache.CacheCosmetics
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		TArray<class UCosmeticItem*>                       Cosmetics                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UObject*                                     Object                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UCosmeticCache::CacheCosmetics(TArray<class UCosmeticItem*> Cosmetics, class UObject* Object)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.CosmeticCache.CacheCosmetics");
		
		UCosmeticCache_CacheCosmetics_Params params {};
		params.Cosmetics = Cosmetics;
		params.Object = Object;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0563BD40
	 * 		Name   -> Function Insurgency.CosmeticCache.CacheCosmetic
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		class UCosmeticItem*                               Cosmetic                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UObject*                                     Object                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UCosmeticCache::CacheCosmetic(class UCosmeticItem* Cosmetic, class UObject* Object)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.CosmeticCache.CacheCosmetic");
		
		UCosmeticCache_CacheCosmetic_Params params {};
		params.Cosmetic = Cosmetic;
		params.Object = Object;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UCosmeticCache.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UCosmeticCache::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.CosmeticCache");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0563E360
	 * 		Name   -> Function Insurgency.CosmeticItem.UpdateVisibility
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bNewVisibility                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UCosmeticItem::UpdateVisibility(bool bNewVisibility)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.CosmeticItem.UpdateVisibility");
		
		UCosmeticItem_UpdateVisibility_Params params {};
		params.bNewVisibility = bNewVisibility;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x04FDAC20
	 * 		Name   -> Function Insurgency.CosmeticItem.SetupCosmetic
	 * 		Flags  -> (Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UClass*                                      VariationClass                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UCosmeticItem::SetupCosmetic(class UClass* VariationClass)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.CosmeticItem.SetupCosmetic");
		
		UCosmeticItem_SetupCosmetic_Params params {};
		params.VariationClass = VariationClass;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0563E340
	 * 		Name   -> Function Insurgency.CosmeticItem.RemoveCosmetic
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void UCosmeticItem::RemoveCosmetic()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.CosmeticItem.RemoveCosmetic");
		
		UCosmeticItem_RemoveCosmetic_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0563E240
	 * 		Name   -> Function Insurgency.CosmeticItem.ProcessMeshForCache
	 * 		Flags  -> (Final, Native, Static, Public)
	 * Parameters:
	 * 		class UINSSkeletalMeshComponent*                   Mesh                                                       (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UObject*                                     NewOwner                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bCleanMaterials                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UCosmeticItem::STATIC_ProcessMeshForCache(class UINSSkeletalMeshComponent* Mesh, class UObject* NewOwner, bool bCleanMaterials)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.CosmeticItem.ProcessMeshForCache");
		
		UCosmeticItem_ProcessMeshForCache_Params params {};
		params.Mesh = Mesh;
		params.NewOwner = NewOwner;
		params.bCleanMaterials = bCleanMaterials;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0563E220
	 * 		Name   -> Function Insurgency.CosmeticItem.ProcessForCache
	 * 		Flags  -> (Final, Native, Public)
	 */
	void UCosmeticItem::ProcessForCache()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.CosmeticItem.ProcessForCache");
		
		UCosmeticItem_ProcessForCache_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0563E150
	 * 		Name   -> Function Insurgency.CosmeticItem.OwnerHasGearLevelInSlot
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		EItemSlot                                          Slot                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EItemGearLevel                                     Level                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UCosmeticItem::OwnerHasGearLevelInSlot(EItemSlot Slot, EItemGearLevel Level)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.CosmeticItem.OwnerHasGearLevelInSlot");
		
		UCosmeticItem_OwnerHasGearLevelInSlot_Params params {};
		params.Slot = Slot;
		params.Level = Level;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> Function Insurgency.CosmeticItem.OnUpdateEquipmentVariation
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		class UINSSkeletalMeshComponent*                   Mesh                                                       (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UCosmeticItem::OnUpdateEquipmentVariation(class UINSSkeletalMeshComponent* Mesh)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.CosmeticItem.OnUpdateEquipmentVariation");
		
		UCosmeticItem_OnUpdateEquipmentVariation_Params params {};
		params.Mesh = Mesh;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0563DF90
	 * 		Name   -> Function Insurgency.CosmeticItem.OnCosmeticMeshLoaded
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		class UINSSkeletalMeshComponent*                   SkeletalMesh                                               (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FCharacterCosmeticAttachedModel             CosmeticModel                                              (Parm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 * 		bool                                               bFirstPerson                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bBodyMesh                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UCosmeticItem::OnCosmeticMeshLoaded(class UINSSkeletalMeshComponent* SkeletalMesh, const struct FCharacterCosmeticAttachedModel& CosmeticModel, bool bFirstPerson, bool bBodyMesh)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.CosmeticItem.OnCosmeticMeshLoaded");
		
		UCosmeticItem_OnCosmeticMeshLoaded_Params params {};
		params.SkeletalMesh = SkeletalMesh;
		params.CosmeticModel = CosmeticModel;
		params.bFirstPerson = bFirstPerson;
		params.bBodyMesh = bBodyMesh;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0563DED0
	 * 		Name   -> Function Insurgency.CosmeticItem.IsVariationEquippedAnywhere
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		class UClass*                                      VariationClass                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bIncludeSubclasses                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UCosmeticItem::IsVariationEquippedAnywhere(class UClass* VariationClass, bool bIncludeSubclasses)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.CosmeticItem.IsVariationEquippedAnywhere");
		
		UCosmeticItem_IsVariationEquippedAnywhere_Params params {};
		params.VariationClass = VariationClass;
		params.bIncludeSubclasses = bIncludeSubclasses;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0563DEA0
	 * 		Name   -> Function Insurgency.CosmeticItem.IsMeshLoading
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool UCosmeticItem::IsMeshLoading()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.CosmeticItem.IsMeshLoading");
		
		UCosmeticItem_IsMeshLoading_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x04FDFBF0
	 * 		Name   -> Function Insurgency.CosmeticItem.InitSharedState
	 * 		Flags  -> (Native, Public)
	 * Parameters:
	 * 		class USharedCosmeticState*                        NewState                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UCosmeticItem::InitSharedState(class USharedCosmeticState* NewState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.CosmeticItem.InitSharedState");
		
		UCosmeticItem_InitSharedState_Params params {};
		params.NewState = NewState;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0563DCC0
	 * 		Name   -> Function Insurgency.CosmeticItem.InitializeLoadedCosmeticMesh
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		class UINSSkeletalMeshComponent*                   SkeletalMesh                                               (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FCharacterCosmeticAttachedModel             CosmeticModel                                              (Parm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 * 		bool                                               bFirstPerson                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bBodyMesh                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bFromCache                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UCosmeticItem::InitializeLoadedCosmeticMesh(class UINSSkeletalMeshComponent* SkeletalMesh, const struct FCharacterCosmeticAttachedModel& CosmeticModel, bool bFirstPerson, bool bBodyMesh, bool bFromCache)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.CosmeticItem.InitializeLoadedCosmeticMesh");
		
		UCosmeticItem_InitializeLoadedCosmeticMesh_Params params {};
		params.SkeletalMesh = SkeletalMesh;
		params.CosmeticModel = CosmeticModel;
		params.bFirstPerson = bFirstPerson;
		params.bBodyMesh = bBodyMesh;
		params.bFromCache = bFromCache;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0563DBF0
	 * 		Name   -> Function Insurgency.CosmeticItem.InitializeFromCache
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		class UObject*                                     Object                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               OnlyFirstPersonMeshes                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UCosmeticItem::InitializeFromCache(class UObject* Object, bool OnlyFirstPersonMeshes)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.CosmeticItem.InitializeFromCache");
		
		UCosmeticItem_InitializeFromCache_Params params {};
		params.Object = Object;
		params.OnlyFirstPersonMeshes = OnlyFirstPersonMeshes;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0563DA30
	 * 		Name   -> Function Insurgency.CosmeticItem.InitializeAttachedMesh
	 * 		Flags  -> (Final, Native, Public, HasOutParms)
	 * Parameters:
	 * 		class UINSSkeletalMeshComponent*                   AttachedMesh                                               (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FCharacterCosmeticAttachedModel             Model                                                      (Parm, OutParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 * 		bool                                               bFirstPerson                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bBodyMesh                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UCosmeticItem::InitializeAttachedMesh(class UINSSkeletalMeshComponent* AttachedMesh, struct FCharacterCosmeticAttachedModel* Model, bool bFirstPerson, bool bBodyMesh)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.CosmeticItem.InitializeAttachedMesh");
		
		UCosmeticItem_InitializeAttachedMesh_Params params {};
		params.AttachedMesh = AttachedMesh;
		params.bFirstPerson = bFirstPerson;
		params.bBodyMesh = bBodyMesh;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (Model != nullptr)
			*Model = params.Model;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0563DA10
	 * 		Name   -> Function Insurgency.CosmeticItem.InitCosmetic
	 * 		Flags  -> (Native, Public, BlueprintCallable)
	 */
	void UCosmeticItem::InitCosmetic()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.CosmeticItem.InitCosmetic");
		
		UCosmeticItem_InitCosmetic_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0563D8B0
	 * 		Name   -> Function Insurgency.CosmeticItem.HasOtherCosmetic
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		bool                                               bIncludeSubclasses                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UCosmeticItem::HasOtherCosmetic(bool bIncludeSubclasses)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.CosmeticItem.HasOtherCosmetic");
		
		UCosmeticItem_HasOtherCosmetic_Params params {};
		params.bIncludeSubclasses = bIncludeSubclasses;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0563D750
	 * 		Name   -> Function Insurgency.CosmeticItem.HasGearItem
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		bool                                               bIncludeSubclasses                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UCosmeticItem::HasGearItem(bool bIncludeSubclasses)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.CosmeticItem.HasGearItem");
		
		UCosmeticItem_HasGearItem_Params params {};
		params.bIncludeSubclasses = bIncludeSubclasses;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0563D680
	 * 		Name   -> Function Insurgency.CosmeticItem.GetVariationInSlot
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		ECharacterAppearanceSlot                           Slot                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            SubSlot                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UClass* UCosmeticItem::GetVariationInSlot(ECharacterAppearanceSlot Slot, int32_t SubSlot)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.CosmeticItem.GetVariationInSlot");
		
		UCosmeticItem_GetVariationInSlot_Params params {};
		params.Slot = Slot;
		params.SubSlot = SubSlot;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0563D5A0
	 * 		Name   -> Function Insurgency.CosmeticItem.GetOuterMesh
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		bool                                               bFirstPerson                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bBodyMesh                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class USkeletalMeshComponent* UCosmeticItem::GetOuterMesh(bool bFirstPerson, bool bBodyMesh)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.CosmeticItem.GetOuterMesh");
		
		UCosmeticItem_GetOuterMesh_Params params {};
		params.bFirstPerson = bFirstPerson;
		params.bBodyMesh = bBodyMesh;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0563D4C0
	 * 		Name   -> Function Insurgency.CosmeticItem.GetOtherCosmeticsWithVariation
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		TArray<struct FSelectedCosmetic>                   OutOtherCosmetics                                          (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UCosmeticItem::GetOtherCosmeticsWithVariation(TArray<struct FSelectedCosmetic>* OutOtherCosmetics)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.CosmeticItem.GetOtherCosmeticsWithVariation");
		
		UCosmeticItem_GetOtherCosmeticsWithVariation_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutOtherCosmetics != nullptr)
			*OutOtherCosmetics = params.OutOtherCosmetics;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0563D410
	 * 		Name   -> Function Insurgency.CosmeticItem.GetOtherCosmetics
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		TArray<class UClass*>                              OutOtherCosmetics                                          (Parm, OutParm, ZeroConstructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UCosmeticItem::GetOtherCosmetics(TArray<class UClass*>* OutOtherCosmetics)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.CosmeticItem.GetOtherCosmetics");
		
		UCosmeticItem_GetOtherCosmetics_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutOtherCosmetics != nullptr)
			*OutOtherCosmetics = params.OutOtherCosmetics;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0563D3E0
	 * 		Name   -> Function Insurgency.CosmeticItem.CreateDuplicate
	 * 		Flags  -> (Final, Native, Public)
	 */
	class UCosmeticItem* UCosmeticItem::CreateDuplicate()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.CosmeticItem.CreateDuplicate");
		
		UCosmeticItem_CreateDuplicate_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0563D3B0
	 * 		Name   -> Function Insurgency.CosmeticItem.CountMeshesLoading
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	int32_t UCosmeticItem::CountMeshesLoading()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.CosmeticItem.CountMeshesLoading");
		
		UCosmeticItem_CountMeshesLoading_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0563D2A0
	 * 		Name   -> Function Insurgency.CosmeticItem.CheckRestriction
	 * 		Flags  -> (Native, Public, HasOutParms, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		struct FProfileCharacterCosmeticState              CosmeticState                                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	bool UCosmeticItem::CheckRestriction(const struct FProfileCharacterCosmeticState& CosmeticState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.CosmeticItem.CheckRestriction");
		
		UCosmeticItem_CheckRestriction_Params params {};
		params.CosmeticState = CosmeticState;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> Function Insurgency.CosmeticItem.BlueprintRemoveCosmetic
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 */
	void UCosmeticItem::BlueprintRemoveCosmetic()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.CosmeticItem.BlueprintRemoveCosmetic");
		
		UCosmeticItem_BlueprintRemoveCosmetic_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> Function Insurgency.CosmeticItem.BlueprintOnItemRemoved
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		class AItemBase*                                   Item                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UCosmeticItem::BlueprintOnItemRemoved(class AItemBase* Item)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.CosmeticItem.BlueprintOnItemRemoved");
		
		UCosmeticItem_BlueprintOnItemRemoved_Params params {};
		params.Item = Item;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> Function Insurgency.CosmeticItem.BlueprintOnItemAdded
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		class AItemBase*                                   Item                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UCosmeticItem::BlueprintOnItemAdded(class AItemBase* Item)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.CosmeticItem.BlueprintOnItemAdded");
		
		UCosmeticItem_BlueprintOnItemAdded_Params params {};
		params.Item = Item;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> Function Insurgency.CosmeticItem.BlueprintInitSharedState
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		class USharedCosmeticState*                        NewState                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UCosmeticItem::BlueprintInitSharedState(class USharedCosmeticState* NewState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.CosmeticItem.BlueprintInitSharedState");
		
		UCosmeticItem_BlueprintInitSharedState_Params params {};
		params.NewState = NewState;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> Function Insurgency.CosmeticItem.BlueprintInitCosmetic
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		class UClass*                                      VariationClass                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UCosmeticItem::BlueprintInitCosmetic(class UClass* VariationClass)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.CosmeticItem.BlueprintInitCosmetic");
		
		UCosmeticItem_BlueprintInitCosmetic_Params params {};
		params.VariationClass = VariationClass;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> Function Insurgency.CosmeticItem.BlueprintCosmeticMeshLoaded
	 * 		Flags  -> (Event, Public, HasOutParms, BlueprintEvent)
	 * Parameters:
	 * 		class UINSSkeletalMeshComponent*                   SkeletalMesh                                               (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FCharacterCosmeticAttachedModel             CosmeticModel                                              (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 * 		bool                                               bFirstPerson                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bBodyMesh                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UCosmeticItem::BlueprintCosmeticMeshLoaded(class UINSSkeletalMeshComponent* SkeletalMesh, const struct FCharacterCosmeticAttachedModel& CosmeticModel, bool bFirstPerson, bool bBodyMesh)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.CosmeticItem.BlueprintCosmeticMeshLoaded");
		
		UCosmeticItem_BlueprintCosmeticMeshLoaded_Params params {};
		params.SkeletalMesh = SkeletalMesh;
		params.CosmeticModel = CosmeticModel;
		params.bFirstPerson = bFirstPerson;
		params.bBodyMesh = bBodyMesh;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0563D120
	 * 		Name   -> Function Insurgency.CosmeticItem.AttachMesh
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		struct FCharacterCosmeticAttachedModel             MeshToAttach                                               (Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 * 		bool                                               bFirstPerson                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bBodyMesh                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UINSSkeletalMeshComponent* UCosmeticItem::AttachMesh(struct FCharacterCosmeticAttachedModel* MeshToAttach, bool bFirstPerson, bool bBodyMesh)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.CosmeticItem.AttachMesh");
		
		UCosmeticItem_AttachMesh_Params params {};
		params.bFirstPerson = bFirstPerson;
		params.bBodyMesh = bBodyMesh;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (MeshToAttach != nullptr)
			*MeshToAttach = params.MeshToAttach;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0563D010
	 * 		Name   -> Function Insurgency.CosmeticItem.ApplyMaterialSwaps
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		class UINSSkeletalMeshComponent*                   SkeletalMesh                                               (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FCharacterCosmeticAttachedModel             CosmeticModel                                              (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	void UCosmeticItem::ApplyMaterialSwaps(class UINSSkeletalMeshComponent* SkeletalMesh, const struct FCharacterCosmeticAttachedModel& CosmeticModel)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.CosmeticItem.ApplyMaterialSwaps");
		
		UCosmeticItem_ApplyMaterialSwaps_Params params {};
		params.SkeletalMesh = SkeletalMesh;
		params.CosmeticModel = CosmeticModel;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UCosmeticItem.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UCosmeticItem::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.CosmeticItem");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UCosmeticItemArms.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UCosmeticItemArms::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.CosmeticItemArms");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UCosmeticItemMultiSlot.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UCosmeticItemMultiSlot::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.CosmeticItemMultiSlot");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056409C0
	 * 		Name   -> Function Insurgency.CosmeticStatics.ValidateCosmeticState
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FProfileCharacterCosmeticState              State                                                      (Parm, OutParm, NativeAccessSpecifierPublic)
	 * 		ECharacterGender                                   Gender                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UCosmeticStatics::STATIC_ValidateCosmeticState(struct FProfileCharacterCosmeticState* State, ECharacterGender Gender)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.CosmeticStatics.ValidateCosmeticState");
		
		UCosmeticStatics_ValidateCosmeticState_Params params {};
		params.Gender = Gender;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (State != nullptr)
			*State = params.State;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05640900
	 * 		Name   -> Function Insurgency.CosmeticStatics.TranslateSlotToIndex
	 * 		Flags  -> (Final, Native, Static, Public)
	 * Parameters:
	 * 		ECharacterAppearanceSlot                           Slot                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            SubSlot                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	int32_t UCosmeticStatics::STATIC_TranslateSlotToIndex(ECharacterAppearanceSlot Slot, int32_t SubSlot)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.CosmeticStatics.TranslateSlotToIndex");
		
		UCosmeticStatics_TranslateSlotToIndex_Params params {};
		params.Slot = Slot;
		params.SubSlot = SubSlot;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05640840
	 * 		Name   -> Function Insurgency.CosmeticStatics.IsVanityCosmetic
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FSelectedCosmetic                           SelectedCosmetic                                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	bool UCosmeticStatics::STATIC_IsVanityCosmetic(const struct FSelectedCosmetic& SelectedCosmetic)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.CosmeticStatics.IsVanityCosmetic");
		
		UCosmeticStatics_IsVanityCosmetic_Params params {};
		params.SelectedCosmetic = SelectedCosmetic;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05640680
	 * 		Name   -> Function Insurgency.CosmeticStatics.IsCosmeticExcluded
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FProfileCharacterCosmeticState              State                                                      (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	bool UCosmeticStatics::STATIC_IsCosmeticExcluded(const struct FProfileCharacterCosmeticState& State)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.CosmeticStatics.IsCosmeticExcluded");
		
		UCosmeticStatics_IsCosmeticExcluded_Params params {};
		params.State = State;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056405C0
	 * 		Name   -> Function Insurgency.CosmeticStatics.GetSelectedCosmeticValue
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FSelectedCosmetic                           SelectedCosmetic                                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	int32_t UCosmeticStatics::STATIC_GetSelectedCosmeticValue(const struct FSelectedCosmetic& SelectedCosmetic)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.CosmeticStatics.GetSelectedCosmeticValue");
		
		UCosmeticStatics_GetSelectedCosmeticValue_Params params {};
		params.SelectedCosmetic = SelectedCosmetic;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05640500
	 * 		Name   -> Function Insurgency.CosmeticStatics.GetSelectedCosmeticTier
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FSelectedCosmetic                           SelectedCosmetic                                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	struct FCompetitiveUnlockTier UCosmeticStatics::STATIC_GetSelectedCosmeticTier(const struct FSelectedCosmetic& SelectedCosmetic)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.CosmeticStatics.GetSelectedCosmeticTier");
		
		UCosmeticStatics_GetSelectedCosmeticTier_Params params {};
		params.SelectedCosmetic = SelectedCosmetic;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05640440
	 * 		Name   -> Function Insurgency.CosmeticStatics.GetSelectedCosmeticRarity
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FSelectedCosmetic                           SelectedCosmetic                                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	ECollectibleRarity UCosmeticStatics::STATIC_GetSelectedCosmeticRarity(const struct FSelectedCosmetic& SelectedCosmetic)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.CosmeticStatics.GetSelectedCosmeticRarity");
		
		UCosmeticStatics_GetSelectedCosmeticRarity_Params params {};
		params.SelectedCosmetic = SelectedCosmetic;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05640380
	 * 		Name   -> Function Insurgency.CosmeticStatics.GetSelectedCosmeticItemId
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FSelectedCosmetic                           SelectedCosmetic                                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	int32_t UCosmeticStatics::STATIC_GetSelectedCosmeticItemId(const struct FSelectedCosmetic& SelectedCosmetic)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.CosmeticStatics.GetSelectedCosmeticItemId");
		
		UCosmeticStatics_GetSelectedCosmeticItemId_Params params {};
		params.SelectedCosmetic = SelectedCosmetic;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056402C0
	 * 		Name   -> Function Insurgency.CosmeticStatics.GetSelectedCosmeticGender
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FSelectedCosmetic                           SelectedCosmetic                                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	ECharacterGender UCosmeticStatics::STATIC_GetSelectedCosmeticGender(const struct FSelectedCosmetic& SelectedCosmetic)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.CosmeticStatics.GetSelectedCosmeticGender");
		
		UCosmeticStatics_GetSelectedCosmeticGender_Params params {};
		params.SelectedCosmetic = SelectedCosmetic;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056401C0
	 * 		Name   -> Function Insurgency.CosmeticStatics.GetSelectedCosmeticFromItemId
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		int32_t                                            ItemId                                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FSelectedCosmetic                           OutCosmeticPair                                            (Parm, OutParm, NativeAccessSpecifierPublic)
	 */
	bool UCosmeticStatics::STATIC_GetSelectedCosmeticFromItemId(int32_t ItemId, struct FSelectedCosmetic* OutCosmeticPair)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.CosmeticStatics.GetSelectedCosmeticFromItemId");
		
		UCosmeticStatics_GetSelectedCosmeticFromItemId_Params params {};
		params.ItemId = ItemId;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutCosmeticPair != nullptr)
			*OutCosmeticPair = params.OutCosmeticPair;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05640100
	 * 		Name   -> Function Insurgency.CosmeticStatics.GetSelectedCosmeticCost
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FSelectedCosmetic                           SelectedCosmetic                                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	int32_t UCosmeticStatics::STATIC_GetSelectedCosmeticCost(const struct FSelectedCosmetic& SelectedCosmetic)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.CosmeticStatics.GetSelectedCosmeticCost");
		
		UCosmeticStatics_GetSelectedCosmeticCost_Params params {};
		params.SelectedCosmetic = SelectedCosmetic;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0563FEF0
	 * 		Name   -> Function Insurgency.CosmeticStatics.GetIncompatibleCosmetics
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FProfileCharacterCosmeticState              State                                                      (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		TArray<class UClass*>                              OutIncompatibleItems                                       (Parm, OutParm, ZeroConstructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UCosmeticStatics::STATIC_GetIncompatibleCosmetics(const struct FProfileCharacterCosmeticState& State, TArray<class UClass*>* OutIncompatibleItems)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.CosmeticStatics.GetIncompatibleCosmetics");
		
		UCosmeticStatics_GetIncompatibleCosmetics_Params params {};
		params.State = State;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutIncompatibleItems != nullptr)
			*OutIncompatibleItems = params.OutIncompatibleItems;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0563FD10
	 * 		Name   -> Function Insurgency.CosmeticStatics.GetDefaultSelectedCosmeticForSlot
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FSelectedCosmetic                           SelectedCosmetic                                           (Parm, OutParm, NativeAccessSpecifierPublic)
	 * 		struct FProfileCharacterCosmeticState              State                                                      (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		ECharacterAppearanceSlot                           Slot                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            SubSlot                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UCosmeticStatics::STATIC_GetDefaultSelectedCosmeticForSlot(struct FSelectedCosmetic* SelectedCosmetic, const struct FProfileCharacterCosmeticState& State, ECharacterAppearanceSlot Slot, int32_t SubSlot)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.CosmeticStatics.GetDefaultSelectedCosmeticForSlot");
		
		UCosmeticStatics_GetDefaultSelectedCosmeticForSlot_Params params {};
		params.State = State;
		params.Slot = Slot;
		params.SubSlot = SubSlot;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (SelectedCosmetic != nullptr)
			*SelectedCosmetic = params.SelectedCosmetic;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0563FC90
	 * 		Name   -> Function Insurgency.CosmeticStatics.GetCosmeticSlotSubslotCount
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		ECharacterAppearanceSlot                           Slot                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	int32_t UCosmeticStatics::STATIC_GetCosmeticSlotSubslotCount(ECharacterAppearanceSlot Slot)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.CosmeticStatics.GetCosmeticSlotSubslotCount");
		
		UCosmeticStatics_GetCosmeticSlotSubslotCount_Params params {};
		params.Slot = Slot;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0563FB00
	 * 		Name   -> Function Insurgency.CosmeticStatics.DoesCosmeticSlotSupportEmptyForState
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		ECharacterAppearanceSlot                           Slot                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FProfileCharacterCosmeticState              State                                                      (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		int32_t                                            SubSlot                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UCosmeticStatics::STATIC_DoesCosmeticSlotSupportEmptyForState(ECharacterAppearanceSlot Slot, const struct FProfileCharacterCosmeticState& State, int32_t SubSlot)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.CosmeticStatics.DoesCosmeticSlotSupportEmptyForState");
		
		UCosmeticStatics_DoesCosmeticSlotSupportEmptyForState_Params params {};
		params.Slot = Slot;
		params.State = State;
		params.SubSlot = SubSlot;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0563FA10
	 * 		Name   -> Function Insurgency.CosmeticStatics.DoesCosmeticSlotSupportEmpty
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		ECharacterAppearanceSlot                           Slot                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            SubSlot                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FName                                        Faction                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UCosmeticStatics::STATIC_DoesCosmeticSlotSupportEmpty(ECharacterAppearanceSlot Slot, int32_t SubSlot, const class FName& Faction)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.CosmeticStatics.DoesCosmeticSlotSupportEmpty");
		
		UCosmeticStatics_DoesCosmeticSlotSupportEmpty_Params params {};
		params.Slot = Slot;
		params.SubSlot = SubSlot;
		params.Faction = Faction;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0563F890
	 * 		Name   -> Function Insurgency.CosmeticStatics.CosmeticStateRemoveAllInSlot
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		struct FProfileCharacterCosmeticState              State                                                      (Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		ECharacterAppearanceSlot                           Slot                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            SubSlot                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UCosmeticStatics::STATIC_CosmeticStateRemoveAllInSlot(struct FProfileCharacterCosmeticState* State, ECharacterAppearanceSlot Slot, int32_t SubSlot)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.CosmeticStatics.CosmeticStateRemoveAllInSlot");
		
		UCosmeticStatics_CosmeticStateRemoveAllInSlot_Params params {};
		params.Slot = Slot;
		params.SubSlot = SubSlot;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (State != nullptr)
			*State = params.State;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0563F700
	 * 		Name   -> Function Insurgency.CosmeticStatics.CosmeticStateHasItemInSlot
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FProfileCharacterCosmeticState              State                                                      (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		ECharacterAppearanceSlot                           Slot                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            SubSlot                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UCosmeticStatics::STATIC_CosmeticStateHasItemInSlot(const struct FProfileCharacterCosmeticState& State, ECharacterAppearanceSlot Slot, int32_t SubSlot)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.CosmeticStatics.CosmeticStateHasItemInSlot");
		
		UCosmeticStatics_CosmeticStateHasItemInSlot_Params params {};
		params.State = State;
		params.Slot = Slot;
		params.SubSlot = SubSlot;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0563F520
	 * 		Name   -> Function Insurgency.CosmeticStatics.CosmeticStateGetItemInSlot
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FProfileCharacterCosmeticState              State                                                      (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		ECharacterAppearanceSlot                           Slot                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            SubSlot                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FSelectedCosmetic                           OutCosmeticPair                                            (Parm, OutParm, NativeAccessSpecifierPublic)
	 */
	bool UCosmeticStatics::STATIC_CosmeticStateGetItemInSlot(const struct FProfileCharacterCosmeticState& State, ECharacterAppearanceSlot Slot, int32_t SubSlot, struct FSelectedCosmetic* OutCosmeticPair)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.CosmeticStatics.CosmeticStateGetItemInSlot");
		
		UCosmeticStatics_CosmeticStateGetItemInSlot_Params params {};
		params.State = State;
		params.Slot = Slot;
		params.SubSlot = SubSlot;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutCosmeticPair != nullptr)
			*OutCosmeticPair = params.OutCosmeticPair;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0563F430
	 * 		Name   -> Function Insurgency.CosmeticStatics.CosmeticStateGetGender
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FProfileCharacterCosmeticState              State                                                      (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	ECharacterGender UCosmeticStatics::STATIC_CosmeticStateGetGender(const struct FProfileCharacterCosmeticState& State)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.CosmeticStatics.CosmeticStateGetGender");
		
		UCosmeticStatics_CosmeticStateGetGender_Params params {};
		params.State = State;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0563F2B0
	 * 		Name   -> Function Insurgency.CosmeticStatics.CosmeticStateGetExclusions
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		struct FProfileCharacterCosmeticState              State                                                      (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UCosmeticStatics::STATIC_CosmeticStateGetExclusions(const struct FProfileCharacterCosmeticState& State)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.CosmeticStatics.CosmeticStateGetExclusions");
		
		UCosmeticStatics_CosmeticStateGetExclusions_Params params {};
		params.State = State;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0563F0F0
	 * 		Name   -> Function Insurgency.CosmeticStatics.CosmeticStateContainsItem
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FProfileCharacterCosmeticState              State                                                      (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	bool UCosmeticStatics::STATIC_CosmeticStateContainsItem(const struct FProfileCharacterCosmeticState& State)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.CosmeticStatics.CosmeticStateContainsItem");
		
		UCosmeticStatics_CosmeticStateContainsItem_Params params {};
		params.State = State;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0563F070
	 * 		Name   -> Function Insurgency.CosmeticStatics.CosmeticSlotHasSubslots
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		ECharacterAppearanceSlot                           Slot                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UCosmeticStatics::STATIC_CosmeticSlotHasSubslots(ECharacterAppearanceSlot Slot)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.CosmeticStatics.CosmeticSlotHasSubslots");
		
		UCosmeticStatics_CosmeticSlotHasSubslots_Params params {};
		params.Slot = Slot;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UCosmeticStatics.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UCosmeticStatics::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.CosmeticStatics");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05641950
	 * 		Name   -> Function Insurgency.CosmeticVariation.RemoveVariation
	 * 		Flags  -> (Final, Native, Public)
	 */
	void UCosmeticVariation::RemoveVariation()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.CosmeticVariation.RemoveVariation");
		
		UCosmeticVariation_RemoveVariation_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05641870
	 * 		Name   -> Function Insurgency.CosmeticVariation.InitVariation
	 * 		Flags  -> (Native, Public, HasOutParms)
	 */
	void UCosmeticVariation::InitVariation()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.CosmeticVariation.InitVariation");
		
		UCosmeticVariation_InitVariation_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056417E0
	 * 		Name   -> Function Insurgency.CosmeticVariation.GetRarityWithItem
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		class UClass*                                      ItemClass                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	ECollectibleRarity UCosmeticVariation::GetRarityWithItem(class UClass* ItemClass)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.CosmeticVariation.GetRarityWithItem");
		
		UCosmeticVariation_GetRarityWithItem_Params params {};
		params.ItemClass = ItemClass;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056417B0
	 * 		Name   -> Function Insurgency.CosmeticVariation.GetOuterCosmetic
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	class UCosmeticItem* UCosmeticVariation::GetOuterCosmetic()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.CosmeticVariation.GetOuterCosmetic");
		
		UCosmeticVariation_GetOuterCosmetic_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> Function Insurgency.CosmeticVariation.BlueprintRemoveVariation
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		class UCosmeticItem*                               OuterCosmetic                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UCosmeticVariation::BlueprintRemoveVariation(class UCosmeticItem* OuterCosmetic)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.CosmeticVariation.BlueprintRemoveVariation");
		
		UCosmeticVariation_BlueprintRemoveVariation_Params params {};
		params.OuterCosmetic = OuterCosmetic;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> Function Insurgency.CosmeticVariation.BlueprintInitVariation
	 * 		Flags  -> (Event, Public, HasOutParms, BlueprintEvent)
	 * Parameters:
	 * 		class UCosmeticItem*                               OuterCosmetic                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UCosmeticVariation::BlueprintInitVariation(class UCosmeticItem* OuterCosmetic)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.CosmeticVariation.BlueprintInitVariation");
		
		UCosmeticVariation_BlueprintInitVariation_Params params {};
		params.OuterCosmetic = OuterCosmetic;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> Function Insurgency.CosmeticVariation.BlueprintCosmeticItemMeshLoaded
	 * 		Flags  -> (Event, Public, HasOutParms, BlueprintEvent)
	 * Parameters:
	 * 		class UINSSkeletalMeshComponent*                   SkeletalMesh                                               (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FCharacterCosmeticAttachedModel             CosmeticModel                                              (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 * 		bool                                               bFirstPerson                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bBodyMesh                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UCosmeticVariation::BlueprintCosmeticItemMeshLoaded(class UINSSkeletalMeshComponent* SkeletalMesh, const struct FCharacterCosmeticAttachedModel& CosmeticModel, bool bFirstPerson, bool bBodyMesh)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.CosmeticVariation.BlueprintCosmeticItemMeshLoaded");
		
		UCosmeticVariation_BlueprintCosmeticItemMeshLoaded_Params params {};
		params.SkeletalMesh = SkeletalMesh;
		params.CosmeticModel = CosmeticModel;
		params.bFirstPerson = bFirstPerson;
		params.bBodyMesh = bBodyMesh;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> Function Insurgency.CosmeticVariation.BlueprintCosmeticItemAllMeshesLoaded
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 */
	void UCosmeticVariation::BlueprintCosmeticItemAllMeshesLoaded()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.CosmeticVariation.BlueprintCosmeticItemAllMeshesLoaded");
		
		UCosmeticVariation_BlueprintCosmeticItemAllMeshesLoaded_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UCosmeticVariation.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UCosmeticVariation::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.CosmeticVariation");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ACoverActor.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ACoverActor::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.CoverActor");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05642030
	 * 		Name   -> Function Insurgency.CoverComponent.IsOccupierClose
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
	 */
	bool UCoverComponent::IsOccupierClose()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.CoverComponent.IsOccupierClose");
		
		UCoverComponent_IsOccupierClose_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05641F50
	 * 		Name   -> Function Insurgency.CoverComponent.HasProtectionAgainstLocation
	 * 		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FVector                                     ThreatLocation                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bUseLOS                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UCoverComponent::HasProtectionAgainstLocation(const struct FVector& ThreatLocation, bool bUseLOS)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.CoverComponent.HasProtectionAgainstLocation");
		
		UCoverComponent_HasProtectionAgainstLocation_Params params {};
		params.ThreatLocation = ThreatLocation;
		params.bUseLOS = bUseLOS;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05641F30
	 * 		Name   -> Function Insurgency.CoverComponent.GetProtectionAngle
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	float UCoverComponent::GetProtectionAngle()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.CoverComponent.GetProtectionAngle");
		
		UCoverComponent_GetProtectionAngle_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05641F00
	 * 		Name   -> Function Insurgency.CoverComponent.GetOccupierDistance
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
	 */
	float UCoverComponent::GetOccupierDistance()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.CoverComponent.GetOccupierDistance");
		
		UCoverComponent_GetOccupierDistance_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05641EE0
	 * 		Name   -> Function Insurgency.CoverComponent.GetOccupier
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	class AINSSoldier* UCoverComponent::GetOccupier()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.CoverComponent.GetOccupier");
		
		UCoverComponent_GetOccupier_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05641E90
	 * 		Name   -> Function Insurgency.CoverComponent.GetLocation
	 * 		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
	 */
	struct FVector UCoverComponent::GetLocation()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.CoverComponent.GetLocation");
		
		UCoverComponent_GetLocation_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05641DD0
	 * 		Name   -> Function Insurgency.CoverComponent.GetDirection
	 * 		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
	 */
	struct FVector UCoverComponent::GetDirection()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.CoverComponent.GetDirection");
		
		UCoverComponent_GetDirection_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05641DA0
	 * 		Name   -> Function Insurgency.CoverComponent.CanMachinegunsDeploy
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
	 */
	bool UCoverComponent::CanMachinegunsDeploy()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.CoverComponent.CanMachinegunsDeploy");
		
		UCoverComponent_CanMachinegunsDeploy_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UCoverComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UCoverComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.CoverComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ACoverGenerator.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ACoverGenerator::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.CoverGenerator");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05642BE0
	 * 		Name   -> Function Insurgency.CoverSystem.RemoveStaleCoverPoints
	 * 		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FVector                                     Origin                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     Extent                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UCoverSystem::RemoveStaleCoverPoints(const struct FVector& Origin, const struct FVector& Extent)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.CoverSystem.RemoveStaleCoverPoints");
		
		UCoverSystem_RemoveStaleCoverPoints_Params params {};
		params.Origin = Origin;
		params.Extent = Extent;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05642B60
	 * 		Name   -> Function Insurgency.CoverSystem.RemoveCoverPointsOfObject
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class AActor*                                      CoverObject                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UCoverSystem::RemoveCoverPointsOfObject(class AActor* CoverObject)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.CoverSystem.RemoveCoverPointsOfObject");
		
		UCoverSystem_RemoveCoverPointsOfObject_Params params {};
		params.CoverObject = CoverObject;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05642B40
	 * 		Name   -> Function Insurgency.CoverSystem.RemoveAll
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void UCoverSystem::RemoveAll()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.CoverSystem.RemoveAll");
		
		UCoverSystem_RemoveAll_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05642AA0
	 * 		Name   -> Function Insurgency.CoverSystem.ReleaseCover
	 * 		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FVector                                     ElementLocation                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UCoverSystem::ReleaseCover(const struct FVector& ElementLocation)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.CoverSystem.ReleaseCover");
		
		UCoverSystem_ReleaseCover_Params params {};
		params.ElementLocation = ElementLocation;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05642910
	 * 		Name   -> Function Insurgency.CoverSystem.OnNavMeshTilesUpdated
	 * 		Flags  -> (Final, Native, Public, HasOutParms)
	 */
	void UCoverSystem::OnNavMeshTilesUpdated()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.CoverSystem.OnNavMeshTilesUpdated");
		
		UCoverSystem_OnNavMeshTilesUpdated_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056428F0
	 * 		Name   -> Function Insurgency.CoverSystem.OnBeginPlay
	 * 		Flags  -> (Final, Native, Private)
	 */
	void UCoverSystem::OnBeginPlay()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.CoverSystem.OnBeginPlay");
		
		UCoverSystem_OnBeginPlay_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05642850
	 * 		Name   -> Function Insurgency.CoverSystem.HoldCover
	 * 		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FVector                                     ElementLocation                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UCoverSystem::HoldCover(const struct FVector& ElementLocation)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.CoverSystem.HoldCover");
		
		UCoverSystem_HoldCover_Params params {};
		params.ElementLocation = ElementLocation;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056427D0
	 * 		Name   -> Function Insurgency.CoverSystem.GetCoverSystem
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UCoverSystem* UCoverSystem::STATIC_GetCoverSystem(class UObject* WorldContextObject)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.CoverSystem.GetCoverSystem");
		
		UCoverSystem_GetCoverSystem_Params params {};
		params.WorldContextObject = WorldContextObject;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UCoverSystem.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UCoverSystem::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.CoverSystem");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05643550
	 * 		Name   -> Function Insurgency.DamageLogComponent.OnOwnerTakeAnyDamage
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		class AActor*                                      DamagedActor                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Damage                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UDamageType*                                 DamageType                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AController*                                 InstigatedBy                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      DamageCauser                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UDamageLogComponent::OnOwnerTakeAnyDamage(class AActor* DamagedActor, float Damage, class UDamageType* DamageType, class AController* InstigatedBy, class AActor* DamageCauser)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.DamageLogComponent.OnOwnerTakeAnyDamage");
		
		UDamageLogComponent_OnOwnerTakeAnyDamage_Params params {};
		params.DamagedActor = DamagedActor;
		params.Damage = Damage;
		params.DamageType = DamageType;
		params.InstigatedBy = InstigatedBy;
		params.DamageCauser = DamageCauser;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05643440
	 * 		Name   -> Function Insurgency.DamageLogComponent.GetHighestDamager
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class AController*                                 Ignore                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              MaxTime                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bCheckTeam                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class AController* UDamageLogComponent::GetHighestDamager(class AController* Ignore, float MaxTime, bool bCheckTeam)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.DamageLogComponent.GetHighestDamager");
		
		UDamageLogComponent_GetHighestDamager_Params params {};
		params.Ignore = Ignore;
		params.MaxTime = MaxTime;
		params.bCheckTeam = bCheckTeam;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05643420
	 * 		Name   -> Function Insurgency.DamageLogComponent.ClearDamageLog
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void UDamageLogComponent::ClearDamageLog()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.DamageLogComponent.ClearDamageLog");
		
		UDamageLogComponent_ClearDamageLog_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDamageLogComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDamageLogComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.DamageLogComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDamageReflectionToggledMessage.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDamageReflectionToggledMessage::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.DamageReflectionToggledMessage");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UINSDamageType.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UINSDamageType::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.INSDamageType");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDamageTypeBullet.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDamageTypeBullet::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.DamageTypeBullet");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDamageTypeBuckshot.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDamageTypeBuckshot::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.DamageTypeBuckshot");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDamageTypeFall.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDamageTypeFall::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.DamageTypeFall");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDamageTypeSuicide.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDamageTypeSuicide::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.DamageTypeSuicide");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDamageTypeEnvironmentalFire.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDamageTypeEnvironmentalFire::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.DamageTypeEnvironmentalFire");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDamageTypeVehicleFire.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDamageTypeVehicleFire::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.DamageTypeVehicleFire");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDamageTypeExplosionGeneric.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDamageTypeExplosionGeneric::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.DamageTypeExplosionGeneric");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDamageTypeExplosionVehicle.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDamageTypeExplosionVehicle::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.DamageTypeExplosionVehicle");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDamageTypeMeleeGeneric.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDamageTypeMeleeGeneric::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.DamageTypeMeleeGeneric");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDamageTypeMeleeSlash.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDamageTypeMeleeSlash::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.DamageTypeMeleeSlash");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDamageTypeMeleeClub.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDamageTypeMeleeClub::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.DamageTypeMeleeClub");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDamageTypeMeleePunch.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDamageTypeMeleePunch::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.DamageTypeMeleePunch");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDamageTypeImpact.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDamageTypeImpact::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.DamageTypeImpact");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDamageTypeVehicleImpact.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDamageTypeVehicleImpact::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.DamageTypeVehicleImpact");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDamageTypeGrenadeImpact.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDamageTypeGrenadeImpact::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.DamageTypeGrenadeImpact");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDamageTypeChargeImpact.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDamageTypeChargeImpact::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.DamageTypeChargeImpact");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDamageTypeDoorBreach.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDamageTypeDoorBreach::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.DamageTypeDoorBreach");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05645D90
	 * 		Name   -> Function Insurgency.DecalManager.SpawnTranslucentTrackedDecalAttached
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UMaterialInterface*                          DecalMaterial                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     DecalSize                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class USceneComponent*                             AttachToComponent                                          (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FName                                        AttachPointName                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     Location                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FRotator                                    Rotation                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		EAttachLocation                                    LocationType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              LifeSpan                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              FadeScreenSize                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UDecalPlaneComponent* UDecalManager::STATIC_SpawnTranslucentTrackedDecalAttached(class UObject* WorldContextObject, class UMaterialInterface* DecalMaterial, const struct FVector& DecalSize, class USceneComponent* AttachToComponent, const class FName& AttachPointName, const struct FVector& Location, const struct FRotator& Rotation, EAttachLocation LocationType, float LifeSpan, float FadeScreenSize)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.DecalManager.SpawnTranslucentTrackedDecalAttached");
		
		UDecalManager_SpawnTranslucentTrackedDecalAttached_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.DecalMaterial = DecalMaterial;
		params.DecalSize = DecalSize;
		params.AttachToComponent = AttachToComponent;
		params.AttachPointName = AttachPointName;
		params.Location = Location;
		params.Rotation = Rotation;
		params.LocationType = LocationType;
		params.LifeSpan = LifeSpan;
		params.FadeScreenSize = FadeScreenSize;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056459B0
	 * 		Name   -> Function Insurgency.DecalManager.SpawnTrackedDecalAttached
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UMaterialInterface*                          DecalMaterial                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     DecalSize                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class USceneComponent*                             AttachToComponent                                          (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FName                                        AttachPointName                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     Location                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FRotator                                    Rotation                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		EAttachLocation                                    LocationType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              LifeSpan                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              FadeScreenSize                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              FadeOutDelay                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              FadeOutDuration                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EDecalChannel                                      DecalChannel                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bUseFootprintArray                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UDecalComponent* UDecalManager::STATIC_SpawnTrackedDecalAttached(class UObject* WorldContextObject, class UMaterialInterface* DecalMaterial, const struct FVector& DecalSize, class USceneComponent* AttachToComponent, const class FName& AttachPointName, const struct FVector& Location, const struct FRotator& Rotation, EAttachLocation LocationType, float LifeSpan, float FadeScreenSize, float FadeOutDelay, float FadeOutDuration, EDecalChannel DecalChannel, bool bUseFootprintArray)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.DecalManager.SpawnTrackedDecalAttached");
		
		UDecalManager_SpawnTrackedDecalAttached_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.DecalMaterial = DecalMaterial;
		params.DecalSize = DecalSize;
		params.AttachToComponent = AttachToComponent;
		params.AttachPointName = AttachPointName;
		params.Location = Location;
		params.Rotation = Rotation;
		params.LocationType = LocationType;
		params.LifeSpan = LifeSpan;
		params.FadeScreenSize = FadeScreenSize;
		params.FadeOutDelay = FadeOutDelay;
		params.FadeOutDuration = FadeOutDuration;
		params.DecalChannel = DecalChannel;
		params.bUseFootprintArray = bUseFootprintArray;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDecalManager.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDecalManager::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.DecalManager");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05646390
	 * 		Name   -> Function Insurgency.DecalPlaneComponent.SetDecalScale
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		float                                              NewScale                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UDecalPlaneComponent::SetDecalScale(float NewScale)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.DecalPlaneComponent.SetDecalScale");
		
		UDecalPlaneComponent_SetDecalScale_Params params {};
		params.NewScale = NewScale;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05646310
	 * 		Name   -> Function Insurgency.DecalPlaneComponent.SetDecalMaterial
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UMaterialInterface*                          Material                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UDecalPlaneComponent::SetDecalMaterial(class UMaterialInterface* Material)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.DecalPlaneComponent.SetDecalMaterial");
		
		UDecalPlaneComponent_SetDecalMaterial_Params params {};
		params.Material = Material;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05646290
	 * 		Name   -> Function Insurgency.DecalPlaneComponent.SetDecalLifespan
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		float                                              Seconds                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UDecalPlaneComponent::SetDecalLifespan(float Seconds)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.DecalPlaneComponent.SetDecalLifespan");
		
		UDecalPlaneComponent_SetDecalLifespan_Params params {};
		params.Seconds = Seconds;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05646270
	 * 		Name   -> Function Insurgency.DecalPlaneComponent.OnLifespanExpired
	 * 		Flags  -> (Final, Native, Public)
	 */
	void UDecalPlaneComponent::OnLifespanExpired()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.DecalPlaneComponent.OnLifespanExpired");
		
		UDecalPlaneComponent_OnLifespanExpired_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDecalPlaneComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDecalPlaneComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.DecalPlaneComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDialogLicenseWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDialogLicenseWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.DialogLicenseWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDismembermentSet.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDismembermentSet::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.DismembermentSet");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056874C0
	 * 		Name   -> Function Insurgency.INSGameMode.SwapSides
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bKillAlivePlayers                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSGameMode::SwapSides(bool bKillAlivePlayers)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameMode.SwapSides");
		
		AINSGameMode_SwapSides_Params params {};
		params.bKillAlivePlayers = bKillAlivePlayers;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05687400
	 * 		Name   -> Function Insurgency.INSGameMode.SetRestrictedAreas
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bState                                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		unsigned char                                      TeamId                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSGameMode::SetRestrictedAreas(bool bState, unsigned char TeamId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameMode.SetRestrictedAreas");
		
		AINSGameMode_SetRestrictedAreas_Params params {};
		params.bState = bState;
		params.TeamId = TeamId;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05687310
	 * 		Name   -> Function Insurgency.INSGameMode.SetPropertyValueFromString
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class FName                                        PropertyName                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FString                                      NewPropertyValue                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool AINSGameMode::SetPropertyValueFromString(const class FName& PropertyName, const class FString& NewPropertyValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameMode.SetPropertyValueFromString");
		
		AINSGameMode_SetPropertyValueFromString_Params params {};
		params.PropertyName = PropertyName;
		params.NewPropertyValue = NewPropertyValue;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05687240
	 * 		Name   -> Function Insurgency.INSGameMode.SetPropertyValueFromFloat
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class FName                                        PropertyName                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              NewPropertyValue                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool AINSGameMode::SetPropertyValueFromFloat(const class FName& PropertyName, float NewPropertyValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameMode.SetPropertyValueFromFloat");
		
		AINSGameMode_SetPropertyValueFromFloat_Params params {};
		params.PropertyName = PropertyName;
		params.NewPropertyValue = NewPropertyValue;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05687170
	 * 		Name   -> Function Insurgency.INSGameMode.RespawnTeam
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		unsigned char                                      TeamId                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bIncludingAlive                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	int32_t AINSGameMode::RespawnTeam(unsigned char TeamId, bool bIncludingAlive)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameMode.RespawnTeam");
		
		AINSGameMode_RespawnTeam_Params params {};
		params.TeamId = TeamId;
		params.bIncludingAlive = bIncludingAlive;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056870F0
	 * 		Name   -> Function Insurgency.INSGameMode.RespawnPlayers
	 * 		Flags  -> (Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		unsigned char                                      TeamId                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSGameMode::RespawnPlayers(unsigned char TeamId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameMode.RespawnPlayers");
		
		AINSGameMode_RespawnPlayers_Params params {};
		params.TeamId = TeamId;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05687060
	 * 		Name   -> Function Insurgency.INSGameMode.RespawnPlayer
	 * 		Flags  -> (Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class AINSPlayerController*                        PlayerController                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSGameMode::RespawnPlayer(class AINSPlayerController* PlayerController)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameMode.RespawnPlayer");
		
		AINSGameMode_RespawnPlayer_Params params {};
		params.PlayerController = PlayerController;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05686FC0
	 * 		Name   -> Function Insurgency.INSGameMode.RespawnBot
	 * 		Flags  -> (Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class AINSAISoldierController*                     BotController                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool AINSGameMode::RespawnBot(class AINSAISoldierController* BotController)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameMode.RespawnBot");
		
		AINSGameMode_RespawnBot_Params params {};
		params.BotController = BotController;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05686F30
	 * 		Name   -> Function Insurgency.INSGameMode.RespawnAllTeams
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bIncludingAlive                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	int32_t AINSGameMode::RespawnAllTeams(bool bIncludingAlive)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameMode.RespawnAllTeams");
		
		AINSGameMode_RespawnAllTeams_Params params {};
		params.bIncludingAlive = bIncludingAlive;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05686EA0
	 * 		Name   -> Function Insurgency.INSGameMode.ReinforceTeam
	 * 		Flags  -> (Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		unsigned char                                      TeamId                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	int32_t AINSGameMode::ReinforceTeam(unsigned char TeamId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameMode.ReinforceTeam");
		
		AINSGameMode_ReinforceTeam_Params params {};
		params.TeamId = TeamId;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05686E70
	 * 		Name   -> Function Insurgency.INSGameMode.ReinforceAllTeams
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	int32_t AINSGameMode::ReinforceAllTeams()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameMode.ReinforceAllTeams");
		
		AINSGameMode_ReinforceAllTeams_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05686DA0
	 * 		Name   -> Function Insurgency.INSGameMode.PerformResupplyForSoldier
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class AINSSoldier*                                 Player                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bRemoveCurrentItems                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSGameMode::PerformResupplyForSoldier(class AINSSoldier* Player, bool bRemoveCurrentItems)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameMode.PerformResupplyForSoldier");
		
		AINSGameMode_PerformResupplyForSoldier_Params params {};
		params.Player = Player;
		params.bRemoveCurrentItems = bRemoveCurrentItems;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05686D20
	 * 		Name   -> Function Insurgency.INSGameMode.OnWavesDepleted_DisableRestricted
	 * 		Flags  -> (Final, Native, Private)
	 * Parameters:
	 * 		class UReinforcementSystemComponent*               Component                                                  (ConstParm, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSGameMode::OnWavesDepleted_DisableRestricted(class UReinforcementSystemComponent* Component)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameMode.OnWavesDepleted_DisableRestricted");
		
		AINSGameMode_OnWavesDepleted_DisableRestricted_Params params {};
		params.Component = Component;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05686C60
	 * 		Name   -> Function Insurgency.INSGameMode.OnWaveGained_ReenableRestricted
	 * 		Flags  -> (Final, Native, Private)
	 * Parameters:
	 * 		class UReinforcementSystemComponent*               Component                                                  (ConstParm, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            OldWaveCount                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSGameMode::OnWaveGained_ReenableRestricted(class UReinforcementSystemComponent* Component, int32_t OldWaveCount)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameMode.OnWaveGained_ReenableRestricted");
		
		AINSGameMode_OnWaveGained_ReenableRestricted_Params params {};
		params.Component = Component;
		params.OldWaveCount = OldWaveCount;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05686B30
	 * 		Name   -> Function Insurgency.INSGameMode.OnVehicleEngineDestroyed
	 * 		Flags  -> (Native, Event, Public, HasOutParms, BlueprintEvent)
	 * Parameters:
	 * 		class UVehicleEnginePart*                          EnginePart                                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AController*                                 KillerPlayer                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		TArray<class AController*>                         AssisterPlayers                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSGameMode::OnVehicleEngineDestroyed(class UVehicleEnginePart* EnginePart, class AController* KillerPlayer, TArray<class AController*> AssisterPlayers)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameMode.OnVehicleEngineDestroyed");
		
		AINSGameMode_OnVehicleEngineDestroyed_Params params {};
		params.EnginePart = EnginePart;
		params.KillerPlayer = KillerPlayer;
		params.AssisterPlayers = AssisterPlayers;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056869C0
	 * 		Name   -> Function Insurgency.INSGameMode.OnTextMessageSent
	 * 		Flags  -> (Native, Event, Public, HasOutParms, BlueprintEvent)
	 * Parameters:
	 * 		class AINSPlayerController*                        Speaker                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FText                                        Message                                                    (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		bool                                               bTeamOnly                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool AINSGameMode::OnTextMessageSent(class AINSPlayerController* Speaker, const class FText& Message, bool bTeamOnly)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameMode.OnTextMessageSent");
		
		AINSGameMode_OnTextMessageSent_Params params {};
		params.Speaker = Speaker;
		params.Message = Message;
		params.bTeamOnly = bTeamOnly;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05686760
	 * 		Name   -> Function Insurgency.INSGameMode.OnSoldierTakeRadialDamage
	 * 		Flags  -> (Native, Event, Public, HasOutParms, HasDefaults, BlueprintEvent)
	 * Parameters:
	 * 		class AINSSoldier*                                 SoldierPawn                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Damage                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AController*                                 EventInstigator                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      DamageCauser                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UDamageType*                                 DamageType                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     Origin                                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FHitResult                                  HitInfo                                                    (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	float AINSGameMode::OnSoldierTakeRadialDamage(class AINSSoldier* SoldierPawn, float Damage, class AController* EventInstigator, class AActor* DamageCauser, class UDamageType* DamageType, const struct FVector& Origin, const struct FHitResult& HitInfo)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameMode.OnSoldierTakeRadialDamage");
		
		AINSGameMode_OnSoldierTakeRadialDamage_Params params {};
		params.SoldierPawn = SoldierPawn;
		params.Damage = Damage;
		params.EventInstigator = EventInstigator;
		params.DamageCauser = DamageCauser;
		params.DamageType = DamageType;
		params.Origin = Origin;
		params.HitInfo = HitInfo;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05686500
	 * 		Name   -> Function Insurgency.INSGameMode.OnSoldierTakePointDamage
	 * 		Flags  -> (Native, Event, Public, HasOutParms, HasDefaults, BlueprintEvent)
	 * Parameters:
	 * 		class AINSSoldier*                                 SoldierPawn                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Damage                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AController*                                 EventInstigator                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      DamageCauser                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UDamageType*                                 DamageType                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FHitResult                                  HitInfo                                                    (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     ShotFromDirection                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	float AINSGameMode::OnSoldierTakePointDamage(class AINSSoldier* SoldierPawn, float Damage, class AController* EventInstigator, class AActor* DamageCauser, class UDamageType* DamageType, const struct FHitResult& HitInfo, const struct FVector& ShotFromDirection)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameMode.OnSoldierTakePointDamage");
		
		AINSGameMode_OnSoldierTakePointDamage_Params params {};
		params.SoldierPawn = SoldierPawn;
		params.Damage = Damage;
		params.EventInstigator = EventInstigator;
		params.DamageCauser = DamageCauser;
		params.DamageType = DamageType;
		params.HitInfo = HitInfo;
		params.ShotFromDirection = ShotFromDirection;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05686370
	 * 		Name   -> Function Insurgency.INSGameMode.OnSoldierTakeAnyDamage
	 * 		Flags  -> (Native, Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		class AINSSoldier*                                 SoldierPawn                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Damage                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AController*                                 EventInstigator                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      DamageCauser                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UDamageType*                                 DamageType                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	float AINSGameMode::OnSoldierTakeAnyDamage(class AINSSoldier* SoldierPawn, float Damage, class AController* EventInstigator, class AActor* DamageCauser, class UDamageType* DamageType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameMode.OnSoldierTakeAnyDamage");
		
		AINSGameMode_OnSoldierTakeAnyDamage_Params params {};
		params.SoldierPawn = SoldierPawn;
		params.Damage = Damage;
		params.EventInstigator = EventInstigator;
		params.DamageCauser = DamageCauser;
		params.DamageType = DamageType;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05686350
	 * 		Name   -> Function Insurgency.INSGameMode.OnScenarioSublevelLoaded
	 * 		Flags  -> (Final, Native, Protected)
	 */
	void AINSGameMode::OnScenarioSublevelLoaded()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameMode.OnScenarioSublevelLoaded");
		
		AINSGameMode_OnScenarioSublevelLoaded_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05686250
	 * 		Name   -> Function Insurgency.INSGameMode.OnObjectiveRigged
	 * 		Flags  -> (Native, Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		class AObjectiveDestructible*                      Objective                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AINSSoldier*                                 Rigger                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AProjectileBase*                             SpawnedExplosive                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSGameMode::OnObjectiveRigged(class AObjectiveDestructible* Objective, class AINSSoldier* Rigger, class AProjectileBase* SpawnedExplosive)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameMode.OnObjectiveRigged");
		
		AINSGameMode_OnObjectiveRigged_Params params {};
		params.Objective = Objective;
		params.Rigger = Rigger;
		params.SpawnedExplosive = SpawnedExplosive;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056860F0
	 * 		Name   -> Function Insurgency.INSGameMode.OnObjectiveDestroyed
	 * 		Flags  -> (Native, Event, Public, HasOutParms, BlueprintEvent)
	 * Parameters:
	 * 		class AObjectiveDestructible*                      Objective                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		unsigned char                                      OldOwners                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		unsigned char                                      NewOwners                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		TArray<class AINSPlayerState*>                     Attackers                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSGameMode::OnObjectiveDestroyed(class AObjectiveDestructible* Objective, unsigned char OldOwners, unsigned char NewOwners, TArray<class AINSPlayerState*> Attackers)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameMode.OnObjectiveDestroyed");
		
		AINSGameMode_OnObjectiveDestroyed_Params params {};
		params.Objective = Objective;
		params.OldOwners = OldOwners;
		params.NewOwners = NewOwners;
		params.Attackers = Attackers;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05685FF0
	 * 		Name   -> Function Insurgency.INSGameMode.OnObjectiveChangeOwnership
	 * 		Flags  -> (Native, Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		class AObjectiveBase*                              Objective                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		unsigned char                                      PreviousOwner                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		unsigned char                                      NewOwners                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSGameMode::OnObjectiveChangeOwnership(class AObjectiveBase* Objective, unsigned char PreviousOwner, unsigned char NewOwners)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameMode.OnObjectiveChangeOwnership");
		
		AINSGameMode_OnObjectiveChangeOwnership_Params params {};
		params.Objective = Objective;
		params.PreviousOwner = PreviousOwner;
		params.NewOwners = NewOwners;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05685F20
	 * 		Name   -> Function Insurgency.INSGameMode.OnObjectiveBeginRig
	 * 		Flags  -> (Native, Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		class AObjectiveDestructible*                      Objective                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AINSSoldier*                                 Rigger                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSGameMode::OnObjectiveBeginRig(class AObjectiveDestructible* Objective, class AINSSoldier* Rigger)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameMode.OnObjectiveBeginRig");
		
		AINSGameMode_OnObjectiveBeginRig_Params params {};
		params.Objective = Objective;
		params.Rigger = Rigger;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05685E40
	 * 		Name   -> Function Insurgency.INSGameMode.OnLoadedRulesets
	 * 		Flags  -> (Final, Native, Private)
	 */
	void AINSGameMode::OnLoadedRulesets()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameMode.OnLoadedRulesets");
		
		AINSGameMode_OnLoadedRulesets_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05685D60
	 * 		Name   -> Function Insurgency.INSGameMode.OnLoadedMutators
	 * 		Flags  -> (Final, Native, Private)
	 */
	void AINSGameMode::OnLoadedMutators()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameMode.OnLoadedMutators");
		
		AINSGameMode_OnLoadedMutators_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05685B40
	 * 		Name   -> Function Insurgency.INSGameMode.OnFireSupportCalled
	 * 		Flags  -> (Native, Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		class AFireSupportBase*                            FireSupportActor                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AController*                                 OfficerController                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AController*                                 ObserverController                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSGameMode::OnFireSupportCalled(class AFireSupportBase* FireSupportActor, class AController* OfficerController, class AController* ObserverController)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameMode.OnFireSupportCalled");
		
		AINSGameMode_OnFireSupportCalled_Params params {};
		params.FireSupportActor = FireSupportActor;
		params.OfficerController = OfficerController;
		params.ObserverController = ObserverController;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05685C40
	 * 		Name   -> Function Insurgency.INSGameMode.OnFirearmFired
	 * 		Flags  -> (Native, Event, Public, HasOutParms, HasDefaults, BlueprintEvent)
	 * Parameters:
	 * 		class AItemFirearm*                                Firearm                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     Origin                                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     ShootDir                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSGameMode::OnFirearmFired(class AItemFirearm* Firearm, const struct FVector& Origin, const struct FVector& ShootDir)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameMode.OnFirearmFired");
		
		AINSGameMode_OnFirearmFired_Params params {};
		params.Firearm = Firearm;
		params.Origin = Origin;
		params.ShootDir = ShootDir;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x04DB4A80
	 * 		Name   -> Function Insurgency.INSGameMode.OnEnterInitialMatchState
	 * 		Flags  -> (Native, Event, Public, BlueprintEvent)
	 */
	void AINSGameMode::OnEnterInitialMatchState()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameMode.OnEnterInitialMatchState");
		
		AINSGameMode_OnEnterInitialMatchState_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05685A70
	 * 		Name   -> Function Insurgency.INSGameMode.OnCaptureObjectiveStartCapture
	 * 		Flags  -> (Native, Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		class AObjectiveCapturable*                        Objective                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		unsigned char                                      NewOwners                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSGameMode::OnCaptureObjectiveStartCapture(class AObjectiveCapturable* Objective, unsigned char NewOwners)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameMode.OnCaptureObjectiveStartCapture");
		
		AINSGameMode_OnCaptureObjectiveStartCapture_Params params {};
		params.Objective = Objective;
		params.NewOwners = NewOwners;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05685910
	 * 		Name   -> Function Insurgency.INSGameMode.OnCaptureObjectiveProgressTick
	 * 		Flags  -> (Native, Event, Public, HasOutParms, BlueprintEvent)
	 * Parameters:
	 * 		class AObjectiveCapturable*                        Objective                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		unsigned char                                      CapturingTeamId                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		unsigned char                                      TeamWithMostPlayersId                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		TArray<class AINSPlayerState*>                     Tickers                                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSGameMode::OnCaptureObjectiveProgressTick(class AObjectiveCapturable* Objective, unsigned char CapturingTeamId, unsigned char TeamWithMostPlayersId, TArray<class AINSPlayerState*> Tickers)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameMode.OnCaptureObjectiveProgressTick");
		
		AINSGameMode_OnCaptureObjectiveProgressTick_Params params {};
		params.Objective = Objective;
		params.CapturingTeamId = CapturingTeamId;
		params.TeamWithMostPlayersId = TeamWithMostPlayersId;
		params.Tickers = Tickers;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056857E0
	 * 		Name   -> Function Insurgency.INSGameMode.OnCaptureObjectiveProgressReset
	 * 		Flags  -> (Native, Event, Public, HasOutParms, BlueprintEvent)
	 * Parameters:
	 * 		class AObjectiveCapturable*                        Objective                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		TArray<class AINSPlayerState*>                     Resetters                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              MaxCaptureProgress                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSGameMode::OnCaptureObjectiveProgressReset(class AObjectiveCapturable* Objective, TArray<class AINSPlayerState*> Resetters, float MaxCaptureProgress)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameMode.OnCaptureObjectiveProgressReset");
		
		AINSGameMode_OnCaptureObjectiveProgressReset_Params params {};
		params.Objective = Objective;
		params.Resetters = Resetters;
		params.MaxCaptureProgress = MaxCaptureProgress;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05685680
	 * 		Name   -> Function Insurgency.INSGameMode.OnCaptureObjectiveChangeOwnership
	 * 		Flags  -> (Native, Event, Public, HasOutParms, BlueprintEvent)
	 * Parameters:
	 * 		class AObjectiveCapturable*                        Objective                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		unsigned char                                      OldOwners                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		unsigned char                                      NewOwners                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		TArray<class AINSPlayerState*>                     Capturers                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSGameMode::OnCaptureObjectiveChangeOwnership(class AObjectiveCapturable* Objective, unsigned char OldOwners, unsigned char NewOwners, TArray<class AINSPlayerState*> Capturers)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameMode.OnCaptureObjectiveChangeOwnership");
		
		AINSGameMode_OnCaptureObjectiveChangeOwnership_Params params {};
		params.Objective = Objective;
		params.OldOwners = OldOwners;
		params.NewOwners = NewOwners;
		params.Capturers = Capturers;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056855B0
	 * 		Name   -> Function Insurgency.INSGameMode.OnCaptureObjectiveBeginOverlap
	 * 		Flags  -> (Native, Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		class AObjectiveCapturable*                        Objective                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AINSSoldier*                                 Overlapper                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSGameMode::OnCaptureObjectiveBeginOverlap(class AObjectiveCapturable* Objective, class AINSSoldier* Overlapper)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameMode.OnCaptureObjectiveBeginOverlap");
		
		AINSGameMode_OnCaptureObjectiveBeginOverlap_Params params {};
		params.Objective = Objective;
		params.Overlapper = Overlapper;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05685490
	 * 		Name   -> Function Insurgency.INSGameMode.OnCanBeDropped
	 * 		Flags  -> (Native, Event, Public, HasOutParms, BlueprintEvent)
	 * Parameters:
	 * 		class AItemBase*                                   Item                                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AINSSoldier*                                 ItemOwner                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bCanDrop                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool AINSGameMode::OnCanBeDropped(class AItemBase* Item, class AINSSoldier* ItemOwner, bool* bCanDrop)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameMode.OnCanBeDropped");
		
		AINSGameMode_OnCanBeDropped_Params params {};
		params.Item = Item;
		params.ItemOwner = ItemOwner;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (bCanDrop != nullptr)
			*bCanDrop = params.bCanDrop;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05685460
	 * 		Name   -> Function Insurgency.INSGameMode.NeedsBots
	 * 		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AINSGameMode::NeedsBots()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameMode.NeedsBots");
		
		AINSGameMode_NeedsBots_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05685430
	 * 		Name   -> Function Insurgency.INSGameMode.IsUsingOfficialRuleset
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AINSGameMode::IsUsingOfficialRuleset()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameMode.IsUsingOfficialRuleset");
		
		AINSGameMode_IsUsingOfficialRuleset_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05685400
	 * 		Name   -> Function Insurgency.INSGameMode.IsNightLightingLoaded
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AINSGameMode::IsNightLightingLoaded()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameMode.IsNightLightingLoaded");
		
		AINSGameMode_IsNightLightingLoaded_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056853D0
	 * 		Name   -> Function Insurgency.INSGameMode.IsMutatedMode
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AINSGameMode::IsMutatedMode()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameMode.IsMutatedMode");
		
		AINSGameMode_IsMutatedMode_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05685340
	 * 		Name   -> Function Insurgency.INSGameMode.IsFinalObjective
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		unsigned char                                      ObjectiveId                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool AINSGameMode::IsFinalObjective(unsigned char ObjectiveId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameMode.IsFinalObjective");
		
		AINSGameMode_IsFinalObjective_Params params {};
		params.ObjectiveId = ObjectiveId;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056852B0
	 * 		Name   -> Function Insurgency.INSGameMode.IsCenterObjective
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		unsigned char                                      ObjectiveId                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool AINSGameMode::IsCenterObjective(unsigned char ObjectiveId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameMode.IsCenterObjective");
		
		AINSGameMode_IsCenterObjective_Params params {};
		params.ObjectiveId = ObjectiveId;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05685280
	 * 		Name   -> Function Insurgency.INSGameMode.IsAttackDefend
	 * 		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AINSGameMode::IsAttackDefend()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameMode.IsAttackDefend");
		
		AINSGameMode_IsAttackDefend_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056851F0
	 * 		Name   -> Function Insurgency.INSGameMode.HasEnabledSpawnZones
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		unsigned char                                      TeamId                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool AINSGameMode::HasEnabledSpawnZones(unsigned char TeamId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameMode.HasEnabledSpawnZones");
		
		AINSGameMode_HasEnabledSpawnZones_Params params {};
		params.TeamId = TeamId;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05685120
	 * 		Name   -> Function Insurgency.INSGameMode.GiveSoldierInventory
	 * 		Flags  -> (Native, Event, Public, BlueprintCallable, BlueprintEvent)
	 * Parameters:
	 * 		class AINSSoldier*                                 Player                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bFromResupply                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSGameMode::GiveSoldierInventory(class AINSSoldier* Player, bool bFromResupply)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameMode.GiveSoldierInventory");
		
		AINSGameMode_GiveSoldierInventory_Params params {};
		params.Player = Player;
		params.bFromResupply = bFromResupply;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056850F0
	 * 		Name   -> Function Insurgency.INSGameMode.GetTheaterDefinition
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	class UTheaterDefinition* AINSGameMode::GetTheaterDefinition()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameMode.GetTheaterDefinition");
		
		AINSGameMode_GetTheaterDefinition_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05685060
	 * 		Name   -> Function Insurgency.INSGameMode.GetTeam
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		unsigned char                                      ID                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class ATeamInfo* AINSGameMode::GetTeam(unsigned char ID)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameMode.GetTeam");
		
		AINSGameMode_GetTeam_Params params {};
		params.ID = ID;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05684FC0
	 * 		Name   -> Function Insurgency.INSGameMode.GetSquadLayoutForFaction
	 * 		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		class UFactionDefinition*                          Faction                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class USquadLayout* AINSGameMode::GetSquadLayoutForFaction(class UFactionDefinition* Faction)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameMode.GetSquadLayoutForFaction");
		
		AINSGameMode_GetSquadLayoutForFaction_Params params {};
		params.Faction = Faction;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05684F20
	 * 		Name   -> Function Insurgency.INSGameMode.GetScoringFor
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		class FName                                        ScoreableAction                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	int32_t AINSGameMode::GetScoringFor(const class FName& ScoreableAction)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameMode.GetScoringFor");
		
		AINSGameMode_GetScoringFor_Params params {};
		params.ScoreableAction = ScoreableAction;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05684E20
	 * 		Name   -> Function Insurgency.INSGameMode.GetPropertyValueAsString
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class FName                                        PropertyName                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FString                                      OutPropertyValue                                           (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool AINSGameMode::GetPropertyValueAsString(const class FName& PropertyName, class FString* OutPropertyValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameMode.GetPropertyValueAsString");
		
		AINSGameMode_GetPropertyValueAsString_Params params {};
		params.PropertyName = PropertyName;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutPropertyValue != nullptr)
			*OutPropertyValue = params.OutPropertyValue;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05684D40
	 * 		Name   -> Function Insurgency.INSGameMode.GetPropertyValueAsFloat
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class FName                                        PropertyName                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              OutPropertyValue                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool AINSGameMode::GetPropertyValueAsFloat(const class FName& PropertyName, float* OutPropertyValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameMode.GetPropertyValueAsFloat");
		
		AINSGameMode_GetPropertyValueAsFloat_Params params {};
		params.PropertyName = PropertyName;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutPropertyValue != nullptr)
			*OutPropertyValue = params.OutPropertyValue;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05684D10
	 * 		Name   -> Function Insurgency.INSGameMode.GetObjectiveCount
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	int32_t AINSGameMode::GetObjectiveCount()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameMode.GetObjectiveCount");
		
		AINSGameMode_GetObjectiveCount_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05684C80
	 * 		Name   -> Function Insurgency.INSGameMode.GetObjective
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		unsigned char                                      ObjectiveId                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class AObjectiveBase* AINSGameMode::GetObjective(unsigned char ObjectiveId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameMode.GetObjective");
		
		AINSGameMode_GetObjective_Params params {};
		params.ObjectiveId = ObjectiveId;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05684BD0
	 * 		Name   -> Function Insurgency.INSGameMode.GetMutatorShortNames
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		TArray<class FName>                                OutNames                                                   (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSGameMode::GetMutatorShortNames(TArray<class FName>* OutNames)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameMode.GetMutatorShortNames");
		
		AINSGameMode_GetMutatorShortNames_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutNames != nullptr)
			*OutNames = params.OutNames;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05684B20
	 * 		Name   -> Function Insurgency.INSGameMode.GetInactiveObjectives
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		TArray<class AObjectiveBase*>                      OutObjectives                                              (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSGameMode::GetInactiveObjectives(TArray<class AObjectiveBase*>* OutObjectives)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameMode.GetInactiveObjectives");
		
		AINSGameMode_GetInactiveObjectives_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutObjectives != nullptr)
			*OutObjectives = params.OutObjectives;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05684AF0
	 * 		Name   -> Function Insurgency.INSGameMode.GetFirstObjective
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	class AObjectiveBase* AINSGameMode::GetFirstObjective()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameMode.GetFirstObjective");
		
		AINSGameMode_GetFirstObjective_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05684AC0
	 * 		Name   -> Function Insurgency.INSGameMode.GetFirstActiveObjective
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	class AObjectiveBase* AINSGameMode::GetFirstActiveObjective()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameMode.GetFirstActiveObjective");
		
		AINSGameMode_GetFirstActiveObjective_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05684A90
	 * 		Name   -> Function Insurgency.INSGameMode.GetFinalObjective
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	class AObjectiveBase* AINSGameMode::GetFinalObjective()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameMode.GetFinalObjective");
		
		AINSGameMode_GetFinalObjective_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05684A00
	 * 		Name   -> Function Insurgency.INSGameMode.GetDestructibleObjective
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		unsigned char                                      ObjectiveId                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class AObjectiveDestructible* AINSGameMode::GetDestructibleObjective(unsigned char ObjectiveId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameMode.GetDestructibleObjective");
		
		AINSGameMode_GetDestructibleObjective_Params params {};
		params.ObjectiveId = ObjectiveId;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056849D0
	 * 		Name   -> Function Insurgency.INSGameMode.GetDefendingTeam
	 * 		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	unsigned char AINSGameMode::GetDefendingTeam()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameMode.GetDefendingTeam");
		
		AINSGameMode_GetDefendingTeam_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056849A0
	 * 		Name   -> Function Insurgency.INSGameMode.GetCenterObjective
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	class AObjectiveBase* AINSGameMode::GetCenterObjective()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameMode.GetCenterObjective");
		
		AINSGameMode_GetCenterObjective_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05684910
	 * 		Name   -> Function Insurgency.INSGameMode.GetCapturableObjective
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		unsigned char                                      ObjectiveId                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class AObjectiveCapturable* AINSGameMode::GetCapturableObjective(unsigned char ObjectiveId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameMode.GetCapturableObjective");
		
		AINSGameMode_GetCapturableObjective_Params params {};
		params.ObjectiveId = ObjectiveId;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056848E0
	 * 		Name   -> Function Insurgency.INSGameMode.GetAttackingTeam
	 * 		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	unsigned char AINSGameMode::GetAttackingTeam()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameMode.GetAttackingTeam");
		
		AINSGameMode_GetAttackingTeam_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056847E0
	 * 		Name   -> Function Insurgency.INSGameMode.GetAIDirector
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
	 */
	class UINSAIDirector* AINSGameMode::GetAIDirector()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameMode.GetAIDirector");
		
		AINSGameMode_GetAIDirector_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05684830
	 * 		Name   -> Function Insurgency.INSGameMode.GetActiveObjectives
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		TArray<class AObjectiveBase*>                      OutObjectives                                              (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSGameMode::GetActiveObjectives(TArray<class AObjectiveBase*>* OutObjectives)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameMode.GetActiveObjectives");
		
		AINSGameMode_GetActiveObjectives_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutObjectives != nullptr)
			*OutObjectives = params.OutObjectives;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05684800
	 * 		Name   -> Function Insurgency.INSGameMode.GetActiveObjectiveCount
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	int32_t AINSGameMode::GetActiveObjectiveCount()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameMode.GetActiveObjectiveCount");
		
		AINSGameMode_GetActiveObjectiveCount_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05684760
	 * 		Name   -> Function Insurgency.INSGameMode.DisableSpawns
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		unsigned char                                      TeamId                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSGameMode::DisableSpawns(unsigned char TeamId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameMode.DisableSpawns");
		
		AINSGameMode_DisableSpawns_Params params {};
		params.TeamId = TeamId;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056846D0
	 * 		Name   -> Function Insurgency.INSGameMode.DisableAllActiveObjectives
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bHideFromHud                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSGameMode::DisableAllActiveObjectives(bool bHideFromHud)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameMode.DisableAllActiveObjectives");
		
		AINSGameMode_DisableAllActiveObjectives_Params params {};
		params.bHideFromHud = bHideFromHud;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05684580
	 * 		Name   -> Function Insurgency.INSGameMode.ChangeTeam
	 * 		Flags  -> (Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class AController*                                 Controller                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		unsigned char                                      NewTeamId                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bForce                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bSuicideIfAlive                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSGameMode::ChangeTeam(class AController* Controller, unsigned char NewTeamId, bool bForce, bool bSuicideIfAlive)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameMode.ChangeTeam");
		
		AINSGameMode_ChangeTeam_Params params {};
		params.Controller = Controller;
		params.NewTeamId = NewTeamId;
		params.bForce = bForce;
		params.bSuicideIfAlive = bSuicideIfAlive;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05684470
	 * 		Name   -> Function Insurgency.INSGameMode.CanUseMutator
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		class UClass*                                      MutatorClass                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool AINSGameMode::CanUseMutator(class UClass* MutatorClass)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameMode.CanUseMutator");
		
		AINSGameMode_CanUseMutator_Params params {};
		params.MutatorClass = MutatorClass;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05684440
	 * 		Name   -> Function Insurgency.INSGameMode.CanScore
	 * 		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AINSGameMode::CanScore()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameMode.CanScore");
		
		AINSGameMode_CanScore_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05684500
	 * 		Name   -> Function Insurgency.INSGameMode.CancelPendingRespawns
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		unsigned char                                      TeamId                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSGameMode::CancelPendingRespawns(unsigned char TeamId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameMode.CancelPendingRespawns");
		
		AINSGameMode_CancelPendingRespawns_Params params {};
		params.TeamId = TeamId;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056842F0
	 * 		Name   -> Function Insurgency.INSGameMode.BroadcastTextMessageTeam
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		unsigned char                                      TeamId                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FText                                        Message                                                    (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		class FName                                        Type                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSGameMode::BroadcastTextMessageTeam(unsigned char TeamId, const class FText& Message, const class FName& Type)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameMode.BroadcastTextMessageTeam");
		
		AINSGameMode_BroadcastTextMessageTeam_Params params {};
		params.TeamId = TeamId;
		params.Message = Message;
		params.Type = Type;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056841D0
	 * 		Name   -> Function Insurgency.INSGameMode.BroadcastTextMessageAllPlayers
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		class FText                                        Message                                                    (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		class FName                                        Type                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSGameMode::BroadcastTextMessageAllPlayers(const class FText& Message, const class FName& Type)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameMode.BroadcastTextMessageAllPlayers");
		
		AINSGameMode_BroadcastTextMessageAllPlayers_Params params {};
		params.Message = Message;
		params.Type = Type;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05683F10
	 * 		Name   -> Function Insurgency.INSGameMode.BroadcastTeamResponseEvent
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		struct FCharacterResponseRequest                   Request                                                    (Parm, NativeAccessSpecifierPublic)
	 * 		unsigned char                                      TeamId                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AINSSoldier*                                 SpeakingSoldier                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Delay                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bPrioritizeFirst                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bOnlyOfficerAndObserver                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSGameMode::BroadcastTeamResponseEvent(const struct FCharacterResponseRequest& Request, unsigned char TeamId, class AINSSoldier* SpeakingSoldier, float Delay, bool bPrioritizeFirst, bool bOnlyOfficerAndObserver)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameMode.BroadcastTeamResponseEvent");
		
		AINSGameMode_BroadcastTeamResponseEvent_Params params {};
		params.Request = Request;
		params.TeamId = TeamId;
		params.SpeakingSoldier = SpeakingSoldier;
		params.Delay = Delay;
		params.bPrioritizeFirst = bPrioritizeFirst;
		params.bOnlyOfficerAndObserver = bOnlyOfficerAndObserver;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05683C10
	 * 		Name   -> Function Insurgency.INSGameMode.BroadcastTeamRadioEvent
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UAkAudioEvent*                               Event                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		unsigned char                                      TeamId                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FText                                        SubtitleText                                               (Parm, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      AssociatedActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bInterrupt                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Delay                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bOnlyOfficerAndObserver                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bPrioritizeFirst                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              QueuedTimeout                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSGameMode::BroadcastTeamRadioEvent(class UAkAudioEvent* Event, unsigned char TeamId, const class FText& SubtitleText, class AActor* AssociatedActor, bool bInterrupt, float Delay, bool bOnlyOfficerAndObserver, bool bPrioritizeFirst, float QueuedTimeout)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameMode.BroadcastTeamRadioEvent");
		
		AINSGameMode_BroadcastTeamRadioEvent_Params params {};
		params.Event = Event;
		params.TeamId = TeamId;
		params.SubtitleText = SubtitleText;
		params.AssociatedActor = AssociatedActor;
		params.bInterrupt = bInterrupt;
		params.Delay = Delay;
		params.bOnlyOfficerAndObserver = bOnlyOfficerAndObserver;
		params.bPrioritizeFirst = bPrioritizeFirst;
		params.QueuedTimeout = QueuedTimeout;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05683B00
	 * 		Name   -> Function Insurgency.INSGameMode.BroadcastTeamMusicEvent
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		EMusicEvent                                        Event                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		unsigned char                                      TeamId                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bIncludeSpectators                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSGameMode::BroadcastTeamMusicEvent(EMusicEvent Event, unsigned char TeamId, bool bIncludeSpectators)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameMode.BroadcastTeamMusicEvent");
		
		AINSGameMode_BroadcastTeamMusicEvent_Params params {};
		params.Event = Event;
		params.TeamId = TeamId;
		params.bIncludeSpectators = bIncludeSpectators;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05683930
	 * 		Name   -> Function Insurgency.INSGameMode.BroadcastStationResponse
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		EStationResponse                                   StationResponse                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		unsigned char                                      TeamId                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      AssociatedActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bInterrupt                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Delay                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bOnlyOfficerAndObserver                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSGameMode::BroadcastStationResponse(EStationResponse StationResponse, unsigned char TeamId, class AActor* AssociatedActor, bool bInterrupt, float Delay, bool bOnlyOfficerAndObserver)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameMode.BroadcastStationResponse");
		
		AINSGameMode_BroadcastStationResponse_Params params {};
		params.StationResponse = StationResponse;
		params.TeamId = TeamId;
		params.AssociatedActor = AssociatedActor;
		params.bInterrupt = bInterrupt;
		params.Delay = Delay;
		params.bOnlyOfficerAndObserver = bOnlyOfficerAndObserver;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056838B0
	 * 		Name   -> Function Insurgency.INSGameMode.BroadcastMusicEvent
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		EMusicEvent                                        Event                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSGameMode::BroadcastMusicEvent(EMusicEvent Event)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameMode.BroadcastMusicEvent");
		
		AINSGameMode_BroadcastMusicEvent_Params params {};
		params.Event = Event;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056837A0
	 * 		Name   -> Function Insurgency.INSGameMode.BroadcastCenterMessageTeam
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		unsigned char                                      TeamId                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FText                                        Message                                                    (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void AINSGameMode::BroadcastCenterMessageTeam(unsigned char TeamId, const class FText& Message)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameMode.BroadcastCenterMessageTeam");
		
		AINSGameMode_BroadcastCenterMessageTeam_Params params {};
		params.TeamId = TeamId;
		params.Message = Message;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056836D0
	 * 		Name   -> Function Insurgency.INSGameMode.BroadcastCenterMessageAllPlayers
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		class FText                                        Message                                                    (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void AINSGameMode::BroadcastCenterMessageAllPlayers(const class FText& Message)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameMode.BroadcastCenterMessageAllPlayers");
		
		AINSGameMode_BroadcastCenterMessageAllPlayers_Params params {};
		params.Message = Message;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> Function Insurgency.INSGameMode.BlueprintOnSoldierKilled
	 * 		Flags  -> (Event, Public, HasOutParms, BlueprintEvent)
	 * Parameters:
	 * 		class AINSSoldier*                                 SoldierPawn                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              KillingDamage                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FDamageEvent                                DamageEvent                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		class AController*                                 Killer                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AController*                                 Assister                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      DamageCauser                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSGameMode::BlueprintOnSoldierKilled(class AINSSoldier* SoldierPawn, float KillingDamage, const struct FDamageEvent& DamageEvent, class AController* Killer, class AController* Assister, class AActor* DamageCauser)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameMode.BlueprintOnSoldierKilled");
		
		AINSGameMode_BlueprintOnSoldierKilled_Params params {};
		params.SoldierPawn = SoldierPawn;
		params.KillingDamage = KillingDamage;
		params.DamageEvent = DamageEvent;
		params.Killer = Killer;
		params.Assister = Assister;
		params.DamageCauser = DamageCauser;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> Function Insurgency.INSGameMode.BlueprintOnPlayerScoreChanged
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		class AINSPlayerState*                             PlayerState                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            NewScore                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            IncrementAmount                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bIncrementedTeam                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSGameMode::BlueprintOnPlayerScoreChanged(class AINSPlayerState* PlayerState, int32_t NewScore, int32_t IncrementAmount, bool bIncrementedTeam)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameMode.BlueprintOnPlayerScoreChanged");
		
		AINSGameMode_BlueprintOnPlayerScoreChanged_Params params {};
		params.PlayerState = PlayerState;
		params.NewScore = NewScore;
		params.IncrementAmount = IncrementAmount;
		params.bIncrementedTeam = bIncrementedTeam;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> Function Insurgency.INSGameMode.BlueprintFactionsInitialized
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 */
	void AINSGameMode::BlueprintFactionsInitialized()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameMode.BlueprintFactionsInitialized");
		
		AINSGameMode_BlueprintFactionsInitialized_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05683610
	 * 		Name   -> Function Insurgency.INSGameMode.AssignPawnTeam
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class APawn*                                       Soldier                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AController*                                 Controller                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSGameMode::AssignPawnTeam(class APawn* Soldier, class AController* Controller)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameMode.AssignPawnTeam");
		
		AINSGameMode_AssignPawnTeam_Params params {};
		params.Soldier = Soldier;
		params.Controller = Controller;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05683530
	 * 		Name   -> Function Insurgency.INSGameMode.AllowObjectiveFullCapture
	 * 		Flags  -> (Native, Public, HasOutParms, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		class AObjectiveCapturable*                        Objective                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AObjectiveBase*                              OutBlockedBy                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool AINSGameMode::AllowObjectiveFullCapture(class AObjectiveCapturable* Objective, class AObjectiveBase** OutBlockedBy)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameMode.AllowObjectiveFullCapture");
		
		AINSGameMode_AllowObjectiveFullCapture_Params params {};
		params.Objective = Objective;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutBlockedBy != nullptr)
			*OutBlockedBy = params.OutBlockedBy;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05683470
	 * 		Name   -> Function Insurgency.INSGameMode.AdvanceSpawns
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		unsigned char                                      ObjectiveId                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		unsigned char                                      TeamId                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSGameMode::AdvanceSpawns(unsigned char ObjectiveId, unsigned char TeamId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameMode.AdvanceSpawns");
		
		AINSGameMode_AdvanceSpawns_Params params {};
		params.ObjectiveId = ObjectiveId;
		params.TeamId = TeamId;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05683320
	 * 		Name   -> Function Insurgency.INSGameMode.AdjustObjectiveCaptureSpeed
	 * 		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class AObjectiveCapturable*                        Objective                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		unsigned char                                      TeamWithMostPlayers                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            PlayerDifference                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            Defenders                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	float AINSGameMode::AdjustObjectiveCaptureSpeed(class AObjectiveCapturable* Objective, unsigned char TeamWithMostPlayers, int32_t PlayerDifference, int32_t Defenders)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameMode.AdjustObjectiveCaptureSpeed");
		
		AINSGameMode_AdjustObjectiveCaptureSpeed_Params params {};
		params.Objective = Objective;
		params.TeamWithMostPlayers = TeamWithMostPlayers;
		params.PlayerDifference = PlayerDifference;
		params.Defenders = Defenders;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AINSGameMode.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AINSGameMode::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.INSGameMode");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05697BF0
	 * 		Name   -> Function Insurgency.INSMultiplayerMode.UpdateVoiceChatChannelFlagsForPlayer
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class AINSPlayerController*                        PlayerController                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSMultiplayerMode::UpdateVoiceChatChannelFlagsForPlayer(class AINSPlayerController* PlayerController)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSMultiplayerMode.UpdateVoiceChatChannelFlagsForPlayer");
		
		AINSMultiplayerMode_UpdateVoiceChatChannelFlagsForPlayer_Params params {};
		params.PlayerController = PlayerController;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05697BD0
	 * 		Name   -> Function Insurgency.INSMultiplayerMode.UpdateVoiceChatChannelFlagsForAll
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void AINSMultiplayerMode::UpdateVoiceChatChannelFlagsForAll()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSMultiplayerMode.UpdateVoiceChatChannelFlagsForAll");
		
		AINSMultiplayerMode_UpdateVoiceChatChannelFlagsForAll_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05697B50
	 * 		Name   -> Function Insurgency.INSMultiplayerMode.SetTransitionTimer
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		float                                              Timer                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSMultiplayerMode::SetTransitionTimer(float Timer)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSMultiplayerMode.SetTransitionTimer");
		
		AINSMultiplayerMode_SetTransitionTimer_Params params {};
		params.Timer = Timer;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05697AD0
	 * 		Name   -> Function Insurgency.INSMultiplayerMode.SetSubMatchState
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class FName                                        NewState                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSMultiplayerMode::SetSubMatchState(const class FName& NewState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSMultiplayerMode.SetSubMatchState");
		
		AINSMultiplayerMode_SetSubMatchState_Params params {};
		params.NewState = NewState;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05697A50
	 * 		Name   -> Function Insurgency.INSMultiplayerMode.SetRoundTimer
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		int32_t                                            Timer                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSMultiplayerMode::SetRoundTimer(int32_t Timer)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSMultiplayerMode.SetRoundTimer");
		
		AINSMultiplayerMode_SetRoundTimer_Params params {};
		params.Timer = Timer;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056979C0
	 * 		Name   -> Function Insurgency.INSMultiplayerMode.SetNeutralSpawnZones
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bEnabled                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSMultiplayerMode::SetNeutralSpawnZones(bool bEnabled)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSMultiplayerMode.SetNeutralSpawnZones");
		
		AINSMultiplayerMode_SetNeutralSpawnZones_Params params {};
		params.bEnabled = bEnabled;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056978F0
	 * 		Name   -> Function Insurgency.INSMultiplayerMode.ScorePlayerStart
	 * 		Flags  -> (Native, Event, Public, BlueprintEvent, Const)
	 * Parameters:
	 * 		class AController*                                 Player                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class APlayerStart*                                PlayerStart                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	float AINSMultiplayerMode::ScorePlayerStart(class AController* Player, class APlayerStart* PlayerStart)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSMultiplayerMode.ScorePlayerStart");
		
		AINSMultiplayerMode_ScorePlayerStart_Params params {};
		params.Player = Player;
		params.PlayerStart = PlayerStart;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> DelegateFunction Insurgency.INSMultiplayerMode.RoundStateChangeDelegate__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 */
	void AINSMultiplayerMode::RoundStateChangeDelegate__DelegateSignature()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction Insurgency.INSMultiplayerMode.RoundStateChangeDelegate__DelegateSignature");
		
		AINSMultiplayerMode_RoundStateChangeDelegate__DelegateSignature_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056978D0
	 * 		Name   -> Function Insurgency.INSMultiplayerMode.RoundRestart
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void AINSMultiplayerMode::RoundRestart()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSMultiplayerMode.RoundRestart");
		
		AINSMultiplayerMode_RoundRestart_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x04DB4620
	 * 		Name   -> Function Insurgency.INSMultiplayerMode.RoundReset
	 * 		Flags  -> (Native, Public, BlueprintCallable)
	 */
	void AINSMultiplayerMode::RoundReset()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSMultiplayerMode.RoundReset");
		
		AINSMultiplayerMode_RoundReset_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05697850
	 * 		Name   -> Function Insurgency.INSMultiplayerMode.RoundOverDraw
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		ERoundConclusion                                   RoundEndReason                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSMultiplayerMode::RoundOverDraw(ERoundConclusion RoundEndReason)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSMultiplayerMode.RoundOverDraw");
		
		AINSMultiplayerMode_RoundOverDraw_Params params {};
		params.RoundEndReason = RoundEndReason;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05697790
	 * 		Name   -> Function Insurgency.INSMultiplayerMode.RoundOverByTeam
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		ERoundConclusion                                   RoundEndReason                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class ATeamInfo*                                   TeamInfo                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSMultiplayerMode::RoundOverByTeam(ERoundConclusion RoundEndReason, class ATeamInfo* TeamInfo)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSMultiplayerMode.RoundOverByTeam");
		
		AINSMultiplayerMode_RoundOverByTeam_Params params {};
		params.RoundEndReason = RoundEndReason;
		params.TeamInfo = TeamInfo;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056976D0
	 * 		Name   -> Function Insurgency.INSMultiplayerMode.RoundOver
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		ERoundConclusion                                   RoundEndReason                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		unsigned char                                      WinningTeam                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSMultiplayerMode::RoundOver(ERoundConclusion RoundEndReason, unsigned char WinningTeam)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSMultiplayerMode.RoundOver");
		
		AINSMultiplayerMode_RoundOver_Params params {};
		params.RoundEndReason = RoundEndReason;
		params.WinningTeam = WinningTeam;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x04DB37A0
	 * 		Name   -> Function Insurgency.INSMultiplayerMode.RoundActiveTick
	 * 		Flags  -> (Native, Event, Public, BlueprintEvent)
	 */
	void AINSMultiplayerMode::RoundActiveTick()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSMultiplayerMode.RoundActiveTick");
		
		AINSMultiplayerMode_RoundActiveTick_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x04DB3BA0
	 * 		Name   -> Function Insurgency.INSMultiplayerMode.RespawnAllBots
	 * 		Flags  -> (Exec, Native, Public)
	 */
	void AINSMultiplayerMode::RespawnAllBots()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSMultiplayerMode.RespawnAllBots");
		
		AINSMultiplayerMode_RespawnAllBots_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05697640
	 * 		Name   -> Function Insurgency.INSMultiplayerMode.ResetRoundWins
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bResetScores                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSMultiplayerMode::ResetRoundWins(bool bResetScores)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSMultiplayerMode.ResetRoundWins");
		
		AINSMultiplayerMode_ResetRoundWins_Params params {};
		params.bResetScores = bResetScores;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05697540
	 * 		Name   -> Function Insurgency.INSMultiplayerMode.PlayObjectiveAnnouncement
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UAkAudioEvent*                               Sound                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            ObjectiveId                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		unsigned char                                      TeamId                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSMultiplayerMode::PlayObjectiveAnnouncement(class UAkAudioEvent* Sound, int32_t ObjectiveId, unsigned char TeamId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSMultiplayerMode.PlayObjectiveAnnouncement");
		
		AINSMultiplayerMode_PlayObjectiveAnnouncement_Params params {};
		params.Sound = Sound;
		params.ObjectiveId = ObjectiveId;
		params.TeamId = TeamId;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05697480
	 * 		Name   -> Function Insurgency.INSMultiplayerMode.PlayAnnouncement
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UAkAudioEvent*                               Sound                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		unsigned char                                      TeamId                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSMultiplayerMode::PlayAnnouncement(class UAkAudioEvent* Sound, unsigned char TeamId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSMultiplayerMode.PlayAnnouncement");
		
		AINSMultiplayerMode_PlayAnnouncement_Params params {};
		params.Sound = Sound;
		params.TeamId = TeamId;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056973F0
	 * 		Name   -> Function Insurgency.INSMultiplayerMode.OnUpdateServerSettings
	 * 		Flags  -> (Native, Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		class AINSMultiplayerGameState*                    InMultiplayerGameState                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSMultiplayerMode::OnUpdateServerSettings(class AINSMultiplayerGameState* InMultiplayerGameState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSMultiplayerMode.OnUpdateServerSettings");
		
		AINSMultiplayerMode_OnUpdateServerSettings_Params params {};
		params.InMultiplayerGameState = InMultiplayerGameState;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056972A0
	 * 		Name   -> Function Insurgency.INSMultiplayerMode.OnTeamChanged
	 * 		Flags  -> (Native, Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		class AController*                                 Controller                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		unsigned char                                      NewTeamId                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bForced                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bDidKillPlayer                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSMultiplayerMode::OnTeamChanged(class AController* Controller, unsigned char NewTeamId, bool bForced, bool bDidKillPlayer)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSMultiplayerMode.OnTeamChanged");
		
		AINSMultiplayerMode_OnTeamChanged_Params params {};
		params.Controller = Controller;
		params.NewTeamId = NewTeamId;
		params.bForced = bForced;
		params.bDidKillPlayer = bDidKillPlayer;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05697270
	 * 		Name   -> Function Insurgency.INSMultiplayerMode.OnRoundTimerExpired
	 * 		Flags  -> (Native, Event, Public, BlueprintEvent)
	 */
	bool AINSMultiplayerMode::OnRoundTimerExpired()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSMultiplayerMode.OnRoundTimerExpired");
		
		AINSMultiplayerMode_OnRoundTimerExpired_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x04DB3600
	 * 		Name   -> Function Insurgency.INSMultiplayerMode.OnRoundStarted
	 * 		Flags  -> (Native, Event, Public, BlueprintEvent)
	 */
	void AINSMultiplayerMode::OnRoundStarted()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSMultiplayerMode.OnRoundStarted");
		
		AINSMultiplayerMode_OnRoundStarted_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x04DB4400
	 * 		Name   -> Function Insurgency.INSMultiplayerMode.OnRoundReset
	 * 		Flags  -> (Native, Event, Public, BlueprintEvent)
	 */
	void AINSMultiplayerMode::OnRoundReset()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSMultiplayerMode.OnRoundReset");
		
		AINSMultiplayerMode_OnRoundReset_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> DelegateFunction Insurgency.INSMultiplayerMode.OnRoundOverDelegate__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 * Parameters:
	 * 		ERoundConclusion                                   RoundEndReason                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		unsigned char                                      WinningTeam                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSMultiplayerMode::OnRoundOverDelegate__DelegateSignature(ERoundConclusion RoundEndReason, unsigned char WinningTeam)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction Insurgency.INSMultiplayerMode.OnRoundOverDelegate__DelegateSignature");
		
		AINSMultiplayerMode_OnRoundOverDelegate__DelegateSignature_Params params {};
		params.RoundEndReason = RoundEndReason;
		params.WinningTeam = WinningTeam;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056971B0
	 * 		Name   -> Function Insurgency.INSMultiplayerMode.OnRoundOver
	 * 		Flags  -> (Native, Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		ERoundConclusion                                   RoundEndReason                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		unsigned char                                      WinningTeam                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSMultiplayerMode::OnRoundOver(ERoundConclusion RoundEndReason, unsigned char WinningTeam)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSMultiplayerMode.OnRoundOver");
		
		AINSMultiplayerMode_OnRoundOver_Params params {};
		params.RoundEndReason = RoundEndReason;
		params.WinningTeam = WinningTeam;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x04DB3660
	 * 		Name   -> Function Insurgency.INSMultiplayerMode.OnResetObjectives
	 * 		Flags  -> (Native, Event, Public, BlueprintEvent)
	 */
	void AINSMultiplayerMode::OnResetObjectives()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSMultiplayerMode.OnResetObjectives");
		
		AINSMultiplayerMode_OnResetObjectives_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x04DB48A0
	 * 		Name   -> Function Insurgency.INSMultiplayerMode.OnPreRoundStarted
	 * 		Flags  -> (Native, Event, Public, BlueprintEvent)
	 */
	void AINSMultiplayerMode::OnPreRoundStarted()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSMultiplayerMode.OnPreRoundStarted");
		
		AINSMultiplayerMode_OnPreRoundStarted_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x04DB4640
	 * 		Name   -> Function Insurgency.INSMultiplayerMode.OnPreRoundPreReset
	 * 		Flags  -> (Native, Event, Public, BlueprintEvent)
	 */
	void AINSMultiplayerMode::OnPreRoundPreReset()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSMultiplayerMode.OnPreRoundPreReset");
		
		AINSMultiplayerMode_OnPreRoundPreReset_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056970E0
	 * 		Name   -> Function Insurgency.INSMultiplayerMode.OnPlayerConfirmedLoadout
	 * 		Flags  -> (Native, Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		class AINSPlayerController*                        PlayerController                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bWasAlreadyConfirmed                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSMultiplayerMode::OnPlayerConfirmedLoadout(class AINSPlayerController* PlayerController, bool bWasAlreadyConfirmed)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSMultiplayerMode.OnPlayerConfirmedLoadout");
		
		AINSMultiplayerMode_OnPlayerConfirmedLoadout_Params params {};
		params.PlayerController = PlayerController;
		params.bWasAlreadyConfirmed = bWasAlreadyConfirmed;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05697010
	 * 		Name   -> Function Insurgency.INSMultiplayerMode.OnPlayerClassAssigned
	 * 		Flags  -> (Native, Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		class AController*                                 Controller                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UPlayerClass*                                PlayerClass                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSMultiplayerMode::OnPlayerClassAssigned(class AController* Controller, class UPlayerClass* PlayerClass)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSMultiplayerMode.OnPlayerClassAssigned");
		
		AINSMultiplayerMode_OnPlayerClassAssigned_Params params {};
		params.Controller = Controller;
		params.PlayerClass = PlayerClass;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05696F70
	 * 		Name   -> Function Insurgency.INSMultiplayerMode.OnPlayerBecomeSpectator
	 * 		Flags  -> (Native, Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		class AINSPlayerController*                        PlayerController                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool AINSMultiplayerMode::OnPlayerBecomeSpectator(class AINSPlayerController* PlayerController)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSMultiplayerMode.OnPlayerBecomeSpectator");
		
		AINSMultiplayerMode_OnPlayerBecomeSpectator_Params params {};
		params.PlayerController = PlayerController;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x04DB4040
	 * 		Name   -> Function Insurgency.INSMultiplayerMode.OnInitObjectives
	 * 		Flags  -> (Native, Event, Public, BlueprintEvent)
	 */
	void AINSMultiplayerMode::OnInitObjectives()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSMultiplayerMode.OnInitObjectives");
		
		AINSMultiplayerMode_OnInitObjectives_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> DelegateFunction Insurgency.INSMultiplayerMode.OnHeroCaptureDelegate__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 * Parameters:
	 * 		class AINSPlayerState*                             HeroPlayer                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSMultiplayerMode::OnHeroCaptureDelegate__DelegateSignature(class AINSPlayerState* HeroPlayer)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction Insurgency.INSMultiplayerMode.OnHeroCaptureDelegate__DelegateSignature");
		
		AINSMultiplayerMode_OnHeroCaptureDelegate__DelegateSignature_Params params {};
		params.HeroPlayer = HeroPlayer;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05696E00
	 * 		Name   -> Function Insurgency.INSMultiplayerMode.OnGameStatsRoundSubmitted
	 * 		Flags  -> (Final, Native, Public, HasOutParms)
	 * Parameters:
	 * 		struct FGameStatsRoundRewards                      Rewards                                                    (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		int32_t                                            RoundNumber                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSMultiplayerMode::OnGameStatsRoundSubmitted(const struct FGameStatsRoundRewards& Rewards, int32_t RoundNumber)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSMultiplayerMode.OnGameStatsRoundSubmitted");
		
		AINSMultiplayerMode_OnGameStatsRoundSubmitted_Params params {};
		params.Rewards = Rewards;
		params.RoundNumber = RoundNumber;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05696D30
	 * 		Name   -> Function Insurgency.INSMultiplayerMode.IsValidPlayerStart
	 * 		Flags  -> (Native, Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		class AController*                                 Player                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class APlayerStart*                                Start                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool AINSMultiplayerMode::IsValidPlayerStart(class AController* Player, class APlayerStart* Start)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSMultiplayerMode.IsValidPlayerStart");
		
		AINSMultiplayerMode_IsValidPlayerStart_Params params {};
		params.Player = Player;
		params.Start = Start;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05696D00
	 * 		Name   -> Function Insurgency.INSMultiplayerMode.IsSoloMode
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AINSMultiplayerMode::IsSoloMode()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSMultiplayerMode.IsSoloMode");
		
		AINSMultiplayerMode_IsSoloMode_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05696CD0
	 * 		Name   -> Function Insurgency.INSMultiplayerMode.IsSingleRoundMode
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AINSMultiplayerMode::IsSingleRoundMode()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSMultiplayerMode.IsSingleRoundMode");
		
		AINSMultiplayerMode_IsSingleRoundMode_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05696CA0
	 * 		Name   -> Function Insurgency.INSMultiplayerMode.IsRoundRunning
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AINSMultiplayerMode::IsRoundRunning()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSMultiplayerMode.IsRoundRunning");
		
		AINSMultiplayerMode_IsRoundRunning_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05696C70
	 * 		Name   -> Function Insurgency.INSMultiplayerMode.IsRoundExpired
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AINSMultiplayerMode::IsRoundExpired()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSMultiplayerMode.IsRoundExpired");
		
		AINSMultiplayerMode_IsRoundExpired_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05696C40
	 * 		Name   -> Function Insurgency.INSMultiplayerMode.IsPreRound
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AINSMultiplayerMode::IsPreRound()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSMultiplayerMode.IsPreRound");
		
		AINSMultiplayerMode_IsPreRound_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05696B80
	 * 		Name   -> Function Insurgency.INSMultiplayerMode.IsPlayerStartEnabled
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class AController*                                 Player                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class APlayerStart*                                Start                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool AINSMultiplayerMode::IsPlayerStartEnabled(class AController* Player, class APlayerStart* Start)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSMultiplayerMode.IsPlayerStartEnabled");
		
		AINSMultiplayerMode_IsPlayerStartEnabled_Params params {};
		params.Player = Player;
		params.Start = Start;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05696B50
	 * 		Name   -> Function Insurgency.INSMultiplayerMode.IsGameOver
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AINSMultiplayerMode::IsGameOver()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSMultiplayerMode.IsGameOver");
		
		AINSMultiplayerMode_IsGameOver_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05696B20
	 * 		Name   -> Function Insurgency.INSMultiplayerMode.IsCoop
	 * 		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AINSMultiplayerMode::IsCoop()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSMultiplayerMode.IsCoop");
		
		AINSMultiplayerMode_IsCoop_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05696AF0
	 * 		Name   -> Function Insurgency.INSMultiplayerMode.IsArcade
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AINSMultiplayerMode::IsArcade()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSMultiplayerMode.IsArcade");
		
		AINSMultiplayerMode_IsArcade_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05696AD0
	 * 		Name   -> Function Insurgency.INSMultiplayerMode.InvalidateRoundTimer
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void AINSMultiplayerMode::InvalidateRoundTimer()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSMultiplayerMode.InvalidateRoundTimer");
		
		AINSMultiplayerMode_InvalidateRoundTimer_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056969C0
	 * 		Name   -> Function Insurgency.INSMultiplayerMode.IncrementTeamPointsById
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		unsigned char                                      TeamId                                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            Amount                                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bCheckWinningConditions                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSMultiplayerMode::IncrementTeamPointsById(unsigned char TeamId, int32_t Amount, bool bCheckWinningConditions)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSMultiplayerMode.IncrementTeamPointsById");
		
		AINSMultiplayerMode_IncrementTeamPointsById_Params params {};
		params.TeamId = TeamId;
		params.Amount = Amount;
		params.bCheckWinningConditions = bCheckWinningConditions;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056968C0
	 * 		Name   -> Function Insurgency.INSMultiplayerMode.IncrementTeamPoints
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class ATeamInfo*                                   Team                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            Amount                                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bCheckWinningConditions                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSMultiplayerMode::IncrementTeamPoints(class ATeamInfo* Team, int32_t Amount, bool bCheckWinningConditions)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSMultiplayerMode.IncrementTeamPoints");
		
		AINSMultiplayerMode_IncrementTeamPoints_Params params {};
		params.Team = Team;
		params.Amount = Amount;
		params.bCheckWinningConditions = bCheckWinningConditions;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05696830
	 * 		Name   -> Function Insurgency.INSMultiplayerMode.GetVoiceChatChannelFlagsForPlayer
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		class AINSPlayerController*                        PlayerController                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	EVoiceChatChannelFlags AINSMultiplayerMode::GetVoiceChatChannelFlagsForPlayer(class AINSPlayerController* PlayerController)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSMultiplayerMode.GetVoiceChatChannelFlagsForPlayer");
		
		AINSMultiplayerMode_GetVoiceChatChannelFlagsForPlayer_Params params {};
		params.PlayerController = PlayerController;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05696800
	 * 		Name   -> Function Insurgency.INSMultiplayerMode.GetTotalPlayerCount
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	int32_t AINSMultiplayerMode::GetTotalPlayerCount()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSMultiplayerMode.GetTotalPlayerCount");
		
		AINSMultiplayerMode_GetTotalPlayerCount_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056967D0
	 * 		Name   -> Function Insurgency.INSMultiplayerMode.GetTeamWithMostPoints
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	class ATeamInfo* AINSMultiplayerMode::GetTeamWithMostPoints()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSMultiplayerMode.GetTeamWithMostPoints");
		
		AINSMultiplayerMode_GetTeamWithMostPoints_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05696730
	 * 		Name   -> Function Insurgency.INSMultiplayerMode.GetTeamWithMajorityControl
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		bool                                               bIncludeContested                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class ATeamInfo* AINSMultiplayerMode::GetTeamWithMajorityControl(bool bIncludeContested)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSMultiplayerMode.GetTeamWithMajorityControl");
		
		AINSMultiplayerMode_GetTeamWithMajorityControl_Params params {};
		params.bIncludeContested = bIncludeContested;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056966D0
	 * 		Name   -> Function Insurgency.INSMultiplayerMode.GetRoundTimer
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	float AINSMultiplayerMode::GetRoundTimer()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSMultiplayerMode.GetRoundTimer");
		
		AINSMultiplayerMode_GetRoundTimer_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056966A0
	 * 		Name   -> Function Insurgency.INSMultiplayerMode.GetRoundTimeElapsed
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	float AINSMultiplayerMode::GetRoundTimeElapsed()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSMultiplayerMode.GetRoundTimeElapsed");
		
		AINSMultiplayerMode_GetRoundTimeElapsed_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05696700
	 * 		Name   -> Function Insurgency.INSMultiplayerMode.GetRoundsPlayed
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	int32_t AINSMultiplayerMode::GetRoundsPlayed()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSMultiplayerMode.GetRoundsPlayed");
		
		AINSMultiplayerMode_GetRoundsPlayed_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> Function Insurgency.INSMultiplayerMode.GetRoundOverText
	 * 		Flags  -> (Event, Public, HasOutParms, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
	 * Parameters:
	 * 		ERoundConclusion                                   RoundEndReason                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		unsigned char                                      WinningTeam                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FText                                        OutText                                                    (Parm, OutParm, NativeAccessSpecifierPublic)
	 */
	bool AINSMultiplayerMode::GetRoundOverText(ERoundConclusion RoundEndReason, unsigned char WinningTeam, class FText* OutText)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSMultiplayerMode.GetRoundOverText");
		
		AINSMultiplayerMode_GetRoundOverText_Params params {};
		params.RoundEndReason = RoundEndReason;
		params.WinningTeam = WinningTeam;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutText != nullptr)
			*OutText = params.OutText;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05696670
	 * 		Name   -> Function Insurgency.INSMultiplayerMode.GetRoundNumber
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	int32_t AINSMultiplayerMode::GetRoundNumber()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSMultiplayerMode.GetRoundNumber");
		
		AINSMultiplayerMode_GetRoundNumber_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056965A0
	 * 		Name   -> Function Insurgency.INSMultiplayerMode.GetPlayerClassForBot
	 * 		Flags  -> (Native, Event, Public, BlueprintEvent, Const)
	 * Parameters:
	 * 		class AINSAISoldierController*                     Bot                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class ATeamInfo*                                   Team                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UPlayerClass* AINSMultiplayerMode::GetPlayerClassForBot(class AINSAISoldierController* Bot, class ATeamInfo* Team)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSMultiplayerMode.GetPlayerClassForBot");
		
		AINSMultiplayerMode_GetPlayerClassForBot_Params params {};
		params.Bot = Bot;
		params.Team = Team;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056964D0
	 * 		Name   -> Function Insurgency.INSMultiplayerMode.GetNumObjectivesOwnedForTeam
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		unsigned char                                      TeamId                                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bIncludeContested                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	int32_t AINSMultiplayerMode::GetNumObjectivesOwnedForTeam(unsigned char TeamId, bool bIncludeContested)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSMultiplayerMode.GetNumObjectivesOwnedForTeam");
		
		AINSMultiplayerMode_GetNumObjectivesOwnedForTeam_Params params {};
		params.TeamId = TeamId;
		params.bIncludeContested = bIncludeContested;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056964A0
	 * 		Name   -> Function Insurgency.INSMultiplayerMode.GetNumObjectivesContested
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	int32_t AINSMultiplayerMode::GetNumObjectivesContested()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSMultiplayerMode.GetNumObjectivesContested");
		
		AINSMultiplayerMode_GetNumObjectivesContested_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05696470
	 * 		Name   -> Function Insurgency.INSMultiplayerMode.GetDefaultWinningTeam
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	class ATeamInfo* AINSMultiplayerMode::GetDefaultWinningTeam()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSMultiplayerMode.GetDefaultWinningTeam");
		
		AINSMultiplayerMode_GetDefaultWinningTeam_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05696350
	 * 		Name   -> Function Insurgency.INSMultiplayerMode.GetAutoAssignPlayerClass
	 * 		Flags  -> (Native, Event, Public, HasOutParms, BlueprintEvent, Const)
	 * Parameters:
	 * 		class AController*                                 Controller                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class ATeamInfo*                                   DesiredTeam                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bOutPromptLoadoutMenu                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UPlayerClass* AINSMultiplayerMode::GetAutoAssignPlayerClass(class AController* Controller, class ATeamInfo* DesiredTeam, bool* bOutPromptLoadoutMenu)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSMultiplayerMode.GetAutoAssignPlayerClass");
		
		AINSMultiplayerMode_GetAutoAssignPlayerClass_Params params {};
		params.Controller = Controller;
		params.DesiredTeam = DesiredTeam;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (bOutPromptLoadoutMenu != nullptr)
			*bOutPromptLoadoutMenu = params.bOutPromptLoadoutMenu;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056962C0
	 * 		Name   -> Function Insurgency.INSMultiplayerMode.FreezePlayers
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bFrozen                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSMultiplayerMode::FreezePlayers(bool bFrozen)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSMultiplayerMode.FreezePlayers");
		
		AINSMultiplayerMode_FreezePlayers_Params params {};
		params.bFrozen = bFrozen;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05696240
	 * 		Name   -> Function Insurgency.INSMultiplayerMode.ExtendRoundTimer
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		int32_t                                            Seconds                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSMultiplayerMode::ExtendRoundTimer(int32_t Seconds)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSMultiplayerMode.ExtendRoundTimer");
		
		AINSMultiplayerMode_ExtendRoundTimer_Params params {};
		params.Seconds = Seconds;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05696220
	 * 		Name   -> Function Insurgency.INSMultiplayerMode.DefaultRoundExpiry
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void AINSMultiplayerMode::DefaultRoundExpiry()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSMultiplayerMode.DefaultRoundExpiry");
		
		AINSMultiplayerMode_DefaultRoundExpiry_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05696200
	 * 		Name   -> Function Insurgency.INSMultiplayerMode.ClearTransitionTimer
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void AINSMultiplayerMode::ClearTransitionTimer()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSMultiplayerMode.ClearTransitionTimer");
		
		AINSMultiplayerMode_ClearTransitionTimer_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056961E0
	 * 		Name   -> Function Insurgency.INSMultiplayerMode.ClearPendingWaves
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void AINSMultiplayerMode::ClearPendingWaves()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSMultiplayerMode.ClearPendingWaves");
		
		AINSMultiplayerMode_ClearPendingWaves_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05696160
	 * 		Name   -> Function Insurgency.INSMultiplayerMode.ClearLastOneStanding
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class ATeamInfo*                                   Team                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSMultiplayerMode::ClearLastOneStanding(class ATeamInfo* Team)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSMultiplayerMode.ClearLastOneStanding");
		
		AINSMultiplayerMode_ClearLastOneStanding_Params params {};
		params.Team = Team;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x04DB46A0
	 * 		Name   -> Function Insurgency.INSMultiplayerMode.CheckTeamEliminationSingleLife
	 * 		Flags  -> (Native, Public, BlueprintCallable)
	 */
	void AINSMultiplayerMode::CheckTeamEliminationSingleLife()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSMultiplayerMode.CheckTeamEliminationSingleLife");
		
		AINSMultiplayerMode_CheckTeamEliminationSingleLife_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056960E0
	 * 		Name   -> Function Insurgency.INSMultiplayerMode.CheckSupplyReward
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class AINSPlayerController*                        Controller                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSMultiplayerMode::CheckSupplyReward(class AINSPlayerController* Controller)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSMultiplayerMode.CheckSupplyReward");
		
		AINSMultiplayerMode_CheckSupplyReward_Params params {};
		params.Controller = Controller;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056960C0
	 * 		Name   -> Function Insurgency.INSMultiplayerMode.CheckPointsWinningConditions
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void AINSMultiplayerMode::CheckPointsWinningConditions()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSMultiplayerMode.CheckPointsWinningConditions");
		
		AINSMultiplayerMode_CheckPointsWinningConditions_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00C76AB0
	 * 		Name   -> Function Insurgency.INSMultiplayerMode.CheckIdlePlayers
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void AINSMultiplayerMode::CheckIdlePlayers()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSMultiplayerMode.CheckIdlePlayers");
		
		AINSMultiplayerMode_CheckIdlePlayers_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056960A0
	 * 		Name   -> Function Insurgency.INSMultiplayerMode.CheckFullCapture
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void AINSMultiplayerMode::CheckFullCapture()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSMultiplayerMode.CheckFullCapture");
		
		AINSMultiplayerMode_CheckFullCapture_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05696020
	 * 		Name   -> Function Insurgency.INSMultiplayerMode.CheckForLastPersonStanding
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class ATeamInfo*                                   Team                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSMultiplayerMode::CheckForLastPersonStanding(class ATeamInfo* Team)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSMultiplayerMode.CheckForLastPersonStanding");
		
		AINSMultiplayerMode_CheckForLastPersonStanding_Params params {};
		params.Team = Team;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05696000
	 * 		Name   -> Function Insurgency.INSMultiplayerMode.CheckEliminationRules
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void AINSMultiplayerMode::CheckEliminationRules()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSMultiplayerMode.CheckEliminationRules");
		
		AINSMultiplayerMode_CheckEliminationRules_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x04DB3D80
	 * 		Name   -> Function Insurgency.INSMultiplayerMode.CheatCaptureObjective
	 * 		Flags  -> (Exec, Native, Public)
	 */
	void AINSMultiplayerMode::CheatCaptureObjective()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSMultiplayerMode.CheatCaptureObjective");
		
		AINSMultiplayerMode_CheatCaptureObjective_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05695FE0
	 * 		Name   -> Function Insurgency.INSMultiplayerMode.BenchmarkOnGameHealthSnapshot
	 * 		Flags  -> (Final, Native, Public)
	 */
	void AINSMultiplayerMode::BenchmarkOnGameHealthSnapshot()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSMultiplayerMode.BenchmarkOnGameHealthSnapshot");
		
		AINSMultiplayerMode_BenchmarkOnGameHealthSnapshot_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05695FC0
	 * 		Name   -> Function Insurgency.INSMultiplayerMode.BalanceTeams
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void AINSMultiplayerMode::BalanceTeams()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSMultiplayerMode.BalanceTeams");
		
		AINSMultiplayerMode_BalanceTeams_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05695F00
	 * 		Name   -> Function Insurgency.INSMultiplayerMode.AwardTeamSupply
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		unsigned char                                      TeamId                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            SupplyAmount                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSMultiplayerMode::AwardTeamSupply(unsigned char TeamId, int32_t SupplyAmount)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSMultiplayerMode.AwardTeamSupply");
		
		AINSMultiplayerMode_AwardTeamSupply_Params params {};
		params.TeamId = TeamId;
		params.SupplyAmount = SupplyAmount;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05695E60
	 * 		Name   -> Function Insurgency.INSMultiplayerMode.AutoAssignTeam
	 * 		Flags  -> (Native, Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		class AController*                                 Controller                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	unsigned char AINSMultiplayerMode::AutoAssignTeam(class AController* Controller)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSMultiplayerMode.AutoAssignTeam");
		
		AINSMultiplayerMode_AutoAssignTeam_Params params {};
		params.Controller = Controller;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05695E30
	 * 		Name   -> Function Insurgency.INSMultiplayerMode.AtWinningCondition
	 * 		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AINSMultiplayerMode::AtWinningCondition()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSMultiplayerMode.AtWinningCondition");
		
		AINSMultiplayerMode_AtWinningCondition_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05695E00
	 * 		Name   -> Function Insurgency.INSMultiplayerMode.AtOvertimeCondition
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AINSMultiplayerMode::AtOvertimeCondition()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSMultiplayerMode.AtOvertimeCondition");
		
		AINSMultiplayerMode_AtOvertimeCondition_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05695DD0
	 * 		Name   -> Function Insurgency.INSMultiplayerMode.AtGameOverCondition
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AINSMultiplayerMode::AtGameOverCondition()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSMultiplayerMode.AtGameOverCondition");
		
		AINSMultiplayerMode_AtGameOverCondition_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05695DA0
	 * 		Name   -> Function Insurgency.INSMultiplayerMode.AreTeamsCurrentlyUnbalanced
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AINSMultiplayerMode::AreTeamsCurrentlyUnbalanced()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSMultiplayerMode.AreTeamsCurrentlyUnbalanced");
		
		AINSMultiplayerMode_AreTeamsCurrentlyUnbalanced_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05695D70
	 * 		Name   -> Function Insurgency.INSMultiplayerMode.AreAnyObjectivesContested
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AINSMultiplayerMode::AreAnyObjectivesContested()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSMultiplayerMode.AreAnyObjectivesContested");
		
		AINSMultiplayerMode_AreAnyObjectivesContested_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AINSMultiplayerMode.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AINSMultiplayerMode::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.INSMultiplayerMode");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056C74F0
	 * 		Name   -> Function Insurgency.INSTeamDeathmatchGameMode.ShouldUseDeathmatchSpawns
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AINSTeamDeathmatchGameMode::ShouldUseDeathmatchSpawns()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSTeamDeathmatchGameMode.ShouldUseDeathmatchSpawns");
		
		AINSTeamDeathmatchGameMode_ShouldUseDeathmatchSpawns_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056C7460
	 * 		Name   -> Function Insurgency.INSTeamDeathmatchGameMode.SetDeathmatchSpawns
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bEnabled                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSTeamDeathmatchGameMode::SetDeathmatchSpawns(bool bEnabled)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSTeamDeathmatchGameMode.SetDeathmatchSpawns");
		
		AINSTeamDeathmatchGameMode_SetDeathmatchSpawns_Params params {};
		params.bEnabled = bEnabled;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056C7440
	 * 		Name   -> Function Insurgency.INSTeamDeathmatchGameMode.EnableDeathmatchSpawns
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void AINSTeamDeathmatchGameMode::EnableDeathmatchSpawns()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSTeamDeathmatchGameMode.EnableDeathmatchSpawns");
		
		AINSTeamDeathmatchGameMode_EnableDeathmatchSpawns_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AINSTeamDeathmatchGameMode.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AINSTeamDeathmatchGameMode::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.INSTeamDeathmatchGameMode");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05646F00
	 * 		Name   -> Function Insurgency.DominationGameMode.CheckDominationScoring
	 * 		Flags  -> (Final, Native, Private)
	 */
	void ADominationGameMode::CheckDominationScoring()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.DominationGameMode.CheckDominationScoring");
		
		ADominationGameMode_CheckDominationScoring_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ADominationGameMode.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ADominationGameMode::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.DominationGameMode");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056484B0
	 * 		Name   -> Function Insurgency.Door.UpdateLocked
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bNewLocked                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ADoor::UpdateLocked(bool bNewLocked)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.Door.UpdateLocked");
		
		ADoor_UpdateLocked_Params params {};
		params.bNewLocked = bNewLocked;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05648420
	 * 		Name   -> Function Insurgency.Door.UpdateEnabled
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bNewEnabled                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ADoor::UpdateEnabled(bool bNewEnabled)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.Door.UpdateEnabled");
		
		ADoor_UpdateEnabled_Params params {};
		params.bNewEnabled = bNewEnabled;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05648400
	 * 		Name   -> Function Insurgency.Door.OnRep_TopHingeBroken
	 * 		Flags  -> (Final, Native, Private)
	 */
	void ADoor::OnRep_TopHingeBroken()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.Door.OnRep_TopHingeBroken");
		
		ADoor_OnRep_TopHingeBroken_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056483E0
	 * 		Name   -> Function Insurgency.Door.OnRep_DoorState
	 * 		Flags  -> (Final, Native, Private)
	 */
	void ADoor::OnRep_DoorState()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.Door.OnRep_DoorState");
		
		ADoor_OnRep_DoorState_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056483C0
	 * 		Name   -> Function Insurgency.Door.OnRep_DoorAngle
	 * 		Flags  -> (Final, Native, Private)
	 */
	void ADoor::OnRep_DoorAngle()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.Door.OnRep_DoorAngle");
		
		ADoor_OnRep_DoorAngle_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056483A0
	 * 		Name   -> Function Insurgency.Door.OnRep_BottomHingeBroken
	 * 		Flags  -> (Final, Native, Private)
	 */
	void ADoor::OnRep_BottomHingeBroken()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.Door.OnRep_BottomHingeBroken");
		
		ADoor_OnRep_BottomHingeBroken_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056481D0
	 * 		Name   -> Function Insurgency.Door.OnDoorHit
	 * 		Flags  -> (Final, Native, Protected, HasOutParms, HasDefaults)
	 * Parameters:
	 * 		class UPrimitiveComponent*                         HitComponent                                               (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      OtherActor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UPrimitiveComponent*                         OtherComp                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     NormalImpulse                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FHitResult                                  Hit                                                        (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	void ADoor::OnDoorHit(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, const struct FVector& NormalImpulse, const struct FHitResult& Hit)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.Door.OnDoorHit");
		
		ADoor_OnDoorHit_Params params {};
		params.HitComponent = HitComponent;
		params.OtherActor = OtherActor;
		params.OtherComp = OtherComp;
		params.NormalImpulse = NormalImpulse;
		params.Hit = Hit;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05648130
	 * 		Name   -> Function Insurgency.Door.NormalDotNormal
	 * 		Flags  -> (Final, Native, Protected, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FVector                                     HitNormal                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	float ADoor::NormalDotNormal(const struct FVector& HitNormal)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.Door.NormalDotNormal");
		
		ADoor_NormalDotNormal_Params params {};
		params.HitNormal = HitNormal;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05648070
	 * 		Name   -> Function Insurgency.Door.Multicast_PlayDoorFX
	 * 		Flags  -> (Net, Native, Event, NetMulticast, Protected, HasDefaults)
	 * Parameters:
	 * 		class UParticleSystem*                             FX                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     Location                                                   (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ADoor::Multicast_PlayDoorFX(class UParticleSystem* FX, const struct FVector& Location)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.Door.Multicast_PlayDoorFX");
		
		ADoor_Multicast_PlayDoorFX_Params params {};
		params.FX = FX;
		params.Location = Location;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05647FC0
	 * 		Name   -> Function Insurgency.Door.Multicast_LaunchDoor
	 * 		Flags  -> (Net, NetReliable, Native, Event, NetMulticast, Public)
	 * Parameters:
	 * 		struct FVector_NetQuantize10                       ImpulseLocation                                            (ConstParm, Parm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector_NetQuantize10                       ImpulseForce                                               (ConstParm, Parm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ADoor::Multicast_LaunchDoor(const struct FVector_NetQuantize10& ImpulseLocation, const struct FVector_NetQuantize10& ImpulseForce)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.Door.Multicast_LaunchDoor");
		
		ADoor_Multicast_LaunchDoor_Params params {};
		params.ImpulseLocation = ImpulseLocation;
		params.ImpulseForce = ImpulseForce;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x04DB5CB0
	 * 		Name   -> Function Insurgency.Door.Multicast_DoorPostAkEvent
	 * 		Flags  -> (Net, NetReliable, Native, Event, NetMulticast, Protected)
	 * Parameters:
	 * 		class UAkAudioEvent*                               Event                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ADoor::Multicast_DoorPostAkEvent(class UAkAudioEvent* Event)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.Door.Multicast_DoorPostAkEvent");
		
		ADoor_Multicast_DoorPostAkEvent_Params params {};
		params.Event = Event;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05647EE0
	 * 		Name   -> Function Insurgency.Door.LaunchDoor
	 * 		Flags  -> (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FVector                                     ImpulseLocation                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     ImpulseForce                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ADoor::LaunchDoor(const struct FVector& ImpulseLocation, const struct FVector& ImpulseForce)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.Door.LaunchDoor");
		
		ADoor_LaunchDoor_Params params {};
		params.ImpulseLocation = ImpulseLocation;
		params.ImpulseForce = ImpulseForce;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05647EB0
	 * 		Name   -> Function Insurgency.Door.IsFalling
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool ADoor::IsFalling()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.Door.IsFalling");
		
		ADoor_IsFalling_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05647E80
	 * 		Name   -> Function Insurgency.Door.IsDoorDestroyed
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool ADoor::IsDoorDestroyed()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.Door.IsDoorDestroyed");
		
		ADoor_IsDoorDestroyed_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05647E50
	 * 		Name   -> Function Insurgency.Door.IsCompletelyOpen
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool ADoor::IsCompletelyOpen()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.Door.IsCompletelyOpen");
		
		ADoor_IsCompletelyOpen_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05647E20
	 * 		Name   -> Function Insurgency.Door.IsClosed
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool ADoor::IsClosed()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.Door.IsClosed");
		
		ADoor_IsClosed_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05647DF0
	 * 		Name   -> Function Insurgency.Door.IsBroken
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool ADoor::IsBroken()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.Door.IsBroken");
		
		ADoor_IsBroken_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05647DC0
	 * 		Name   -> Function Insurgency.Door.HasFallen
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool ADoor::HasFallen()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.Door.HasFallen");
		
		ADoor_HasFallen_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05647D90
	 * 		Name   -> Function Insurgency.Door.GetDoorState
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	EDoorState ADoor::GetDoorState()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.Door.GetDoorState");
		
		ADoor_GetDoorState_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05647D50
	 * 		Name   -> Function Insurgency.Door.GetCenterLocation
	 * 		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
	 */
	struct FVector ADoor::GetCenterLocation()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.Door.GetCenterLocation");
		
		ADoor_GetCenterLocation_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05647CB0
	 * 		Name   -> Function Insurgency.Door.DoorDotProduct
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		class AINSCharacter*                               Pawn                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	float ADoor::DoorDotProduct(class AINSCharacter* Pawn)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.Door.DoorDotProduct");
		
		ADoor_DoorDotProduct_Params params {};
		params.Pawn = Pawn;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05647C90
	 * 		Name   -> Function Insurgency.Door.CheckLaunchDoor
	 * 		Flags  -> (Final, Native, Protected)
	 */
	void ADoor::CheckLaunchDoor()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.Door.CheckLaunchDoor");
		
		ADoor_CheckLaunchDoor_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05647C70
	 * 		Name   -> Function Insurgency.Door.CheckFallenDoorIsStuck
	 * 		Flags  -> (Final, Native, Public)
	 */
	void ADoor::CheckFallenDoorIsStuck()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.Door.CheckFallenDoorIsStuck");
		
		ADoor_CheckFallenDoorIsStuck_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05647BB0
	 * 		Name   -> Function Insurgency.Door.BreakDown
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		float                                              DotProduct                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Speed                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ADoor::BreakDown(float DotProduct, float Speed)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.Door.BreakDown");
		
		ADoor_BreakDown_Params params {};
		params.DotProduct = DotProduct;
		params.Speed = Speed;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05647B80
	 * 		Name   -> Function Insurgency.Door.AreHingesShotOff
	 * 		Flags  -> (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
	 */
	bool ADoor::AreHingesShotOff()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.Door.AreHingesShotOff");
		
		ADoor_AreHingesShotOff_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ADoor.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ADoor::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.Door");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDynamicAccurateObstacleSpawnerInterface.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDynamicAccurateObstacleSpawnerInterface::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.DynamicAccurateObstacleSpawnerInterface");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> Function Insurgency.DynamicHintWidget.UpdateVisibility
	 * 		Flags  -> (Event, Public, BlueprintCallable, BlueprintEvent)
	 */
	void UDynamicHintWidget::UpdateVisibility()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.DynamicHintWidget.UpdateVisibility");
		
		UDynamicHintWidget_UpdateVisibility_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> Function Insurgency.DynamicHintWidget.OnFillRowWithInformationMultipleActions
	 * 		Flags  -> (Event, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintEvent)
	 * Parameters:
	 * 		bool                                               IsPrimaryRow                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FText                                        AdditionalText                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		class UTexture2D*                                  HintTexture                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		TArray<class FName>                                ActionNames                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     Location                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Timeout                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UDynamicHintWidget::OnFillRowWithInformationMultipleActions(bool IsPrimaryRow, const class FText& AdditionalText, class UTexture2D* HintTexture, TArray<class FName> ActionNames, const struct FVector& Location, float Timeout)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.DynamicHintWidget.OnFillRowWithInformationMultipleActions");
		
		UDynamicHintWidget_OnFillRowWithInformationMultipleActions_Params params {};
		params.IsPrimaryRow = IsPrimaryRow;
		params.AdditionalText = AdditionalText;
		params.HintTexture = HintTexture;
		params.ActionNames = ActionNames;
		params.Location = Location;
		params.Timeout = Timeout;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> Function Insurgency.DynamicHintWidget.OnFillRowWithInformation
	 * 		Flags  -> (Event, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintEvent)
	 * Parameters:
	 * 		bool                                               IsPrimaryRow                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FText                                        AdditionalText                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		class UTexture2D*                                  HintTexture                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FName                                        ActionName                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     Location                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Timeout                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UDynamicHintWidget::OnFillRowWithInformation(bool IsPrimaryRow, const class FText& AdditionalText, class UTexture2D* HintTexture, const class FName& ActionName, const struct FVector& Location, float Timeout)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.DynamicHintWidget.OnFillRowWithInformation");
		
		UDynamicHintWidget_OnFillRowWithInformation_Params params {};
		params.IsPrimaryRow = IsPrimaryRow;
		params.AdditionalText = AdditionalText;
		params.HintTexture = HintTexture;
		params.ActionName = ActionName;
		params.Location = Location;
		params.Timeout = Timeout;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDynamicHintWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDynamicHintWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.DynamicHintWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x057064D0
	 * 		Name   -> Function Insurgency.PhysicalDebris.OnBounce
	 * 		Flags  -> (Final, Native, Public, HasOutParms, HasDefaults)
	 * Parameters:
	 * 		class UPrimitiveComponent*                         HitComponent                                               (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      OtherActor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UPrimitiveComponent*                         OtherComp                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     NormalImpulse                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FHitResult                                  Hit                                                        (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	void APhysicalDebris::OnBounce(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, const struct FVector& NormalImpulse, const struct FHitResult& Hit)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.PhysicalDebris.OnBounce");
		
		APhysicalDebris_OnBounce_Params params {};
		params.HitComponent = HitComponent;
		params.OtherActor = OtherActor;
		params.OtherComp = OtherComp;
		params.NormalImpulse = NormalImpulse;
		params.Hit = Hit;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction APhysicalDebris.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* APhysicalDebris::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.PhysicalDebris");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AEjectedBrass.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AEjectedBrass::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.EjectedBrass");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05648E90
	 * 		Name   -> Function Insurgency.EntranceZone.OnBeginEntranceOverlap
	 * 		Flags  -> (Final, Native, Public, HasOutParms)
	 * Parameters:
	 * 		class UPrimitiveComponent*                         OverlappedComponent                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      OtherActor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UPrimitiveComponent*                         OtherComp                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            OtherBodyIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bFromSweep                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FHitResult                                  SweepResult                                                (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	void AEntranceZone::OnBeginEntranceOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32_t OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.EntranceZone.OnBeginEntranceOverlap");
		
		AEntranceZone_OnBeginEntranceOverlap_Params params {};
		params.OverlappedComponent = OverlappedComponent;
		params.OtherActor = OtherActor;
		params.OtherComp = OtherComp;
		params.OtherBodyIndex = OtherBodyIndex;
		params.bFromSweep = bFromSweep;
		params.SweepResult = SweepResult;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AEntranceZone.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AEntranceZone::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.EntranceZone");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056493D0
	 * 		Name   -> Function Insurgency.EnumerateReplayEventsProxy.EnumerateReplayEvents
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FString                                      Group                                                      (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UEnumerateReplayEventsProxy* UEnumerateReplayEventsProxy::STATIC_EnumerateReplayEvents(class UObject* WorldContextObject, const class FString& Group)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.EnumerateReplayEventsProxy.EnumerateReplayEvents");
		
		UEnumerateReplayEventsProxy_EnumerateReplayEvents_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.Group = Group;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UEnumerateReplayEventsProxy.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UEnumerateReplayEventsProxy::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.EnumerateReplayEventsProxy");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05649810
	 * 		Name   -> Function Insurgency.EnumerateReplaysProxy.EnumerateReplays
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FString                                      MetaData                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UEnumerateReplaysProxy* UEnumerateReplaysProxy::STATIC_EnumerateReplays(class UObject* WorldContextObject, const class FString& MetaData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.EnumerateReplaysProxy.EnumerateReplays");
		
		UEnumerateReplaysProxy_EnumerateReplays_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.MetaData = MetaData;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UEnumerateReplaysProxy.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UEnumerateReplaysProxy::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.EnumerateReplaysProxy");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UEnvQueryContext_ActiveObjectives.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UEnvQueryContext_ActiveObjectives::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.EnvQueryContext_ActiveObjectives");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UEnvQueryContext_AliveAllies.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UEnvQueryContext_AliveAllies::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.EnvQueryContext_AliveAllies");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UEnvQueryContext_AliveEnemies.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UEnvQueryContext_AliveEnemies::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.EnvQueryContext_AliveEnemies");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UEnvQueryContext_GetClaimedSearchAreasForinvestigation.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UEnvQueryContext_GetClaimedSearchAreasForinvestigation::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.EnvQueryContext_GetClaimedSearchAreasForinvestigation");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UEnvQueryContext_NearbyOfficers.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UEnvQueryContext_NearbyOfficers::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.EnvQueryContext_NearbyOfficers");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UEnvQueryContext_PreviousPath.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UEnvQueryContext_PreviousPath::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.EnvQueryContext_PreviousPath");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UEnvQueryContext_SquadCenter.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UEnvQueryContext_SquadCenter::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.EnvQueryContext_SquadCenter");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UEnvQueryContext_SquadDestination.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UEnvQueryContext_SquadDestination::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.EnvQueryContext_SquadDestination");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UEnvQueryContext_SquadMembers.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UEnvQueryContext_SquadMembers::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.EnvQueryContext_SquadMembers");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UEnvQueryContext_SquadMembersDest.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UEnvQueryContext_SquadMembersDest::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.EnvQueryContext_SquadMembersDest");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UEnvQueryContext_SquadPath.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UEnvQueryContext_SquadPath::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.EnvQueryContext_SquadPath");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UEnvQueryGenerator_CoverLocations.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UEnvQueryGenerator_CoverLocations::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.EnvQueryGenerator_CoverLocations");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UEnvQueryTest_ActiveObjective.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UEnvQueryTest_ActiveObjective::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.EnvQueryTest_ActiveObjective");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UEnvQueryTest_ContestedObjective.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UEnvQueryTest_ContestedObjective::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.EnvQueryTest_ContestedObjective");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UEnvQueryTest_OnReachableNavMesh.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UEnvQueryTest_OnReachableNavMesh::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.EnvQueryTest_OnReachableNavMesh");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UEnvQueryTest_OnTacticalGrid.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UEnvQueryTest_OnTacticalGrid::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.EnvQueryTest_OnTacticalGrid");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UEnvQueryTest_SpatialVisibility.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UEnvQueryTest_SpatialVisibility::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.EnvQueryTest_SpatialVisibility");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UEnvQueryTest_TeamPresence.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UEnvQueryTest_TeamPresence::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.EnvQueryTest_TeamPresence");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> Function Insurgency.EquipableAnimInstance.SetEquipable
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		class AItemEquipable*                              Item                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UEquipableAnimInstance::SetEquipable(class AItemEquipable* Item)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.EquipableAnimInstance.SetEquipable");
		
		UEquipableAnimInstance_SetEquipable_Params params {};
		params.Item = Item;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0564D890
	 * 		Name   -> Function Insurgency.EquipableAnimInstance.OnUpgradeRemoved
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		class UWeaponUpgradeComponent*                     Upgrade                                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UEquipableAnimInstance::OnUpgradeRemoved(class UWeaponUpgradeComponent* Upgrade)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.EquipableAnimInstance.OnUpgradeRemoved");
		
		UEquipableAnimInstance_OnUpgradeRemoved_Params params {};
		params.Upgrade = Upgrade;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0564D7D0
	 * 		Name   -> Function Insurgency.EquipableAnimInstance.OnUpgradeMeshLoaded
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		class UINSSkeletalMeshComponent*                   Mesh                                                       (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UWeaponVisualUpgradeComponent*               Upgrade                                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UEquipableAnimInstance::OnUpgradeMeshLoaded(class UINSSkeletalMeshComponent* Mesh, class UWeaponVisualUpgradeComponent* Upgrade)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.EquipableAnimInstance.OnUpgradeMeshLoaded");
		
		UEquipableAnimInstance_OnUpgradeMeshLoaded_Params params {};
		params.Mesh = Mesh;
		params.Upgrade = Upgrade;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0564D750
	 * 		Name   -> Function Insurgency.EquipableAnimInstance.OnUpgradeInstalled
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		class UWeaponUpgradeComponent*                     Upgrade                                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UEquipableAnimInstance::OnUpgradeInstalled(class UWeaponUpgradeComponent* Upgrade)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.EquipableAnimInstance.OnUpgradeInstalled");
		
		UEquipableAnimInstance_OnUpgradeInstalled_Params params {};
		params.Upgrade = Upgrade;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0564D6D0
	 * 		Name   -> Function Insurgency.EquipableAnimInstance.OnSwitchMagazineInterrupt
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		float                                              AnimationInterruptTime                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UEquipableAnimInstance::OnSwitchMagazineInterrupt(float AnimationInterruptTime)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.EquipableAnimInstance.OnSwitchMagazineInterrupt");
		
		UEquipableAnimInstance_OnSwitchMagazineInterrupt_Params params {};
		params.AnimationInterruptTime = AnimationInterruptTime;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0564D600
	 * 		Name   -> Function Insurgency.EquipableAnimInstance.OnSwitchMagazine
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		float                                              RateMultiplier                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bDryReload                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UEquipableAnimInstance::OnSwitchMagazine(float RateMultiplier, bool bDryReload)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.EquipableAnimInstance.OnSwitchMagazine");
		
		UEquipableAnimInstance_OnSwitchMagazine_Params params {};
		params.RateMultiplier = RateMultiplier;
		params.bDryReload = bDryReload;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0564D5E0
	 * 		Name   -> Function Insurgency.EquipableAnimInstance.OnRevolverChambersUpdated
	 * 		Flags  -> (Final, Native, Public)
	 */
	void UEquipableAnimInstance::OnRevolverChambersUpdated()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.EquipableAnimInstance.OnRevolverChambersUpdated");
		
		UEquipableAnimInstance_OnRevolverChambersUpdated_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0564D5C0
	 * 		Name   -> Function Insurgency.EquipableAnimInstance.OnRevolverActiveChamberUpdated
	 * 		Flags  -> (Final, Native, Public)
	 */
	void UEquipableAnimInstance::OnRevolverActiveChamberUpdated()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.EquipableAnimInstance.OnRevolverActiveChamberUpdated");
		
		UEquipableAnimInstance_OnRevolverActiveChamberUpdated_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0564D5A0
	 * 		Name   -> Function Insurgency.EquipableAnimInstance.OnReloadInterrupt
	 * 		Flags  -> (Final, Native, Public)
	 */
	void UEquipableAnimInstance::OnReloadInterrupt()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.EquipableAnimInstance.OnReloadInterrupt");
		
		UEquipableAnimInstance_OnReloadInterrupt_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0564D480
	 * 		Name   -> Function Insurgency.EquipableAnimInstance.OnReloadAfterSwitchMagazine
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		bool                                               bDryReload                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bSingleReload                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              RateMultiplier                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UEquipableAnimInstance::OnReloadAfterSwitchMagazine(bool bDryReload, bool bSingleReload, float RateMultiplier)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.EquipableAnimInstance.OnReloadAfterSwitchMagazine");
		
		UEquipableAnimInstance_OnReloadAfterSwitchMagazine_Params params {};
		params.bDryReload = bDryReload;
		params.bSingleReload = bSingleReload;
		params.RateMultiplier = RateMultiplier;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0564D360
	 * 		Name   -> Function Insurgency.EquipableAnimInstance.OnReload
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		bool                                               bDryReload                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bSingleReload                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              RateMultiplier                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UEquipableAnimInstance::OnReload(bool bDryReload, bool bSingleReload, float RateMultiplier)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.EquipableAnimInstance.OnReload");
		
		UEquipableAnimInstance_OnReload_Params params {};
		params.bDryReload = bDryReload;
		params.bSingleReload = bSingleReload;
		params.RateMultiplier = RateMultiplier;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0564D2D0
	 * 		Name   -> Function Insurgency.EquipableAnimInstance.OnPlayerClassAttributesUpdated
	 * 		Flags  -> (Native, Public)
	 * Parameters:
	 * 		class AINSSoldier*                                 UpdatedSoldier                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UEquipableAnimInstance::OnPlayerClassAttributesUpdated(class AINSSoldier* UpdatedSoldier)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.EquipableAnimInstance.OnPlayerClassAttributesUpdated");
		
		UEquipableAnimInstance_OnPlayerClassAttributesUpdated_Params params {};
		params.UpdatedSoldier = UpdatedSoldier;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0564D250
	 * 		Name   -> Function Insurgency.EquipableAnimInstance.OnMeshLoaded
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		class UINSSkeletalMeshComponent*                   Mesh                                                       (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UEquipableAnimInstance::OnMeshLoaded(class UINSSkeletalMeshComponent* Mesh)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.EquipableAnimInstance.OnMeshLoaded");
		
		UEquipableAnimInstance_OnMeshLoaded_Params params {};
		params.Mesh = Mesh;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0564D170
	 * 		Name   -> Function Insurgency.EquipableAnimInstance.OnMeleeWeaponHit
	 * 		Flags  -> (Final, Native, Public, HasOutParms)
	 * Parameters:
	 * 		struct FHitResult                                  Hit                                                        (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	void UEquipableAnimInstance::OnMeleeWeaponHit(const struct FHitResult& Hit)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.EquipableAnimInstance.OnMeleeWeaponHit");
		
		UEquipableAnimInstance_OnMeleeWeaponHit_Params params {};
		params.Hit = Hit;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0564D080
	 * 		Name   -> Function Insurgency.EquipableAnimInstance.OnMeleeWeaponAttack
	 * 		Flags  -> (Final, Native, Public, HasOutParms)
	 * Parameters:
	 * 		struct FMeleeConfig                                SelectedAttack                                             (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UEquipableAnimInstance::OnMeleeWeaponAttack(const struct FMeleeConfig& SelectedAttack)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.EquipableAnimInstance.OnMeleeWeaponAttack");
		
		UEquipableAnimInstance_OnMeleeWeaponAttack_Params params {};
		params.SelectedAttack = SelectedAttack;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0564CFC0
	 * 		Name   -> Function Insurgency.EquipableAnimInstance.OnItemUnequip
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		bool                                               bInstant                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AItemEquipable*                              SwitchingTo                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UEquipableAnimInstance::OnItemUnequip(bool bInstant, class AItemEquipable* SwitchingTo)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.EquipableAnimInstance.OnItemUnequip");
		
		UEquipableAnimInstance_OnItemUnequip_Params params {};
		params.bInstant = bInstant;
		params.SwitchingTo = SwitchingTo;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0564CEB0
	 * 		Name   -> Function Insurgency.EquipableAnimInstance.OnItemEquip
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		bool                                               bInstant                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AItemEquipable*                              SwitchingFrom                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bWantsFirstEquip                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UEquipableAnimInstance::OnItemEquip(bool bInstant, class AItemEquipable* SwitchingFrom, bool bWantsFirstEquip)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.EquipableAnimInstance.OnItemEquip");
		
		UEquipableAnimInstance_OnItemEquip_Params params {};
		params.bInstant = bInstant;
		params.SwitchingFrom = SwitchingFrom;
		params.bWantsFirstEquip = bWantsFirstEquip;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0564CE30
	 * 		Name   -> Function Insurgency.EquipableAnimInstance.OnGrenadeThrowModeChanged
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		EGrenadeThrowMode                                  OldState                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UEquipableAnimInstance::OnGrenadeThrowModeChanged(EGrenadeThrowMode OldState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.EquipableAnimInstance.OnGrenadeThrowModeChanged");
		
		UEquipableAnimInstance_OnGrenadeThrowModeChanged_Params params {};
		params.OldState = OldState;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0564CDB0
	 * 		Name   -> Function Insurgency.EquipableAnimInstance.OnGrenadeStateChanged
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		EGrenadeState                                      OldState                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UEquipableAnimInstance::OnGrenadeStateChanged(EGrenadeState OldState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.EquipableAnimInstance.OnGrenadeStateChanged");
		
		UEquipableAnimInstance_OnGrenadeStateChanged_Params params {};
		params.OldState = OldState;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0564CD30
	 * 		Name   -> Function Insurgency.EquipableAnimInstance.OnGrenadeStartCook
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		EGrenadeThrowMode                                  NewThrowMode                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UEquipableAnimInstance::OnGrenadeStartCook(EGrenadeThrowMode NewThrowMode)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.EquipableAnimInstance.OnGrenadeStartCook");
		
		UEquipableAnimInstance_OnGrenadeStartCook_Params params {};
		params.NewThrowMode = NewThrowMode;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0564CCA0
	 * 		Name   -> Function Insurgency.EquipableAnimInstance.OnGenericMeleeAttack
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		bool                                               bBash                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UEquipableAnimInstance::OnGenericMeleeAttack(bool bBash)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.EquipableAnimInstance.OnGenericMeleeAttack");
		
		UEquipableAnimInstance_OnGenericMeleeAttack_Params params {};
		params.bBash = bBash;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0564CBE0
	 * 		Name   -> Function Insurgency.EquipableAnimInstance.OnGearInteracted
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		class AItemInteractableGear*                       GearItem                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EEquipableState                                    NewState                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UEquipableAnimInstance::OnGearInteracted(class AItemInteractableGear* GearItem, EEquipableState NewState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.EquipableAnimInstance.OnGearInteracted");
		
		UEquipableAnimInstance_OnGearInteracted_Params params {};
		params.GearItem = GearItem;
		params.NewState = NewState;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0564CBC0
	 * 		Name   -> Function Insurgency.EquipableAnimInstance.OnFirearmStopFire
	 * 		Flags  -> (Final, Native, Public)
	 */
	void UEquipableAnimInstance::OnFirearmStopFire()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.EquipableAnimInstance.OnFirearmStopFire");
		
		UEquipableAnimInstance_OnFirearmStopFire_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0564CBA0
	 * 		Name   -> Function Insurgency.EquipableAnimInstance.OnFirearmStartFire
	 * 		Flags  -> (Final, Native, Public)
	 */
	void UEquipableAnimInstance::OnFirearmStartFire()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.EquipableAnimInstance.OnFirearmStartFire");
		
		UEquipableAnimInstance_OnFirearmStartFire_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0564CAC0
	 * 		Name   -> Function Insurgency.EquipableAnimInstance.OnFirearmFired
	 * 		Flags  -> (Final, Native, Public, HasOutParms, HasDefaults)
	 * Parameters:
	 * 		struct FVector                                     FireOrigin                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     FireDirection                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UEquipableAnimInstance::OnFirearmFired(const struct FVector& FireOrigin, const struct FVector& FireDirection)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.EquipableAnimInstance.OnFirearmFired");
		
		UEquipableAnimInstance_OnFirearmFired_Params params {};
		params.FireOrigin = FireOrigin;
		params.FireDirection = FireDirection;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0564CAA0
	 * 		Name   -> Function Insurgency.EquipableAnimInstance.OnFirearmDryFire
	 * 		Flags  -> (Final, Native, Public)
	 */
	void UEquipableAnimInstance::OnFirearmDryFire()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.EquipableAnimInstance.OnFirearmDryFire");
		
		UEquipableAnimInstance_OnFirearmDryFire_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0564C9D0
	 * 		Name   -> Function Insurgency.EquipableAnimInstance.OnFastReload
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		bool                                               bDryReload                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              RateMultiplier                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UEquipableAnimInstance::OnFastReload(bool bDryReload, float RateMultiplier)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.EquipableAnimInstance.OnFastReload");
		
		UEquipableAnimInstance_OnFastReload_Params params {};
		params.bDryReload = bDryReload;
		params.RateMultiplier = RateMultiplier;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0564C9B0
	 * 		Name   -> Function Insurgency.EquipableAnimInstance.OnEndViewTarget
	 * 		Flags  -> (Final, Native, Public)
	 */
	void UEquipableAnimInstance::OnEndViewTarget()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.EquipableAnimInstance.OnEndViewTarget");
		
		UEquipableAnimInstance_OnEndViewTarget_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0564C8F0
	 * 		Name   -> Function Insurgency.EquipableAnimInstance.OnCycleFiremode
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		EFirearmFiremode                                   OldFiremode                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EFirearmFiremode                                   NewFiremode                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UEquipableAnimInstance::OnCycleFiremode(EFirearmFiremode OldFiremode, EFirearmFiremode NewFiremode)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.EquipableAnimInstance.OnCycleFiremode");
		
		UEquipableAnimInstance_OnCycleFiremode_Params params {};
		params.OldFiremode = OldFiremode;
		params.NewFiremode = NewFiremode;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0564C8D0
	 * 		Name   -> Function Insurgency.EquipableAnimInstance.OnBoltCycle
	 * 		Flags  -> (Final, Native, Public)
	 */
	void UEquipableAnimInstance::OnBoltCycle()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.EquipableAnimInstance.OnBoltCycle");
		
		UEquipableAnimInstance_OnBoltCycle_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0564C810
	 * 		Name   -> Function Insurgency.EquipableAnimInstance.OnBipodLegsStateChanged
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		EBipodState                                        OldState                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EBipodState                                        NewState                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UEquipableAnimInstance::OnBipodLegsStateChanged(EBipodState OldState, EBipodState NewState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.EquipableAnimInstance.OnBipodLegsStateChanged");
		
		UEquipableAnimInstance_OnBipodLegsStateChanged_Params params {};
		params.OldState = OldState;
		params.NewState = NewState;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0564C750
	 * 		Name   -> Function Insurgency.EquipableAnimInstance.OnBipodDeployedStateChanged
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		EBipodState                                        OldState                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EBipodState                                        NewState                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UEquipableAnimInstance::OnBipodDeployedStateChanged(EBipodState OldState, EBipodState NewState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.EquipableAnimInstance.OnBipodDeployedStateChanged");
		
		UEquipableAnimInstance_OnBipodDeployedStateChanged_Params params {};
		params.OldState = OldState;
		params.NewState = NewState;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0564C730
	 * 		Name   -> Function Insurgency.EquipableAnimInstance.OnBecomeViewTarget
	 * 		Flags  -> (Final, Native, Public)
	 */
	void UEquipableAnimInstance::OnBecomeViewTarget()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.EquipableAnimInstance.OnBecomeViewTarget");
		
		UEquipableAnimInstance_OnBecomeViewTarget_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0564C710
	 * 		Name   -> Function Insurgency.EquipableAnimInstance.OnAmmoCheck
	 * 		Flags  -> (Final, Native, Public)
	 */
	void UEquipableAnimInstance::OnAmmoCheck()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.EquipableAnimInstance.OnAmmoCheck");
		
		UEquipableAnimInstance_OnAmmoCheck_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0564C690
	 * 		Name   -> Function Insurgency.EquipableAnimInstance.OnAllUpgradeMeshesLoaded
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		class UWeaponVisualUpgradeComponent*               Upgrade                                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UEquipableAnimInstance::OnAllUpgradeMeshesLoaded(class UWeaponVisualUpgradeComponent* Upgrade)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.EquipableAnimInstance.OnAllUpgradeMeshesLoaded");
		
		UEquipableAnimInstance_OnAllUpgradeMeshesLoaded_Params params {};
		params.Upgrade = Upgrade;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0564C660
	 * 		Name   -> Function Insurgency.EquipableAnimInstance.CanFireEvents
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool UEquipableAnimInstance::CanFireEvents()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.EquipableAnimInstance.CanFireEvents");
		
		UEquipableAnimInstance_CanFireEvents_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> Function Insurgency.EquipableAnimInstance.BlueprintOnUpgradeStateChanged
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		class UWeaponUpgradeComponent*                     Upgrade                                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UEquipableAnimInstance::BlueprintOnUpgradeStateChanged(class UWeaponUpgradeComponent* Upgrade)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.EquipableAnimInstance.BlueprintOnUpgradeStateChanged");
		
		UEquipableAnimInstance_BlueprintOnUpgradeStateChanged_Params params {};
		params.Upgrade = Upgrade;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> Function Insurgency.EquipableAnimInstance.BlueprintOnUpgradeRemoved
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		class UWeaponUpgradeComponent*                     Upgrade                                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UEquipableAnimInstance::BlueprintOnUpgradeRemoved(class UWeaponUpgradeComponent* Upgrade)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.EquipableAnimInstance.BlueprintOnUpgradeRemoved");
		
		UEquipableAnimInstance_BlueprintOnUpgradeRemoved_Params params {};
		params.Upgrade = Upgrade;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> Function Insurgency.EquipableAnimInstance.BlueprintOnUpgradeMeshLoaded
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		class UINSSkeletalMeshComponent*                   Mesh                                                       (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UWeaponVisualUpgradeComponent*               Upgrade                                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UEquipableAnimInstance::BlueprintOnUpgradeMeshLoaded(class UINSSkeletalMeshComponent* Mesh, class UWeaponVisualUpgradeComponent* Upgrade)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.EquipableAnimInstance.BlueprintOnUpgradeMeshLoaded");
		
		UEquipableAnimInstance_BlueprintOnUpgradeMeshLoaded_Params params {};
		params.Mesh = Mesh;
		params.Upgrade = Upgrade;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> Function Insurgency.EquipableAnimInstance.BlueprintOnUpgradeInstalled
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		class UWeaponUpgradeComponent*                     Upgrade                                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UEquipableAnimInstance::BlueprintOnUpgradeInstalled(class UWeaponUpgradeComponent* Upgrade)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.EquipableAnimInstance.BlueprintOnUpgradeInstalled");
		
		UEquipableAnimInstance_BlueprintOnUpgradeInstalled_Params params {};
		params.Upgrade = Upgrade;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> Function Insurgency.EquipableAnimInstance.BlueprintOnSwitchMagazineInterrupt
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		float                                              AnimationInterruptTime                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UEquipableAnimInstance::BlueprintOnSwitchMagazineInterrupt(float AnimationInterruptTime)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.EquipableAnimInstance.BlueprintOnSwitchMagazineInterrupt");
		
		UEquipableAnimInstance_BlueprintOnSwitchMagazineInterrupt_Params params {};
		params.AnimationInterruptTime = AnimationInterruptTime;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> Function Insurgency.EquipableAnimInstance.BlueprintOnSwitchMagazine
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		float                                              RateMultiplier                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bDryReload                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UEquipableAnimInstance::BlueprintOnSwitchMagazine(float RateMultiplier, bool bDryReload)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.EquipableAnimInstance.BlueprintOnSwitchMagazine");
		
		UEquipableAnimInstance_BlueprintOnSwitchMagazine_Params params {};
		params.RateMultiplier = RateMultiplier;
		params.bDryReload = bDryReload;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> Function Insurgency.EquipableAnimInstance.BlueprintOnRevolverChambersUpdated
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 */
	void UEquipableAnimInstance::BlueprintOnRevolverChambersUpdated()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.EquipableAnimInstance.BlueprintOnRevolverChambersUpdated");
		
		UEquipableAnimInstance_BlueprintOnRevolverChambersUpdated_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> Function Insurgency.EquipableAnimInstance.BlueprintOnRevolverActiveChamberUpdated
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 */
	void UEquipableAnimInstance::BlueprintOnRevolverActiveChamberUpdated()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.EquipableAnimInstance.BlueprintOnRevolverActiveChamberUpdated");
		
		UEquipableAnimInstance_BlueprintOnRevolverActiveChamberUpdated_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> Function Insurgency.EquipableAnimInstance.BlueprintOnReloadInterrupt
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 */
	void UEquipableAnimInstance::BlueprintOnReloadInterrupt()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.EquipableAnimInstance.BlueprintOnReloadInterrupt");
		
		UEquipableAnimInstance_BlueprintOnReloadInterrupt_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> Function Insurgency.EquipableAnimInstance.BlueprintOnReloadAfterSwitchMagazine
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		bool                                               bDryReload                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bSingleReload                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              RateMultiplier                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UEquipableAnimInstance::BlueprintOnReloadAfterSwitchMagazine(bool bDryReload, bool bSingleReload, float RateMultiplier)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.EquipableAnimInstance.BlueprintOnReloadAfterSwitchMagazine");
		
		UEquipableAnimInstance_BlueprintOnReloadAfterSwitchMagazine_Params params {};
		params.bDryReload = bDryReload;
		params.bSingleReload = bSingleReload;
		params.RateMultiplier = RateMultiplier;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> Function Insurgency.EquipableAnimInstance.BlueprintOnReload
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		bool                                               bDryReload                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bSingleReload                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              RateMultiplier                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UEquipableAnimInstance::BlueprintOnReload(bool bDryReload, bool bSingleReload, float RateMultiplier)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.EquipableAnimInstance.BlueprintOnReload");
		
		UEquipableAnimInstance_BlueprintOnReload_Params params {};
		params.bDryReload = bDryReload;
		params.bSingleReload = bSingleReload;
		params.RateMultiplier = RateMultiplier;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> Function Insurgency.EquipableAnimInstance.BlueprintOnPlayerClassAttributesUpdated
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 */
	void UEquipableAnimInstance::BlueprintOnPlayerClassAttributesUpdated()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.EquipableAnimInstance.BlueprintOnPlayerClassAttributesUpdated");
		
		UEquipableAnimInstance_BlueprintOnPlayerClassAttributesUpdated_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> Function Insurgency.EquipableAnimInstance.BlueprintOnMeshLoaded
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 */
	void UEquipableAnimInstance::BlueprintOnMeshLoaded()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.EquipableAnimInstance.BlueprintOnMeshLoaded");
		
		UEquipableAnimInstance_BlueprintOnMeshLoaded_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> Function Insurgency.EquipableAnimInstance.BlueprintOnMeleeWeaponHit
	 * 		Flags  -> (Event, Public, HasOutParms, BlueprintEvent)
	 * Parameters:
	 * 		struct FHitResult                                  Hit                                                        (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	void UEquipableAnimInstance::BlueprintOnMeleeWeaponHit(const struct FHitResult& Hit)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.EquipableAnimInstance.BlueprintOnMeleeWeaponHit");
		
		UEquipableAnimInstance_BlueprintOnMeleeWeaponHit_Params params {};
		params.Hit = Hit;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> Function Insurgency.EquipableAnimInstance.BlueprintOnMeleeWeaponAttack
	 * 		Flags  -> (Event, Public, HasOutParms, BlueprintEvent)
	 * Parameters:
	 * 		struct FMeleeConfig                                SelectedAttack                                             (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UEquipableAnimInstance::BlueprintOnMeleeWeaponAttack(const struct FMeleeConfig& SelectedAttack)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.EquipableAnimInstance.BlueprintOnMeleeWeaponAttack");
		
		UEquipableAnimInstance_BlueprintOnMeleeWeaponAttack_Params params {};
		params.SelectedAttack = SelectedAttack;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> Function Insurgency.EquipableAnimInstance.BlueprintOnItemUnequip
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		bool                                               bInstant                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AItemEquipable*                              SwitchingTo                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UEquipableAnimInstance::BlueprintOnItemUnequip(bool bInstant, class AItemEquipable* SwitchingTo)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.EquipableAnimInstance.BlueprintOnItemUnequip");
		
		UEquipableAnimInstance_BlueprintOnItemUnequip_Params params {};
		params.bInstant = bInstant;
		params.SwitchingTo = SwitchingTo;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> Function Insurgency.EquipableAnimInstance.BlueprintOnItemEquip
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		bool                                               bInstant                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AItemEquipable*                              SwitchingFrom                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bWantsFirstEquip                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UEquipableAnimInstance::BlueprintOnItemEquip(bool bInstant, class AItemEquipable* SwitchingFrom, bool bWantsFirstEquip)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.EquipableAnimInstance.BlueprintOnItemEquip");
		
		UEquipableAnimInstance_BlueprintOnItemEquip_Params params {};
		params.bInstant = bInstant;
		params.SwitchingFrom = SwitchingFrom;
		params.bWantsFirstEquip = bWantsFirstEquip;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> Function Insurgency.EquipableAnimInstance.BlueprintOnGrenadeThrowModeChanged
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		EGrenadeThrowMode                                  OldState                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UEquipableAnimInstance::BlueprintOnGrenadeThrowModeChanged(EGrenadeThrowMode OldState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.EquipableAnimInstance.BlueprintOnGrenadeThrowModeChanged");
		
		UEquipableAnimInstance_BlueprintOnGrenadeThrowModeChanged_Params params {};
		params.OldState = OldState;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> Function Insurgency.EquipableAnimInstance.BlueprintOnGrenadeStateChanged
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		EGrenadeState                                      OldState                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UEquipableAnimInstance::BlueprintOnGrenadeStateChanged(EGrenadeState OldState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.EquipableAnimInstance.BlueprintOnGrenadeStateChanged");
		
		UEquipableAnimInstance_BlueprintOnGrenadeStateChanged_Params params {};
		params.OldState = OldState;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> Function Insurgency.EquipableAnimInstance.BlueprintOnGrenadeStartCook
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		EGrenadeThrowMode                                  NewThrowMode                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UEquipableAnimInstance::BlueprintOnGrenadeStartCook(EGrenadeThrowMode NewThrowMode)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.EquipableAnimInstance.BlueprintOnGrenadeStartCook");
		
		UEquipableAnimInstance_BlueprintOnGrenadeStartCook_Params params {};
		params.NewThrowMode = NewThrowMode;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> Function Insurgency.EquipableAnimInstance.BlueprintOnGenericMeleeAttack
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		bool                                               bBash                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UEquipableAnimInstance::BlueprintOnGenericMeleeAttack(bool bBash)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.EquipableAnimInstance.BlueprintOnGenericMeleeAttack");
		
		UEquipableAnimInstance_BlueprintOnGenericMeleeAttack_Params params {};
		params.bBash = bBash;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> Function Insurgency.EquipableAnimInstance.BlueprintOnGearInteracted
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		class AItemInteractableGear*                       GearItem                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EEquipableState                                    NewState                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UEquipableAnimInstance::BlueprintOnGearInteracted(class AItemInteractableGear* GearItem, EEquipableState NewState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.EquipableAnimInstance.BlueprintOnGearInteracted");
		
		UEquipableAnimInstance_BlueprintOnGearInteracted_Params params {};
		params.GearItem = GearItem;
		params.NewState = NewState;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> Function Insurgency.EquipableAnimInstance.BlueprintOnFirearmStopFire
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 */
	void UEquipableAnimInstance::BlueprintOnFirearmStopFire()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.EquipableAnimInstance.BlueprintOnFirearmStopFire");
		
		UEquipableAnimInstance_BlueprintOnFirearmStopFire_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> Function Insurgency.EquipableAnimInstance.BlueprintOnFirearmStartFire
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 */
	void UEquipableAnimInstance::BlueprintOnFirearmStartFire()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.EquipableAnimInstance.BlueprintOnFirearmStartFire");
		
		UEquipableAnimInstance_BlueprintOnFirearmStartFire_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> Function Insurgency.EquipableAnimInstance.BlueprintOnFirearmFired
	 * 		Flags  -> (Event, Public, HasOutParms, HasDefaults, BlueprintEvent)
	 * Parameters:
	 * 		struct FVector                                     FireOrigin                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     FireDirection                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UEquipableAnimInstance::BlueprintOnFirearmFired(const struct FVector& FireOrigin, const struct FVector& FireDirection)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.EquipableAnimInstance.BlueprintOnFirearmFired");
		
		UEquipableAnimInstance_BlueprintOnFirearmFired_Params params {};
		params.FireOrigin = FireOrigin;
		params.FireDirection = FireDirection;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> Function Insurgency.EquipableAnimInstance.BlueprintOnFirearmDryFire
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 */
	void UEquipableAnimInstance::BlueprintOnFirearmDryFire()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.EquipableAnimInstance.BlueprintOnFirearmDryFire");
		
		UEquipableAnimInstance_BlueprintOnFirearmDryFire_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> Function Insurgency.EquipableAnimInstance.BlueprintOnFastReload
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		bool                                               bDryReload                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              RateMultiplier                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UEquipableAnimInstance::BlueprintOnFastReload(bool bDryReload, float RateMultiplier)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.EquipableAnimInstance.BlueprintOnFastReload");
		
		UEquipableAnimInstance_BlueprintOnFastReload_Params params {};
		params.bDryReload = bDryReload;
		params.RateMultiplier = RateMultiplier;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> Function Insurgency.EquipableAnimInstance.BlueprintOnEndViewTarget
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 */
	void UEquipableAnimInstance::BlueprintOnEndViewTarget()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.EquipableAnimInstance.BlueprintOnEndViewTarget");
		
		UEquipableAnimInstance_BlueprintOnEndViewTarget_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> Function Insurgency.EquipableAnimInstance.BlueprintOnCycleFiremode
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		EFirearmFiremode                                   OldFiremode                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EFirearmFiremode                                   NewFiremode                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UEquipableAnimInstance::BlueprintOnCycleFiremode(EFirearmFiremode OldFiremode, EFirearmFiremode NewFiremode)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.EquipableAnimInstance.BlueprintOnCycleFiremode");
		
		UEquipableAnimInstance_BlueprintOnCycleFiremode_Params params {};
		params.OldFiremode = OldFiremode;
		params.NewFiremode = NewFiremode;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> Function Insurgency.EquipableAnimInstance.BlueprintOnBoltCycle
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 */
	void UEquipableAnimInstance::BlueprintOnBoltCycle()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.EquipableAnimInstance.BlueprintOnBoltCycle");
		
		UEquipableAnimInstance_BlueprintOnBoltCycle_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> Function Insurgency.EquipableAnimInstance.BlueprintOnBipodLegsStateChanged
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		EBipodState                                        OldState                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EBipodState                                        NewState                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UEquipableAnimInstance::BlueprintOnBipodLegsStateChanged(EBipodState OldState, EBipodState NewState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.EquipableAnimInstance.BlueprintOnBipodLegsStateChanged");
		
		UEquipableAnimInstance_BlueprintOnBipodLegsStateChanged_Params params {};
		params.OldState = OldState;
		params.NewState = NewState;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> Function Insurgency.EquipableAnimInstance.BlueprintOnBipodDeployedStateChanged
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		EBipodState                                        OldState                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EBipodState                                        NewState                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UEquipableAnimInstance::BlueprintOnBipodDeployedStateChanged(EBipodState OldState, EBipodState NewState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.EquipableAnimInstance.BlueprintOnBipodDeployedStateChanged");
		
		UEquipableAnimInstance_BlueprintOnBipodDeployedStateChanged_Params params {};
		params.OldState = OldState;
		params.NewState = NewState;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> Function Insurgency.EquipableAnimInstance.BlueprintOnBecomeViewTarget
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 */
	void UEquipableAnimInstance::BlueprintOnBecomeViewTarget()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.EquipableAnimInstance.BlueprintOnBecomeViewTarget");
		
		UEquipableAnimInstance_BlueprintOnBecomeViewTarget_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> Function Insurgency.EquipableAnimInstance.BlueprintOnAmmoCheck
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 */
	void UEquipableAnimInstance::BlueprintOnAmmoCheck()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.EquipableAnimInstance.BlueprintOnAmmoCheck");
		
		UEquipableAnimInstance_BlueprintOnAmmoCheck_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> Function Insurgency.EquipableAnimInstance.BlueprintOnAllUpgradeMeshesLoaded
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		class UWeaponVisualUpgradeComponent*               Upgrade                                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UEquipableAnimInstance::BlueprintOnAllUpgradeMeshesLoaded(class UWeaponVisualUpgradeComponent* Upgrade)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.EquipableAnimInstance.BlueprintOnAllUpgradeMeshesLoaded");
		
		UEquipableAnimInstance_BlueprintOnAllUpgradeMeshesLoaded_Params params {};
		params.Upgrade = Upgrade;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UEquipableAnimInstance.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UEquipableAnimInstance::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.EquipableAnimInstance");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UExplosionPenetrationSettings.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UExplosionPenetrationSettings::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.ExplosionPenetrationSettings");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05653180
	 * 		Name   -> Function Insurgency.ExplosionReaction.OnExplosion
	 * 		Flags  -> (Native, Event, Public, HasOutParms, HasDefaults, BlueprintEvent)
	 * Parameters:
	 * 		float                                              Distance                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Damage                                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FHitResult                                  HitResult                                                  (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     ImpulseDir                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AExplosionReaction::OnExplosion(float Distance, float Damage, const struct FHitResult& HitResult, const struct FVector& ImpulseDir)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ExplosionReaction.OnExplosion");
		
		AExplosionReaction_OnExplosion_Params params {};
		params.Distance = Distance;
		params.Damage = Damage;
		params.HitResult = HitResult;
		params.ImpulseDir = ImpulseDir;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AExplosionReaction.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AExplosionReaction::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.ExplosionReaction");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UExternalHyperlinkDecorator.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UExternalHyperlinkDecorator::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.ExternalHyperlinkDecorator");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UFactionDefinition.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UFactionDefinition::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.FactionDefinition");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05653750
	 * 		Name   -> Function Insurgency.FeaturedItemsSettings.GetFeaturedItemsSettings
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 */
	class UFeaturedItemsSettings* UFeaturedItemsSettings::STATIC_GetFeaturedItemsSettings()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.FeaturedItemsSettings.GetFeaturedItemsSettings");
		
		UFeaturedItemsSettings_GetFeaturedItemsSettings_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UFeaturedItemsSettings.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UFeaturedItemsSettings::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.FeaturedItemsSettings");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056551B0
	 * 		Name   -> Function Insurgency.FireSupportBase.PlayIncomingDialogue
	 * 		Flags  -> (Final, Native, Public)
	 */
	void AFireSupportBase::PlayIncomingDialogue()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.FireSupportBase.PlayIncomingDialogue");
		
		AFireSupportBase_PlayIncomingDialogue_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00C76AB0
	 * 		Name   -> Function Insurgency.FireSupportBase.PlayDestroyedDialogue
	 * 		Flags  -> (Final, Native, Public)
	 */
	void AFireSupportBase::PlayDestroyedDialogue()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.FireSupportBase.PlayDestroyedDialogue");
		
		AFireSupportBase_PlayDestroyedDialogue_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05655170
	 * 		Name   -> Function Insurgency.FireSupportBase.GetTeamId
	 * 		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	unsigned char AFireSupportBase::GetTeamId()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.FireSupportBase.GetTeamId");
		
		AFireSupportBase_GetTeamId_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05655020
	 * 		Name   -> Function Insurgency.FireSupportBase.GetSubtitleText
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class FText                                        DisplayText                                                (ConstParm, Parm, NativeAccessSpecifierPublic)
	 */
	class FText AFireSupportBase::GetSubtitleText(const class FText& DisplayText)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.FireSupportBase.GetSubtitleText");
		
		AFireSupportBase_GetSubtitleText_Params params {};
		params.DisplayText = DisplayText;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AFireSupportBase.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AFireSupportBase::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.FireSupportBase");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056541C0
	 * 		Name   -> Function Insurgency.FireSupportAircraft.PlayKillResponse
	 * 		Flags  -> (Final, Native, Private)
	 */
	void AFireSupportAircraft::PlayKillResponse()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.FireSupportAircraft.PlayKillResponse");
		
		AFireSupportAircraft_PlayKillResponse_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05654140
	 * 		Name   -> Function Insurgency.FireSupportAircraft.OnPayloadDropped
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		class AAircraftBase*                               Aircraft                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AFireSupportAircraft::OnPayloadDropped(class AAircraftBase* Aircraft)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.FireSupportAircraft.OnPayloadDropped");
		
		AFireSupportAircraft_OnPayloadDropped_Params params {};
		params.Aircraft = Aircraft;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056540C0
	 * 		Name   -> Function Insurgency.FireSupportAircraft.OnPayloadArrived
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		class AAircraftBase*                               Aircraft                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AFireSupportAircraft::OnPayloadArrived(class AAircraftBase* Aircraft)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.FireSupportAircraft.OnPayloadArrived");
		
		AFireSupportAircraft_OnPayloadArrived_Params params {};
		params.Aircraft = Aircraft;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05654040
	 * 		Name   -> Function Insurgency.FireSupportAircraft.OnFireSupportKillsEnemy
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		class AFireSupportBase*                            FireSupport                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AFireSupportAircraft::OnFireSupportKillsEnemy(class AFireSupportBase* FireSupport)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.FireSupportAircraft.OnFireSupportKillsEnemy");
		
		AFireSupportAircraft_OnFireSupportKillsEnemy_Params params {};
		params.FireSupport = FireSupport;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05653FC0
	 * 		Name   -> Function Insurgency.FireSupportAircraft.OnFinishStrafe
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		class AAircraftBase*                               Aircraft                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AFireSupportAircraft::OnFinishStrafe(class AAircraftBase* Aircraft)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.FireSupportAircraft.OnFinishStrafe");
		
		AFireSupportAircraft_OnFinishStrafe_Params params {};
		params.Aircraft = Aircraft;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05653F40
	 * 		Name   -> Function Insurgency.FireSupportAircraft.OnBeginStrafe
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		class AAircraftBase*                               Aircraft                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AFireSupportAircraft::OnBeginStrafe(class AAircraftBase* Aircraft)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.FireSupportAircraft.OnBeginStrafe");
		
		AFireSupportAircraft_OnBeginStrafe_Params params {};
		params.Aircraft = Aircraft;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05653EC0
	 * 		Name   -> Function Insurgency.FireSupportAircraft.OnAllPayloadsDropped
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		class AAircraftBase*                               Aircraft                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AFireSupportAircraft::OnAllPayloadsDropped(class AAircraftBase* Aircraft)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.FireSupportAircraft.OnAllPayloadsDropped");
		
		AFireSupportAircraft_OnAllPayloadsDropped_Params params {};
		params.Aircraft = Aircraft;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05653EA0
	 * 		Name   -> Function Insurgency.FireSupportAircraft.BeginLeave
	 * 		Flags  -> (Final, Native, Private)
	 */
	void AFireSupportAircraft::BeginLeave()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.FireSupportAircraft.BeginLeave");
		
		AFireSupportAircraft_BeginLeave_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AFireSupportAircraft.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AFireSupportAircraft::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.FireSupportAircraft");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05654A80
	 * 		Name   -> Function Insurgency.FireSupportArtillery.SpawnRound
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void AFireSupportArtillery::SpawnRound()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.FireSupportArtillery.SpawnRound");
		
		AFireSupportArtillery_SpawnRound_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05654A60
	 * 		Name   -> Function Insurgency.FireSupportArtillery.QueueNextRound
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void AFireSupportArtillery::QueueNextRound()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.FireSupportArtillery.QueueNextRound");
		
		AFireSupportArtillery_QueueNextRound_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05654A40
	 * 		Name   -> Function Insurgency.FireSupportArtillery.OnVolleyDelayComplete
	 * 		Flags  -> (Final, Native, Public)
	 */
	void AFireSupportArtillery::OnVolleyDelayComplete()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.FireSupportArtillery.OnVolleyDelayComplete");
		
		AFireSupportArtillery_OnVolleyDelayComplete_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05654A20
	 * 		Name   -> Function Insurgency.FireSupportArtillery.OnRoundsImpacted
	 * 		Flags  -> (Final, Native, Private)
	 */
	void AFireSupportArtillery::OnRoundsImpacted()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.FireSupportArtillery.OnRoundsImpacted");
		
		AFireSupportArtillery_OnRoundsImpacted_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00CBA850
	 * 		Name   -> Function Insurgency.FireSupportArtillery.Multicast_QueuedNextRound
	 * 		Flags  -> (Net, Native, Event, NetMulticast, Public)
	 */
	void AFireSupportArtillery::Multicast_QueuedNextRound()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.FireSupportArtillery.Multicast_QueuedNextRound");
		
		AFireSupportArtillery_Multicast_QueuedNextRound_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05654820
	 * 		Name   -> Function Insurgency.FireSupportArtillery.GetSimpleArtilleryTrajectory
	 * 		Flags  -> (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FVector                                     TargetLocation                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     SourceLocation                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Gravity                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              ProjectileSpeed                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              OutFlyTime                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FVector AFireSupportArtillery::GetSimpleArtilleryTrajectory(const struct FVector& TargetLocation, const struct FVector& SourceLocation, float Gravity, float* ProjectileSpeed, float* OutFlyTime)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.FireSupportArtillery.GetSimpleArtilleryTrajectory");
		
		AFireSupportArtillery_GetSimpleArtilleryTrajectory_Params params {};
		params.TargetLocation = TargetLocation;
		params.SourceLocation = SourceLocation;
		params.Gravity = Gravity;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (ProjectileSpeed != nullptr)
			*ProjectileSpeed = params.ProjectileSpeed;
		if (OutFlyTime != nullptr)
			*OutFlyTime = params.OutFlyTime;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05654620
	 * 		Name   -> Function Insurgency.FireSupportArtillery.GetArtilleryTrajectory
	 * 		Flags  -> (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FVector                                     TargetLocation                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     SourceLocation                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Gravity                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              InOutSpeed                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              OutFlyTime                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FVector AFireSupportArtillery::GetArtilleryTrajectory(const struct FVector& TargetLocation, const struct FVector& SourceLocation, float Gravity, float* InOutSpeed, float* OutFlyTime)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.FireSupportArtillery.GetArtilleryTrajectory");
		
		AFireSupportArtillery_GetArtilleryTrajectory_Params params {};
		params.TargetLocation = TargetLocation;
		params.SourceLocation = SourceLocation;
		params.Gravity = Gravity;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (InOutSpeed != nullptr)
			*InOutSpeed = params.InOutSpeed;
		if (OutFlyTime != nullptr)
			*OutFlyTime = params.OutFlyTime;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056545E0
	 * 		Name   -> Function Insurgency.FireSupportArtillery.GetArtilleryTargetLocation
	 * 		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable)
	 */
	struct FVector AFireSupportArtillery::GetArtilleryTargetLocation()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.FireSupportArtillery.GetArtilleryTargetLocation");
		
		AFireSupportArtillery_GetArtilleryTargetLocation_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05654530
	 * 		Name   -> Function Insurgency.FireSupportArtillery.GetArtillerySourceLocation
	 * 		Flags  -> (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FVector                                     TargetLocation                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FVector AFireSupportArtillery::GetArtillerySourceLocation(const struct FVector& TargetLocation)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.FireSupportArtillery.GetArtillerySourceLocation");
		
		AFireSupportArtillery_GetArtillerySourceLocation_Params params {};
		params.TargetLocation = TargetLocation;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AFireSupportArtillery.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AFireSupportArtillery::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.FireSupportArtillery");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05654F20
	 * 		Name   -> Function Insurgency.FireSupportDefinition.GetPrintName
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
	 */
	class FText UFireSupportDefinition::GetPrintName()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.FireSupportDefinition.GetPrintName");
		
		UFireSupportDefinition_GetPrintName_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UFireSupportDefinition.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UFireSupportDefinition::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.FireSupportDefinition");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05678A70
	 * 		Name   -> Function Insurgency.INSCharacter.UpdateServerTimeOnStartRound
	 * 		Flags  -> (Net, Native, Event, NetMulticast, Public)
	 */
	void AINSCharacter::UpdateServerTimeOnStartRound()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSCharacter.UpdateServerTimeOnStartRound");
		
		AINSCharacter_UpdateServerTimeOnStartRound_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05678A50
	 * 		Name   -> Function Insurgency.INSCharacter.TickFireDamage
	 * 		Flags  -> (Final, Native, Public)
	 */
	void AINSCharacter::TickFireDamage()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSCharacter.TickFireDamage");
		
		AINSCharacter_TickFireDamage_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05678A00
	 * 		Name   -> Function Insurgency.INSCharacter.Server_ToggleVehicleLights
	 * 		Flags  -> (Net, NetReliable, Native, Event, Protected, NetServer, NetValidate)
	 */
	void AINSCharacter::Server_ToggleVehicleLights()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSCharacter.Server_ToggleVehicleLights");
		
		AINSCharacter_Server_ToggleVehicleLights_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056789B0
	 * 		Name   -> Function Insurgency.INSCharacter.Server_StopHonkHorn
	 * 		Flags  -> (Net, NetReliable, Native, Event, Protected, NetServer, NetValidate)
	 */
	void AINSCharacter::Server_StopHonkHorn()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSCharacter.Server_StopHonkHorn");
		
		AINSCharacter_Server_StopHonkHorn_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05678960
	 * 		Name   -> Function Insurgency.INSCharacter.Server_StopHandbreak
	 * 		Flags  -> (Net, NetReliable, Native, Event, Protected, NetServer, NetValidate)
	 */
	void AINSCharacter::Server_StopHandbreak()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSCharacter.Server_StopHandbreak");
		
		AINSCharacter_Server_StopHandbreak_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05678910
	 * 		Name   -> Function Insurgency.INSCharacter.Server_StartHonkHorn
	 * 		Flags  -> (Net, NetReliable, Native, Event, Protected, NetServer, NetValidate)
	 */
	void AINSCharacter::Server_StartHonkHorn()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSCharacter.Server_StartHonkHorn");
		
		AINSCharacter_Server_StartHonkHorn_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056788C0
	 * 		Name   -> Function Insurgency.INSCharacter.Server_StartHandbreak
	 * 		Flags  -> (Net, NetReliable, Native, Event, Protected, NetServer, NetValidate)
	 */
	void AINSCharacter::Server_StartHandbreak()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSCharacter.Server_StartHandbreak");
		
		AINSCharacter_Server_StartHandbreak_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x04DB4940
	 * 		Name   -> Function Insurgency.INSCharacter.ResetMeshTransform
	 * 		Flags  -> (Native, Public)
	 */
	void AINSCharacter::ResetMeshTransform()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSCharacter.ResetMeshTransform");
		
		AINSCharacter_ResetMeshTransform_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056788A0
	 * 		Name   -> Function Insurgency.INSCharacter.OnRep_VehicleSeat
	 * 		Flags  -> (Final, Native, Protected)
	 */
	void AINSCharacter::OnRep_VehicleSeat()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSCharacter.OnRep_VehicleSeat");
		
		AINSCharacter_OnRep_VehicleSeat_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05678880
	 * 		Name   -> Function Insurgency.INSCharacter.OnRep_OnFire
	 * 		Flags  -> (Final, Native, Public)
	 */
	void AINSCharacter::OnRep_OnFire()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSCharacter.OnRep_OnFire");
		
		AINSCharacter_OnRep_OnFire_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05678860
	 * 		Name   -> Function Insurgency.INSCharacter.OnRep_IsDying
	 * 		Flags  -> (Final, Native, Protected)
	 */
	void AINSCharacter::OnRep_IsDying()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSCharacter.OnRep_IsDying");
		
		AINSCharacter_OnRep_IsDying_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05678690
	 * 		Name   -> Function Insurgency.INSCharacter.OnRagdollHit
	 * 		Flags  -> (Final, Native, Public, HasOutParms, HasDefaults)
	 * Parameters:
	 * 		class UPrimitiveComponent*                         HitComponent                                               (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      OtherActor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UPrimitiveComponent*                         OtherComp                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     NormalImpulse                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FHitResult                                  Hit                                                        (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	void AINSCharacter::OnRagdollHit(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, const struct FVector& NormalImpulse, const struct FHitResult& Hit)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSCharacter.OnRagdollHit");
		
		AINSCharacter_OnRagdollHit_Params params {};
		params.HitComponent = HitComponent;
		params.OtherActor = OtherActor;
		params.OtherComp = OtherComp;
		params.NormalImpulse = NormalImpulse;
		params.Hit = Hit;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05678480
	 * 		Name   -> Function Insurgency.INSCharacter.OnCapsuleOverlap
	 * 		Flags  -> (Final, Native, Protected, HasOutParms)
	 * Parameters:
	 * 		class UPrimitiveComponent*                         OverlappedComponent                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      OtherActor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UPrimitiveComponent*                         OtherComp                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            OtherBodyIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bFromSweep                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FHitResult                                  SweepResult                                                (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	void AINSCharacter::OnCapsuleOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32_t OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSCharacter.OnCapsuleOverlap");
		
		AINSCharacter_OnCapsuleOverlap_Params params {};
		params.OverlappedComponent = OverlappedComponent;
		params.OtherActor = OtherActor;
		params.OtherComp = OtherComp;
		params.OtherBodyIndex = OtherBodyIndex;
		params.bFromSweep = bFromSweep;
		params.SweepResult = SweepResult;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056782B0
	 * 		Name   -> Function Insurgency.INSCharacter.OnCapsuleHit
	 * 		Flags  -> (Final, Native, Protected, HasOutParms, HasDefaults)
	 * Parameters:
	 * 		class UPrimitiveComponent*                         HitComponent                                               (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      OtherActor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UPrimitiveComponent*                         OtherComp                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     NormalImpulse                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FHitResult                                  Hit                                                        (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	void AINSCharacter::OnCapsuleHit(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, const struct FVector& NormalImpulse, const struct FHitResult& Hit)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSCharacter.OnCapsuleHit");
		
		AINSCharacter_OnCapsuleHit_Params params {};
		params.HitComponent = HitComponent;
		params.OtherActor = OtherActor;
		params.OtherComp = OtherComp;
		params.NormalImpulse = NormalImpulse;
		params.Hit = Hit;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056781E0
	 * 		Name   -> Function Insurgency.INSCharacter.OnAuthoritiveDamageReaction
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		struct FNetHitReaction                             Hit                                                        (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void AINSCharacter::OnAuthoritiveDamageReaction(const struct FNetHitReaction& Hit)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSCharacter.OnAuthoritiveDamageReaction");
		
		AINSCharacter_OnAuthoritiveDamageReaction_Params params {};
		params.Hit = Hit;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05678120
	 * 		Name   -> Function Insurgency.INSCharacter.MulticastResetCharacterAt
	 * 		Flags  -> (Net, NetReliable, Native, Event, NetMulticast, Public)
	 * Parameters:
	 * 		struct FVector_NetQuantize100                      NewLocation                                                (ConstParm, Parm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            ResetId                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSCharacter::MulticastResetCharacterAt(const struct FVector_NetQuantize100& NewLocation, int32_t ResetId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSCharacter.MulticastResetCharacterAt");
		
		AINSCharacter_MulticastResetCharacterAt_Params params {};
		params.NewLocation = NewLocation;
		params.ResetId = ResetId;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056780A0
	 * 		Name   -> Function Insurgency.INSCharacter.MulticastHideCharacter
	 * 		Flags  -> (Net, NetReliable, Native, Event, NetMulticast, Public)
	 * Parameters:
	 * 		int32_t                                            ResetId                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSCharacter::MulticastHideCharacter(int32_t ResetId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSCharacter.MulticastHideCharacter");
		
		AINSCharacter_MulticastHideCharacter_Params params {};
		params.ResetId = ResetId;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05677FE0
	 * 		Name   -> Function Insurgency.INSCharacter.MulticastAuthoritiveDamageReaction
	 * 		Flags  -> (Net, NetReliable, Native, Event, NetMulticast, Public)
	 * Parameters:
	 * 		struct FNetHitReaction                             Hit                                                        (ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void AINSCharacter::MulticastAuthoritiveDamageReaction(const struct FNetHitReaction& Hit)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSCharacter.MulticastAuthoritiveDamageReaction");
		
		AINSCharacter_MulticastAuthoritiveDamageReaction_Params params {};
		params.Hit = Hit;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05677FB0
	 * 		Name   -> Function Insurgency.INSCharacter.IsAIControlled
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AINSCharacter::IsAIControlled()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSCharacter.IsAIControlled");
		
		AINSCharacter_IsAIControlled_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05677F30
	 * 		Name   -> Function Insurgency.INSCharacter.Ignite
	 * 		Flags  -> (Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		float                                              Duration                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSCharacter::Ignite(float Duration)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSCharacter.Ignite");
		
		AINSCharacter_Ignite_Params params {};
		params.Duration = Duration;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05677EA0
	 * 		Name   -> Function Insurgency.INSCharacter.HasRecentlySpawned
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		float                                              Threshold                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool AINSCharacter::HasRecentlySpawned(float Threshold)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSCharacter.HasRecentlySpawned");
		
		AINSCharacter_HasRecentlySpawned_Params params {};
		params.Threshold = Threshold;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05677DA0
	 * 		Name   -> Function Insurgency.INSCharacter.GetVehicleSeatCameraLocation
	 * 		Flags  -> (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		struct FVector                                     OutLocation                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FRotator                                    OutRotation                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	bool AINSCharacter::GetVehicleSeatCameraLocation(struct FVector* OutLocation, struct FRotator* OutRotation)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSCharacter.GetVehicleSeatCameraLocation");
		
		AINSCharacter_GetVehicleSeatCameraLocation_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutLocation != nullptr)
			*OutLocation = params.OutLocation;
		if (OutRotation != nullptr)
			*OutRotation = params.OutRotation;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05677D70
	 * 		Name   -> Function Insurgency.INSCharacter.GetVehicleSeat
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	class UVehicleSeatComponent* AINSCharacter::GetVehicleSeat()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSCharacter.GetVehicleSeat");
		
		AINSCharacter_GetVehicleSeat_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05677D40
	 * 		Name   -> Function Insurgency.INSCharacter.GetTimeSinceSpawn
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	float AINSCharacter::GetTimeSinceSpawn()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSCharacter.GetTimeSinceSpawn");
		
		AINSCharacter_GetTimeSinceSpawn_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05677D10
	 * 		Name   -> Function Insurgency.INSCharacter.GetSignificanceLevel
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	unsigned char AINSCharacter::GetSignificanceLevel()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSCharacter.GetSignificanceLevel");
		
		AINSCharacter_GetSignificanceLevel_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05677CD0
	 * 		Name   -> Function Insurgency.INSCharacter.GetRepresentativeRotation
	 * 		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
	 */
	struct FRotator AINSCharacter::GetRepresentativeRotation()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSCharacter.GetRepresentativeRotation");
		
		AINSCharacter_GetRepresentativeRotation_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05677CA0
	 * 		Name   -> Function Insurgency.INSCharacter.GetCharacterMeshLOD
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
	 */
	int32_t AINSCharacter::GetCharacterMeshLOD()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSCharacter.GetCharacterMeshLOD");
		
		AINSCharacter_GetCharacterMeshLOD_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05677A70
	 * 		Name   -> Function Insurgency.INSCharacter.DoBloodSplatterEffect
	 * 		Flags  -> (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FVector                                     DecalPosition                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FRotator                                    DecalRotation                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		class USceneComponent*                             AttachComponent                                            (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EPhysicalSurface                                   PhysicalSurface                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EBloodSplatterType                                 BloodSplatterType                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bKillShot                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bBroadcast                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSCharacter::DoBloodSplatterEffect(const struct FVector& DecalPosition, const struct FRotator& DecalRotation, class USceneComponent* AttachComponent, EPhysicalSurface PhysicalSurface, EBloodSplatterType BloodSplatterType, bool bKillShot, bool bBroadcast)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSCharacter.DoBloodSplatterEffect");
		
		AINSCharacter_DoBloodSplatterEffect_Params params {};
		params.DecalPosition = DecalPosition;
		params.DecalRotation = DecalRotation;
		params.AttachComponent = AttachComponent;
		params.PhysicalSurface = PhysicalSurface;
		params.BloodSplatterType = BloodSplatterType;
		params.bKillShot = bKillShot;
		params.bBroadcast = bBroadcast;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05677990
	 * 		Name   -> Function Insurgency.INSCharacter.CalcGenericDamageVelocityModifier
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		float                                              Damage                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FName                                        HitBone                                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	float AINSCharacter::CalcGenericDamageVelocityModifier(float Damage, const class FName& HitBone)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSCharacter.CalcGenericDamageVelocityModifier");
		
		AINSCharacter_CalcGenericDamageVelocityModifier_Params params {};
		params.Damage = Damage;
		params.HitBone = HitBone;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05677850
	 * 		Name   -> Function Insurgency.INSCharacter.CalcDamageVelocityModifier
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		float                                              Damage                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FDamageEvent                                DamageEvent                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		class FName                                        HitBone                                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	float AINSCharacter::CalcDamageVelocityModifier(float Damage, const struct FDamageEvent& DamageEvent, const class FName& HitBone)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSCharacter.CalcDamageVelocityModifier");
		
		AINSCharacter_CalcDamageVelocityModifier_Params params {};
		params.Damage = Damage;
		params.DamageEvent = DamageEvent;
		params.HitBone = HitBone;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05677730
	 * 		Name   -> Function Insurgency.INSCharacter.BroadcastSurfaceHitReaction
	 * 		Flags  -> (Net, Native, Event, NetMulticast, Public)
	 * Parameters:
	 * 		class USurfaceReaction*                            SurfaceReaction                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FHitResult                                  Hit                                                        (ConstParm, Parm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	void AINSCharacter::BroadcastSurfaceHitReaction(class USurfaceReaction* SurfaceReaction, const struct FHitResult& Hit)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSCharacter.BroadcastSurfaceHitReaction");
		
		AINSCharacter_BroadcastSurfaceHitReaction_Params params {};
		params.SurfaceReaction = SurfaceReaction;
		params.Hit = Hit;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05677550
	 * 		Name   -> Function Insurgency.INSCharacter.BroadcastDeath
	 * 		Flags  -> (Net, NetReliable, Native, Event, NetMulticast, Public, HasDefaults)
	 * Parameters:
	 * 		float                                              KillingDamage                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UClass*                                      DamageType                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     HitPosition                                                (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     DamageForce                                                (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AController*                                 Killer                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      DamageCauser                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSCharacter::BroadcastDeath(float KillingDamage, class UClass* DamageType, const struct FVector& HitPosition, const struct FVector& DamageForce, class AController* Killer, class AActor* DamageCauser)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSCharacter.BroadcastDeath");
		
		AINSCharacter_BroadcastDeath_Params params {};
		params.KillingDamage = KillingDamage;
		params.DamageType = DamageType;
		params.HitPosition = HitPosition;
		params.DamageForce = DamageForce;
		params.Killer = Killer;
		params.DamageCauser = DamageCauser;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05677370
	 * 		Name   -> Function Insurgency.INSCharacter.BroadcastBloodSplatterEffect
	 * 		Flags  -> (Net, NetReliable, Native, Event, NetMulticast, Public, HasDefaults)
	 * Parameters:
	 * 		struct FVector                                     DecalPosition                                              (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FRotator                                    DecalRotation                                              (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		class USceneComponent*                             AttachComponent                                            (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EPhysicalSurface                                   PhysicalSurface                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EBloodSplatterType                                 BloodSplatterType                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bKillShot                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSCharacter::BroadcastBloodSplatterEffect(const struct FVector& DecalPosition, const struct FRotator& DecalRotation, class USceneComponent* AttachComponent, EPhysicalSurface PhysicalSurface, EBloodSplatterType BloodSplatterType, bool bKillShot)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSCharacter.BroadcastBloodSplatterEffect");
		
		AINSCharacter_BroadcastBloodSplatterEffect_Params params {};
		params.DecalPosition = DecalPosition;
		params.DecalRotation = DecalRotation;
		params.AttachComponent = AttachComponent;
		params.PhysicalSurface = PhysicalSurface;
		params.BloodSplatterType = BloodSplatterType;
		params.bKillShot = bKillShot;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AINSCharacter.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AINSCharacter::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.INSCharacter");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AFireSupportCharacter.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AFireSupportCharacter::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.FireSupportCharacter");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056566C0
	 * 		Name   -> Function Insurgency.FireSupportHoveringVehicle.UpdateKillDialogue
	 * 		Flags  -> (Final, Native, Private)
	 */
	void AFireSupportHoveringVehicle::UpdateKillDialogue()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.FireSupportHoveringVehicle.UpdateKillDialogue");
		
		AFireSupportHoveringVehicle_UpdateKillDialogue_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056566A0
	 * 		Name   -> Function Insurgency.FireSupportHoveringVehicle.PlayTakingFireDialogue
	 * 		Flags  -> (Final, Native, Private)
	 */
	void AFireSupportHoveringVehicle::PlayTakingFireDialogue()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.FireSupportHoveringVehicle.PlayTakingFireDialogue");
		
		AFireSupportHoveringVehicle_PlayTakingFireDialogue_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05656680
	 * 		Name   -> Function Insurgency.FireSupportHoveringVehicle.PlayTakingDamageDialogue
	 * 		Flags  -> (Final, Native, Private)
	 */
	void AFireSupportHoveringVehicle::PlayTakingDamageDialogue()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.FireSupportHoveringVehicle.PlayTakingDamageDialogue");
		
		AFireSupportHoveringVehicle_PlayTakingDamageDialogue_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05656660
	 * 		Name   -> Function Insurgency.FireSupportHoveringVehicle.PlayFallingDialogue
	 * 		Flags  -> (Final, Native, Private)
	 */
	void AFireSupportHoveringVehicle::PlayFallingDialogue()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.FireSupportHoveringVehicle.PlayFallingDialogue");
		
		AFireSupportHoveringVehicle_PlayFallingDialogue_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> Function Insurgency.FireSupportHoveringVehicle.OnWeaponFired
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		class AVehicleHoveringBase*                        HoveringVehicle                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AItemFirearm*                                Weapon                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AFireSupportHoveringVehicle::OnWeaponFired(class AVehicleHoveringBase* HoveringVehicle, class AItemFirearm* Weapon)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.FireSupportHoveringVehicle.OnWeaponFired");
		
		AFireSupportHoveringVehicle_OnWeaponFired_Params params {};
		params.HoveringVehicle = HoveringVehicle;
		params.Weapon = Weapon;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056564D0
	 * 		Name   -> Function Insurgency.FireSupportHoveringVehicle.OnVehicleTakeAnyDamage
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		class AActor*                                      DamagedActor                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Damage                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UDamageType*                                 DamageType                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AController*                                 InstigatedBy                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      DamageCauser                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AFireSupportHoveringVehicle::OnVehicleTakeAnyDamage(class AActor* DamagedActor, float Damage, class UDamageType* DamageType, class AController* InstigatedBy, class AActor* DamageCauser)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.FireSupportHoveringVehicle.OnVehicleTakeAnyDamage");
		
		AFireSupportHoveringVehicle_OnVehicleTakeAnyDamage_Params params {};
		params.DamagedActor = DamagedActor;
		params.Damage = Damage;
		params.DamageType = DamageType;
		params.InstigatedBy = InstigatedBy;
		params.DamageCauser = DamageCauser;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05656450
	 * 		Name   -> Function Insurgency.FireSupportHoveringVehicle.OnTryDodge
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		class AVehicleHoveringBase*                        HoveringVehicle                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AFireSupportHoveringVehicle::OnTryDodge(class AVehicleHoveringBase* HoveringVehicle)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.FireSupportHoveringVehicle.OnTryDodge");
		
		AFireSupportHoveringVehicle_OnTryDodge_Params params {};
		params.HoveringVehicle = HoveringVehicle;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056563D0
	 * 		Name   -> Function Insurgency.FireSupportHoveringVehicle.OnStartFalling
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		class AVehicleHoveringBase*                        HoveringVehicle                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AFireSupportHoveringVehicle::OnStartFalling(class AVehicleHoveringBase* HoveringVehicle)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.FireSupportHoveringVehicle.OnStartFalling");
		
		AFireSupportHoveringVehicle_OnStartFalling_Params params {};
		params.HoveringVehicle = HoveringVehicle;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05656300
	 * 		Name   -> Function Insurgency.FireSupportHoveringVehicle.OnPartDamaged
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		class UVehiclePartComponent*                       Part                                                       (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Damage                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AFireSupportHoveringVehicle::OnPartDamaged(class UVehiclePartComponent* Part, float Damage)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.FireSupportHoveringVehicle.OnPartDamaged");
		
		AFireSupportHoveringVehicle_OnPartDamaged_Params params {};
		params.Part = Part;
		params.Damage = Damage;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05656240
	 * 		Name   -> Function Insurgency.FireSupportHoveringVehicle.OnLostPassenger
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		class AVehicleHoveringBase*                        HoveringVehicle                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UVehicleSeatComponent*                       Seat                                                       (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AFireSupportHoveringVehicle::OnLostPassenger(class AVehicleHoveringBase* HoveringVehicle, class UVehicleSeatComponent* Seat)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.FireSupportHoveringVehicle.OnLostPassenger");
		
		AFireSupportHoveringVehicle_OnLostPassenger_Params params {};
		params.HoveringVehicle = HoveringVehicle;
		params.Seat = Seat;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056561C0
	 * 		Name   -> Function Insurgency.FireSupportHoveringVehicle.OnImminentImpact
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		class AVehicleHoveringBase*                        HoveringVehicle                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AFireSupportHoveringVehicle::OnImminentImpact(class AVehicleHoveringBase* HoveringVehicle)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.FireSupportHoveringVehicle.OnImminentImpact");
		
		AFireSupportHoveringVehicle_OnImminentImpact_Params params {};
		params.HoveringVehicle = HoveringVehicle;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05656140
	 * 		Name   -> Function Insurgency.FireSupportHoveringVehicle.OnFireSupportKillsEnemy
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		class AFireSupportBase*                            FireSupport                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AFireSupportHoveringVehicle::OnFireSupportKillsEnemy(class AFireSupportBase* FireSupport)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.FireSupportHoveringVehicle.OnFireSupportKillsEnemy");
		
		AFireSupportHoveringVehicle_OnFireSupportKillsEnemy_Params params {};
		params.FireSupport = FireSupport;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056560C0
	 * 		Name   -> Function Insurgency.FireSupportHoveringVehicle.OnFinishDodge
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		class AVehicleHoveringBase*                        HoveringVehicle                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AFireSupportHoveringVehicle::OnFinishDodge(class AVehicleHoveringBase* HoveringVehicle)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.FireSupportHoveringVehicle.OnFinishDodge");
		
		AFireSupportHoveringVehicle_OnFinishDodge_Params params {};
		params.HoveringVehicle = HoveringVehicle;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05656040
	 * 		Name   -> Function Insurgency.FireSupportHoveringVehicle.OnCrashImpact
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		class AVehicleHoveringBase*                        HoveringVehicle                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AFireSupportHoveringVehicle::OnCrashImpact(class AVehicleHoveringBase* HoveringVehicle)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.FireSupportHoveringVehicle.OnCrashImpact");
		
		AFireSupportHoveringVehicle_OnCrashImpact_Params params {};
		params.HoveringVehicle = HoveringVehicle;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05655FC0
	 * 		Name   -> Function Insurgency.FireSupportHoveringVehicle.OnArriving
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		class AVehicleHoveringBase*                        HoveringVehicle                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AFireSupportHoveringVehicle::OnArriving(class AVehicleHoveringBase* HoveringVehicle)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.FireSupportHoveringVehicle.OnArriving");
		
		AFireSupportHoveringVehicle_OnArriving_Params params {};
		params.HoveringVehicle = HoveringVehicle;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05655F90
	 * 		Name   -> Function Insurgency.FireSupportHoveringVehicle.CanPlayCrewDialogue
	 * 		Flags  -> (Final, Native, Private, BlueprintCallable, BlueprintPure)
	 */
	bool AFireSupportHoveringVehicle::CanPlayCrewDialogue()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.FireSupportHoveringVehicle.CanPlayCrewDialogue");
		
		AFireSupportHoveringVehicle_CanPlayCrewDialogue_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> Function Insurgency.FireSupportHoveringVehicle.BlueprintOnLeaving
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 */
	void AFireSupportHoveringVehicle::BlueprintOnLeaving()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.FireSupportHoveringVehicle.BlueprintOnLeaving");
		
		AFireSupportHoveringVehicle_BlueprintOnLeaving_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> Function Insurgency.FireSupportHoveringVehicle.BlueprintOnArriving
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		class AVehicleHoveringBase*                        HoveringVehicle                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AFireSupportHoveringVehicle::BlueprintOnArriving(class AVehicleHoveringBase* HoveringVehicle)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.FireSupportHoveringVehicle.BlueprintOnArriving");
		
		AFireSupportHoveringVehicle_BlueprintOnArriving_Params params {};
		params.HoveringVehicle = HoveringVehicle;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AFireSupportHoveringVehicle.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AFireSupportHoveringVehicle::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.FireSupportHoveringVehicle");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056568B0
	 * 		Name   -> Function Insurgency.FireSupportOwnerInterface.GetFireSupportActor
	 * 		Flags  -> (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
	 */
	class AFireSupportBase* UFireSupportOwnerInterface::GetFireSupportActor()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.FireSupportOwnerInterface.GetFireSupportActor");
		
		UFireSupportOwnerInterface_GetFireSupportActor_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UFireSupportOwnerInterface.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UFireSupportOwnerInterface::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.FireSupportOwnerInterface");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05656D40
	 * 		Name   -> Function Insurgency.FireVolume.OnOverlapEnd
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		class AActor*                                      OverlappedActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      OtherActor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AFireVolume::OnOverlapEnd(class AActor* OverlappedActor, class AActor* OtherActor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.FireVolume.OnOverlapEnd");
		
		AFireVolume_OnOverlapEnd_Params params {};
		params.OverlappedActor = OverlappedActor;
		params.OtherActor = OtherActor;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05656C80
	 * 		Name   -> Function Insurgency.FireVolume.OnOverlapBegin
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		class AActor*                                      OverlappedActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      OtherActor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AFireVolume::OnOverlapBegin(class AActor* OverlappedActor, class AActor* OtherActor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.FireVolume.OnOverlapBegin");
		
		AFireVolume_OnOverlapBegin_Params params {};
		params.OverlappedActor = OverlappedActor;
		params.OtherActor = OtherActor;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AFireVolume.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AFireVolume::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.FireVolume");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UFirstPersonAnimInstance.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UFirstPersonAnimInstance::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.FirstPersonAnimInstance");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056577A0
	 * 		Name   -> Function Insurgency.FloatingHintTextContainer.UpdateSupplyCrateHintLocation
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void UFloatingHintTextContainer::UpdateSupplyCrateHintLocation()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.FloatingHintTextContainer.UpdateSupplyCrateHintLocation");
		
		UFloatingHintTextContainer_UpdateSupplyCrateHintLocation_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05657780
	 * 		Name   -> Function Insurgency.FloatingHintTextContainer.UpdateSupplyCrateHint
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void UFloatingHintTextContainer::UpdateSupplyCrateHint()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.FloatingHintTextContainer.UpdateSupplyCrateHint");
		
		UFloatingHintTextContainer_UpdateSupplyCrateHint_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05657760
	 * 		Name   -> Function Insurgency.FloatingHintTextContainer.UpdateShowKeyHints
	 * 		Flags  -> (Final, Native, Private)
	 */
	void UFloatingHintTextContainer::UpdateShowKeyHints()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.FloatingHintTextContainer.UpdateShowKeyHints");
		
		UFloatingHintTextContainer_UpdateShowKeyHints_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05657740
	 * 		Name   -> Function Insurgency.FloatingHintTextContainer.UpdatePointsOfInterest
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void UFloatingHintTextContainer::UpdatePointsOfInterest()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.FloatingHintTextContainer.UpdatePointsOfInterest");
		
		UFloatingHintTextContainer_UpdatePointsOfInterest_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05657720
	 * 		Name   -> Function Insurgency.FloatingHintTextContainer.UpdateHints
	 * 		Flags  -> (Final, Native, Protected, BlueprintCallable)
	 */
	void UFloatingHintTextContainer::UpdateHints()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.FloatingHintTextContainer.UpdateHints");
		
		UFloatingHintTextContainer_UpdateHints_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05657600
	 * 		Name   -> Function Insurgency.FloatingHintTextContainer.UpdateDynamicHintLocation
	 * 		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FVector                                     ObjPos                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bIsUsableObject                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bIsVaulting                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UFloatingHintTextContainer::UpdateDynamicHintLocation(const struct FVector& ObjPos, bool bIsUsableObject, bool bIsVaulting)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.FloatingHintTextContainer.UpdateDynamicHintLocation");
		
		UFloatingHintTextContainer_UpdateDynamicHintLocation_Params params {};
		params.ObjPos = ObjPos;
		params.bIsUsableObject = bIsUsableObject;
		params.bIsVaulting = bIsVaulting;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056575E0
	 * 		Name   -> Function Insurgency.FloatingHintTextContainer.HidePointsOfInterest
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void UFloatingHintTextContainer::HidePointsOfInterest()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.FloatingHintTextContainer.HidePointsOfInterest");
		
		UFloatingHintTextContainer_HidePointsOfInterest_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05657420
	 * 		Name   -> Function Insurgency.FloatingHintTextContainer.GetDynamicHintLocationForUseObject
	 * 		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		class AActor*                                      UseObject                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AINSSoldier*                                 Soldier                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FHitResult                                  UseHitResult                                               (Parm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	struct FVector UFloatingHintTextContainer::GetDynamicHintLocationForUseObject(class AActor* UseObject, class AINSSoldier* Soldier, const struct FHitResult& UseHitResult)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.FloatingHintTextContainer.GetDynamicHintLocationForUseObject");
		
		UFloatingHintTextContainer_GetDynamicHintLocationForUseObject_Params params {};
		params.UseObject = UseObject;
		params.Soldier = Soldier;
		params.UseHitResult = UseHitResult;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05657380
	 * 		Name   -> Function Insurgency.FloatingHintTextContainer.GetDriverIconAndLocation
	 * 		Flags  -> (Final, Native, Protected, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FVector                                     Location                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UTexture2D* UFloatingHintTextContainer::GetDriverIconAndLocation(struct FVector* Location)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.FloatingHintTextContainer.GetDriverIconAndLocation");
		
		UFloatingHintTextContainer_GetDriverIconAndLocation_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (Location != nullptr)
			*Location = params.Location;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056572C0
	 * 		Name   -> Function Insurgency.FloatingHintTextContainer.FindUseActor
	 * 		Flags  -> (Final, Native, Protected, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		TArray<struct FUsableActor>                        OutUsableActors                                            (Parm, OutParm, ZeroConstructor, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UFloatingHintTextContainer::FindUseActor(TArray<struct FUsableActor>* OutUsableActors)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.FloatingHintTextContainer.FindUseActor");
		
		UFloatingHintTextContainer_FindUseActor_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutUsableActors != nullptr)
			*OutUsableActors = params.OutUsableActors;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UFloatingHintTextContainer.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UFloatingHintTextContainer::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.FloatingHintTextContainer");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05657A50
	 * 		Name   -> Function Insurgency.FloatingObjectiveContainer.UpdateObjectiveIcons
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void UFloatingObjectiveContainer::UpdateObjectiveIcons()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.FloatingObjectiveContainer.UpdateObjectiveIcons");
		
		UFloatingObjectiveContainer_UpdateObjectiveIcons_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056579C0
	 * 		Name   -> Function Insurgency.FloatingObjectiveContainer.ShouldObjectiveBeVisible
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		class AObjectiveBase*                              Objective                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UFloatingObjectiveContainer::ShouldObjectiveBeVisible(class AObjectiveBase* Objective)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.FloatingObjectiveContainer.ShouldObjectiveBeVisible");
		
		UFloatingObjectiveContainer_ShouldObjectiveBeVisible_Params params {};
		params.Objective = Objective;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056579A0
	 * 		Name   -> Function Insurgency.FloatingObjectiveContainer.PopulateObjectiveIcons
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void UFloatingObjectiveContainer::PopulateObjectiveIcons()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.FloatingObjectiveContainer.PopulateObjectiveIcons");
		
		UFloatingObjectiveContainer_PopulateObjectiveIcons_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UFloatingObjectiveContainer.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UFloatingObjectiveContainer::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.FloatingObjectiveContainer");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05657CC0
	 * 		Name   -> Function Insurgency.FloatingPointOfInterestWidget.SetPointOfInterest
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UPointOfInterestActorComponent*              InPointOfInterest                                          (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UFloatingPointOfInterestWidget::SetPointOfInterest(class UPointOfInterestActorComponent* InPointOfInterest)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.FloatingPointOfInterestWidget.SetPointOfInterest");
		
		UFloatingPointOfInterestWidget_SetPointOfInterest_Params params {};
		params.InPointOfInterest = InPointOfInterest;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> Function Insurgency.FloatingPointOfInterestWidget.OnSetPointOfInterest
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		class UPointOfInterestActorComponent*              InPointOfInterest                                          (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UFloatingPointOfInterestWidget::OnSetPointOfInterest(class UPointOfInterestActorComponent* InPointOfInterest)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.FloatingPointOfInterestWidget.OnSetPointOfInterest");
		
		UFloatingPointOfInterestWidget_OnSetPointOfInterest_Params params {};
		params.InPointOfInterest = InPointOfInterest;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05657C90
	 * 		Name   -> Function Insurgency.FloatingPointOfInterestWidget.GetPointOfInterestActor
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	class AActor* UFloatingPointOfInterestWidget::GetPointOfInterestActor()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.FloatingPointOfInterestWidget.GetPointOfInterestActor");
		
		UFloatingPointOfInterestWidget_GetPointOfInterestActor_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UFloatingPointOfInterestWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UFloatingPointOfInterestWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.FloatingPointOfInterestWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05658160
	 * 		Name   -> Function Insurgency.FoliageInteractionComponent.OnInteractionEndOverlap
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		class UPrimitiveComponent*                         OverlappedComponent                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      OtherActor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UPrimitiveComponent*                         OtherComp                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            OtherBodyIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UFoliageInteractionComponent::OnInteractionEndOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32_t OtherBodyIndex)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.FoliageInteractionComponent.OnInteractionEndOverlap");
		
		UFoliageInteractionComponent_OnInteractionEndOverlap_Params params {};
		params.OverlappedComponent = OverlappedComponent;
		params.OtherActor = OtherActor;
		params.OtherComp = OtherComp;
		params.OtherBodyIndex = OtherBodyIndex;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05657F50
	 * 		Name   -> Function Insurgency.FoliageInteractionComponent.OnInteractionBeginOverlap
	 * 		Flags  -> (Final, Native, Public, HasOutParms)
	 * Parameters:
	 * 		class UPrimitiveComponent*                         OverlappedComponent                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      OtherActor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UPrimitiveComponent*                         OtherComp                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            OtherBodyIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bFromSweep                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FHitResult                                  SweepResult                                                (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	void UFoliageInteractionComponent::OnInteractionBeginOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32_t OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.FoliageInteractionComponent.OnInteractionBeginOverlap");
		
		UFoliageInteractionComponent_OnInteractionBeginOverlap_Params params {};
		params.OverlappedComponent = OverlappedComponent;
		params.OtherActor = OtherActor;
		params.OtherComp = OtherComp;
		params.OtherBodyIndex = OtherBodyIndex;
		params.bFromSweep = bFromSweep;
		params.SweepResult = SweepResult;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UFoliageInteractionComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UFoliageInteractionComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.FoliageInteractionComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AFoliageInteractionManager.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AFoliageInteractionManager::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.FoliageInteractionManager");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05757AF0
	 * 		Name   -> Function Insurgency.WeaponUpgradeComponent.PlaySoundEventPair
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		struct FAkComponentCameraPair                      AudioEvent                                                 (Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UWeaponUpgradeComponent::PlaySoundEventPair(struct FAkComponentCameraPair* AudioEvent)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.WeaponUpgradeComponent.PlaySoundEventPair");
		
		UWeaponUpgradeComponent_PlaySoundEventPair_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (AudioEvent != nullptr)
			*AudioEvent = params.AudioEvent;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05757A30
	 * 		Name   -> Function Insurgency.WeaponUpgradeComponent.PlaySoundEventFromView
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UAkAudioEvent*                               FirstPersonEvent                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UAkAudioEvent*                               ThirdPersonEvent                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UWeaponUpgradeComponent::PlaySoundEventFromView(class UAkAudioEvent* FirstPersonEvent, class UAkAudioEvent* ThirdPersonEvent)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.WeaponUpgradeComponent.PlaySoundEventFromView");
		
		UWeaponUpgradeComponent_PlaySoundEventFromView_Params params {};
		params.FirstPersonEvent = FirstPersonEvent;
		params.ThirdPersonEvent = ThirdPersonEvent;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05757960
	 * 		Name   -> Function Insurgency.WeaponUpgradeComponent.PlaySoundEvent
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UAkAudioEvent*                               Event                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bApplySpeedOfSound                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UWeaponUpgradeComponent::PlaySoundEvent(class UAkAudioEvent* Event, bool bApplySpeedOfSound)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.WeaponUpgradeComponent.PlaySoundEvent");
		
		UWeaponUpgradeComponent_PlaySoundEvent_Params params {};
		params.Event = Event;
		params.bApplySpeedOfSound = bApplySpeedOfSound;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> DelegateFunction Insurgency.WeaponUpgradeComponent.OnUpgradeStateChangedDelegate__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 * Parameters:
	 * 		class UWeaponUpgradeComponent*                     Upgrade                                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UWeaponUpgradeComponent::OnUpgradeStateChangedDelegate__DelegateSignature(class UWeaponUpgradeComponent* Upgrade)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction Insurgency.WeaponUpgradeComponent.OnUpgradeStateChangedDelegate__DelegateSignature");
		
		UWeaponUpgradeComponent_OnUpgradeStateChangedDelegate__DelegateSignature_Params params {};
		params.Upgrade = Upgrade;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x04DD0000
	 * 		Name   -> Function Insurgency.WeaponUpgradeComponent.OnUpgradeStateChanged
	 * 		Flags  -> (Native, Event, Public, BlueprintCallable, BlueprintEvent)
	 */
	void UWeaponUpgradeComponent::OnUpgradeStateChanged()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.WeaponUpgradeComponent.OnUpgradeStateChanged");
		
		UWeaponUpgradeComponent_OnUpgradeStateChanged_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056EC190
	 * 		Name   -> Function Insurgency.WeaponUpgradeComponent.IsToggled
	 * 		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure)
	 */
	bool UWeaponUpgradeComponent::IsToggled()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.WeaponUpgradeComponent.IsToggled");
		
		UWeaponUpgradeComponent_IsToggled_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05757930
	 * 		Name   -> Function Insurgency.WeaponUpgradeComponent.IsOwnerLocallyControlled
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool UWeaponUpgradeComponent::IsOwnerLocallyControlled()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.WeaponUpgradeComponent.IsOwnerLocallyControlled");
		
		UWeaponUpgradeComponent_IsOwnerLocallyControlled_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05757900
	 * 		Name   -> Function Insurgency.WeaponUpgradeComponent.GetOwningSoldier
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	class AINSSoldier* UWeaponUpgradeComponent::GetOwningSoldier()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.WeaponUpgradeComponent.GetOwningSoldier");
		
		UWeaponUpgradeComponent_GetOwningSoldier_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05757860
	 * 		Name   -> Function Insurgency.WeaponUpgradeComponent.GetActiveOwningWeaponOrAttached
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		bool                                               bReturnOwnerIfInactive                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class AItemWeapon* UWeaponUpgradeComponent::GetActiveOwningWeaponOrAttached(bool bReturnOwnerIfInactive)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.WeaponUpgradeComponent.GetActiveOwningWeaponOrAttached");
		
		UWeaponUpgradeComponent_GetActiveOwningWeaponOrAttached_Params params {};
		params.bReturnOwnerIfInactive = bReturnOwnerIfInactive;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x057577C0
	 * 		Name   -> Function Insurgency.WeaponUpgradeComponent.ConflictsWith
	 * 		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		class UWeaponUpgradeComponent*                     Other                                                      (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UWeaponUpgradeComponent::ConflictsWith(class UWeaponUpgradeComponent* Other)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.WeaponUpgradeComponent.ConflictsWith");
		
		UWeaponUpgradeComponent_ConflictsWith_Params params {};
		params.Other = Other;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05757790
	 * 		Name   -> Function Insurgency.WeaponUpgradeComponent.CanShowCosmeticEffects
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool UWeaponUpgradeComponent::CanShowCosmeticEffects()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.WeaponUpgradeComponent.CanShowCosmeticEffects");
		
		UWeaponUpgradeComponent_CanShowCosmeticEffects_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> Function Insurgency.WeaponUpgradeComponent.BlueprintOnUpgradeRemoved
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 */
	void UWeaponUpgradeComponent::BlueprintOnUpgradeRemoved()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.WeaponUpgradeComponent.BlueprintOnUpgradeRemoved");
		
		UWeaponUpgradeComponent_BlueprintOnUpgradeRemoved_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> Function Insurgency.WeaponUpgradeComponent.BlueprintOnUpgradeInstalled
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 */
	void UWeaponUpgradeComponent::BlueprintOnUpgradeInstalled()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.WeaponUpgradeComponent.BlueprintOnUpgradeInstalled");
		
		UWeaponUpgradeComponent_BlueprintOnUpgradeInstalled_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> Function Insurgency.WeaponUpgradeComponent.BlueprintOnUpgradeInit
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 */
	void UWeaponUpgradeComponent::BlueprintOnUpgradeInit()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.WeaponUpgradeComponent.BlueprintOnUpgradeInit");
		
		UWeaponUpgradeComponent_BlueprintOnUpgradeInit_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UWeaponUpgradeComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UWeaponUpgradeComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.WeaponUpgradeComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05758240
	 * 		Name   -> Function Insurgency.WeaponVisualUpgradeComponent.OnSpawnedThirdPersonMesh
	 * 		Flags  -> (Native, Public)
	 * Parameters:
	 * 		class UINSSkeletalMeshComponent*                   SpawnedMesh                                                (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bCheckAllLoaded                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UWeaponVisualUpgradeComponent::OnSpawnedThirdPersonMesh(class UINSSkeletalMeshComponent* SpawnedMesh, bool bCheckAllLoaded)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.WeaponVisualUpgradeComponent.OnSpawnedThirdPersonMesh");
		
		UWeaponVisualUpgradeComponent_OnSpawnedThirdPersonMesh_Params params {};
		params.SpawnedMesh = SpawnedMesh;
		params.bCheckAllLoaded = bCheckAllLoaded;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05758170
	 * 		Name   -> Function Insurgency.WeaponVisualUpgradeComponent.OnSpawnedFirstPersonMesh
	 * 		Flags  -> (Native, Public)
	 * Parameters:
	 * 		class UINSSkeletalMeshComponent*                   SpawnedMesh                                                (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bCheckAllLoaded                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UWeaponVisualUpgradeComponent::OnSpawnedFirstPersonMesh(class UINSSkeletalMeshComponent* SpawnedMesh, bool bCheckAllLoaded)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.WeaponVisualUpgradeComponent.OnSpawnedFirstPersonMesh");
		
		UWeaponVisualUpgradeComponent_OnSpawnedFirstPersonMesh_Params params {};
		params.SpawnedMesh = SpawnedMesh;
		params.bCheckAllLoaded = bCheckAllLoaded;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05758140
	 * 		Name   -> Function Insurgency.WeaponVisualUpgradeComponent.AreAllThirdPersonMeshesLoaded
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool UWeaponVisualUpgradeComponent::AreAllThirdPersonMeshesLoaded()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.WeaponVisualUpgradeComponent.AreAllThirdPersonMeshesLoaded");
		
		UWeaponVisualUpgradeComponent_AreAllThirdPersonMeshesLoaded_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05758110
	 * 		Name   -> Function Insurgency.WeaponVisualUpgradeComponent.AreAllFirstPersonMeshesLoaded
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool UWeaponVisualUpgradeComponent::AreAllFirstPersonMeshesLoaded()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.WeaponVisualUpgradeComponent.AreAllFirstPersonMeshesLoaded");
		
		UWeaponVisualUpgradeComponent_AreAllFirstPersonMeshesLoaded_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UWeaponVisualUpgradeComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UWeaponVisualUpgradeComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.WeaponVisualUpgradeComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0574E300
	 * 		Name   -> Function Insurgency.WeaponLightComponent.UpdateLightLocation
	 * 		Flags  -> (Final, Native, Public)
	 */
	void UWeaponLightComponent::UpdateLightLocation()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.WeaponLightComponent.UpdateLightLocation");
		
		UWeaponLightComponent_UpdateLightLocation_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0574E2E0
	 * 		Name   -> Function Insurgency.WeaponLightComponent.UpdateLaserBeam
	 * 		Flags  -> (Final, Native, Public)
	 */
	void UWeaponLightComponent::UpdateLaserBeam()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.WeaponLightComponent.UpdateLaserBeam");
		
		UWeaponLightComponent_UpdateLaserBeam_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0574E2C0
	 * 		Name   -> Function Insurgency.WeaponLightComponent.UpdateBlindingParticle
	 * 		Flags  -> (Final, Native, Public)
	 */
	void UWeaponLightComponent::UpdateBlindingParticle()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.WeaponLightComponent.UpdateBlindingParticle");
		
		UWeaponLightComponent_UpdateBlindingParticle_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0574E2A0
	 * 		Name   -> Function Insurgency.WeaponLightComponent.UpdateBeam
	 * 		Flags  -> (Final, Native, Public)
	 */
	void UWeaponLightComponent::UpdateBeam()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.WeaponLightComponent.UpdateBeam");
		
		UWeaponLightComponent_UpdateBeam_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0574E1E0
	 * 		Name   -> Function Insurgency.WeaponLightComponent.StartTraceTask
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		float                                              Interval                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		ECollisionChannel                                  Channel                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UWeaponLightComponent::StartTraceTask(float Interval, ECollisionChannel Channel)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.WeaponLightComponent.StartTraceTask");
		
		UWeaponLightComponent_StartTraceTask_Params params {};
		params.Interval = Interval;
		params.Channel = Channel;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0574E1B0
	 * 		Name   -> Function Insurgency.WeaponLightComponent.ShouldEnterPointShootMode
	 * 		Flags  -> (Final, Native, Public, Const)
	 */
	bool UWeaponLightComponent::ShouldEnterPointShootMode()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.WeaponLightComponent.ShouldEnterPointShootMode");
		
		UWeaponLightComponent_ShouldEnterPointShootMode_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0574E0E0
	 * 		Name   -> Function Insurgency.WeaponLightComponent.SetLightMode
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		EWeaponLightMode                                   Mode                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bFromReplication                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UWeaponLightComponent::SetLightMode(EWeaponLightMode Mode, bool bFromReplication)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.WeaponLightComponent.SetLightMode");
		
		UWeaponLightComponent_SetLightMode_Params params {};
		params.Mode = Mode;
		params.bFromReplication = bFromReplication;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0574E030
	 * 		Name   -> Function Insurgency.WeaponLightComponent.ServerSetLightMode
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
	 * Parameters:
	 * 		EWeaponLightMode                                   Mode                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UWeaponLightComponent::ServerSetLightMode(EWeaponLightMode Mode)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.WeaponLightComponent.ServerSetLightMode");
		
		UWeaponLightComponent_ServerSetLightMode_Params params {};
		params.Mode = Mode;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0574E010
	 * 		Name   -> Function Insurgency.WeaponLightComponent.RecreateEffects
	 * 		Flags  -> (Final, Native, Public)
	 */
	void UWeaponLightComponent::RecreateEffects()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.WeaponLightComponent.RecreateEffects");
		
		UWeaponLightComponent_RecreateEffects_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0574DFF0
	 * 		Name   -> Function Insurgency.WeaponLightComponent.RecreateBeamEffects
	 * 		Flags  -> (Final, Native, Public)
	 */
	void UWeaponLightComponent::RecreateBeamEffects()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.WeaponLightComponent.RecreateBeamEffects");
		
		UWeaponLightComponent_RecreateBeamEffects_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0574DFD0
	 * 		Name   -> Function Insurgency.WeaponLightComponent.OnRep_CurrentLightMode
	 * 		Flags  -> (Final, Native, Public)
	 */
	void UWeaponLightComponent::OnRep_CurrentLightMode()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.WeaponLightComponent.OnRep_CurrentLightMode");
		
		UWeaponLightComponent_OnRep_CurrentLightMode_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0574DFA0
	 * 		Name   -> Function Insurgency.WeaponLightComponent.LocalPlayerCanSeeInfrared
	 * 		Flags  -> (Final, Native, Protected, Const)
	 */
	bool UWeaponLightComponent::LocalPlayerCanSeeInfrared()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.WeaponLightComponent.LocalPlayerCanSeeInfrared");
		
		UWeaponLightComponent_LocalPlayerCanSeeInfrared_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0574DF80
	 * 		Name   -> Function Insurgency.WeaponLightComponent.KillLaserSightEffect
	 * 		Flags  -> (Final, Native, Public)
	 */
	void UWeaponLightComponent::KillLaserSightEffect()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.WeaponLightComponent.KillLaserSightEffect");
		
		UWeaponLightComponent_KillLaserSightEffect_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0574DF60
	 * 		Name   -> Function Insurgency.WeaponLightComponent.KillBlindingEffect
	 * 		Flags  -> (Final, Native, Public)
	 */
	void UWeaponLightComponent::KillBlindingEffect()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.WeaponLightComponent.KillBlindingEffect");
		
		UWeaponLightComponent_KillBlindingEffect_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0574DF40
	 * 		Name   -> Function Insurgency.WeaponLightComponent.KillAnyEffects
	 * 		Flags  -> (Final, Native, Public)
	 */
	void UWeaponLightComponent::KillAnyEffects()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.WeaponLightComponent.KillAnyEffects");
		
		UWeaponLightComponent_KillAnyEffects_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0574DEB0
	 * 		Name   -> Function Insurgency.WeaponLightComponent.HasLightingMode
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		EWeaponLightMode                                   LightMode                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UWeaponLightComponent::HasLightingMode(EWeaponLightMode LightMode)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.WeaponLightComponent.HasLightingMode");
		
		UWeaponLightComponent_HasLightingMode_Params params {};
		params.LightMode = LightMode;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0574DE80
	 * 		Name   -> Function Insurgency.WeaponLightComponent.GetNextLightMode
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	EWeaponLightMode UWeaponLightComponent::GetNextLightMode()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.WeaponLightComponent.GetNextLightMode");
		
		UWeaponLightComponent_GetNextLightMode_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0574DE50
	 * 		Name   -> Function Insurgency.WeaponLightComponent.GetFirstLightMode
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	EWeaponLightMode UWeaponLightComponent::GetFirstLightMode()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.WeaponLightComponent.GetFirstLightMode");
		
		UWeaponLightComponent_GetFirstLightMode_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0574DE30
	 * 		Name   -> Function Insurgency.WeaponLightComponent.CreateLaserSightEffect
	 * 		Flags  -> (Final, Native, Public)
	 */
	void UWeaponLightComponent::CreateLaserSightEffect()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.WeaponLightComponent.CreateLaserSightEffect");
		
		UWeaponLightComponent_CreateLaserSightEffect_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0574DE10
	 * 		Name   -> Function Insurgency.WeaponLightComponent.CalculateLightTargetVisibility
	 * 		Flags  -> (Final, Native, Public)
	 */
	void UWeaponLightComponent::CalculateLightTargetVisibility()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.WeaponLightComponent.CalculateLightTargetVisibility");
		
		UWeaponLightComponent_CalculateLightTargetVisibility_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0574DDF0
	 * 		Name   -> Function Insurgency.WeaponLightComponent.CalculateLightTarget
	 * 		Flags  -> (Final, Native, Public)
	 */
	void UWeaponLightComponent::CalculateLightTarget()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.WeaponLightComponent.CalculateLightTarget");
		
		UWeaponLightComponent_CalculateLightTarget_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UWeaponLightComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UWeaponLightComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.WeaponLightComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UForegripLightcomponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UForegripLightcomponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.ForegripLightcomponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UFriendlyFireMessage.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UFriendlyFireMessage::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.FriendlyFireMessage");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UFriendlyFireReflectMessage.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UFriendlyFireReflectMessage::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.FriendlyFireReflectMessage");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05658AC0
	 * 		Name   -> Function Insurgency.FrontlineWaveDrainWidget.OnWaveDrainUpdated
	 * 		Flags  -> (Final, Native, Private)
	 * Parameters:
	 * 		class AINSFrontlineTeamInfo*                       TeamInfo                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              NewDrainTime                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UFrontlineWaveDrainWidget::OnWaveDrainUpdated(class AINSFrontlineTeamInfo* TeamInfo, float NewDrainTime)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.FrontlineWaveDrainWidget.OnWaveDrainUpdated");
		
		UFrontlineWaveDrainWidget_OnWaveDrainUpdated_Params params {};
		params.TeamInfo = TeamInfo;
		params.NewDrainTime = NewDrainTime;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> Function Insurgency.FrontlineWaveDrainWidget.OnVisibilityUpdated
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		bool                                               bIsVisible                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UFrontlineWaveDrainWidget::OnVisibilityUpdated(bool bIsVisible)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.FrontlineWaveDrainWidget.OnVisibilityUpdated");
		
		UFrontlineWaveDrainWidget_OnVisibilityUpdated_Params params {};
		params.bIsVisible = bIsVisible;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05658A00
	 * 		Name   -> Function Insurgency.FrontlineWaveDrainWidget.OnTeamChanged
	 * 		Flags  -> (Final, Native, Private)
	 * Parameters:
	 * 		unsigned char                                      TeamId                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class ATeamInfo*                                   TeamInfo                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UFrontlineWaveDrainWidget::OnTeamChanged(unsigned char TeamId, class ATeamInfo* TeamInfo)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.FrontlineWaveDrainWidget.OnTeamChanged");
		
		UFrontlineWaveDrainWidget_OnTeamChanged_Params params {};
		params.TeamId = TeamId;
		params.TeamInfo = TeamInfo;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056589E0
	 * 		Name   -> Function Insurgency.FrontlineWaveDrainWidget.OnRefreshTeams
	 * 		Flags  -> (Final, Native, Private)
	 */
	void UFrontlineWaveDrainWidget::OnRefreshTeams()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.FrontlineWaveDrainWidget.OnRefreshTeams");
		
		UFrontlineWaveDrainWidget_OnRefreshTeams_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056589B0
	 * 		Name   -> Function Insurgency.FrontlineWaveDrainWidget.GetDesiredDisplayTeam
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	unsigned char UFrontlineWaveDrainWidget::GetDesiredDisplayTeam()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.FrontlineWaveDrainWidget.GetDesiredDisplayTeam");
		
		UFrontlineWaveDrainWidget_GetDesiredDisplayTeam_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UFrontlineWaveDrainWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UFrontlineWaveDrainWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.FrontlineWaveDrainWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0565A0D0
	 * 		Name   -> Function Insurgency.GameHUD.UpdateScoreboardActive
	 * 		Flags  -> (Final, Native, Protected, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               newScoreboardVisible                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGameHUD::UpdateScoreboardActive(bool newScoreboardVisible)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.GameHUD.UpdateScoreboardActive");
		
		UGameHUD_UpdateScoreboardActive_Params params {};
		params.newScoreboardVisible = newScoreboardVisible;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0565A0B0
	 * 		Name   -> Function Insurgency.GameHUD.UpdatePostRoundState
	 * 		Flags  -> (Final, Native, Protected, BlueprintCallable)
	 */
	void UGameHUD::UpdatePostRoundState()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.GameHUD.UpdatePostRoundState");
		
		UGameHUD_UpdatePostRoundState_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0565A020
	 * 		Name   -> Function Insurgency.GameHUD.UpdateMenuOpen
	 * 		Flags  -> (Final, Native, Protected, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               newMenuOpen                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGameHUD::UpdateMenuOpen(bool newMenuOpen)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.GameHUD.UpdateMenuOpen");
		
		UGameHUD_UpdateMenuOpen_Params params {};
		params.newMenuOpen = newMenuOpen;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0565A000
	 * 		Name   -> Function Insurgency.GameHUD.UpdateElementAlpha
	 * 		Flags  -> (Final, Native, Protected, BlueprintCallable)
	 */
	void UGameHUD::UpdateElementAlpha()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.GameHUD.UpdateElementAlpha");
		
		UGameHUD_UpdateElementAlpha_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05659E00
	 * 		Name   -> Function Insurgency.GameHUD.TookDamage
	 * 		Flags  -> (Final, Native, Protected, HasOutParms, HasDefaults)
	 * Parameters:
	 * 		float                                              Damage                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AINSSoldier*                                 Target                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     HitSource                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     HitDirection                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AController*                                 EventInstigator                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      DamageCauser                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGameHUD::TookDamage(float Damage, class AINSSoldier* Target, const struct FVector& HitSource, const struct FVector& HitDirection, class AController* EventInstigator, class AActor* DamageCauser)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.GameHUD.TookDamage");
		
		UGameHUD_TookDamage_Params params {};
		params.Damage = Damage;
		params.Target = Target;
		params.HitSource = HitSource;
		params.HitDirection = HitDirection;
		params.EventInstigator = EventInstigator;
		params.DamageCauser = DamageCauser;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> Function Insurgency.GameHUD.ToggleResupplyVisibility
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 * Parameters:
	 * 		bool                                               bNewVisibility                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGameHUD::ToggleResupplyVisibility(bool bNewVisibility)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.GameHUD.ToggleResupplyVisibility");
		
		UGameHUD_ToggleResupplyVisibility_Params params {};
		params.bNewVisibility = bNewVisibility;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05659D70
	 * 		Name   -> Function Insurgency.GameHUD.SetHasAlivePawn
	 * 		Flags  -> (Final, Native, Protected, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               newAlivePawn                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGameHUD::SetHasAlivePawn(bool newAlivePawn)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.GameHUD.SetHasAlivePawn");
		
		UGameHUD_SetHasAlivePawn_Params params {};
		params.newAlivePawn = newAlivePawn;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05659D50
	 * 		Name   -> Function Insurgency.GameHUD.OnRoundReset
	 * 		Flags  -> (Final, Native, Protected)
	 */
	void UGameHUD::OnRoundReset()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.GameHUD.OnRoundReset");
		
		UGameHUD_OnRoundReset_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05659BC0
	 * 		Name   -> Function Insurgency.GameHUD.OnRoundOver
	 * 		Flags  -> (Final, Native, Protected, HasOutParms)
	 * Parameters:
	 * 		struct FPlayerRoundOverData                        UIData                                                     (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UGameHUD::OnRoundOver(const struct FPlayerRoundOverData& UIData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.GameHUD.OnRoundOver");
		
		UGameHUD_OnRoundOver_Params params {};
		params.UIData = UIData;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> Function Insurgency.GameHUD.OnQueueObjectiveBriefing
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 */
	void UGameHUD::OnQueueObjectiveBriefing()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.GameHUD.OnQueueObjectiveBriefing");
		
		UGameHUD_OnQueueObjectiveBriefing_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05659B30
	 * 		Name   -> Function Insurgency.GameHUD.OnPauseStateChanged
	 * 		Flags  -> (Final, Native, Protected, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               newPauseState                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGameHUD::OnPauseStateChanged(bool newPauseState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.GameHUD.OnPauseStateChanged");
		
		UGameHUD_OnPauseStateChanged_Params params {};
		params.newPauseState = newPauseState;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05659AB0
	 * 		Name   -> Function Insurgency.GameHUD.OnMatchStateUpdate
	 * 		Flags  -> (Final, Native, Protected)
	 * Parameters:
	 * 		class FName                                        NewState                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGameHUD::OnMatchStateUpdate(const class FName& NewState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.GameHUD.OnMatchStateUpdate");
		
		UGameHUD_OnMatchStateUpdate_Params params {};
		params.NewState = NewState;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> Function Insurgency.GameHUD.OnExitSpawnZone
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 */
	void UGameHUD::OnExitSpawnZone()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.GameHUD.OnExitSpawnZone");
		
		UGameHUD_OnExitSpawnZone_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056599F0
	 * 		Name   -> Function Insurgency.GameHUD.OnEquipableItemChanged
	 * 		Flags  -> (Final, Native, Protected)
	 * Parameters:
	 * 		class AItemEquipable*                              NewItem                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AItemEquipable*                              PreviousItem                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGameHUD::OnEquipableItemChanged(class AItemEquipable* NewItem, class AItemEquipable* PreviousItem)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.GameHUD.OnEquipableItemChanged");
		
		UGameHUD_OnEquipableItemChanged_Params params {};
		params.NewItem = NewItem;
		params.PreviousItem = PreviousItem;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056599C0
	 * 		Name   -> Function Insurgency.GameHUD.IsScoreboardActive
	 * 		Flags  -> (Final, Native, Protected, BlueprintCallable, BlueprintPure)
	 */
	bool UGameHUD::IsScoreboardActive()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.GameHUD.IsScoreboardActive");
		
		UGameHUD_IsScoreboardActive_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05659990
	 * 		Name   -> Function Insurgency.GameHUD.IsMenuOpen
	 * 		Flags  -> (Final, Native, Protected, BlueprintCallable, BlueprintPure)
	 */
	bool UGameHUD::IsMenuOpen()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.GameHUD.IsMenuOpen");
		
		UGameHUD_IsMenuOpen_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05659960
	 * 		Name   -> Function Insurgency.GameHUD.GetScoreboardHiddenCanvasVisibility
	 * 		Flags  -> (Final, Native, Protected, BlueprintCallable, BlueprintPure)
	 */
	ESlateVisibility UGameHUD::GetScoreboardHiddenCanvasVisibility()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.GameHUD.GetScoreboardHiddenCanvasVisibility");
		
		UGameHUD_GetScoreboardHiddenCanvasVisibility_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05659930
	 * 		Name   -> Function Insurgency.GameHUD.GetHUDCanvasVisibility
	 * 		Flags  -> (Final, Native, Protected, BlueprintCallable, BlueprintPure)
	 */
	ESlateVisibility UGameHUD::GetHUDCanvasVisibility()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.GameHUD.GetHUDCanvasVisibility");
		
		UGameHUD_GetHUDCanvasVisibility_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05659900
	 * 		Name   -> Function Insurgency.GameHUD.GetFullScreenScoreboardHiddenCanvasVisibility
	 * 		Flags  -> (Final, Native, Protected, BlueprintCallable, BlueprintPure)
	 */
	ESlateVisibility UGameHUD::GetFullScreenScoreboardHiddenCanvasVisibility()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.GameHUD.GetFullScreenScoreboardHiddenCanvasVisibility");
		
		UGameHUD_GetFullScreenScoreboardHiddenCanvasVisibility_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> Function Insurgency.GameHUD.DoMapVoteStarted
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 */
	void UGameHUD::DoMapVoteStarted()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.GameHUD.DoMapVoteStarted");
		
		UGameHUD_DoMapVoteStarted_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> Function Insurgency.GameHUD.DoCreateRoundVictory
	 * 		Flags  -> (Event, Protected, HasOutParms, BlueprintEvent)
	 * Parameters:
	 * 		struct FPlayerRoundOverData                        UIData                                                     (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	class UWidget* UGameHUD::DoCreateRoundVictory(const struct FPlayerRoundOverData& UIData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.GameHUD.DoCreateRoundVictory");
		
		UGameHUD_DoCreateRoundVictory_Params params {};
		params.UIData = UIData;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> Function Insurgency.GameHUD.DoCreateDamageIndicator
	 * 		Flags  -> (Event, Protected, HasOutParms, HasDefaults, BlueprintEvent)
	 * Parameters:
	 * 		struct FVector                                     HitSource                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Damage                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UWidget* UGameHUD::DoCreateDamageIndicator(const struct FVector& HitSource, float Damage)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.GameHUD.DoCreateDamageIndicator");
		
		UGameHUD_DoCreateDamageIndicator_Params params {};
		params.HitSource = HitSource;
		params.Damage = Damage;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGameHUD.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGameHUD::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.GameHUD");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0565B200
	 * 		Name   -> Function Insurgency.GameInputStatics.IsValidKey
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FKey                                        Key                                                        (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UGameInputStatics::STATIC_IsValidKey(const struct FKey& Key)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.GameInputStatics.IsValidKey");
		
		UGameInputStatics_IsValidKey_Params params {};
		params.Key = Key;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0565B0E0
	 * 		Name   -> Function Insurgency.GameInputStatics.IsKeyBoundToAction
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class FName                                        Action                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FKey                                        Key                                                        (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UGameInputStatics::STATIC_IsKeyBoundToAction(const class FName& Action, const struct FKey& Key)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.GameInputStatics.IsKeyBoundToAction");
		
		UGameInputStatics_IsKeyBoundToAction_Params params {};
		params.Action = Action;
		params.Key = Key;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0565AF80
	 * 		Name   -> Function Insurgency.GameInputStatics.GetAxisKeyMappingSource
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class UINSPlayerLocalProfile*                      LocalProfile                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	TArray<struct FInputAxisKeyMapping> UGameInputStatics::STATIC_GetAxisKeyMappingSource(class UINSPlayerLocalProfile* LocalProfile)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.GameInputStatics.GetAxisKeyMappingSource");
		
		UGameInputStatics_GetAxisKeyMappingSource_Params params {};
		params.LocalProfile = LocalProfile;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0565AD50
	 * 		Name   -> Function Insurgency.GameInputStatics.GetAllKeysBoundToGamepad
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		class FName                                        ActionOrAxis                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bIsAxis                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              AxisScale                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bGamepad                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UINSPlayerLocalProfile*                      LocalProfile                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		TArray<struct FKey>                                Keys                                                       (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UGameInputStatics::STATIC_GetAllKeysBoundToGamepad(const class FName& ActionOrAxis, bool bIsAxis, float AxisScale, bool bGamepad, class UINSPlayerLocalProfile* LocalProfile, TArray<struct FKey>* Keys)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.GameInputStatics.GetAllKeysBoundToGamepad");
		
		UGameInputStatics_GetAllKeysBoundToGamepad_Params params {};
		params.ActionOrAxis = ActionOrAxis;
		params.bIsAxis = bIsAxis;
		params.AxisScale = AxisScale;
		params.bGamepad = bGamepad;
		params.LocalProfile = LocalProfile;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (Keys != nullptr)
			*Keys = params.Keys;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0565ABA0
	 * 		Name   -> Function Insurgency.GameInputStatics.GetAllKeysBoundToAxis
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		class FName                                        Axis                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Scale                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		TArray<struct FKey>                                Keys                                                       (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UINSPlayerLocalProfile*                      LocalProfile                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UGameInputStatics::STATIC_GetAllKeysBoundToAxis(const class FName& Axis, float Scale, TArray<struct FKey>* Keys, class UINSPlayerLocalProfile* LocalProfile)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.GameInputStatics.GetAllKeysBoundToAxis");
		
		UGameInputStatics_GetAllKeysBoundToAxis_Params params {};
		params.Axis = Axis;
		params.Scale = Scale;
		params.LocalProfile = LocalProfile;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (Keys != nullptr)
			*Keys = params.Keys;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0565AA30
	 * 		Name   -> Function Insurgency.GameInputStatics.GetAllKeysBoundToAction
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		class FName                                        Action                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		TArray<struct FKey>                                Keys                                                       (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UINSPlayerLocalProfile*                      LocalProfile                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UGameInputStatics::STATIC_GetAllKeysBoundToAction(const class FName& Action, TArray<struct FKey>* Keys, class UINSPlayerLocalProfile* LocalProfile)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.GameInputStatics.GetAllKeysBoundToAction");
		
		UGameInputStatics_GetAllKeysBoundToAction_Params params {};
		params.Action = Action;
		params.LocalProfile = LocalProfile;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (Keys != nullptr)
			*Keys = params.Keys;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0565A850
	 * 		Name   -> Function Insurgency.GameInputStatics.GetAllKeysBoundTo
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		class FName                                        ActionOrAxis                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bIsAxis                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              AxisScale                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UINSPlayerLocalProfile*                      LocalProfile                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		TArray<struct FKey>                                Keys                                                       (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UGameInputStatics::STATIC_GetAllKeysBoundTo(const class FName& ActionOrAxis, bool bIsAxis, float AxisScale, class UINSPlayerLocalProfile* LocalProfile, TArray<struct FKey>* Keys)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.GameInputStatics.GetAllKeysBoundTo");
		
		UGameInputStatics_GetAllKeysBoundTo_Params params {};
		params.ActionOrAxis = ActionOrAxis;
		params.bIsAxis = bIsAxis;
		params.AxisScale = AxisScale;
		params.LocalProfile = LocalProfile;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (Keys != nullptr)
			*Keys = params.Keys;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0565A6B0
	 * 		Name   -> Function Insurgency.GameInputStatics.GetActionKeyMappingSource
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class UINSPlayerLocalProfile*                      LocalProfile                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	TArray<struct FInputActionKeyMapping> UGameInputStatics::STATIC_GetActionKeyMappingSource(class UINSPlayerLocalProfile* LocalProfile)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.GameInputStatics.GetActionKeyMappingSource");
		
		UGameInputStatics_GetActionKeyMappingSource_Params params {};
		params.LocalProfile = LocalProfile;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0565A570
	 * 		Name   -> Function Insurgency.GameInputStatics.FindKeyBoundToAxis
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class FName                                        Axis                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Scale                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UINSPlayerLocalProfile*                      LocalProfile                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FKey UGameInputStatics::STATIC_FindKeyBoundToAxis(const class FName& Axis, float Scale, class UINSPlayerLocalProfile* LocalProfile)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.GameInputStatics.FindKeyBoundToAxis");
		
		UGameInputStatics_FindKeyBoundToAxis_Params params {};
		params.Axis = Axis;
		params.Scale = Scale;
		params.LocalProfile = LocalProfile;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0565A470
	 * 		Name   -> Function Insurgency.GameInputStatics.FindKeyBoundToAction
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class FName                                        Action                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UINSPlayerLocalProfile*                      LocalProfile                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FKey UGameInputStatics::STATIC_FindKeyBoundToAction(const class FName& Action, class UINSPlayerLocalProfile* LocalProfile)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.GameInputStatics.FindKeyBoundToAction");
		
		UGameInputStatics_FindKeyBoundToAction_Params params {};
		params.Action = Action;
		params.LocalProfile = LocalProfile;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGameInputStatics.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGameInputStatics::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.GameInputStatics");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0565B610
	 * 		Name   -> Function Insurgency.GameplayEffectsStatics.HasPlayerInRange
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Tolerance                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     TestLocation                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UGameplayEffectsStatics::STATIC_HasPlayerInRange(class UObject* WorldContextObject, float Tolerance, const struct FVector& TestLocation)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.GameplayEffectsStatics.HasPlayerInRange");
		
		UGameplayEffectsStatics_HasPlayerInRange_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.Tolerance = Tolerance;
		params.TestLocation = TestLocation;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGameplayEffectsStatics.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGameplayEffectsStatics::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.GameplayEffectsStatics");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGameUIData.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGameUIData::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.GameUIData");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0565FD20
	 * 		Name   -> Function Insurgency.GameUIStatics.TransformToScreen
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		class APlayerController*                           Controller                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UUserWidget*                                 Widget                                                     (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     InWorldLocation                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector2D                                   OutScreenLocation                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              OutFrontDot                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              OutRightDot                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              OutDistance                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bIsOnScreen                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGameUIStatics::STATIC_TransformToScreen(class APlayerController* Controller, class UUserWidget* Widget, const struct FVector& InWorldLocation, struct FVector2D* OutScreenLocation, float* OutFrontDot, float* OutRightDot, float* OutDistance, bool* bIsOnScreen)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.GameUIStatics.TransformToScreen");
		
		UGameUIStatics_TransformToScreen_Params params {};
		params.Controller = Controller;
		params.Widget = Widget;
		params.InWorldLocation = InWorldLocation;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutScreenLocation != nullptr)
			*OutScreenLocation = params.OutScreenLocation;
		if (OutFrontDot != nullptr)
			*OutFrontDot = params.OutFrontDot;
		if (OutRightDot != nullptr)
			*OutRightDot = params.OutRightDot;
		if (OutDistance != nullptr)
			*OutDistance = params.OutDistance;
		if (bIsOnScreen != nullptr)
			*bIsOnScreen = params.bIsOnScreen;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0565FAF0
	 * 		Name   -> Function Insurgency.GameUIStatics.ReplaceKeyWithLessonMarkup
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		class FText                                        InText                                                     (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		TArray<struct FLessonInputAction>                  Actions                                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FText                                        OutText                                                    (Parm, OutParm, NativeAccessSpecifierPublic)
	 */
	void UGameUIStatics::STATIC_ReplaceKeyWithLessonMarkup(const class FText& InText, TArray<struct FLessonInputAction> Actions, class FText* OutText)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.GameUIStatics.ReplaceKeyWithLessonMarkup");
		
		UGameUIStatics_ReplaceKeyWithLessonMarkup_Params params {};
		params.InText = InText;
		params.Actions = Actions;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutText != nullptr)
			*OutText = params.OutText;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0565FA60
	 * 		Name   -> Function Insurgency.GameUIStatics.OpenURLInOverlay
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class FString                                      URL                                                        (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGameUIStatics::STATIC_OpenURLInOverlay(const class FString& URL)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.GameUIStatics.OpenURLInOverlay");
		
		UGameUIStatics_OpenURLInOverlay_Params params {};
		params.URL = URL;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0565F9B0
	 * 		Name   -> Function Insurgency.GameUIStatics.OpenPlatformProfileForPlayer
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class APlayerController*                           Controller                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class APlayerState*                                PlayerState                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGameUIStatics::STATIC_OpenPlatformProfileForPlayer(class APlayerController* Controller, class APlayerState* PlayerState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.GameUIStatics.OpenPlatformProfileForPlayer");
		
		UGameUIStatics_OpenPlatformProfileForPlayer_Params params {};
		params.Controller = Controller;
		params.PlayerState = PlayerState;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0565F920
	 * 		Name   -> Function Insurgency.GameUIStatics.OpenPlatformProfileForPlatformId
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class FString                                      RequestedPlatformId                                        (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGameUIStatics::STATIC_OpenPlatformProfileForPlatformId(const class FString& RequestedPlatformId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.GameUIStatics.OpenPlatformProfileForPlatformId");
		
		UGameUIStatics_OpenPlatformProfileForPlatformId_Params params {};
		params.RequestedPlatformId = RequestedPlatformId;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0565F8F0
	 * 		Name   -> Function Insurgency.GameUIStatics.IsModSupportedPlatform
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 */
	bool UGameUIStatics::STATIC_IsModSupportedPlatform()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.GameUIStatics.IsModSupportedPlatform");
		
		UGameUIStatics_IsModSupportedPlatform_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0565F8C0
	 * 		Name   -> Function Insurgency.GameUIStatics.IsDeveloperPlayingLocal
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 */
	bool UGameUIStatics::STATIC_IsDeveloperPlayingLocal()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.GameUIStatics.IsDeveloperPlayingLocal");
		
		UGameUIStatics_IsDeveloperPlayingLocal_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0565F620
	 * 		Name   -> Function Insurgency.GameUIStatics.GetUseTimeoutsForUseActor
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class AActor*                                      UsableActor                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AINSSoldier*                                 Pawn                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              PrimaryUseTimeoutFrac                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              SecondaryUseTimeoutFrac                                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGameUIStatics::STATIC_GetUseTimeoutsForUseActor(class AActor* UsableActor, class AINSSoldier* Pawn, float* PrimaryUseTimeoutFrac, float* SecondaryUseTimeoutFrac)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.GameUIStatics.GetUseTimeoutsForUseActor");
		
		UGameUIStatics_GetUseTimeoutsForUseActor_Params params {};
		params.UsableActor = UsableActor;
		params.Pawn = Pawn;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (PrimaryUseTimeoutFrac != nullptr)
			*PrimaryUseTimeoutFrac = params.PrimaryUseTimeoutFrac;
		if (SecondaryUseTimeoutFrac != nullptr)
			*SecondaryUseTimeoutFrac = params.SecondaryUseTimeoutFrac;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0565F780
	 * 		Name   -> Function Insurgency.GameUIStatics.GetUserRequestedLanguage
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		class FString                                      OutRawRequestedLang                                        (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               OutHasUsedFallback                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class FString UGameUIStatics::STATIC_GetUserRequestedLanguage(class FString* OutRawRequestedLang, bool* OutHasUsedFallback)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.GameUIStatics.GetUserRequestedLanguage");
		
		UGameUIStatics_GetUserRequestedLanguage_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutRawRequestedLang != nullptr)
			*OutRawRequestedLang = params.OutRawRequestedLang;
		if (OutHasUsedFallback != nullptr)
			*OutHasUsedFallback = params.OutHasUsedFallback;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0565F310
	 * 		Name   -> Function Insurgency.GameUIStatics.GetUseMessage
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class AActor*                                      UsableActor                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AINSPlayerController*                        Controller                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FHitResult                                  UseHitResult                                               (Parm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 * 		bool                                               bInProgress                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FText                                        OutPrimaryText                                             (Parm, OutParm, NativeAccessSpecifierPublic)
	 * 		class FText                                        OutSubText                                                 (Parm, OutParm, NativeAccessSpecifierPublic)
	 */
	void UGameUIStatics::STATIC_GetUseMessage(class AActor* UsableActor, class AINSPlayerController* Controller, const struct FHitResult& UseHitResult, bool bInProgress, class FText* OutPrimaryText, class FText* OutSubText)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.GameUIStatics.GetUseMessage");
		
		UGameUIStatics_GetUseMessage_Params params {};
		params.UsableActor = UsableActor;
		params.Controller = Controller;
		params.UseHitResult = UseHitResult;
		params.bInProgress = bInProgress;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutPrimaryText != nullptr)
			*OutPrimaryText = params.OutPrimaryText;
		if (OutSubText != nullptr)
			*OutSubText = params.OutSubText;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0565F0A0
	 * 		Name   -> Function Insurgency.GameUIStatics.GetUseImage
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class AActor*                                      UsableActor                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AINSPlayerController*                        Controller                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FHitResult                                  UseHitResult                                               (Parm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 * 		bool                                               bInProgress                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FText                                        OutAdditionalText                                          (Parm, OutParm, NativeAccessSpecifierPublic)
	 */
	class UTexture2D* UGameUIStatics::STATIC_GetUseImage(class AActor* UsableActor, class AINSPlayerController* Controller, const struct FHitResult& UseHitResult, bool bInProgress, class FText* OutAdditionalText)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.GameUIStatics.GetUseImage");
		
		UGameUIStatics_GetUseImage_Params params {};
		params.UsableActor = UsableActor;
		params.Controller = Controller;
		params.UseHitResult = UseHitResult;
		params.bInProgress = bInProgress;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutAdditionalText != nullptr)
			*OutAdditionalText = params.OutAdditionalText;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0565EF70
	 * 		Name   -> Function Insurgency.GameUIStatics.GetUseAction
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class AActor*                                      UsableActor                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FName                                        PrimaryUseAction                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		TArray<class FName>                                SubUseActions                                              (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGameUIStatics::STATIC_GetUseAction(class AActor* UsableActor, class FName* PrimaryUseAction, TArray<class FName>* SubUseActions)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.GameUIStatics.GetUseAction");
		
		UGameUIStatics_GetUseAction_Params params {};
		params.UsableActor = UsableActor;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (PrimaryUseAction != nullptr)
			*PrimaryUseAction = params.PrimaryUseAction;
		if (SubUseActions != nullptr)
			*SubUseActions = params.SubUseActions;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0565ED00
	 * 		Name   -> Function Insurgency.GameUIStatics.GetSubUseImage
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class AActor*                                      UsableActor                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AINSPlayerController*                        Controller                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FHitResult                                  UseHitResult                                               (Parm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 * 		bool                                               bInProgress                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FText                                        OutAdditionalText                                          (Parm, OutParm, NativeAccessSpecifierPublic)
	 */
	class UTexture2D* UGameUIStatics::STATIC_GetSubUseImage(class AActor* UsableActor, class AINSPlayerController* Controller, const struct FHitResult& UseHitResult, bool bInProgress, class FText* OutAdditionalText)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.GameUIStatics.GetSubUseImage");
		
		UGameUIStatics_GetSubUseImage_Params params {};
		params.UsableActor = UsableActor;
		params.Controller = Controller;
		params.UseHitResult = UseHitResult;
		params.bInProgress = bInProgress;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutAdditionalText != nullptr)
			*OutAdditionalText = params.OutAdditionalText;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0565EB70
	 * 		Name   -> Function Insurgency.GameUIStatics.GetRadialOffsetForSize
	 * 		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		float                                              Spacing                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Width                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Height                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		ERadialMenuDirection                               Direction                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            Options                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FVector2D UGameUIStatics::STATIC_GetRadialOffsetForSize(float Spacing, float Width, float Height, ERadialMenuDirection Direction, int32_t Options)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.GameUIStatics.GetRadialOffsetForSize");
		
		UGameUIStatics_GetRadialOffsetForSize_Params params {};
		params.Spacing = Spacing;
		params.Width = Width;
		params.Height = Height;
		params.Direction = Direction;
		params.Options = Options;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0565EA70
	 * 		Name   -> Function Insurgency.GameUIStatics.GetRadialOffset
	 * 		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		float                                              Spacing                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		ERadialMenuDirection                               Direction                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            Options                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FVector2D UGameUIStatics::STATIC_GetRadialOffset(float Spacing, ERadialMenuDirection Direction, int32_t Options)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.GameUIStatics.GetRadialOffset");
		
		UGameUIStatics_GetRadialOffset_Params params {};
		params.Spacing = Spacing;
		params.Direction = Direction;
		params.Options = Options;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0565E9F0
	 * 		Name   -> Function Insurgency.GameUIStatics.GetPreferredFileSizeUnit
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		int64_t                                            SizeInBytes                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	EFileSizeUnit UGameUIStatics::STATIC_GetPreferredFileSizeUnit(int64_t SizeInBytes)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.GameUIStatics.GetPreferredFileSizeUnit");
		
		UGameUIStatics_GetPreferredFileSizeUnit_Params params {};
		params.SizeInBytes = SizeInBytes;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0565E8A0
	 * 		Name   -> Function Insurgency.GameUIStatics.GetOtherEarnedTaglineDescription
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FOtherPlayerAwardedTagline                  EarnedTagline                                              (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 * 		class FText                                        OutDescription                                             (Parm, OutParm, NativeAccessSpecifierPublic)
	 */
	void UGameUIStatics::STATIC_GetOtherEarnedTaglineDescription(const struct FOtherPlayerAwardedTagline& EarnedTagline, class FText* OutDescription)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.GameUIStatics.GetOtherEarnedTaglineDescription");
		
		UGameUIStatics_GetOtherEarnedTaglineDescription_Params params {};
		params.EarnedTagline = EarnedTagline;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutDescription != nullptr)
			*OutDescription = params.OutDescription;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0565E6A0
	 * 		Name   -> Function Insurgency.GameUIStatics.GetObjectPrintName
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		class UObject*                                     InObject                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FText                                        OutPrintName                                               (Parm, OutParm, NativeAccessSpecifierPublic)
	 */
	void UGameUIStatics::STATIC_GetObjectPrintName(class UObject* InObject, class FText* OutPrintName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.GameUIStatics.GetObjectPrintName");
		
		UGameUIStatics_GetObjectPrintName_Params params {};
		params.InObject = InObject;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutPrintName != nullptr)
			*OutPrintName = params.OutPrintName;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0565E820
	 * 		Name   -> Function Insurgency.GameUIStatics.GetObjectivePhonetic
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		unsigned char                                      ObjectiveId                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class FText UGameUIStatics::STATIC_GetObjectivePhonetic(unsigned char ObjectiveId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.GameUIStatics.GetObjectivePhonetic");
		
		UGameUIStatics_GetObjectivePhonetic_Params params {};
		params.ObjectiveId = ObjectiveId;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0565E7A0
	 * 		Name   -> Function Insurgency.GameUIStatics.GetObjectiveLetter
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		unsigned char                                      ObjectiveId                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class FText UGameUIStatics::STATIC_GetObjectiveLetter(unsigned char ObjectiveId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.GameUIStatics.GetObjectiveLetter");
		
		UGameUIStatics_GetObjectiveLetter_Params params {};
		params.ObjectiveId = ObjectiveId;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0565E5A0
	 * 		Name   -> Function Insurgency.GameUIStatics.GetLocalizedWeaponUpgradeSlot
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		EWeaponUpgradeSlot                                 WeaponUpgradeSlot                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FText                                        OutPrintName                                               (Parm, OutParm, NativeAccessSpecifierPublic)
	 */
	void UGameUIStatics::STATIC_GetLocalizedWeaponUpgradeSlot(EWeaponUpgradeSlot WeaponUpgradeSlot, class FText* OutPrintName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.GameUIStatics.GetLocalizedWeaponUpgradeSlot");
		
		UGameUIStatics_GetLocalizedWeaponUpgradeSlot_Params params {};
		params.WeaponUpgradeSlot = WeaponUpgradeSlot;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutPrintName != nullptr)
			*OutPrintName = params.OutPrintName;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0565E490
	 * 		Name   -> Function Insurgency.GameUIStatics.GetLocalizedWeaponName
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class FString                                      OriginalWeaponName                                         (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FText                                        OutLocalizedWeaponName                                     (Parm, OutParm, NativeAccessSpecifierPublic)
	 */
	void UGameUIStatics::STATIC_GetLocalizedWeaponName(const class FString& OriginalWeaponName, class FText* OutLocalizedWeaponName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.GameUIStatics.GetLocalizedWeaponName");
		
		UGameUIStatics_GetLocalizedWeaponName_Params params {};
		params.OriginalWeaponName = OriginalWeaponName;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutLocalizedWeaponName != nullptr)
			*OutLocalizedWeaponName = params.OutLocalizedWeaponName;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0565E380
	 * 		Name   -> Function Insurgency.GameUIStatics.GetLocalizedScenarioName
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class FString                                      OriginalScenarioName                                       (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FText                                        OutScenarioNameText                                        (Parm, OutParm, NativeAccessSpecifierPublic)
	 */
	void UGameUIStatics::STATIC_GetLocalizedScenarioName(const class FString& OriginalScenarioName, class FText* OutScenarioNameText)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.GameUIStatics.GetLocalizedScenarioName");
		
		UGameUIStatics_GetLocalizedScenarioName_Params params {};
		params.OriginalScenarioName = OriginalScenarioName;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutScenarioNameText != nullptr)
			*OutScenarioNameText = params.OutScenarioNameText;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0565E270
	 * 		Name   -> Function Insurgency.GameUIStatics.GetLocalizedMapName
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class FString                                      OriginalMapName                                            (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FText                                        OutMapNameText                                             (Parm, OutParm, NativeAccessSpecifierPublic)
	 */
	void UGameUIStatics::STATIC_GetLocalizedMapName(const class FString& OriginalMapName, class FText* OutMapNameText)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.GameUIStatics.GetLocalizedMapName");
		
		UGameUIStatics_GetLocalizedMapName_Params params {};
		params.OriginalMapName = OriginalMapName;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutMapNameText != nullptr)
			*OutMapNameText = params.OutMapNameText;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0565E130
	 * 		Name   -> Function Insurgency.GameUIStatics.GetLocalizedItemSubSlot
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		EItemSlot                                          ItemSlot                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            SubSlot                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FText                                        OutPrintName                                               (Parm, OutParm, NativeAccessSpecifierPublic)
	 */
	void UGameUIStatics::STATIC_GetLocalizedItemSubSlot(EItemSlot ItemSlot, int32_t SubSlot, class FText* OutPrintName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.GameUIStatics.GetLocalizedItemSubSlot");
		
		UGameUIStatics_GetLocalizedItemSubSlot_Params params {};
		params.ItemSlot = ItemSlot;
		params.SubSlot = SubSlot;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutPrintName != nullptr)
			*OutPrintName = params.OutPrintName;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0565E030
	 * 		Name   -> Function Insurgency.GameUIStatics.GetLocalizedItemSlot
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		EItemSlot                                          ItemSlot                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FText                                        OutPrintName                                               (Parm, OutParm, NativeAccessSpecifierPublic)
	 */
	void UGameUIStatics::STATIC_GetLocalizedItemSlot(EItemSlot ItemSlot, class FText* OutPrintName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.GameUIStatics.GetLocalizedItemSlot");
		
		UGameUIStatics_GetLocalizedItemSlot_Params params {};
		params.ItemSlot = ItemSlot;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutPrintName != nullptr)
			*OutPrintName = params.OutPrintName;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0565DEE0
	 * 		Name   -> Function Insurgency.GameUIStatics.GetLocalizedCompassHeading
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		ECardinalDirection                                 Direction                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bAbbreviated                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FText                                        OutHeading                                                 (Parm, OutParm, NativeAccessSpecifierPublic)
	 */
	void UGameUIStatics::STATIC_GetLocalizedCompassHeading(ECardinalDirection Direction, bool bAbbreviated, class FText* OutHeading)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.GameUIStatics.GetLocalizedCompassHeading");
		
		UGameUIStatics_GetLocalizedCompassHeading_Params params {};
		params.Direction = Direction;
		params.bAbbreviated = bAbbreviated;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutHeading != nullptr)
			*OutHeading = params.OutHeading;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0565DE60
	 * 		Name   -> Function Insurgency.GameUIStatics.GetItemIcon
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class UClass*                                      ItemClass                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UTexture2D* UGameUIStatics::STATIC_GetItemIcon(class UClass* ItemClass)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.GameUIStatics.GetItemIcon");
		
		UGameUIStatics_GetItemIcon_Params params {};
		params.ItemClass = ItemClass;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0565DDE0
	 * 		Name   -> Function Insurgency.GameUIStatics.GetGamePageInStoreURL
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 */
	class FString UGameUIStatics::STATIC_GetGamePageInStoreURL()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.GameUIStatics.GetGamePageInStoreURL");
		
		UGameUIStatics_GetGamePageInStoreURL_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0565DCF0
	 * 		Name   -> Function Insurgency.GameUIStatics.GetFormattedShorthandTimespan
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FTimespan                                   InputTimespan                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class FText UGameUIStatics::STATIC_GetFormattedShorthandTimespan(const struct FTimespan& InputTimespan)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.GameUIStatics.GetFormattedShorthandTimespan");
		
		UGameUIStatics_GetFormattedShorthandTimespan_Params params {};
		params.InputTimespan = InputTimespan;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0565DB90
	 * 		Name   -> Function Insurgency.GameUIStatics.GetFormattedObjectiveName
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class AObjectiveBase*                              Objective                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bOverrideFactionColor                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		unsigned char                                      FactionOverride                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class FText UGameUIStatics::STATIC_GetFormattedObjectiveName(class AObjectiveBase* Objective, bool bOverrideFactionColor, unsigned char FactionOverride)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.GameUIStatics.GetFormattedObjectiveName");
		
		UGameUIStatics_GetFormattedObjectiveName_Params params {};
		params.Objective = Objective;
		params.bOverrideFactionColor = bOverrideFactionColor;
		params.FactionOverride = FactionOverride;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0565DA70
	 * 		Name   -> Function Insurgency.GameUIStatics.GetFormattedFileSizeInUnits
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		int64_t                                            SizeInBytes                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EFileSizeUnit                                      FileSizeUnit                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class FText UGameUIStatics::STATIC_GetFormattedFileSizeInUnits(int64_t SizeInBytes, EFileSizeUnit FileSizeUnit)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.GameUIStatics.GetFormattedFileSizeInUnits");
		
		UGameUIStatics_GetFormattedFileSizeInUnits_Params params {};
		params.SizeInBytes = SizeInBytes;
		params.FileSizeUnit = FileSizeUnit;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0565D990
	 * 		Name   -> Function Insurgency.GameUIStatics.GetFormattedFileSize
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		int64_t                                            SizeInBytes                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class FText UGameUIStatics::STATIC_GetFormattedFileSize(int64_t SizeInBytes)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.GameUIStatics.GetFormattedFileSize");
		
		UGameUIStatics_GetFormattedFileSize_Params params {};
		params.SizeInBytes = SizeInBytes;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0565D7D0
	 * 		Name   -> Function Insurgency.GameUIStatics.GetFormattedDistanceMetersTwoPoints
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class FText                                        OutDistanceText                                            (Parm, OutParm, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     PointA                                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     PointB                                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bShowDecimal                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGameUIStatics::STATIC_GetFormattedDistanceMetersTwoPoints(class FText* OutDistanceText, const struct FVector& PointA, const struct FVector& PointB, bool bShowDecimal)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.GameUIStatics.GetFormattedDistanceMetersTwoPoints");
		
		UGameUIStatics_GetFormattedDistanceMetersTwoPoints_Params params {};
		params.PointA = PointA;
		params.PointB = PointB;
		params.bShowDecimal = bShowDecimal;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutDistanceText != nullptr)
			*OutDistanceText = params.OutDistanceText;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0565D6F0
	 * 		Name   -> Function Insurgency.GameUIStatics.GetFormattedDistanceMetersKilometers
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		int32_t                                            Meters                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class FText UGameUIStatics::STATIC_GetFormattedDistanceMetersKilometers(int32_t Meters)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.GameUIStatics.GetFormattedDistanceMetersKilometers");
		
		UGameUIStatics_GetFormattedDistanceMetersKilometers_Params params {};
		params.Meters = Meters;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0565D5A0
	 * 		Name   -> Function Insurgency.GameUIStatics.GetFormattedDistanceMeters
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class FText                                        OutDistanceText                                            (Parm, OutParm, NativeAccessSpecifierPublic)
	 * 		float                                              DistanceInUnits                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bShowDecimal                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGameUIStatics::STATIC_GetFormattedDistanceMeters(class FText* OutDistanceText, float DistanceInUnits, bool bShowDecimal)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.GameUIStatics.GetFormattedDistanceMeters");
		
		UGameUIStatics_GetFormattedDistanceMeters_Params params {};
		params.DistanceInUnits = DistanceInUnits;
		params.bShowDecimal = bShowDecimal;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutDistanceText != nullptr)
			*OutDistanceText = params.OutDistanceText;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0565D2F0
	 * 		Name   -> Function Insurgency.GameUIStatics.GetFilteredRadialResponseForPlayer
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		class AINSSoldier*                                 Player                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FRadialCommand                              InCommand                                                  (Parm, NativeAccessSpecifierPublic)
	 * 		ECharacterResponse                                 OutResponse                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGameUIStatics::STATIC_GetFilteredRadialResponseForPlayer(class AINSSoldier* Player, const struct FRadialCommand& InCommand, ECharacterResponse* OutResponse)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.GameUIStatics.GetFilteredRadialResponseForPlayer");
		
		UGameUIStatics_GetFilteredRadialResponseForPlayer_Params params {};
		params.Player = Player;
		params.InCommand = InCommand;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutResponse != nullptr)
			*OutResponse = params.OutResponse;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0565D1B0
	 * 		Name   -> Function Insurgency.GameUIStatics.GetEarnedTaglineDescription
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FPlayerAwardedTagline                       EarnedTagline                                              (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 * 		class FText                                        OutDescription                                             (Parm, OutParm, NativeAccessSpecifierPublic)
	 */
	void UGameUIStatics::STATIC_GetEarnedTaglineDescription(const struct FPlayerAwardedTagline& EarnedTagline, class FText* OutDescription)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.GameUIStatics.GetEarnedTaglineDescription");
		
		UGameUIStatics_GetEarnedTaglineDescription_Params params {};
		params.EarnedTagline = EarnedTagline;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutDescription != nullptr)
			*OutDescription = params.OutDescription;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0565D070
	 * 		Name   -> Function Insurgency.GameUIStatics.GetDeathDescriptionFromKillNotice
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FPlayerKillNotice                           KillNotice                                                 (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 * 		class FText                                        OutDescription                                             (Parm, OutParm, NativeAccessSpecifierPublic)
	 */
	void UGameUIStatics::STATIC_GetDeathDescriptionFromKillNotice(const struct FPlayerKillNotice& KillNotice, class FText* OutDescription)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.GameUIStatics.GetDeathDescriptionFromKillNotice");
		
		UGameUIStatics_GetDeathDescriptionFromKillNotice_Params params {};
		params.KillNotice = KillNotice;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutDescription != nullptr)
			*OutDescription = params.OutDescription;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0565CF30
	 * 		Name   -> Function Insurgency.GameUIStatics.GetDeathDescription
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class UClass*                                      CauserActor                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UClass*                                      DamageType                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FText                                        OutDescription                                             (Parm, OutParm, NativeAccessSpecifierPublic)
	 */
	void UGameUIStatics::STATIC_GetDeathDescription(class UClass* CauserActor, class UClass* DamageType, class FText* OutDescription)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.GameUIStatics.GetDeathDescription");
		
		UGameUIStatics_GetDeathDescription_Params params {};
		params.CauserActor = CauserActor;
		params.DamageType = DamageType;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutDescription != nullptr)
			*OutDescription = params.OutDescription;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0565CE60
	 * 		Name   -> Function Insurgency.GameUIStatics.GetCompassAngle
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              YawAngle                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	float UGameUIStatics::STATIC_GetCompassAngle(class UObject* WorldContextObject, float YawAngle)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.GameUIStatics.GetCompassAngle");
		
		UGameUIStatics_GetCompassAngle_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.YawAngle = YawAngle;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0565CDC0
	 * 		Name   -> Function Insurgency.GameUIStatics.GetClipboardContents
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		class FString                                      OutClipboardContents                                       (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGameUIStatics::STATIC_GetClipboardContents(class FString* OutClipboardContents)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.GameUIStatics.GetClipboardContents");
		
		UGameUIStatics_GetClipboardContents_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutClipboardContents != nullptr)
			*OutClipboardContents = params.OutClipboardContents;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0565CCC0
	 * 		Name   -> Function Insurgency.GameUIStatics.GetClassPrintName
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		class UClass*                                      InClass                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FText                                        OutPrintName                                               (Parm, OutParm, NativeAccessSpecifierPublic)
	 */
	void UGameUIStatics::STATIC_GetClassPrintName(class UClass* InClass, class FText* OutPrintName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.GameUIStatics.GetClassPrintName");
		
		UGameUIStatics_GetClassPrintName_Params params {};
		params.InClass = InClass;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutPrintName != nullptr)
			*OutPrintName = params.OutPrintName;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0565CBF0
	 * 		Name   -> Function Insurgency.GameUIStatics.GetCardinalFromYaw
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              YawAngle                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	ECardinalDirection UGameUIStatics::STATIC_GetCardinalFromYaw(class UObject* WorldContextObject, float YawAngle)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.GameUIStatics.GetCardinalFromYaw");
		
		UGameUIStatics_GetCardinalFromYaw_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.YawAngle = YawAngle;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0565CB20
	 * 		Name   -> Function Insurgency.GameUIStatics.GetCardinalFromRotator
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FRotator                                    Rotation                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	ECardinalDirection UGameUIStatics::STATIC_GetCardinalFromRotator(class UObject* WorldContextObject, const struct FRotator& Rotation)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.GameUIStatics.GetCardinalFromRotator");
		
		UGameUIStatics_GetCardinalFromRotator_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.Rotation = Rotation;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0565CA50
	 * 		Name   -> Function Insurgency.GameUIStatics.GetAccountNickname
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class FString UGameUIStatics::STATIC_GetAccountNickname(class UObject* WorldContextObject)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.GameUIStatics.GetAccountNickname");
		
		UGameUIStatics_GetAccountNickname_Params params {};
		params.WorldContextObject = WorldContextObject;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0565C810
	 * 		Name   -> Function Insurgency.GameUIStatics.FormatTextFromParameterPairs
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		class FText                                        InFormat                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		TMap<class FString, class FText>                   InFormatPairs                                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		class FText                                        OutText                                                    (Parm, OutParm, NativeAccessSpecifierPublic)
	 */
	void UGameUIStatics::STATIC_FormatTextFromParameterPairs(const class FText& InFormat, TMap<class FString, class FText> InFormatPairs, class FText* OutText)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.GameUIStatics.FormatTextFromParameterPairs");
		
		UGameUIStatics_FormatTextFromParameterPairs_Params params {};
		params.InFormat = InFormat;
		params.InFormatPairs = InFormatPairs;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutText != nullptr)
			*OutText = params.OutText;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0565C780
	 * 		Name   -> Function Insurgency.GameUIStatics.DateTimeFromUnixTimestamp
	 * 		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		int64_t                                            UnixTimeStamp                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FDateTime UGameUIStatics::STATIC_DateTimeFromUnixTimestamp(int64_t UnixTimeStamp)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.GameUIStatics.DateTimeFromUnixTimestamp");
		
		UGameUIStatics_DateTimeFromUnixTimestamp_Params params {};
		params.UnixTimeStamp = UnixTimeStamp;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0565C6C0
	 * 		Name   -> Function Insurgency.GameUIStatics.CopyTextToClipboard
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		class FText                                        CopyText                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UGameUIStatics::STATIC_CopyTextToClipboard(const class FText& CopyText)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.GameUIStatics.CopyTextToClipboard");
		
		UGameUIStatics_CopyTextToClipboard_Params params {};
		params.CopyText = CopyText;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0565C630
	 * 		Name   -> Function Insurgency.GameUIStatics.CopyStringToClipboard
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class FString                                      CopyString                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGameUIStatics::STATIC_CopyStringToClipboard(const class FString& CopyString)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.GameUIStatics.CopyStringToClipboard");
		
		UGameUIStatics_CopyStringToClipboard_Params params {};
		params.CopyString = CopyString;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0565C5C0
	 * 		Name   -> Function Insurgency.GameUIStatics.CenterViewportCursor
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class APlayerController*                           PlayerController                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGameUIStatics::STATIC_CenterViewportCursor(class APlayerController* PlayerController)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.GameUIStatics.CenterViewportCursor");
		
		UGameUIStatics_CenterViewportCursor_Params params {};
		params.PlayerController = PlayerController;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGameUIStatics.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGameUIStatics::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.GameUIStatics");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGearUpgradeComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGearUpgradeComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.GearUpgradeComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> Function Insurgency.GenericDialogWidget.BP_OpeningVirtualKeyboard
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 */
	void UGenericDialogWidget::BP_OpeningVirtualKeyboard()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.GenericDialogWidget.BP_OpeningVirtualKeyboard");
		
		UGenericDialogWidget_BP_OpeningVirtualKeyboard_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> Function Insurgency.GenericDialogWidget.BP_ClosingVirtualKeyboard
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 */
	void UGenericDialogWidget::BP_ClosingVirtualKeyboard()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.GenericDialogWidget.BP_ClosingVirtualKeyboard");
		
		UGenericDialogWidget_BP_ClosingVirtualKeyboard_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGenericDialogWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGenericDialogWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.GenericDialogWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05660600
	 * 		Name   -> Function Insurgency.GetBannerProxy.GetBanner
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UGetBannerProxy* UGetBannerProxy::STATIC_GetBanner(class UObject* WorldContextObject)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.GetBannerProxy.GetBanner");
		
		UGetBannerProxy_GetBanner_Params params {};
		params.WorldContextObject = WorldContextObject;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGetBannerProxy.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGetBannerProxy::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.GetBannerProxy");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05660D90
	 * 		Name   -> Function Insurgency.GetMotdProxy.GetMotd
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bInForNewsPopup                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UGetMotdProxy* UGetMotdProxy::STATIC_GetMotd(class UObject* WorldContextObject, bool bInForNewsPopup)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.GetMotdProxy.GetMotd");
		
		UGetMotdProxy_GetMotd_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.bInForNewsPopup = bInForNewsPopup;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGetMotdProxy.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGetMotdProxy::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.GetMotdProxy");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UHelicopterMovementComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UHelicopterMovementComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.HelicopterMovementComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AHelicopterNavTarget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AHelicopterNavTarget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.HelicopterNavTarget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UHelicopterPathFollowingComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UHelicopterPathFollowingComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.HelicopterPathFollowingComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05662910
	 * 		Name   -> Function Insurgency.HUDWidgetInterface.OnRoundOverUIToggled
	 * 		Flags  -> (Native, Event, Public, BlueprintCallable, BlueprintEvent)
	 * Parameters:
	 * 		bool                                               bNowVisible                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UHUDWidgetInterface::OnRoundOverUIToggled(bool bNowVisible)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.HUDWidgetInterface.OnRoundOverUIToggled");
		
		UHUDWidgetInterface_OnRoundOverUIToggled_Params params {};
		params.bNowVisible = bNowVisible;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05662740
	 * 		Name   -> Function Insurgency.HUDWidgetInterface.OnMapVoteStarted
	 * 		Flags  -> (Native, Event, Public, BlueprintCallable, BlueprintEvent)
	 */
	void UHUDWidgetInterface::OnMapVoteStarted()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.HUDWidgetInterface.OnMapVoteStarted");
		
		UHUDWidgetInterface_OnMapVoteStarted_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UHUDWidgetInterface.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UHUDWidgetInterface::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.HUDWidgetInterface");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x04DB43C0
	 * 		Name   -> Function Insurgency.HUDBase.ToggleScoreboard
	 * 		Flags  -> (Native, Public, BlueprintCallable)
	 */
	void AHUDBase::ToggleScoreboard()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.HUDBase.ToggleScoreboard");
		
		AHUDBase_ToggleScoreboard_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05662C70
	 * 		Name   -> Function Insurgency.HUDBase.ToggleCompass
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void AHUDBase::ToggleCompass()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.HUDBase.ToggleCompass");
		
		AHUDBase_ToggleCompass_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056629C0
	 * 		Name   -> Function Insurgency.HUDBase.TextWithShadowClipped
	 * 		Flags  -> (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		float                                              PosX                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              PosY                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FText                                        Text                                                       (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		class UFont*                                       Font                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FLinearColor                                TextColor                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Scale                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Width                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Height                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AHUDBase::TextWithShadowClipped(float PosX, float PosY, const class FText& Text, class UFont* Font, const struct FLinearColor& TextColor, float Scale, float Width, float Height)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.HUDBase.TextWithShadowClipped");
		
		AHUDBase_TextWithShadowClipped_Params params {};
		params.PosX = PosX;
		params.PosY = PosY;
		params.Text = Text;
		params.Font = Font;
		params.TextColor = TextColor;
		params.Scale = Scale;
		params.Width = Width;
		params.Height = Height;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x04DB3540
	 * 		Name   -> Function Insurgency.HUDBase.ShowScoreboard
	 * 		Flags  -> (Native, Public, BlueprintCallable)
	 */
	void AHUDBase::ShowScoreboard()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.HUDBase.ShowScoreboard");
		
		AHUDBase_ShowScoreboard_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056629A0
	 * 		Name   -> Function Insurgency.HUDBase.ShowCompass
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void AHUDBase::ShowCompass()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.HUDBase.ShowCompass");
		
		AHUDBase_ShowCompass_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05662780
	 * 		Name   -> Function Insurgency.HUDBase.OnRoundOverUIShown
	 * 		Flags  -> (Final, Native, Public, HasOutParms)
	 * Parameters:
	 * 		struct FPlayerRoundOverData                        UIData                                                     (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void AHUDBase::OnRoundOverUIShown(const struct FPlayerRoundOverData& UIData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.HUDBase.OnRoundOverUIShown");
		
		AHUDBase_OnRoundOverUIShown_Params params {};
		params.UIData = UIData;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05662760
	 * 		Name   -> Function Insurgency.HUDBase.OnRoundOverUIHidden
	 * 		Flags  -> (Final, Native, Public)
	 */
	void AHUDBase::OnRoundOverUIHidden()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.HUDBase.OnRoundOverUIHidden");
		
		AHUDBase_OnRoundOverUIHidden_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05662720
	 * 		Name   -> Function Insurgency.HUDBase.OnMapVoteStarted
	 * 		Flags  -> (Final, Native, Public)
	 */
	void AHUDBase::OnMapVoteStarted()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.HUDBase.OnMapVoteStarted");
		
		AHUDBase_OnMapVoteStarted_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> DelegateFunction Insurgency.HUDBase.OnCompassToggledByUserDelegate__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 * Parameters:
	 * 		bool                                               bVisible                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AHUDBase::OnCompassToggledByUserDelegate__DelegateSignature(bool bVisible)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction Insurgency.HUDBase.OnCompassToggledByUserDelegate__DelegateSignature");
		
		AHUDBase_OnCompassToggledByUserDelegate__DelegateSignature_Params params {};
		params.bVisible = bVisible;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x04DB4000
	 * 		Name   -> Function Insurgency.HUDBase.HideScoreboard
	 * 		Flags  -> (Native, Public, BlueprintCallable)
	 */
	void AHUDBase::HideScoreboard()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.HUDBase.HideScoreboard");
		
		AHUDBase_HideScoreboard_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05662700
	 * 		Name   -> Function Insurgency.HUDBase.HideCompass
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void AHUDBase::HideCompass()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.HUDBase.HideCompass");
		
		AHUDBase_HideCompass_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05662490
	 * 		Name   -> Function Insurgency.HUDBase.DrawStringWithShadowClipped
	 * 		Flags  -> (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		float                                              PosX                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              PosY                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FString                                      InputString                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UFont*                                       Font                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FLinearColor                                TextColor                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Scale                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Width                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Height                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AHUDBase::DrawStringWithShadowClipped(float PosX, float PosY, const class FString& InputString, class UFont* Font, const struct FLinearColor& TextColor, float Scale, float Width, float Height)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.HUDBase.DrawStringWithShadowClipped");
		
		AHUDBase_DrawStringWithShadowClipped_Params params {};
		params.PosX = PosX;
		params.PosY = PosY;
		params.InputString = InputString;
		params.Font = Font;
		params.TextColor = TextColor;
		params.Scale = Scale;
		params.Width = Width;
		params.Height = Height;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x04DB41A0
	 * 		Name   -> Function Insurgency.HUDBase.DebugToggleOverlay
	 * 		Flags  -> (Exec, Native, Public)
	 */
	void AHUDBase::DebugToggleOverlay()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.HUDBase.DebugToggleOverlay");
		
		AHUDBase_DebugToggleOverlay_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05662400
	 * 		Name   -> Function Insurgency.HUDBase.CreatePlayerScreenWidget
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UClass*                                      WidgetClass                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UUserWidget* AHUDBase::CreatePlayerScreenWidget(class UClass* WidgetClass)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.HUDBase.CreatePlayerScreenWidget");
		
		AHUDBase_CreatePlayerScreenWidget_Params params {};
		params.WidgetClass = WidgetClass;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05662370
	 * 		Name   -> Function Insurgency.HUDBase.CreateFullScreenWidget
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UClass*                                      WidgetClass                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UUserWidget* AHUDBase::CreateFullScreenWidget(class UClass* WidgetClass)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.HUDBase.CreateFullScreenWidget");
		
		AHUDBase_CreateFullScreenWidget_Params params {};
		params.WidgetClass = WidgetClass;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> Function Insurgency.HUDBase.BlueprintOnRoundOverUIToggled
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		bool                                               bNowVisible                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AHUDBase::BlueprintOnRoundOverUIToggled(bool bNowVisible)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.HUDBase.BlueprintOnRoundOverUIToggled");
		
		AHUDBase_BlueprintOnRoundOverUIToggled_Params params {};
		params.bNowVisible = bNowVisible;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> Function Insurgency.HUDBase.BlueprintOnMapVoteStarted
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 */
	void AHUDBase::BlueprintOnMapVoteStarted()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.HUDBase.BlueprintOnMapVoteStarted");
		
		AHUDBase_BlueprintOnMapVoteStarted_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AHUDBase.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AHUDBase::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.HUDBase");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> Function Insurgency.HUDContextualHintContainer.UsingControllerUpdate
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 * Parameters:
	 * 		bool                                               bUsingController                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EeInputIconType                                    NewIconType                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UHUDContextualHintContainer::UsingControllerUpdate(bool bUsingController, EeInputIconType NewIconType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.HUDContextualHintContainer.UsingControllerUpdate");
		
		UHUDContextualHintContainer_UsingControllerUpdate_Params params {};
		params.bUsingController = bUsingController;
		params.NewIconType = NewIconType;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05663720
	 * 		Name   -> Function Insurgency.HUDContextualHintContainer.UpdateHintClassImage
	 * 		Flags  -> (Final, Native, Protected)
	 * Parameters:
	 * 		class UPlayerClass*                                PlayerClass                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UHUDContextualHintContainer::UpdateHintClassImage(class UPlayerClass* PlayerClass)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.HUDContextualHintContainer.UpdateHintClassImage");
		
		UHUDContextualHintContainer_UpdateHintClassImage_Params params {};
		params.PlayerClass = PlayerClass;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05663700
	 * 		Name   -> Function Insurgency.HUDContextualHintContainer.UpdateChildrenVisibility
	 * 		Flags  -> (Final, Native, Protected, BlueprintCallable)
	 */
	void UHUDContextualHintContainer::UpdateChildrenVisibility()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.HUDContextualHintContainer.UpdateChildrenVisibility");
		
		UHUDContextualHintContainer_UpdateChildrenVisibility_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056636E0
	 * 		Name   -> Function Insurgency.HUDContextualHintContainer.ShowHints
	 * 		Flags  -> (Final, Native, Protected)
	 */
	void UHUDContextualHintContainer::ShowHints()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.HUDContextualHintContainer.ShowHints");
		
		UHUDContextualHintContainer_ShowHints_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05663650
	 * 		Name   -> Function Insurgency.HUDContextualHintContainer.SetAllowResupply
	 * 		Flags  -> (Final, Native, Protected, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bNewCanResupply                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UHUDContextualHintContainer::SetAllowResupply(bool bNewCanResupply)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.HUDContextualHintContainer.SetAllowResupply");
		
		UHUDContextualHintContainer_SetAllowResupply_Params params {};
		params.bNewCanResupply = bNewCanResupply;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05663630
	 * 		Name   -> Function Insurgency.HUDContextualHintContainer.OnSoldierSpawned
	 * 		Flags  -> (Final, Native, Protected)
	 */
	void UHUDContextualHintContainer::OnSoldierSpawned()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.HUDContextualHintContainer.OnSoldierSpawned");
		
		UHUDContextualHintContainer_OnSoldierSpawned_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056635B0
	 * 		Name   -> Function Insurgency.HUDContextualHintContainer.OnResupplied
	 * 		Flags  -> (Final, Native, Protected)
	 * Parameters:
	 * 		class AINSSoldier*                                 Player                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UHUDContextualHintContainer::OnResupplied(class AINSSoldier* Player)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.HUDContextualHintContainer.OnResupplied");
		
		UHUDContextualHintContainer_OnResupplied_Params params {};
		params.Player = Player;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056634D0
	 * 		Name   -> Function Insurgency.HUDContextualHintContainer.OnItemAddedToInventory
	 * 		Flags  -> (Final, Native, Protected)
	 * Parameters:
	 * 		class AINSSoldier*                                 Soldier                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AItemBase*                                   Item                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UHUDContextualHintContainer::OnItemAddedToInventory(class AINSSoldier* Soldier, class AItemBase* Item)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.HUDContextualHintContainer.OnItemAddedToInventory");
		
		UHUDContextualHintContainer_OnItemAddedToInventory_Params params {};
		params.Soldier = Soldier;
		params.Item = Item;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05663590
	 * 		Name   -> Function Insurgency.HUDContextualHintContainer.OnInventoryChanged
	 * 		Flags  -> (Final, Native, Protected)
	 */
	void UHUDContextualHintContainer::OnInventoryChanged()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.HUDContextualHintContainer.OnInventoryChanged");
		
		UHUDContextualHintContainer_OnInventoryChanged_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056634D0
	 * 		Name   -> Function Insurgency.HUDContextualHintContainer.OnChangedWeapon
	 * 		Flags  -> (Final, Native, Protected)
	 * Parameters:
	 * 		class AItemEquipable*                              NewItem                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AItemEquipable*                              PreviousItem                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UHUDContextualHintContainer::OnChangedWeapon(class AItemEquipable* NewItem, class AItemEquipable* PreviousItem)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.HUDContextualHintContainer.OnChangedWeapon");
		
		UHUDContextualHintContainer_OnChangedWeapon_Params params {};
		params.NewItem = NewItem;
		params.PreviousItem = PreviousItem;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056634B0
	 * 		Name   -> Function Insurgency.HUDContextualHintContainer.HideHints
	 * 		Flags  -> (Final, Native, Protected)
	 */
	void UHUDContextualHintContainer::HideHints()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.HUDContextualHintContainer.HideHints");
		
		UHUDContextualHintContainer_HideHints_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05663480
	 * 		Name   -> Function Insurgency.HUDContextualHintContainer.GetFadeOutAnimation
	 * 		Flags  -> (Native, Event, Protected, BlueprintEvent, Const)
	 */
	class UWidgetAnimation* UHUDContextualHintContainer::GetFadeOutAnimation()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.HUDContextualHintContainer.GetFadeOutAnimation");
		
		UHUDContextualHintContainer_GetFadeOutAnimation_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05663450
	 * 		Name   -> Function Insurgency.HUDContextualHintContainer.GetFadeInAnimation
	 * 		Flags  -> (Native, Event, Protected, BlueprintEvent, Const)
	 */
	class UWidgetAnimation* UHUDContextualHintContainer::GetFadeInAnimation()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.HUDContextualHintContainer.GetFadeInAnimation");
		
		UHUDContextualHintContainer_GetFadeInAnimation_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05663370
	 * 		Name   -> Function Insurgency.HUDContextualHintContainer.GetAssets
	 * 		Flags  -> (Native, Event, Protected, HasOutParms, BlueprintEvent)
	 * Parameters:
	 * 		EAssetName                                         AssetName                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FChildAsset                                 Asset                                                      (Parm, OutParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	void UHUDContextualHintContainer::GetAssets(EAssetName AssetName, struct FChildAsset* Asset)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.HUDContextualHintContainer.GetAssets");
		
		UHUDContextualHintContainer_GetAssets_Params params {};
		params.AssetName = AssetName;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (Asset != nullptr)
			*Asset = params.Asset;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UHUDContextualHintContainer.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UHUDContextualHintContainer::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.HUDContextualHintContainer");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05663A30
	 * 		Name   -> Function Insurgency.HUDMultiplayer.StartTeamChatInput
	 * 		Flags  -> (Final, Native, Public)
	 */
	void AHUDMultiplayer::StartTeamChatInput()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.HUDMultiplayer.StartTeamChatInput");
		
		AHUDMultiplayer_StartTeamChatInput_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05663A10
	 * 		Name   -> Function Insurgency.HUDMultiplayer.StartGlobalChatInput
	 * 		Flags  -> (Final, Native, Public)
	 */
	void AHUDMultiplayer::StartGlobalChatInput()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.HUDMultiplayer.StartGlobalChatInput");
		
		AHUDMultiplayer_StartGlobalChatInput_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05663980
	 * 		Name   -> Function Insurgency.HUDMultiplayer.StartChatInput
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bTeamOnly                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AHUDMultiplayer::StartChatInput(bool bTeamOnly)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.HUDMultiplayer.StartChatInput");
		
		AHUDMultiplayer_StartChatInput_Params params {};
		params.bTeamOnly = bTeamOnly;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AHUDMultiplayer.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AHUDMultiplayer::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.HUDMultiplayer");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05663CA0
	 * 		Name   -> Function Insurgency.HUDReplay.ToggleControls
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void AHUDReplay::ToggleControls()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.HUDReplay.ToggleControls");
		
		AHUDReplay_ToggleControls_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05663C80
	 * 		Name   -> Function Insurgency.HUDReplay.ShowControls
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void AHUDReplay::ShowControls()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.HUDReplay.ShowControls");
		
		AHUDReplay_ShowControls_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> DelegateFunction Insurgency.HUDReplay.ReplayControlsToggled__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 * Parameters:
	 * 		bool                                               bState                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AHUDReplay::ReplayControlsToggled__DelegateSignature(bool bState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction Insurgency.HUDReplay.ReplayControlsToggled__DelegateSignature");
		
		AHUDReplay_ReplayControlsToggled__DelegateSignature_Params params {};
		params.bState = bState;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05663C60
	 * 		Name   -> Function Insurgency.HUDReplay.HideControls
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void AHUDReplay::HideControls()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.HUDReplay.HideControls");
		
		AHUDReplay_HideControls_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AHUDReplay.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AHUDReplay::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.HUDReplay");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> Function Insurgency.InGameMenuWidget.OnPanelOpened
	 * 		Flags  -> (Event, Public, BlueprintCallable, BlueprintEvent)
	 * Parameters:
	 * 		EIngameMenuType                                    DesiredMenu                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EIngameMenuEntryState                              FromState                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UInGameMenuWidget::OnPanelOpened(EIngameMenuType DesiredMenu, EIngameMenuEntryState FromState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.InGameMenuWidget.OnPanelOpened");
		
		UInGameMenuWidget_OnPanelOpened_Params params {};
		params.DesiredMenu = DesiredMenu;
		params.FromState = FromState;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> Function Insurgency.InGameMenuWidget.OnHidePanel
	 * 		Flags  -> (Event, Public, BlueprintCallable, BlueprintEvent)
	 */
	void UInGameMenuWidget::OnHidePanel()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.InGameMenuWidget.OnHidePanel");
		
		UInGameMenuWidget_OnHidePanel_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UInGameMenuWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UInGameMenuWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.InGameMenuWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AINSAIDebugHUD.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AINSAIDebugHUD::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.INSAIDebugHUD");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056660F0
	 * 		Name   -> Function Insurgency.INSAIDirector.UpdateInvestigations
	 * 		Flags  -> (Final, Native, Private)
	 */
	void UINSAIDirector::UpdateInvestigations()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSAIDirector.UpdateInvestigations");
		
		UINSAIDirector_UpdateInvestigations_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056660D0
	 * 		Name   -> Function Insurgency.INSAIDirector.ToggleAIPerception
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void UINSAIDirector::ToggleAIPerception()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSAIDirector.ToggleAIPerception");
		
		UINSAIDirector_ToggleAIPerception_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05665EF0
	 * 		Name   -> Function Insurgency.INSAIDirector.SpawnFakeClient
	 * 		Flags  -> (Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class ATeamInfo*                                   Faction                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UClass*                                      PawnClass                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UClass*                                      AIControllerClass                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		TArray<class UPlayerClass*>                        PlayerClasses                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bWantsPlayerState                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class AINSAISoldierController* UINSAIDirector::SpawnFakeClient(class ATeamInfo* Faction, class UClass* PawnClass, class UClass* AIControllerClass, TArray<class UPlayerClass*> PlayerClasses, bool bWantsPlayerState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSAIDirector.SpawnFakeClient");
		
		UINSAIDirector_SpawnFakeClient_Params params {};
		params.Faction = Faction;
		params.PawnClass = PawnClass;
		params.AIControllerClass = AIControllerClass;
		params.PlayerClasses = PlayerClasses;
		params.bWantsPlayerState = bWantsPlayerState;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05665D20
	 * 		Name   -> Function Insurgency.INSAIDirector.SpawnBot
	 * 		Flags  -> (Native, Public, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		class ATeamInfo*                                   Faction                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UClass*                                      PawnClass                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     Location                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bWantsPlayerState                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UPlayerClass*                                BotClass                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class AINSAISoldierController* UINSAIDirector::SpawnBot(class ATeamInfo* Faction, class UClass* PawnClass, const struct FVector& Location, bool bWantsPlayerState, class UPlayerClass* BotClass)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSAIDirector.SpawnBot");
		
		UINSAIDirector_SpawnBot_Params params {};
		params.Faction = Faction;
		params.PawnClass = PawnClass;
		params.Location = Location;
		params.bWantsPlayerState = bWantsPlayerState;
		params.BotClass = BotClass;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05665C90
	 * 		Name   -> Function Insurgency.INSAIDirector.SetTargetPlayers
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bState                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UINSAIDirector::SetTargetPlayers(bool bState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSAIDirector.SetTargetPlayers");
		
		UINSAIDirector_SetTargetPlayers_Params params {};
		params.bState = bState;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05665C00
	 * 		Name   -> Function Insurgency.INSAIDirector.SetAINeutral
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bState                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UINSAIDirector::SetAINeutral(bool bState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSAIDirector.SetAINeutral");
		
		UINSAIDirector_SetAINeutral_Params params {};
		params.bState = bState;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05665B70
	 * 		Name   -> Function Insurgency.INSAIDirector.SetAIEnabled
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bState                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UINSAIDirector::SetAIEnabled(bool bState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSAIDirector.SetAIEnabled");
		
		UINSAIDirector_SetAIEnabled_Params params {};
		params.bState = bState;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05665AF0
	 * 		Name   -> Function Insurgency.INSAIDirector.SetAIDifficulty
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		float                                              NewDifficulty                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UINSAIDirector::SetAIDifficulty(float NewDifficulty)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSAIDirector.SetAIDifficulty");
		
		UINSAIDirector_SetAIDifficulty_Params params {};
		params.NewDifficulty = NewDifficulty;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05665A60
	 * 		Name   -> Function Insurgency.INSAIDirector.RoundWon
	 * 		Flags  -> (Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bAttackers                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UINSAIDirector::RoundWon(bool bAttackers)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSAIDirector.RoundWon");
		
		UINSAIDirector_RoundWon_Params params {};
		params.bAttackers = bAttackers;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056659C0
	 * 		Name   -> Function Insurgency.INSAIDirector.IsInRadiusOfBurningGrenade
	 * 		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FVector                                     Location                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UINSAIDirector::IsInRadiusOfBurningGrenade(const struct FVector& Location)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSAIDirector.IsInRadiusOfBurningGrenade");
		
		UINSAIDirector_IsInRadiusOfBurningGrenade_Params params {};
		params.Location = Location;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05665990
	 * 		Name   -> Function Insurgency.INSAIDirector.IsAIPerceptionEnabled
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool UINSAIDirector::IsAIPerceptionEnabled()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSAIDirector.IsAIPerceptionEnabled");
		
		UINSAIDirector_IsAIPerceptionEnabled_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05665960
	 * 		Name   -> Function Insurgency.INSAIDirector.IsAINeutral
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool UINSAIDirector::IsAINeutral()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSAIDirector.IsAINeutral");
		
		UINSAIDirector_IsAINeutral_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05665930
	 * 		Name   -> Function Insurgency.INSAIDirector.IsAIEnabled
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool UINSAIDirector::IsAIEnabled()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSAIDirector.IsAIEnabled");
		
		UINSAIDirector_IsAIEnabled_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05665870
	 * 		Name   -> Function Insurgency.INSAIDirector.GetSpawnedBots
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
	 */
	TArray<class AINSAISoldierController*> UINSAIDirector::GetSpawnedBots()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSAIDirector.GetSpawnedBots");
		
		UINSAIDirector_GetSpawnedBots_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056657E0
	 * 		Name   -> Function Insurgency.INSAIDirector.GetGrenadeTargets
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
	 */
	TArray<struct FBotGrenadeTarget> UINSAIDirector::GetGrenadeTargets()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSAIDirector.GetGrenadeTargets");
		
		UINSAIDirector_GetGrenadeTargets_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05665760
	 * 		Name   -> Function Insurgency.INSAIDirector.GetDoors
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
	 */
	TArray<class ADoor*> UINSAIDirector::GetDoors()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSAIDirector.GetDoors");
		
		UINSAIDirector_GetDoors_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056656E0
	 * 		Name   -> Function Insurgency.INSAIDirector.GetAllSquads
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
	 */
	TArray<class UINSAISquad*> UINSAIDirector::GetAllSquads()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSAIDirector.GetAllSquads");
		
		UINSAIDirector_GetAllSquads_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05665600
	 * 		Name   -> Function Insurgency.INSAIDirector.GetAllCoverPoints
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bOccupiedOnly                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	TArray<class UCoverComponent*> UINSAIDirector::GetAllCoverPoints(bool bOccupiedOnly)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSAIDirector.GetAllCoverPoints");
		
		UINSAIDirector_GetAllCoverPoints_Params params {};
		params.bOccupiedOnly = bOccupiedOnly;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056654E0
	 * 		Name   -> Function Insurgency.INSAIDirector.GetAIDifficulty
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	float UINSAIDirector::GetAIDifficulty()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSAIDirector.GetAIDifficulty");
		
		UINSAIDirector_GetAIDifficulty_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05665580
	 * 		Name   -> Function Insurgency.INSAIDirector.GetActiveGrenades
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	TArray<class AProjectileGrenade*> UINSAIDirector::GetActiveGrenades()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSAIDirector.GetActiveGrenades");
		
		UINSAIDirector_GetActiveGrenades_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05665500
	 * 		Name   -> Function Insurgency.INSAIDirector.GetActiveAndBurningGrenades
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	TArray<class AProjectileGrenade*> UINSAIDirector::GetActiveAndBurningGrenades()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSAIDirector.GetActiveAndBurningGrenades");
		
		UINSAIDirector_GetActiveAndBurningGrenades_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056653B0
	 * 		Name   -> Function Insurgency.INSAIDirector.FindBestCoverFromLocation
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class AINSAISoldierController*                     Me                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FCoverSearchParams                          SearchParams                                               (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	class UCoverComponent* UINSAIDirector::FindBestCoverFromLocation(class AINSAISoldierController* Me, const struct FCoverSearchParams& SearchParams)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSAIDirector.FindBestCoverFromLocation");
		
		UINSAIDirector_FindBestCoverFromLocation_Params params {};
		params.Me = Me;
		params.SearchParams = SearchParams;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05665230
	 * 		Name   -> Function Insurgency.INSAIDirector.EQS_GenerateSpawn
	 * 		Flags  -> (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		class AINSSoldier*                                 Soldier                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     GenerationLocation                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     OutSpawnLocation                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bTesting                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UINSAIDirector::EQS_GenerateSpawn(class AINSSoldier* Soldier, const struct FVector& GenerationLocation, struct FVector* OutSpawnLocation, bool bTesting)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSAIDirector.EQS_GenerateSpawn");
		
		UINSAIDirector_EQS_GenerateSpawn_Params params {};
		params.Soldier = Soldier;
		params.GenerationLocation = GenerationLocation;
		params.bTesting = bTesting;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutSpawnLocation != nullptr)
			*OutSpawnLocation = params.OutSpawnLocation;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05665100
	 * 		Name   -> Function Insurgency.INSAIDirector.EQS_FindOutdoorLocation
	 * 		Flags  -> (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FVector                                     Location                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Radius                                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     OutdoorLocation                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UINSAIDirector::EQS_FindOutdoorLocation(const struct FVector& Location, float Radius, struct FVector* OutdoorLocation)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSAIDirector.EQS_FindOutdoorLocation");
		
		UINSAIDirector_EQS_FindOutdoorLocation_Params params {};
		params.Location = Location;
		params.Radius = Radius;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutdoorLocation != nullptr)
			*OutdoorLocation = params.OutdoorLocation;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05665000
	 * 		Name   -> Function Insurgency.INSAIDirector.EQS_FindNavigatableLocationWithLOS
	 * 		Flags  -> (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FVector                                     LOSLocation                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     OutLocation                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UINSAIDirector::EQS_FindNavigatableLocationWithLOS(const struct FVector& LOSLocation, struct FVector* OutLocation)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSAIDirector.EQS_FindNavigatableLocationWithLOS");
		
		UINSAIDirector_EQS_FindNavigatableLocationWithLOS_Params params {};
		params.LOSLocation = LOSLocation;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutLocation != nullptr)
			*OutLocation = params.OutLocation;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05664EF0
	 * 		Name   -> Function Insurgency.INSAIDirector.EQS_FindInvestigation
	 * 		Flags  -> (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		class AINSSoldier*                                 Soldier                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UBotInvestigation*                           Investigation                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     OutInvestigateLocation                                     (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UINSAIDirector::EQS_FindInvestigation(class AINSSoldier* Soldier, class UBotInvestigation* Investigation, struct FVector* OutInvestigateLocation)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSAIDirector.EQS_FindInvestigation");
		
		UINSAIDirector_EQS_FindInvestigation_Params params {};
		params.Soldier = Soldier;
		params.Investigation = Investigation;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutInvestigateLocation != nullptr)
			*OutInvestigateLocation = params.OutInvestigateLocation;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05664E10
	 * 		Name   -> Function Insurgency.INSAIDirector.EQS_FindFlank
	 * 		Flags  -> (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		class AINSSoldier*                                 Soldier                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     OutFlankLocation                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UINSAIDirector::EQS_FindFlank(class AINSSoldier* Soldier, struct FVector* OutFlankLocation)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSAIDirector.EQS_FindFlank");
		
		UINSAIDirector_EQS_FindFlank_Params params {};
		params.Soldier = Soldier;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutFlankLocation != nullptr)
			*OutFlankLocation = params.OutFlankLocation;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05664CB0
	 * 		Name   -> Function Insurgency.INSAIDirector.EQS_FindCover
	 * 		Flags  -> (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		class AINSSoldier*                                 Soldier                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FCoverSearchParams                          SearchParams                                               (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     OutCoverLocation                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UINSAIDirector::EQS_FindCover(class AINSSoldier* Soldier, const struct FCoverSearchParams& SearchParams, struct FVector* OutCoverLocation)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSAIDirector.EQS_FindCover");
		
		UINSAIDirector_EQS_FindCover_Params params {};
		params.Soldier = Soldier;
		params.SearchParams = SearchParams;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutCoverLocation != nullptr)
			*OutCoverLocation = params.OutCoverLocation;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05664BA0
	 * 		Name   -> Function Insurgency.INSAIDirector.ClearCoverForBot
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class AINSAISoldierController*                     Bot                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FName                                        ReasonForClearing                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bAvoidBriefly                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UINSAIDirector::ClearCoverForBot(class AINSAISoldierController* Bot, const class FName& ReasonForClearing, bool bAvoidBriefly)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSAIDirector.ClearCoverForBot");
		
		UINSAIDirector_ClearCoverForBot_Params params {};
		params.Bot = Bot;
		params.ReasonForClearing = ReasonForClearing;
		params.bAvoidBriefly = bAvoidBriefly;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05664B70
	 * 		Name   -> Function Insurgency.INSAIDirector.CanTargetPlayers
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool UINSAIDirector::CanTargetPlayers()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSAIDirector.CanTargetPlayers");
		
		UINSAIDirector_CanTargetPlayers_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05664AB0
	 * 		Name   -> Function Insurgency.INSAIDirector.AssignCoverToBot
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class AINSAISoldierController*                     Bot                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UCoverComponent*                             Cover                                                      (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UINSAIDirector::AssignCoverToBot(class AINSAISoldierController* Bot, class UCoverComponent* Cover)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSAIDirector.AssignCoverToBot");
		
		UINSAIDirector_AssignCoverToBot_Params params {};
		params.Bot = Bot;
		params.Cover = Cover;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056649E0
	 * 		Name   -> Function Insurgency.INSAIDirector.AddOrphanedBotsToNearbySquads
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		bool                                               bForceMove                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              SearchRadius                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UINSAIDirector::AddOrphanedBotsToNearbySquads(bool bForceMove, float SearchRadius)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSAIDirector.AddOrphanedBotsToNearbySquads");
		
		UINSAIDirector_AddOrphanedBotsToNearbySquads_Params params {};
		params.bForceMove = bForceMove;
		params.SearchRadius = SearchRadius;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UINSAIDirector.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UINSAIDirector::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.INSAIDirector");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05667120
	 * 		Name   -> Function Insurgency.BotInvestigation.GetTimeUntilFinished
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
	 */
	float UBotInvestigation::GetTimeUntilFinished()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.BotInvestigation.GetTimeUntilFinished");
		
		UBotInvestigation_GetTimeUntilFinished_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056670F0
	 * 		Name   -> Function Insurgency.BotInvestigation.GetTimeSinceStarted
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
	 */
	float UBotInvestigation::GetTimeSinceStarted()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.BotInvestigation.GetTimeSinceStarted");
		
		UBotInvestigation_GetTimeSinceStarted_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UBotInvestigation.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UBotInvestigation::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.BotInvestigation");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UModifiedNavArea.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UModifiedNavArea::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.ModifiedNavArea");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05667740
	 * 		Name   -> Function Insurgency.INSAIPerception.SeePawn
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		class APawn*                                       SeenPawn                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UINSAIPerception::SeePawn(class APawn* SeenPawn)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSAIPerception.SeePawn");
		
		UINSAIPerception_SeePawn_Params params {};
		params.SeenPawn = SeenPawn;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056675C0
	 * 		Name   -> Function Insurgency.INSAIPerception.OnTargetPerceptionUpdate
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		class AActor*                                      TriggeringActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FAIStimulus                                 Stimulus                                                   (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UINSAIPerception::OnTargetPerceptionUpdate(class AActor* TriggeringActor, const struct FAIStimulus& Stimulus)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSAIPerception.OnTargetPerceptionUpdate");
		
		UINSAIPerception_OnTargetPerceptionUpdate_Params params {};
		params.TriggeringActor = TriggeringActor;
		params.Stimulus = Stimulus;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056674C0
	 * 		Name   -> Function Insurgency.INSAIPerception.Initialize
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class AINSAISoldierController*                     BotController                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UBotMemoryHandler*                           BotMemory                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UAIPerceptionComponent*                      Perception                                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UINSAIPerception::Initialize(class AINSAISoldierController* BotController, class UBotMemoryHandler* BotMemory, class UAIPerceptionComponent* Perception)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSAIPerception.Initialize");
		
		UINSAIPerception_Initialize_Params params {};
		params.BotController = BotController;
		params.BotMemory = BotMemory;
		params.Perception = Perception;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05667360
	 * 		Name   -> Function Insurgency.INSAIPerception.HearPawn
	 * 		Flags  -> (Final, Native, Public, HasOutParms, HasDefaults)
	 * Parameters:
	 * 		class APawn*                                       HeardPawn                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     Location                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Distance                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bHasLOS                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UINSAIPerception::HearPawn(class APawn* HeardPawn, const struct FVector& Location, float Distance, bool bHasLOS)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSAIPerception.HearPawn");
		
		UINSAIPerception_HearPawn_Params params {};
		params.HeardPawn = HeardPawn;
		params.Location = Location;
		params.Distance = Distance;
		params.bHasLOS = bHasLOS;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UINSAIPerception.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UINSAIPerception::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.INSAIPerception");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05669A70
	 * 		Name   -> Function Insurgency.INSAISoldierController.ToggleMovement
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bEnabled                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSAISoldierController::ToggleMovement(bool bEnabled)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSAISoldierController.ToggleMovement");
		
		AINSAISoldierController_ToggleMovement_Params params {};
		params.bEnabled = bEnabled;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05669A50
	 * 		Name   -> Function Insurgency.INSAISoldierController.StopFiring
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void AINSAISoldierController::StopFiring()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSAISoldierController.StopFiring");
		
		AINSAISoldierController_StopFiring_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05669A30
	 * 		Name   -> Function Insurgency.INSAISoldierController.StartFiringAtFocalPoint
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void AINSAISoldierController::StartFiringAtFocalPoint()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSAISoldierController.StartFiringAtFocalPoint");
		
		AINSAISoldierController_StartFiringAtFocalPoint_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056699A0
	 * 		Name   -> Function Insurgency.INSAISoldierController.Sidestep
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		float                                              Cooldown                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool AINSAISoldierController::Sidestep(float Cooldown)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSAISoldierController.Sidestep");
		
		AINSAISoldierController_Sidestep_Params params {};
		params.Cooldown = Cooldown;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05669920
	 * 		Name   -> Function Insurgency.INSAISoldierController.SetDesiredStance
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		ESoldierStance                                     NewStance                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSAISoldierController::SetDesiredStance(ESoldierStance NewStance)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSAISoldierController.SetDesiredStance");
		
		AINSAISoldierController_SetDesiredStance_Params params {};
		params.NewStance = NewStance;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05669890
	 * 		Name   -> Function Insurgency.INSAISoldierController.SetAIEnabled
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bEnabled                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSAISoldierController::SetAIEnabled(bool bEnabled)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSAISoldierController.SetAIEnabled");
		
		AINSAISoldierController_SetAIEnabled_Params params {};
		params.bEnabled = bEnabled;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x04F23800
	 * 		Name   -> Function Insurgency.INSAISoldierController.SeePawn
	 * 		Flags  -> (Final, Native, Private)
	 * Parameters:
	 * 		class APawn*                                       OtherPawn                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSAISoldierController::SeePawn(class APawn* OtherPawn)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSAISoldierController.SeePawn");
		
		AINSAISoldierController_SeePawn_Params params {};
		params.OtherPawn = OtherPawn;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> Function Insurgency.INSAISoldierController.OnTargetSpotted
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		class UBotKnownTargetMemory*                       Target                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSAISoldierController::OnTargetSpotted(class UBotKnownTargetMemory* Target)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSAISoldierController.OnTargetSpotted");
		
		AINSAISoldierController_OnTargetSpotted_Params params {};
		params.Target = Target;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> Function Insurgency.INSAISoldierController.OnTargetLostLOS
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		class UBotKnownTargetMemory*                       Target                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSAISoldierController::OnTargetLostLOS(class UBotKnownTargetMemory* Target)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSAISoldierController.OnTargetLostLOS");
		
		AINSAISoldierController_OnTargetLostLOS_Params params {};
		params.Target = Target;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> Function Insurgency.INSAISoldierController.OnTargetKilled
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		class UBotKnownTargetMemory*                       Target                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSAISoldierController::OnTargetKilled(class UBotKnownTargetMemory* Target)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSAISoldierController.OnTargetKilled");
		
		AINSAISoldierController_OnTargetKilled_Params params {};
		params.Target = Target;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> Function Insurgency.INSAISoldierController.OnTargetGainedLOS
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		class UBotKnownTargetMemory*                       Target                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSAISoldierController::OnTargetGainedLOS(class UBotKnownTargetMemory* Target)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSAISoldierController.OnTargetGainedLOS");
		
		AINSAISoldierController_OnTargetGainedLOS_Params params {};
		params.Target = Target;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> Function Insurgency.INSAISoldierController.OnSquadMemberKilled
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		class AINSSoldier*                                 KilledSoldier                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bWasSquadLeader                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSAISoldierController::OnSquadMemberKilled(class AINSSoldier* KilledSoldier, bool bWasSquadLeader)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSAISoldierController.OnSquadMemberKilled");
		
		AINSAISoldierController_OnSquadMemberKilled_Params params {};
		params.KilledSoldier = KilledSoldier;
		params.bWasSquadLeader = bWasSquadLeader;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> Function Insurgency.INSAISoldierController.OnFriendlyLeftFiringAngle
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 */
	void AINSAISoldierController::OnFriendlyLeftFiringAngle()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSAISoldierController.OnFriendlyLeftFiringAngle");
		
		AINSAISoldierController_OnFriendlyLeftFiringAngle_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> Function Insurgency.INSAISoldierController.OnFriendlyInFiringAngle
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 */
	void AINSAISoldierController::OnFriendlyInFiringAngle()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSAISoldierController.OnFriendlyInFiringAngle");
		
		AINSAISoldierController_OnFriendlyInFiringAngle_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> Function Insurgency.INSAISoldierController.OnFinishedPatrol
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 */
	void AINSAISoldierController::OnFinishedPatrol()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSAISoldierController.OnFinishedPatrol");
		
		AINSAISoldierController_OnFinishedPatrol_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> Function Insurgency.INSAISoldierController.OnAIStateChange
	 * 		Flags  -> (Event, Public, HasOutParms, BlueprintEvent)
	 * Parameters:
	 * 		EAIControllerState                                 OldState                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EAIControllerState                                 NewState                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSAISoldierController::OnAIStateChange(EAIControllerState* OldState, EAIControllerState* NewState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSAISoldierController.OnAIStateChange");
		
		AINSAISoldierController_OnAIStateChange_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OldState != nullptr)
			*OldState = params.OldState;
		if (NewState != nullptr)
			*NewState = params.NewState;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05669670
	 * 		Name   -> Function Insurgency.INSAISoldierController.MoveToOverride
	 * 		Flags  -> (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FVector                                     Destination                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EAIDesiredLocomotion                               MoveType                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		ESoldierStance                                     Stance                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EAIDesiredLocomotionPriority                       Priority                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bIgnoreDeathAreas                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              AcceptRadius                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bAllowPartialPath                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	EPathFollowingRequestResult AINSAISoldierController::MoveToOverride(const struct FVector& Destination, EAIDesiredLocomotion MoveType, ESoldierStance Stance, EAIDesiredLocomotionPriority Priority, bool bIgnoreDeathAreas, float AcceptRadius, bool bAllowPartialPath)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSAISoldierController.MoveToOverride");
		
		AINSAISoldierController_MoveToOverride_Params params {};
		params.Destination = Destination;
		params.MoveType = MoveType;
		params.Stance = Stance;
		params.Priority = Priority;
		params.bIgnoreDeathAreas = bIgnoreDeathAreas;
		params.AcceptRadius = AcceptRadius;
		params.bAllowPartialPath = bAllowPartialPath;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05669400
	 * 		Name   -> Function Insurgency.INSAISoldierController.MoveToLocationSafe
	 * 		Flags  -> (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FVector                                     Destination                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FString                                      Reason                                                     (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EAIDesiredLocomotion                               MoveType                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		ESoldierStance                                     Stance                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EAIDesiredLocomotionPriority                       Priority                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bIgnoreDeathAreas                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              AcceptRadius                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bAllowPartialPath                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	EPathFollowingRequestResult AINSAISoldierController::MoveToLocationSafe(const struct FVector& Destination, const class FString& Reason, EAIDesiredLocomotion MoveType, ESoldierStance Stance, EAIDesiredLocomotionPriority Priority, bool bIgnoreDeathAreas, float AcceptRadius, bool bAllowPartialPath)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSAISoldierController.MoveToLocationSafe");
		
		AINSAISoldierController_MoveToLocationSafe_Params params {};
		params.Destination = Destination;
		params.Reason = Reason;
		params.MoveType = MoveType;
		params.Stance = Stance;
		params.Priority = Priority;
		params.bIgnoreDeathAreas = bIgnoreDeathAreas;
		params.AcceptRadius = AcceptRadius;
		params.bAllowPartialPath = bAllowPartialPath;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056691A0
	 * 		Name   -> Function Insurgency.INSAISoldierController.MoveToActorSafe
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class AActor*                                      DestinationActor                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FString                                      Reason                                                     (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EAIDesiredLocomotion                               MoveType                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		ESoldierStance                                     Stance                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EAIDesiredLocomotionPriority                       Priority                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bIgnoreDeathAreas                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              AcceptRadius                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bAllowPartialPath                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	EPathFollowingRequestResult AINSAISoldierController::MoveToActorSafe(class AActor* DestinationActor, const class FString& Reason, EAIDesiredLocomotion MoveType, ESoldierStance Stance, EAIDesiredLocomotionPriority Priority, bool bIgnoreDeathAreas, float AcceptRadius, bool bAllowPartialPath)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSAISoldierController.MoveToActorSafe");
		
		AINSAISoldierController_MoveToActorSafe_Params params {};
		params.DestinationActor = DestinationActor;
		params.Reason = Reason;
		params.MoveType = MoveType;
		params.Stance = Stance;
		params.Priority = Priority;
		params.bIgnoreDeathAreas = bIgnoreDeathAreas;
		params.AcceptRadius = AcceptRadius;
		params.bAllowPartialPath = bAllowPartialPath;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05669010
	 * 		Name   -> Function Insurgency.INSAISoldierController.LookAtLocation
	 * 		Flags  -> (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FVector                                     Location                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EAIDesiredLookAtPriority                           Priority                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FString                                      LookReason                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Duration                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool AINSAISoldierController::LookAtLocation(const struct FVector& Location, EAIDesiredLookAtPriority Priority, const class FString& LookReason, float Duration)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSAISoldierController.LookAtLocation");
		
		AINSAISoldierController_LookAtLocation_Params params {};
		params.Location = Location;
		params.Priority = Priority;
		params.LookReason = LookReason;
		params.Duration = Duration;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05668EB0
	 * 		Name   -> Function Insurgency.INSAISoldierController.LookAtActor
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class AActor*                                      Actor                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EAIDesiredLookAtPriority                           Priority                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FString                                      LookReason                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Duration                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool AINSAISoldierController::LookAtActor(class AActor* Actor, EAIDesiredLookAtPriority Priority, const class FString& LookReason, float Duration)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSAISoldierController.LookAtActor");
		
		AINSAISoldierController_LookAtActor_Params params {};
		params.Actor = Actor;
		params.Priority = Priority;
		params.LookReason = LookReason;
		params.Duration = Duration;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05668DD0
	 * 		Name   -> Function Insurgency.INSAISoldierController.LineOfSightToLocation
	 * 		Flags  -> (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		struct FVector                                     Location                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bShowDebug                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool AINSAISoldierController::LineOfSightToLocation(const struct FVector& Location, bool bShowDebug)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSAISoldierController.LineOfSightToLocation");
		
		AINSAISoldierController_LineOfSightToLocation_Params params {};
		params.Location = Location;
		params.bShowDebug = bShowDebug;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05668D40
	 * 		Name   -> Function Insurgency.INSAISoldierController.IsTeamMate
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		class AINSSoldier*                                 Target                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool AINSAISoldierController::IsTeamMate(class AINSSoldier* Target)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSAISoldierController.IsTeamMate");
		
		AINSAISoldierController_IsTeamMate_Params params {};
		params.Target = Target;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05668C70
	 * 		Name   -> Function Insurgency.INSAISoldierController.IsTargetFacingMe
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class UBotKnownTargetMemory*                       Target                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              AngleThreshold                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool AINSAISoldierController::IsTargetFacingMe(class UBotKnownTargetMemory* Target, float AngleThreshold)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSAISoldierController.IsTargetFacingMe");
		
		AINSAISoldierController_IsTargetFacingMe_Params params {};
		params.Target = Target;
		params.AngleThreshold = AngleThreshold;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05668C40
	 * 		Name   -> Function Insurgency.INSAISoldierController.IsSquadLeader
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AINSAISoldierController::IsSquadLeader()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSAISoldierController.IsSquadLeader");
		
		AINSAISoldierController_IsSquadLeader_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05668BA0
	 * 		Name   -> Function Insurgency.INSAISoldierController.IsSmokeBlockingVisionToLocation
	 * 		Flags  -> (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		struct FVector                                     Location                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool AINSAISoldierController::IsSmokeBlockingVisionToLocation(const struct FVector& Location)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSAISoldierController.IsSmokeBlockingVisionToLocation");
		
		AINSAISoldierController_IsSmokeBlockingVisionToLocation_Params params {};
		params.Location = Location;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05668B70
	 * 		Name   -> Function Insurgency.INSAISoldierController.IsFriendlyInFiringLine
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AINSAISoldierController::IsFriendlyInFiringLine()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSAISoldierController.IsFriendlyInFiringLine");
		
		AINSAISoldierController_IsFriendlyInFiringLine_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05668AE0
	 * 		Name   -> Function Insurgency.INSAISoldierController.IsFriendlyInFiringAngle
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		float                                              AngleThreshold                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool AINSAISoldierController::IsFriendlyInFiringAngle(float AngleThreshold)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSAISoldierController.IsFriendlyInFiringAngle");
		
		AINSAISoldierController_IsFriendlyInFiringAngle_Params params {};
		params.AngleThreshold = AngleThreshold;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05668AB0
	 * 		Name   -> Function Insurgency.INSAISoldierController.IsAIEnabled
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AINSAISoldierController::IsAIEnabled()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSAISoldierController.IsAIEnabled");
		
		AINSAISoldierController_IsAIEnabled_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05668950
	 * 		Name   -> Function Insurgency.INSAISoldierController.HearNoise
	 * 		Flags  -> (Final, Native, Private, HasOutParms, HasDefaults)
	 * Parameters:
	 * 		class APawn*                                       OtherActor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     Location                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Distance                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bHasLOS                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSAISoldierController::HearNoise(class APawn* OtherActor, const struct FVector& Location, float Distance, bool bHasLOS)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSAISoldierController.HearNoise");
		
		AINSAISoldierController_HearNoise_Params params {};
		params.OtherActor = OtherActor;
		params.Location = Location;
		params.Distance = Distance;
		params.bHasLOS = bHasLOS;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05668910
	 * 		Name   -> Function Insurgency.INSAISoldierController.GetTeamId
	 * 		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	unsigned char AINSAISoldierController::GetTeamId()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSAISoldierController.GetTeamId");
		
		AINSAISoldierController_GetTeamId_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056688E0
	 * 		Name   -> Function Insurgency.INSAISoldierController.GetSquadLeaderCover
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	class UCoverComponent* AINSAISoldierController::GetSquadLeaderCover()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSAISoldierController.GetSquadLeaderCover");
		
		AINSAISoldierController_GetSquadLeaderCover_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056688B0
	 * 		Name   -> Function Insurgency.INSAISoldierController.GetSquad
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	class UINSAISquad* AINSAISoldierController::GetSquad()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSAISoldierController.GetSquad");
		
		AINSAISoldierController_GetSquad_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05668880
	 * 		Name   -> Function Insurgency.INSAISoldierController.GetSoldier
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	class AINSSoldier* AINSAISoldierController::GetSoldier()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSAISoldierController.GetSoldier");
		
		AINSAISoldierController_GetSoldier_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05668860
	 * 		Name   -> Function Insurgency.INSAISoldierController.GetObjectives
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	class UBotObjectiveHandler* AINSAISoldierController::GetObjectives()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSAISoldierController.GetObjectives");
		
		AINSAISoldierController_GetObjectives_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05668840
	 * 		Name   -> Function Insurgency.INSAISoldierController.GetMovementHandler
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	class UBotMovementHandler* AINSAISoldierController::GetMovementHandler()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSAISoldierController.GetMovementHandler");
		
		AINSAISoldierController_GetMovementHandler_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05668820
	 * 		Name   -> Function Insurgency.INSAISoldierController.GetMood
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	class UBotMoodHandler* AINSAISoldierController::GetMood()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSAISoldierController.GetMood");
		
		AINSAISoldierController_GetMood_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05668800
	 * 		Name   -> Function Insurgency.INSAISoldierController.GetMemory
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	class UBotMemoryHandler* AINSAISoldierController::GetMemory()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSAISoldierController.GetMemory");
		
		AINSAISoldierController_GetMemory_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056687D0
	 * 		Name   -> Function Insurgency.INSAISoldierController.GetFirearm
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	class AItemFirearm* AINSAISoldierController::GetFirearm()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSAISoldierController.GetFirearm");
		
		AINSAISoldierController_GetFirearm_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056687B0
	 * 		Name   -> Function Insurgency.INSAISoldierController.GetDesiredLocomotionType
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
	 */
	EAIDesiredLocomotion AINSAISoldierController::GetDesiredLocomotionType()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSAISoldierController.GetDesiredLocomotionType");
		
		AINSAISoldierController_GetDesiredLocomotionType_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05668790
	 * 		Name   -> Function Insurgency.INSAISoldierController.GetCombatHandler
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	class UBotCombatHandler* AINSAISoldierController::GetCombatHandler()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSAISoldierController.GetCombatHandler");
		
		AINSAISoldierController_GetCombatHandler_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056686F0
	 * 		Name   -> Function Insurgency.INSAISoldierController.GetChanceToSpotTarget
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		class UBotKnownTargetMemory*                       Target                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	float AINSAISoldierController::GetChanceToSpotTarget(class UBotKnownTargetMemory* Target)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSAISoldierController.GetChanceToSpotTarget");
		
		AINSAISoldierController_GetChanceToSpotTarget_Params params {};
		params.Target = Target;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056686D0
	 * 		Name   -> Function Insurgency.INSAISoldierController.GetBehaviorHandler
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	class UBotBehaviorHandler* AINSAISoldierController::GetBehaviorHandler()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSAISoldierController.GetBehaviorHandler");
		
		AINSAISoldierController_GetBehaviorHandler_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05668630
	 * 		Name   -> Function Insurgency.INSAISoldierController.GetAngleToLocationFromEyeDirection
	 * 		Flags  -> (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		struct FVector                                     Location                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	float AINSAISoldierController::GetAngleToLocationFromEyeDirection(const struct FVector& Location)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSAISoldierController.GetAngleToLocationFromEyeDirection");
		
		AINSAISoldierController_GetAngleToLocationFromEyeDirection_Params params {};
		params.Location = Location;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x04DCFF00
	 * 		Name   -> Function Insurgency.INSAISoldierController.ForgetEverything
	 * 		Flags  -> (Native, Public, BlueprintCallable)
	 */
	void AINSAISoldierController::ForgetEverything()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSAISoldierController.ForgetEverything");
		
		AINSAISoldierController_ForgetEverything_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05668610
	 * 		Name   -> Function Insurgency.INSAISoldierController.ClearLookAt
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void AINSAISoldierController::ClearLookAt()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSAISoldierController.ClearLookAt");
		
		AINSAISoldierController_ClearLookAt_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056685E0
	 * 		Name   -> Function Insurgency.INSAISoldierController.CanSidestep
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AINSAISoldierController::CanSidestep()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSAISoldierController.CanSidestep");
		
		AINSAISoldierController_CanSidestep_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AINSAISoldierController.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AINSAISoldierController::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.INSAISoldierController");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0566B310
	 * 		Name   -> Function Insurgency.INSAIVehicleController.IsStuck
	 * 		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure)
	 */
	bool AINSAIVehicleController::IsStuck()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSAIVehicleController.IsStuck");
		
		AINSAIVehicleController_IsStuck_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0566B2E0
	 * 		Name   -> Function Insurgency.INSAIVehicleController.GetVehicle
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
	 */
	class AVehicleBase* AINSAIVehicleController::GetVehicle()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSAIVehicleController.GetVehicle");
		
		AINSAIVehicleController_GetVehicle_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0566B2C0
	 * 		Name   -> Function Insurgency.INSAIVehicleController.GetAISquad
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
	 */
	class UINSAISquad* AINSAIVehicleController::GetAISquad()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSAIVehicleController.GetAISquad");
		
		AINSAIVehicleController_GetAISquad_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AINSAIVehicleController.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AINSAIVehicleController::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.INSAIVehicleController");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AINSAISplineVehicleController.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AINSAISplineVehicleController::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.INSAISplineVehicleController");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0566AFA0
	 * 		Name   -> Function Insurgency.INSAISquad.UpdateMemberDestination
	 * 		Flags  -> (Final, Native, Public, HasOutParms, HasDefaults)
	 * Parameters:
	 * 		class AINSSoldier*                                 Soldier                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     Destination                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UINSAISquad::UpdateMemberDestination(class AINSSoldier* Soldier, const struct FVector& Destination)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSAISquad.UpdateMemberDestination");
		
		UINSAISquad_UpdateMemberDestination_Params params {};
		params.Soldier = Soldier;
		params.Destination = Destination;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0566AEE0
	 * 		Name   -> Function Insurgency.INSAISquad.RemovePawnFromSquad
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class AINSSoldier*                                 RemovedMember                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bWasDeath                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UINSAISquad::RemovePawnFromSquad(class AINSSoldier* RemovedMember, bool bWasDeath)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSAISquad.RemovePawnFromSquad");
		
		UINSAISquad_RemovePawnFromSquad_Params params {};
		params.RemovedMember = RemovedMember;
		params.bWasDeath = bWasDeath;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0566AE60
	 * 		Name   -> Function Insurgency.INSAISquad.PurgeInvestigation
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UBotInvestigation*                           Investigation                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UINSAISquad::PurgeInvestigation(class UBotInvestigation* Investigation)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSAISquad.PurgeInvestigation");
		
		UINSAISquad_PurgeInvestigation_Params params {};
		params.Investigation = Investigation;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0566ADA0
	 * 		Name   -> Function Insurgency.INSAISquad.OnSoldierReachedObjectiveEntrance
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		class AINSSoldier*                                 Soldier                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AEntranceZone*                               EntranceZone                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UINSAISquad::OnSoldierReachedObjectiveEntrance(class AINSSoldier* Soldier, class AEntranceZone* EntranceZone)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSAISquad.OnSoldierReachedObjectiveEntrance");
		
		UINSAISquad_OnSoldierReachedObjectiveEntrance_Params params {};
		params.Soldier = Soldier;
		params.EntranceZone = EntranceZone;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0566AD10
	 * 		Name   -> Function Insurgency.INSAISquad.IsSquadMemberPlayingDialogue
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		ECharacterResponse                                 Response                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UINSAISquad::IsSquadMemberPlayingDialogue(ECharacterResponse Response)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSAISquad.IsSquadMemberPlayingDialogue");
		
		UINSAISquad_IsSquadMemberPlayingDialogue_Params params {};
		params.Response = Response;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0566ACF0
	 * 		Name   -> Function Insurgency.INSAISquad.GetTeamId
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	int32_t UINSAISquad::GetTeamId()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSAISquad.GetTeamId");
		
		UINSAISquad_GetTeamId_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0566ACD0
	 * 		Name   -> Function Insurgency.INSAISquad.GetTargetObjectiveEntrance
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	class AEntranceZone* UINSAISquad::GetTargetObjectiveEntrance()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSAISquad.GetTargetObjectiveEntrance");
		
		UINSAISquad_GetTargetObjectiveEntrance_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0566ACB0
	 * 		Name   -> Function Insurgency.INSAISquad.GetTargetObjective
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	class AObjectiveBase* UINSAISquad::GetTargetObjective()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSAISquad.GetTargetObjective");
		
		UINSAISquad_GetTargetObjective_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0566AC20
	 * 		Name   -> Function Insurgency.INSAISquad.GetSquadPosition
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		class AINSSoldier*                                 Member                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	int32_t UINSAISquad::GetSquadPosition(class AINSSoldier* Member)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSAISquad.GetSquadPosition");
		
		UINSAISquad_GetSquadPosition_Params params {};
		params.Member = Member;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0566AA70
	 * 		Name   -> Function Insurgency.INSAISquad.GetSquadMembersDestinations
	 * 		Flags  -> (Final, Native, Public, Const)
	 */
	TMap<class AINSSoldier*, struct FVector> UINSAISquad::GetSquadMembersDestinations()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSAISquad.GetSquadMembersDestinations");
		
		UINSAISquad_GetSquadMembersDestinations_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0566A9F0
	 * 		Name   -> Function Insurgency.INSAISquad.GetSquadMembers
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
	 */
	TArray<class AINSSoldier*> UINSAISquad::GetSquadMembers()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSAISquad.GetSquadMembers");
		
		UINSAISquad_GetSquadMembers_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0566A9C0
	 * 		Name   -> Function Insurgency.INSAISquad.GetSquadLeader
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	class AINSSoldier* UINSAISquad::GetSquadLeader()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSAISquad.GetSquadLeader");
		
		UINSAISquad_GetSquadLeader_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0566A930
	 * 		Name   -> Function Insurgency.INSAISquad.GetRoleForSoldier
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class AINSSoldier*                                 Soldier                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	EAISquadRole UINSAISquad::GetRoleForSoldier(class AINSSoldier* Soldier)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSAISquad.GetRoleForSoldier");
		
		UINSAISquad_GetRoleForSoldier_Params params {};
		params.Soldier = Soldier;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0566A870
	 * 		Name   -> Function Insurgency.INSAISquad.GetPendingInvestigations
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
	 */
	TArray<class UBotInvestigation*> UINSAISquad::GetPendingInvestigations()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSAISquad.GetPendingInvestigations");
		
		UINSAISquad_GetPendingInvestigations_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0566A790
	 * 		Name   -> Function Insurgency.INSAISquad.GetMovementGroup
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		class AINSSoldier*                                 Soldier                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	TArray<class AINSSoldier*> UINSAISquad::GetMovementGroup(class AINSSoldier* Soldier)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSAISquad.GetMovementGroup");
		
		UINSAISquad_GetMovementGroup_Params params {};
		params.Soldier = Soldier;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0566A760
	 * 		Name   -> Function Insurgency.INSAISquad.GetMaxSquadSize
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	int32_t UINSAISquad::GetMaxSquadSize()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSAISquad.GetMaxSquadSize");
		
		UINSAISquad_GetMaxSquadSize_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0566A6D0
	 * 		Name   -> Function Insurgency.INSAISquad.GetContestedObjective
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		class AINSSoldier*                                 Investigator                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UBotInvestigation* UINSAISquad::GetContestedObjective(class AINSSoldier* Investigator)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSAISquad.GetContestedObjective");
		
		UINSAISquad_GetContestedObjective_Params params {};
		params.Investigator = Investigator;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0566A5F0
	 * 		Name   -> Function Insurgency.INSAISquad.GetActualSquadPathLocations
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		class AINSSoldier*                                 Soldier                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	TArray<struct FVector> UINSAISquad::GetActualSquadPathLocations(class AINSSoldier* Soldier)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSAISquad.GetActualSquadPathLocations");
		
		UINSAISquad_GetActualSquadPathLocations_Params params {};
		params.Soldier = Soldier;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0566A5C0
	 * 		Name   -> Function Insurgency.INSAISquad.GetActiveInvestigation
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	class UBotInvestigation* UINSAISquad::GetActiveInvestigation()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSAISquad.GetActiveInvestigation");
		
		UINSAISquad_GetActiveInvestigation_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0566A590
	 * 		Name   -> Function Insurgency.INSAISquad.CountSquadMembers
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	int32_t UINSAISquad::CountSquadMembers()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSAISquad.CountSquadMembers");
		
		UINSAISquad_CountSquadMembers_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0566A550
	 * 		Name   -> Function Insurgency.INSAISquad.CenterPosition
	 * 		Flags  -> (Final, Native, Public, HasDefaults, Const)
	 */
	struct FVector UINSAISquad::CenterPosition()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSAISquad.CenterPosition");
		
		UINSAISquad_CenterPosition_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0566A490
	 * 		Name   -> Function Insurgency.INSAISquad.AddPawnToSquad
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class AINSSoldier*                                 NewMember                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bIsLeader                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UINSAISquad::AddPawnToSquad(class AINSSoldier* NewMember, bool bIsLeader)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSAISquad.AddPawnToSquad");
		
		UINSAISquad_AddPawnToSquad_Params params {};
		params.NewMember = NewMember;
		params.bIsLeader = bIsLeader;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UINSAISquad.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UINSAISquad::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.INSAISquad");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0566B4F0
	 * 		Name   -> Function Insurgency.INSAmbushGameMode.GetVIPSoldier
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
	 */
	class AINSSoldier* AINSAmbushGameMode::GetVIPSoldier()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSAmbushGameMode.GetVIPSoldier");
		
		AINSAmbushGameMode_GetVIPSoldier_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AINSAmbushGameMode.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AINSAmbushGameMode::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.INSAmbushGameMode");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UINSAssetManager.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UINSAssetManager::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.INSAssetManager");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UINSAudioComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UINSAudioComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.INSAudioComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05672D50
	 * 		Name   -> Function Insurgency.INSBasePlayerController.UpdateMinimapZoomLevel
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		float                                              Axis                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSBasePlayerController::UpdateMinimapZoomLevel(float Axis)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSBasePlayerController.UpdateMinimapZoomLevel");
		
		AINSBasePlayerController_UpdateMinimapZoomLevel_Params params {};
		params.Axis = Axis;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05672CC0
	 * 		Name   -> Function Insurgency.INSBasePlayerController.UpdateInputMode
	 * 		Flags  -> (Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bForce                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSBasePlayerController::UpdateInputMode(bool bForce)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSBasePlayerController.UpdateInputMode");
		
		AINSBasePlayerController_UpdateInputMode_Params params {};
		params.bForce = bForce;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05672DD0
	 * 		Name   -> Function Insurgency.INSBasePlayerController.UpdatedPlayerSettings
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void AINSBasePlayerController::UpdatedPlayerSettings()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSBasePlayerController.UpdatedPlayerSettings");
		
		AINSBasePlayerController_UpdatedPlayerSettings_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05672C40
	 * 		Name   -> Function Insurgency.INSBasePlayerController.UnmutePlayerState
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class APlayerState*                                OtherPlayerState                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSBasePlayerController::UnmutePlayerState(class APlayerState* OtherPlayerState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSBasePlayerController.UnmutePlayerState");
		
		AINSBasePlayerController_UnmutePlayerState_Params params {};
		params.OtherPlayerState = OtherPlayerState;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05672C20
	 * 		Name   -> Function Insurgency.INSBasePlayerController.ToggleDebugMenu
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void AINSBasePlayerController::ToggleDebugMenu()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSBasePlayerController.ToggleDebugMenu");
		
		AINSBasePlayerController_ToggleDebugMenu_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05672C00
	 * 		Name   -> Function Insurgency.INSBasePlayerController.ToggleAdminMenu
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void AINSBasePlayerController::ToggleAdminMenu()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSBasePlayerController.ToggleAdminMenu");
		
		AINSBasePlayerController_ToggleAdminMenu_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05672B70
	 * 		Name   -> Function Insurgency.INSBasePlayerController.ShowScoreboard
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bShow                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSBasePlayerController::ShowScoreboard(bool bShow)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSBasePlayerController.ShowScoreboard");
		
		AINSBasePlayerController_ShowScoreboard_Params params {};
		params.bShow = bShow;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> DelegateFunction Insurgency.INSBasePlayerController.ShowRoundOverUIDelegate__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate, HasOutParms)
	 * Parameters:
	 * 		struct FPlayerRoundOverData                        UIData                                                     (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void AINSBasePlayerController::ShowRoundOverUIDelegate__DelegateSignature(const struct FPlayerRoundOverData& UIData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction Insurgency.INSBasePlayerController.ShowRoundOverUIDelegate__DelegateSignature");
		
		AINSBasePlayerController_ShowRoundOverUIDelegate__DelegateSignature_Params params {};
		params.UIData = UIData;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> DelegateFunction Insurgency.INSBasePlayerController.ShowMatchOverUIDelegate__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate, HasOutParms)
	 * Parameters:
	 * 		struct FPlayerMatchOverData                        UIData                                                     (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void AINSBasePlayerController::ShowMatchOverUIDelegate__DelegateSignature(const struct FPlayerMatchOverData& UIData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction Insurgency.INSBasePlayerController.ShowMatchOverUIDelegate__DelegateSignature");
		
		AINSBasePlayerController_ShowMatchOverUIDelegate__DelegateSignature_Params params {};
		params.UIData = UIData;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05672B50
	 * 		Name   -> Function Insurgency.INSBasePlayerController.ShowMap
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void AINSBasePlayerController::ShowMap()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSBasePlayerController.ShowMap");
		
		AINSBasePlayerController_ShowMap_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05672AC0
	 * 		Name   -> Function Insurgency.INSBasePlayerController.ShowGenericMenu
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UClass*                                      WidgetClass                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UUserWidget* AINSBasePlayerController::ShowGenericMenu(class UClass* WidgetClass)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSBasePlayerController.ShowGenericMenu");
		
		AINSBasePlayerController_ShowGenericMenu_Params params {};
		params.WidgetClass = WidgetClass;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05672A00
	 * 		Name   -> Function Insurgency.INSBasePlayerController.ShouldHintLesson
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UClass*                                      Lesson                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class ALessonArea*                                 LessonArea                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool AINSBasePlayerController::ShouldHintLesson(class UClass* Lesson, class ALessonArea* LessonArea)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSBasePlayerController.ShouldHintLesson");
		
		AINSBasePlayerController_ShouldHintLesson_Params params {};
		params.Lesson = Lesson;
		params.LessonArea = LessonArea;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05672820
	 * 		Name   -> Function Insurgency.INSBasePlayerController.SetVideo
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		class FString                                      GroupId                                                    (ConstParm, Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FString                                      HighlightId                                                (ConstParm, Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            StartDelta                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            EndDelta                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSBasePlayerController::SetVideo(const class FString& GroupId, const class FString& HighlightId, int32_t StartDelta, int32_t EndDelta)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSBasePlayerController.SetVideo");
		
		AINSBasePlayerController_SetVideo_Params params {};
		params.GroupId = GroupId;
		params.HighlightId = HighlightId;
		params.StartDelta = StartDelta;
		params.EndDelta = EndDelta;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056727A0
	 * 		Name   -> Function Insurgency.INSBasePlayerController.SetGenericMenu
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UUserWidget*                                 Widget                                                     (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSBasePlayerController::SetGenericMenu(class UUserWidget* Widget)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSBasePlayerController.SetGenericMenu");
		
		AINSBasePlayerController_SetGenericMenu_Params params {};
		params.Widget = Widget;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05672650
	 * 		Name   -> Function Insurgency.INSBasePlayerController.SetActiveHint
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UClass*                                      Lesson                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              HintTime                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bPlayVideo                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bPause                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSBasePlayerController::SetActiveHint(class UClass* Lesson, float HintTime, bool bPlayVideo, bool bPause)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSBasePlayerController.SetActiveHint");
		
		AINSBasePlayerController_SetActiveHint_Params params {};
		params.Lesson = Lesson;
		params.HintTime = HintTime;
		params.bPlayVideo = bPlayVideo;
		params.bPause = bPause;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05672590
	 * 		Name   -> Function Insurgency.INSBasePlayerController.Server_AdminUnbanPlayer
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetServer, BlueprintCallable, NetValidate)
	 * Parameters:
	 * 		class FString                                      UniqueId                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSBasePlayerController::Server_AdminUnbanPlayer(const class FString& UniqueId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSBasePlayerController.Server_AdminUnbanPlayer");
		
		AINSBasePlayerController_Server_AdminUnbanPlayer_Params params {};
		params.UniqueId = UniqueId;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056724D0
	 * 		Name   -> Function Insurgency.INSBasePlayerController.Server_AdminTravelScenario
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
	 * Parameters:
	 * 		class FString                                      Scenario                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSBasePlayerController::Server_AdminTravelScenario(const class FString& Scenario)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSBasePlayerController.Server_AdminTravelScenario");
		
		AINSBasePlayerController_Server_AdminTravelScenario_Params params {};
		params.Scenario = Scenario;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05672410
	 * 		Name   -> Function Insurgency.INSBasePlayerController.Server_AdminTravelMap
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
	 * Parameters:
	 * 		class FString                                      TravelArgs                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSBasePlayerController::Server_AdminTravelMap(const class FString& TravelArgs)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSBasePlayerController.Server_AdminTravelMap");
		
		AINSBasePlayerController_Server_AdminTravelMap_Params params {};
		params.TravelArgs = TravelArgs;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056722F0
	 * 		Name   -> Function Insurgency.INSBasePlayerController.Server_AdminTravel
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetServer, BlueprintCallable, NetValidate)
	 * Parameters:
	 * 		class FString                                      Level                                                      (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FString                                      Scenario                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSBasePlayerController::Server_AdminTravel(const class FString& Level, const class FString& Scenario)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSBasePlayerController.Server_AdminTravel");
		
		AINSBasePlayerController_Server_AdminTravel_Params params {};
		params.Level = Level;
		params.Scenario = Scenario;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056721E0
	 * 		Name   -> Function Insurgency.INSBasePlayerController.Server_AdminSetGamemodeProperty
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetServer, BlueprintCallable, NetValidate)
	 * Parameters:
	 * 		class FString                                      Property                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FString                                      Value                                                      (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSBasePlayerController::Server_AdminSetGamemodeProperty(const class FString& Property, const class FString& Value)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSBasePlayerController.Server_AdminSetGamemodeProperty");
		
		AINSBasePlayerController_Server_AdminSetGamemodeProperty_Params params {};
		params.Property = Property;
		params.Value = Value;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05672130
	 * 		Name   -> Function Insurgency.INSBasePlayerController.Server_AdminRestartRound
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetServer, BlueprintCallable, NetValidate)
	 * Parameters:
	 * 		bool                                               bSwitchTeams                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSBasePlayerController::Server_AdminRestartRound(bool bSwitchTeams)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSBasePlayerController.Server_AdminRestartRound");
		
		AINSBasePlayerController_Server_AdminRestartRound_Params params {};
		params.bSwitchTeams = bSwitchTeams;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056720E0
	 * 		Name   -> Function Insurgency.INSBasePlayerController.Server_AdminRestartLevel
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetServer, BlueprintCallable, NetValidate)
	 */
	void AINSBasePlayerController::Server_AdminRestartLevel()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSBasePlayerController.Server_AdminRestartLevel");
		
		AINSBasePlayerController_Server_AdminRestartLevel_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05672090
	 * 		Name   -> Function Insurgency.INSBasePlayerController.Server_AdminRespawnAllPlayers
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
	 */
	void AINSBasePlayerController::Server_AdminRespawnAllPlayers()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSBasePlayerController.Server_AdminRespawnAllPlayers");
		
		AINSBasePlayerController_Server_AdminRespawnAllPlayers_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05671FD0
	 * 		Name   -> Function Insurgency.INSBasePlayerController.Server_AdminRequestScenarios
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetServer, BlueprintCallable, NetValidate)
	 * Parameters:
	 * 		class FString                                      LevelName                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSBasePlayerController::Server_AdminRequestScenarios(const class FString& LevelName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSBasePlayerController.Server_AdminRequestScenarios");
		
		AINSBasePlayerController_Server_AdminRequestScenarios_Params params {};
		params.LevelName = LevelName;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05671F80
	 * 		Name   -> Function Insurgency.INSBasePlayerController.Server_AdminRequestLevels
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetServer, BlueprintCallable, NetValidate)
	 */
	void AINSBasePlayerController::Server_AdminRequestLevels()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSBasePlayerController.Server_AdminRequestLevels");
		
		AINSBasePlayerController_Server_AdminRequestLevels_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05671ED0
	 * 		Name   -> Function Insurgency.INSBasePlayerController.Server_AdminKickPlayer
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetServer, BlueprintCallable, NetValidate)
	 * Parameters:
	 * 		int32_t                                            PlayerId                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSBasePlayerController::Server_AdminKickPlayer(int32_t PlayerId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSBasePlayerController.Server_AdminKickPlayer");
		
		AINSBasePlayerController_Server_AdminKickPlayer_Params params {};
		params.PlayerId = PlayerId;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05671E10
	 * 		Name   -> Function Insurgency.INSBasePlayerController.Server_AdminGetGamemodeProperty
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetServer, BlueprintCallable, NetValidate)
	 * Parameters:
	 * 		class FString                                      Property                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSBasePlayerController::Server_AdminGetGamemodeProperty(const class FString& Property)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSBasePlayerController.Server_AdminGetGamemodeProperty");
		
		AINSBasePlayerController_Server_AdminGetGamemodeProperty_Params params {};
		params.Property = Property;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05671DC0
	 * 		Name   -> Function Insurgency.INSBasePlayerController.Server_AdminForceGameOver
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetServer, BlueprintCallable, NetValidate)
	 */
	void AINSBasePlayerController::Server_AdminForceGameOver()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSBasePlayerController.Server_AdminForceGameOver");
		
		AINSBasePlayerController_Server_AdminForceGameOver_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05671D70
	 * 		Name   -> Function Insurgency.INSBasePlayerController.Server_AdminExtendRoundTimer
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
	 */
	void AINSBasePlayerController::Server_AdminExtendRoundTimer()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSBasePlayerController.Server_AdminExtendRoundTimer");
		
		AINSBasePlayerController_Server_AdminExtendRoundTimer_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05671CB0
	 * 		Name   -> Function Insurgency.INSBasePlayerController.Server_AdminEndRound
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetServer, BlueprintCallable, NetValidate)
	 * Parameters:
	 * 		bool                                               bVictory                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSBasePlayerController::Server_AdminEndRound(bool bVictory)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSBasePlayerController.Server_AdminEndRound");
		
		AINSBasePlayerController_Server_AdminEndRound_Params params {};
		params.bVictory = bVictory;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05671C60
	 * 		Name   -> Function Insurgency.INSBasePlayerController.Server_AdminDebugPlayerState
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
	 */
	void AINSBasePlayerController::Server_AdminDebugPlayerState()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSBasePlayerController.Server_AdminDebugPlayerState");
		
		AINSBasePlayerController_Server_AdminDebugPlayerState_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05671C10
	 * 		Name   -> Function Insurgency.INSBasePlayerController.Server_AdminDebugLightLevels
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
	 */
	void AINSBasePlayerController::Server_AdminDebugLightLevels()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSBasePlayerController.Server_AdminDebugLightLevels");
		
		AINSBasePlayerController_Server_AdminDebugLightLevels_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05671B50
	 * 		Name   -> Function Insurgency.INSBasePlayerController.Server_AdminConsoleCommand
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetServer, BlueprintCallable, NetValidate)
	 * Parameters:
	 * 		class FString                                      Command                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSBasePlayerController::Server_AdminConsoleCommand(const class FString& Command)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSBasePlayerController.Server_AdminConsoleCommand");
		
		AINSBasePlayerController_Server_AdminConsoleCommand_Params params {};
		params.Command = Command;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05671A90
	 * 		Name   -> Function Insurgency.INSBasePlayerController.Server_AdminCheat
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetServer, BlueprintCallable, NetValidate)
	 * Parameters:
	 * 		class FString                                      Command                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSBasePlayerController::Server_AdminCheat(const class FString& Command)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSBasePlayerController.Server_AdminCheat");
		
		AINSBasePlayerController_Server_AdminCheat_Params params {};
		params.Command = Command;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05671A40
	 * 		Name   -> Function Insurgency.INSBasePlayerController.Server_AdminBypassWaitingState
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetServer, BlueprintCallable, NetValidate)
	 */
	void AINSBasePlayerController::Server_AdminBypassWaitingState()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSBasePlayerController.Server_AdminBypassWaitingState");
		
		AINSBasePlayerController_Server_AdminBypassWaitingState_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05671990
	 * 		Name   -> Function Insurgency.INSBasePlayerController.Server_AdminBroadcastMusic
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetServer, BlueprintCallable, NetValidate)
	 * Parameters:
	 * 		EMusicEvent                                        Event                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSBasePlayerController::Server_AdminBroadcastMusic(EMusicEvent Event)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSBasePlayerController.Server_AdminBroadcastMusic");
		
		AINSBasePlayerController_Server_AdminBroadcastMusic_Params params {};
		params.Event = Event;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056718D0
	 * 		Name   -> Function Insurgency.INSBasePlayerController.Server_AdminBeginProfiling
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetServer, BlueprintCallable, NetValidate)
	 * Parameters:
	 * 		bool                                               bStopAtRoundEnd                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSBasePlayerController::Server_AdminBeginProfiling(bool bStopAtRoundEnd)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSBasePlayerController.Server_AdminBeginProfiling");
		
		AINSBasePlayerController_Server_AdminBeginProfiling_Params params {};
		params.bStopAtRoundEnd = bStopAtRoundEnd;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056717D0
	 * 		Name   -> Function Insurgency.INSBasePlayerController.Server_AdminBanPlayer
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetServer, BlueprintCallable, NetValidate)
	 * Parameters:
	 * 		int32_t                                            PlayerId                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              BanDuration                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSBasePlayerController::Server_AdminBanPlayer(int32_t PlayerId, float BanDuration)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSBasePlayerController.Server_AdminBanPlayer");
		
		AINSBasePlayerController_Server_AdminBanPlayer_Params params {};
		params.PlayerId = PlayerId;
		params.BanDuration = BanDuration;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> DelegateFunction Insurgency.INSBasePlayerController.RoundOverRewardsDelegate__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate, HasOutParms)
	 * Parameters:
	 * 		int32_t                                            RoundNumber                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FGameStatsRoundReward                       Rewards                                                    (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void AINSBasePlayerController::RoundOverRewardsDelegate__DelegateSignature(int32_t RoundNumber, const struct FGameStatsRoundReward& Rewards)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction Insurgency.INSBasePlayerController.RoundOverRewardsDelegate__DelegateSignature");
		
		AINSBasePlayerController_RoundOverRewardsDelegate__DelegateSignature_Params params {};
		params.RoundNumber = RoundNumber;
		params.Rewards = Rewards;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056717B0
	 * 		Name   -> Function Insurgency.INSBasePlayerController.ReturnToMainMenu
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void AINSBasePlayerController::ReturnToMainMenu()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSBasePlayerController.ReturnToMainMenu");
		
		AINSBasePlayerController_ReturnToMainMenu_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05671790
	 * 		Name   -> Function Insurgency.INSBasePlayerController.ResetPlayerAccount
	 * 		Flags  -> (Final, Exec, Native, Private)
	 */
	void AINSBasePlayerController::ResetPlayerAccount()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSBasePlayerController.ResetPlayerAccount");
		
		AINSBasePlayerController_ResetPlayerAccount_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> DelegateFunction Insurgency.INSBasePlayerController.RefreshTeamsDelegate__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 */
	void AINSBasePlayerController::RefreshTeamsDelegate__DelegateSignature()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction Insurgency.INSBasePlayerController.RefreshTeamsDelegate__DelegateSignature");
		
		AINSBasePlayerController_RefreshTeamsDelegate__DelegateSignature_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> DelegateFunction Insurgency.INSBasePlayerController.RefreshObjectivesDelegate__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 */
	void AINSBasePlayerController::RefreshObjectivesDelegate__DelegateSignature()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction Insurgency.INSBasePlayerController.RefreshObjectivesDelegate__DelegateSignature");
		
		AINSBasePlayerController_RefreshObjectivesDelegate__DelegateSignature_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> DelegateFunction Insurgency.INSBasePlayerController.RefreshMutatorsDelegate__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 */
	void AINSBasePlayerController::RefreshMutatorsDelegate__DelegateSignature()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction Insurgency.INSBasePlayerController.RefreshMutatorsDelegate__DelegateSignature");
		
		AINSBasePlayerController_RefreshMutatorsDelegate__DelegateSignature_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05671770
	 * 		Name   -> Function Insurgency.INSBasePlayerController.PrintAvailableFireSupport
	 * 		Flags  -> (Final, Exec, Native, Public)
	 */
	void AINSBasePlayerController::PrintAvailableFireSupport()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSBasePlayerController.PrintAvailableFireSupport");
		
		AINSBasePlayerController_PrintAvailableFireSupport_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> DelegateFunction Insurgency.INSBasePlayerController.PlayerSettingsUpdatedDelegate__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 */
	void AINSBasePlayerController::PlayerSettingsUpdatedDelegate__DelegateSignature()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction Insurgency.INSBasePlayerController.PlayerSettingsUpdatedDelegate__DelegateSignature");
		
		AINSBasePlayerController_PlayerSettingsUpdatedDelegate__DelegateSignature_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> DelegateFunction Insurgency.INSBasePlayerController.PlayerAdminReceivedScenarioList__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate, HasOutParms)
	 * Parameters:
	 * 		TArray<class FString>                              Scenarios                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSBasePlayerController::PlayerAdminReceivedScenarioList__DelegateSignature(TArray<class FString> Scenarios)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction Insurgency.INSBasePlayerController.PlayerAdminReceivedScenarioList__DelegateSignature");
		
		AINSBasePlayerController_PlayerAdminReceivedScenarioList__DelegateSignature_Params params {};
		params.Scenarios = Scenarios;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> DelegateFunction Insurgency.INSBasePlayerController.PlayerAdminReceivedLevelList__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate, HasOutParms)
	 * Parameters:
	 * 		TArray<class FString>                              LevelNames                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSBasePlayerController::PlayerAdminReceivedLevelList__DelegateSignature(TArray<class FString> LevelNames)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction Insurgency.INSBasePlayerController.PlayerAdminReceivedLevelList__DelegateSignature");
		
		AINSBasePlayerController_PlayerAdminReceivedLevelList__DelegateSignature_Params params {};
		params.LevelNames = LevelNames;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05671750
	 * 		Name   -> Function Insurgency.INSBasePlayerController.OpenNVIDIAHighlights
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void AINSBasePlayerController::OpenNVIDIAHighlights()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSBasePlayerController.OpenNVIDIAHighlights");
		
		AINSBasePlayerController_OpenNVIDIAHighlights_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056715B0
	 * 		Name   -> Function Insurgency.INSBasePlayerController.OnSoundscapeUpdate
	 * 		Flags  -> (Final, Native, Public, HasOutParms)
	 * Parameters:
	 * 		struct FSoundscapeStateRepl                        NewState                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void AINSBasePlayerController::OnSoundscapeUpdate(const struct FSoundscapeStateRepl& NewState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSBasePlayerController.OnSoundscapeUpdate");
		
		AINSBasePlayerController_OnSoundscapeUpdate_Params params {};
		params.NewState = NewState;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> DelegateFunction Insurgency.INSBasePlayerController.OnShowCenterMessageDelegate__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate, HasOutParms)
	 * Parameters:
	 * 		class FText                                        MessageText                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void AINSBasePlayerController::OnShowCenterMessageDelegate__DelegateSignature(const class FText& MessageText)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction Insurgency.INSBasePlayerController.OnShowCenterMessageDelegate__DelegateSignature");
		
		AINSBasePlayerController_OnShowCenterMessageDelegate__DelegateSignature_Params params {};
		params.MessageText = MessageText;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> DelegateFunction Insurgency.INSBasePlayerController.OnSetViewTargetDelegate__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 * Parameters:
	 * 		class AActor*                                      NewViewTarget                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSBasePlayerController::OnSetViewTargetDelegate__DelegateSignature(class AActor* NewViewTarget)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction Insurgency.INSBasePlayerController.OnSetViewTargetDelegate__DelegateSignature");
		
		AINSBasePlayerController_OnSetViewTargetDelegate__DelegateSignature_Params params {};
		params.NewViewTarget = NewViewTarget;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> DelegateFunction Insurgency.INSBasePlayerController.OnScoreboardShownDelegate__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 * Parameters:
	 * 		bool                                               bShow                                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSBasePlayerController::OnScoreboardShownDelegate__DelegateSignature(bool bShow)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction Insurgency.INSBasePlayerController.OnScoreboardShownDelegate__DelegateSignature");
		
		AINSBasePlayerController_OnScoreboardShownDelegate__DelegateSignature_Params params {};
		params.bShow = bShow;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05671590
	 * 		Name   -> Function Insurgency.INSBasePlayerController.OnQueuedHintReady
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void AINSBasePlayerController::OnQueuedHintReady()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSBasePlayerController.OnQueuedHintReady");
		
		AINSBasePlayerController_OnQueuedHintReady_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05671570
	 * 		Name   -> Function Insurgency.INSBasePlayerController.OnPlayerReportingStart
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void AINSBasePlayerController::OnPlayerReportingStart()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSBasePlayerController.OnPlayerReportingStart");
		
		AINSBasePlayerController_OnPlayerReportingStart_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05671550
	 * 		Name   -> Function Insurgency.INSBasePlayerController.OnPlayerReportingEnd
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void AINSBasePlayerController::OnPlayerReportingEnd()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSBasePlayerController.OnPlayerReportingEnd");
		
		AINSBasePlayerController_OnPlayerReportingEnd_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05671480
	 * 		Name   -> Function Insurgency.INSBasePlayerController.OnPlayerKillEvent
	 * 		Flags  -> (Final, Native, Public, HasOutParms)
	 * Parameters:
	 * 		struct FSoldierKillInfo                            SoldierKillInfo                                            (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void AINSBasePlayerController::OnPlayerKillEvent(const struct FSoldierKillInfo& SoldierKillInfo)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSBasePlayerController.OnPlayerKillEvent");
		
		AINSBasePlayerController_OnPlayerKillEvent_Params params {};
		params.SoldierKillInfo = SoldierKillInfo;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05671400
	 * 		Name   -> Function Insurgency.INSBasePlayerController.OnLocalPlayerProfileUpdated
	 * 		Flags  -> (Native, Public)
	 * Parameters:
	 * 		EProfileBlockType                                  SavedBlockType                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSBasePlayerController::OnLocalPlayerProfileUpdated(EProfileBlockType SavedBlockType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSBasePlayerController.OnLocalPlayerProfileUpdated");
		
		AINSBasePlayerController_OnLocalPlayerProfileUpdated_Params params {};
		params.SavedBlockType = SavedBlockType;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056713C0
	 * 		Name   -> Function Insurgency.INSBasePlayerController.OnHUDDisplayOptionChanged
	 * 		Flags  -> (Final, Native, Public)
	 */
	void AINSBasePlayerController::OnHUDDisplayOptionChanged()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSBasePlayerController.OnHUDDisplayOptionChanged");
		
		AINSBasePlayerController_OnHUDDisplayOptionChanged_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056713E0
	 * 		Name   -> Function Insurgency.INSBasePlayerController.OnHighlightsPreferencesChanged
	 * 		Flags  -> (Final, Native, Public)
	 */
	void AINSBasePlayerController::OnHighlightsPreferencesChanged()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSBasePlayerController.OnHighlightsPreferencesChanged");
		
		AINSBasePlayerController_OnHighlightsPreferencesChanged_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056713A0
	 * 		Name   -> Function Insurgency.INSBasePlayerController.OnActiveHintExpired
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void AINSBasePlayerController::OnActiveHintExpired()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSBasePlayerController.OnActiveHintExpired");
		
		AINSBasePlayerController_OnActiveHintExpired_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05671320
	 * 		Name   -> Function Insurgency.INSBasePlayerController.MutePlayerState
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class APlayerState*                                OtherPlayerState                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSBasePlayerController::MutePlayerState(class APlayerState* OtherPlayerState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSBasePlayerController.MutePlayerState");
		
		AINSBasePlayerController_MutePlayerState_Params params {};
		params.OtherPlayerState = OtherPlayerState;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056712F0
	 * 		Name   -> Function Insurgency.INSBasePlayerController.IsUsingGamepad
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AINSBasePlayerController::IsUsingGamepad()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSBasePlayerController.IsUsingGamepad");
		
		AINSBasePlayerController_IsUsingGamepad_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056712C0
	 * 		Name   -> Function Insurgency.INSBasePlayerController.IsSpectator
	 * 		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AINSBasePlayerController::IsSpectator()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSBasePlayerController.IsSpectator");
		
		AINSBasePlayerController_IsSpectator_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056712A0
	 * 		Name   -> Function Insurgency.INSBasePlayerController.IsReportingPlayer
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	bool AINSBasePlayerController::IsReportingPlayer()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSBasePlayerController.IsReportingPlayer");
		
		AINSBasePlayerController_IsReportingPlayer_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05671210
	 * 		Name   -> Function Insurgency.INSBasePlayerController.IsPlayerStateMuted
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class APlayerState*                                OtherPlayerState                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool AINSBasePlayerController::IsPlayerStateMuted(class APlayerState* OtherPlayerState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSBasePlayerController.IsPlayerStateMuted");
		
		AINSBasePlayerController_IsPlayerStateMuted_Params params {};
		params.OtherPlayerState = OtherPlayerState;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05671180
	 * 		Name   -> Function Insurgency.INSBasePlayerController.IsInFirstPersonFor
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		class UObject*                                     Object                                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool AINSBasePlayerController::IsInFirstPersonFor(class UObject* Object)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSBasePlayerController.IsInFirstPersonFor");
		
		AINSBasePlayerController_IsInFirstPersonFor_Params params {};
		params.Object = Object;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056710F0
	 * 		Name   -> Function Insurgency.INSBasePlayerController.InitNVIDIAHighlights
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bNeedsPlayerState                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSBasePlayerController::InitNVIDIAHighlights(bool bNeedsPlayerState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSBasePlayerController.InitNVIDIAHighlights");
		
		AINSBasePlayerController_InitNVIDIAHighlights_Params params {};
		params.bNeedsPlayerState = bNeedsPlayerState;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05670ED0
	 * 		Name   -> Function Insurgency.INSBasePlayerController.InformIncomingHint
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UClass*                                      Lesson                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              HintTime                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bQueueIfBusy                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bPlayVideo                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bForceShow                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bPauseGame                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class ALessonArea*                                 LessonArea                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSBasePlayerController::InformIncomingHint(class UClass* Lesson, float HintTime, bool bQueueIfBusy, bool bPlayVideo, bool bForceShow, bool bPauseGame, class ALessonArea* LessonArea)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSBasePlayerController.InformIncomingHint");
		
		AINSBasePlayerController_InformIncomingHint_Params params {};
		params.Lesson = Lesson;
		params.HintTime = HintTime;
		params.bQueueIfBusy = bQueueIfBusy;
		params.bPlayVideo = bPlayVideo;
		params.bForceShow = bForceShow;
		params.bPauseGame = bPauseGame;
		params.LessonArea = LessonArea;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> DelegateFunction Insurgency.INSBasePlayerController.HideRoundOverUIDelegate__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 */
	void AINSBasePlayerController::HideRoundOverUIDelegate__DelegateSignature()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction Insurgency.INSBasePlayerController.HideRoundOverUIDelegate__DelegateSignature");
		
		AINSBasePlayerController_HideRoundOverUIDelegate__DelegateSignature_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05670EB0
	 * 		Name   -> Function Insurgency.INSBasePlayerController.HideOpenMenu
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void AINSBasePlayerController::HideOpenMenu()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSBasePlayerController.HideOpenMenu");
		
		AINSBasePlayerController_HideOpenMenu_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05670E90
	 * 		Name   -> Function Insurgency.INSBasePlayerController.HideMap
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void AINSBasePlayerController::HideMap()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSBasePlayerController.HideMap");
		
		AINSBasePlayerController_HideMap_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05670E10
	 * 		Name   -> Function Insurgency.INSBasePlayerController.HideHint
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UClass*                                      Lesson                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSBasePlayerController::HideHint(class UClass* Lesson)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSBasePlayerController.HideHint");
		
		AINSBasePlayerController_HideHint_Params params {};
		params.Lesson = Lesson;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05670DE0
	 * 		Name   -> Function Insurgency.INSBasePlayerController.GetLocalProfile
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	class UINSPlayerLocalProfile* AINSBasePlayerController::GetLocalProfile()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSBasePlayerController.GetLocalProfile");
		
		AINSBasePlayerController_GetLocalProfile_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05670DB0
	 * 		Name   -> Function Insurgency.INSBasePlayerController.GetLocalPlayer
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	class UINSLocalPlayer* AINSBasePlayerController::GetLocalPlayer()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSBasePlayerController.GetLocalPlayer");
		
		AINSBasePlayerController_GetLocalPlayer_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05670D80
	 * 		Name   -> Function Insurgency.INSBasePlayerController.GetINSPlayerState
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	class AINSPlayerState* AINSBasePlayerController::GetINSPlayerState()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSBasePlayerController.GetINSPlayerState");
		
		AINSBasePlayerController_GetINSPlayerState_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05670D50
	 * 		Name   -> Function Insurgency.INSBasePlayerController.GetHUDBase
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
	 */
	class AHUDBase* AINSBasePlayerController::GetHUDBase()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSBasePlayerController.GetHUDBase");
		
		AINSBasePlayerController_GetHUDBase_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05670CC0
	 * 		Name   -> Function Insurgency.INSBasePlayerController.DestroyNVIDIAHighlights
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bDeleteHighlights                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSBasePlayerController::DestroyNVIDIAHighlights(bool bDeleteHighlights)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSBasePlayerController.DestroyNVIDIAHighlights");
		
		AINSBasePlayerController_DestroyNVIDIAHighlights_Params params {};
		params.bDeleteHighlights = bDeleteHighlights;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056709C0
	 * 		Name   -> Function Insurgency.INSBasePlayerController.ClientTeamMessageText
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetClient)
	 * Parameters:
	 * 		class APlayerState*                                SenderPlayerState                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FText                                        InText                                                     (ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		class FName                                        Type                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              MsgLifeTime                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSBasePlayerController::ClientTeamMessageText(class APlayerState* SenderPlayerState, const class FText& InText, const class FName& Type, float MsgLifeTime)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSBasePlayerController.ClientTeamMessageText");
		
		AINSBasePlayerController_ClientTeamMessageText_Params params {};
		params.SenderPlayerState = SenderPlayerState;
		params.InText = InText;
		params.Type = Type;
		params.MsgLifeTime = MsgLifeTime;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05670900
	 * 		Name   -> Function Insurgency.INSBasePlayerController.ClientShowFriendlyKillWarning
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetClient)
	 * Parameters:
	 * 		int32_t                                            TeamKills                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            Limit                                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSBasePlayerController::ClientShowFriendlyKillWarning(int32_t TeamKills, int32_t Limit)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSBasePlayerController.ClientShowFriendlyKillWarning");
		
		AINSBasePlayerController_ClientShowFriendlyKillWarning_Params params {};
		params.TeamKills = TeamKills;
		params.Limit = Limit;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056707F0
	 * 		Name   -> Function Insurgency.INSBasePlayerController.ClientRoundOverRewards
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetClient)
	 * Parameters:
	 * 		int32_t                                            RoundNumber                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FGameStatsRoundReward                       Rewards                                                    (ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void AINSBasePlayerController::ClientRoundOverRewards(int32_t RoundNumber, const struct FGameStatsRoundReward& Rewards)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSBasePlayerController.ClientRoundOverRewards");
		
		AINSBasePlayerController_ClientRoundOverRewards_Params params {};
		params.RoundNumber = RoundNumber;
		params.Rewards = Rewards;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05670670
	 * 		Name   -> Function Insurgency.INSBasePlayerController.ClientReceivedRoundOver
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetClient)
	 * Parameters:
	 * 		struct FPlayerRoundOverData                        UIData                                                     (ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void AINSBasePlayerController::ClientReceivedRoundOver(const struct FPlayerRoundOverData& UIData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSBasePlayerController.ClientReceivedRoundOver");
		
		AINSBasePlayerController_ClientReceivedRoundOver_Params params {};
		params.UIData = UIData;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05670550
	 * 		Name   -> Function Insurgency.INSBasePlayerController.ClientReceivedMatchOver
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetClient)
	 * Parameters:
	 * 		struct FPlayerMatchOverData                        UIData                                                     (ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void AINSBasePlayerController::ClientReceivedMatchOver(const struct FPlayerMatchOverData& UIData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSBasePlayerController.ClientReceivedMatchOver");
		
		AINSBasePlayerController_ClientReceivedMatchOver_Params params {};
		params.UIData = UIData;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05670350
	 * 		Name   -> Function Insurgency.INSBasePlayerController.ClientPlayIncomingRadioEventSpectator
	 * 		Flags  -> (Net, Native, Event, Public, NetClient)
	 * Parameters:
	 * 		class UAkAudioEvent*                               Event                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            Seed                                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bOnlyOfficerOrObserver                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		unsigned char                                      TeamId                                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSBasePlayerController::ClientPlayIncomingRadioEventSpectator(class UAkAudioEvent* Event, int32_t Seed, bool bOnlyOfficerOrObserver, unsigned char TeamId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSBasePlayerController.ClientPlayIncomingRadioEventSpectator");
		
		AINSBasePlayerController_ClientPlayIncomingRadioEventSpectator_Params params {};
		params.Event = Event;
		params.Seed = Seed;
		params.bOnlyOfficerOrObserver = bOnlyOfficerOrObserver;
		params.TeamId = TeamId;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05670280
	 * 		Name   -> Function Insurgency.INSBasePlayerController.ClientPlayIncomingRadioEvent
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetClient)
	 * Parameters:
	 * 		class UAkAudioEvent*                               Event                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            Seed                                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSBasePlayerController::ClientPlayIncomingRadioEvent(class UAkAudioEvent* Event, int32_t Seed)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSBasePlayerController.ClientPlayIncomingRadioEvent");
		
		AINSBasePlayerController_ClientPlayIncomingRadioEvent_Params params {};
		params.Event = Event;
		params.Seed = Seed;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056704A0
	 * 		Name   -> Function Insurgency.INSBasePlayerController.ClientPlayerKillNotice
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetClient)
	 * Parameters:
	 * 		struct FPlayerKillNotice                           Notice                                                     (ConstParm, Parm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void AINSBasePlayerController::ClientPlayerKillNotice(const struct FPlayerKillNotice& Notice)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSBasePlayerController.ClientPlayerKillNotice");
		
		AINSBasePlayerController_ClientPlayerKillNotice_Params params {};
		params.Notice = Notice;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05670070
	 * 		Name   -> Function Insurgency.INSBasePlayerController.ClientPawnReceivedDamage
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, HasDefaults, NetClient)
	 * Parameters:
	 * 		float                                              Damage                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AINSSoldier*                                 Target                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     HitSource                                                  (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     HitDirection                                               (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AController*                                 EventInstigator                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      DamageCauser                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FString                                      BoneName                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSBasePlayerController::ClientPawnReceivedDamage(float Damage, class AINSSoldier* Target, const struct FVector& HitSource, const struct FVector& HitDirection, class AController* EventInstigator, class AActor* DamageCauser, const class FString& BoneName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSBasePlayerController.ClientPawnReceivedDamage");
		
		AINSBasePlayerController_ClientPawnReceivedDamage_Params params {};
		params.Damage = Damage;
		params.Target = Target;
		params.HitSource = HitSource;
		params.HitDirection = HitDirection;
		params.EventInstigator = EventInstigator;
		params.DamageCauser = DamageCauser;
		params.BoneName = BoneName;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0566FF10
	 * 		Name   -> Function Insurgency.INSBasePlayerController.ClientObjectiveDestroyed
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetClient)
	 * Parameters:
	 * 		class AObjectiveDestructible*                      Objective                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		unsigned char                                      OldOwners                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		unsigned char                                      NewOwners                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		TArray<class AINSPlayerState*>                     Attackers                                                  (ConstParm, Parm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSBasePlayerController::ClientObjectiveDestroyed(class AObjectiveDestructible* Objective, unsigned char OldOwners, unsigned char NewOwners, TArray<class AINSPlayerState*> Attackers)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSBasePlayerController.ClientObjectiveDestroyed");
		
		AINSBasePlayerController_ClientObjectiveDestroyed_Params params {};
		params.Objective = Objective;
		params.OldOwners = OldOwners;
		params.NewOwners = NewOwners;
		params.Attackers = Attackers;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0566FDB0
	 * 		Name   -> Function Insurgency.INSBasePlayerController.ClientObjectiveCapture
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetClient)
	 * Parameters:
	 * 		class AObjectiveCapturable*                        Objective                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		unsigned char                                      OldOwners                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		unsigned char                                      NewOwners                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		TArray<class AINSPlayerState*>                     Capturers                                                  (ConstParm, Parm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSBasePlayerController::ClientObjectiveCapture(class AObjectiveCapturable* Objective, unsigned char OldOwners, unsigned char NewOwners, TArray<class AINSPlayerState*> Capturers)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSBasePlayerController.ClientObjectiveCapture");
		
		AINSBasePlayerController_ClientObjectiveCapture_Params params {};
		params.Objective = Objective;
		params.OldOwners = OldOwners;
		params.NewOwners = NewOwners;
		params.Capturers = Capturers;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0566FC60
	 * 		Name   -> Function Insurgency.INSBasePlayerController.ClientMessageText
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetClient, BlueprintCallable)
	 * Parameters:
	 * 		class FText                                        Text                                                       (ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		class FName                                        Type                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              MsgLifeTime                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSBasePlayerController::ClientMessageText(const class FText& Text, const class FName& Type, float MsgLifeTime)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSBasePlayerController.ClientMessageText");
		
		AINSBasePlayerController_ClientMessageText_Params params {};
		params.Text = Text;
		params.Type = Type;
		params.MsgLifeTime = MsgLifeTime;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05670C00
	 * 		Name   -> Function Insurgency.INSBasePlayerController.Client_AdminReceiveScenarios
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetClient)
	 * Parameters:
	 * 		TArray<class FString>                              Scenarios                                                  (ConstParm, Parm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSBasePlayerController::Client_AdminReceiveScenarios(TArray<class FString> Scenarios)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSBasePlayerController.Client_AdminReceiveScenarios");
		
		AINSBasePlayerController_Client_AdminReceiveScenarios_Params params {};
		params.Scenarios = Scenarios;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05670B40
	 * 		Name   -> Function Insurgency.INSBasePlayerController.Client_AdminReceiveLevels
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetClient)
	 * Parameters:
	 * 		TArray<class FString>                              LevelNames                                                 (ConstParm, Parm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSBasePlayerController::Client_AdminReceiveLevels(TArray<class FString> LevelNames)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSBasePlayerController.Client_AdminReceiveLevels");
		
		AINSBasePlayerController_Client_AdminReceiveLevels_Params params {};
		params.LevelNames = LevelNames;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0566FBC0
	 * 		Name   -> Function Insurgency.INSBasePlayerController.AdminUnbanPlayer
	 * 		Flags  -> (Final, Exec, Native, Public)
	 * Parameters:
	 * 		class FString                                      UniqueId                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSBasePlayerController::AdminUnbanPlayer(const class FString& UniqueId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSBasePlayerController.AdminUnbanPlayer");
		
		AINSBasePlayerController_AdminUnbanPlayer_Params params {};
		params.UniqueId = UniqueId;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0566FB20
	 * 		Name   -> Function Insurgency.INSBasePlayerController.AdminTravelScenario
	 * 		Flags  -> (Final, Exec, Native, Public)
	 * Parameters:
	 * 		class FString                                      Scenario                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSBasePlayerController::AdminTravelScenario(const class FString& Scenario)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSBasePlayerController.AdminTravelScenario");
		
		AINSBasePlayerController_AdminTravelScenario_Params params {};
		params.Scenario = Scenario;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0566FA80
	 * 		Name   -> Function Insurgency.INSBasePlayerController.AdminTravelMap
	 * 		Flags  -> (Final, Exec, Native, Public)
	 * Parameters:
	 * 		class FString                                      TravelArgs                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSBasePlayerController::AdminTravelMap(const class FString& TravelArgs)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSBasePlayerController.AdminTravelMap");
		
		AINSBasePlayerController_AdminTravelMap_Params params {};
		params.TravelArgs = TravelArgs;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0566F990
	 * 		Name   -> Function Insurgency.INSBasePlayerController.AdminSetGamemodeProperty
	 * 		Flags  -> (Final, Exec, Native, Public)
	 * Parameters:
	 * 		class FString                                      Property                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FString                                      Value                                                      (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSBasePlayerController::AdminSetGamemodeProperty(const class FString& Property, const class FString& Value)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSBasePlayerController.AdminSetGamemodeProperty");
		
		AINSBasePlayerController_AdminSetGamemodeProperty_Params params {};
		params.Property = Property;
		params.Value = Value;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0566F900
	 * 		Name   -> Function Insurgency.INSBasePlayerController.AdminRestartRound
	 * 		Flags  -> (Final, Exec, Native, Public)
	 * Parameters:
	 * 		bool                                               bSwitchTeams                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSBasePlayerController::AdminRestartRound(bool bSwitchTeams)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSBasePlayerController.AdminRestartRound");
		
		AINSBasePlayerController_AdminRestartRound_Params params {};
		params.bSwitchTeams = bSwitchTeams;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0566F8E0
	 * 		Name   -> Function Insurgency.INSBasePlayerController.AdminRespawnAllPlayers
	 * 		Flags  -> (Final, Exec, Native, Public)
	 */
	void AINSBasePlayerController::AdminRespawnAllPlayers()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSBasePlayerController.AdminRespawnAllPlayers");
		
		AINSBasePlayerController_AdminRespawnAllPlayers_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0566F860
	 * 		Name   -> Function Insurgency.INSBasePlayerController.AdminKickPlayer
	 * 		Flags  -> (Final, Exec, Native, Public)
	 * Parameters:
	 * 		int32_t                                            PlayerId                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSBasePlayerController::AdminKickPlayer(int32_t PlayerId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSBasePlayerController.AdminKickPlayer");
		
		AINSBasePlayerController_AdminKickPlayer_Params params {};
		params.PlayerId = PlayerId;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0566F7C0
	 * 		Name   -> Function Insurgency.INSBasePlayerController.AdminGetGamemodeProperty
	 * 		Flags  -> (Final, Exec, Native, Public)
	 * Parameters:
	 * 		class FString                                      Property                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSBasePlayerController::AdminGetGamemodeProperty(const class FString& Property)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSBasePlayerController.AdminGetGamemodeProperty");
		
		AINSBasePlayerController_AdminGetGamemodeProperty_Params params {};
		params.Property = Property;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0566F7A0
	 * 		Name   -> Function Insurgency.INSBasePlayerController.AdminForceGameOver
	 * 		Flags  -> (Final, Exec, Native, Public)
	 */
	void AINSBasePlayerController::AdminForceGameOver()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSBasePlayerController.AdminForceGameOver");
		
		AINSBasePlayerController_AdminForceGameOver_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0566F780
	 * 		Name   -> Function Insurgency.INSBasePlayerController.AdminExtendRoundTimer
	 * 		Flags  -> (Final, Exec, Native, Public)
	 */
	void AINSBasePlayerController::AdminExtendRoundTimer()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSBasePlayerController.AdminExtendRoundTimer");
		
		AINSBasePlayerController_AdminExtendRoundTimer_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0566F760
	 * 		Name   -> Function Insurgency.INSBasePlayerController.AdminDebugPlayerState
	 * 		Flags  -> (Final, Exec, Native, Public)
	 */
	void AINSBasePlayerController::AdminDebugPlayerState()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSBasePlayerController.AdminDebugPlayerState");
		
		AINSBasePlayerController_AdminDebugPlayerState_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0566F740
	 * 		Name   -> Function Insurgency.INSBasePlayerController.AdminDebugLightLevels
	 * 		Flags  -> (Final, Exec, Native, Public)
	 */
	void AINSBasePlayerController::AdminDebugLightLevels()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSBasePlayerController.AdminDebugLightLevels");
		
		AINSBasePlayerController_AdminDebugLightLevels_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0566F6A0
	 * 		Name   -> Function Insurgency.INSBasePlayerController.AdminConsoleCommand
	 * 		Flags  -> (Final, Exec, Native, Public)
	 * Parameters:
	 * 		class FString                                      Command                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSBasePlayerController::AdminConsoleCommand(const class FString& Command)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSBasePlayerController.AdminConsoleCommand");
		
		AINSBasePlayerController_AdminConsoleCommand_Params params {};
		params.Command = Command;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0566F600
	 * 		Name   -> Function Insurgency.INSBasePlayerController.AdminCheat
	 * 		Flags  -> (Final, Exec, Native, Public)
	 * Parameters:
	 * 		class FString                                      Command                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSBasePlayerController::AdminCheat(const class FString& Command)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSBasePlayerController.AdminCheat");
		
		AINSBasePlayerController_AdminCheat_Params params {};
		params.Command = Command;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0566F530
	 * 		Name   -> Function Insurgency.INSBasePlayerController.AdminBanPlayer
	 * 		Flags  -> (Final, Exec, Native, Public)
	 * Parameters:
	 * 		int32_t                                            PlayerId                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              BanDuration                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSBasePlayerController::AdminBanPlayer(int32_t PlayerId, float BanDuration)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSBasePlayerController.AdminBanPlayer");
		
		AINSBasePlayerController_AdminBanPlayer_Params params {};
		params.PlayerId = PlayerId;
		params.BanDuration = BanDuration;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AINSBasePlayerController.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AINSBasePlayerController::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.INSBasePlayerController");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x008EA6D0
	 * 		Name   -> Function Insurgency.INSAIBlueprintLibrary.IsWithEditor
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 */
	bool UINSAIBlueprintLibrary::STATIC_IsWithEditor()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSAIBlueprintLibrary.IsWithEditor");
		
		UINSAIBlueprintLibrary_IsWithEditor_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056731F0
	 * 		Name   -> Function Insurgency.INSAIBlueprintLibrary.GetNavAreaClassAtLocation
	 * 		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     Location                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     Extents                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UClass* UINSAIBlueprintLibrary::STATIC_GetNavAreaClassAtLocation(class UObject* WorldContextObject, const struct FVector& Location, const struct FVector& Extents)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSAIBlueprintLibrary.GetNavAreaClassAtLocation");
		
		UINSAIBlueprintLibrary_GetNavAreaClassAtLocation_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.Location = Location;
		params.Extents = Extents;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05673170
	 * 		Name   -> Function Insurgency.INSAIBlueprintLibrary.GetAIDirector
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UINSAIDirector* UINSAIBlueprintLibrary::STATIC_GetAIDirector(class UObject* WorldContextObject)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSAIBlueprintLibrary.GetAIDirector");
		
		UINSAIBlueprintLibrary_GetAIDirector_Params params {};
		params.WorldContextObject = WorldContextObject;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05672FE0
	 * 		Name   -> Function Insurgency.INSAIBlueprintLibrary.ChangeNavAreaAtLocation
	 * 		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     Location                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     Extents                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UClass*                                      NewAreaClass                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Duration                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UINSAIBlueprintLibrary::STATIC_ChangeNavAreaAtLocation(class UObject* WorldContextObject, const struct FVector& Location, const struct FVector& Extents, class UClass* NewAreaClass, float Duration)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSAIBlueprintLibrary.ChangeNavAreaAtLocation");
		
		UINSAIBlueprintLibrary_ChangeNavAreaAtLocation_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.Location = Location;
		params.Extents = Extents;
		params.NewAreaClass = NewAreaClass;
		params.Duration = Duration;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UINSAIBlueprintLibrary.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UINSAIBlueprintLibrary::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.INSAIBlueprintLibrary");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x008EA6D0
	 * 		Name   -> Function Insurgency.INSBlueprintBuildMetadata.IsCTE
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 */
	bool UINSBlueprintBuildMetadata::STATIC_IsCTE()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSBlueprintBuildMetadata.IsCTE");
		
		UINSBlueprintBuildMetadata_IsCTE_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x008EA6D0
	 * 		Name   -> Function Insurgency.INSBlueprintBuildMetadata.IsConsoleBeta
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 */
	bool UINSBlueprintBuildMetadata::STATIC_IsConsoleBeta()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSBlueprintBuildMetadata.IsConsoleBeta");
		
		UINSBlueprintBuildMetadata_IsConsoleBeta_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056735E0
	 * 		Name   -> Function Insurgency.INSBlueprintBuildMetadata.GetPlatformUserID
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 */
	class FString UINSBlueprintBuildMetadata::STATIC_GetPlatformUserID()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSBlueprintBuildMetadata.GetPlatformUserID");
		
		UINSBlueprintBuildMetadata_GetPlatformUserID_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05673560
	 * 		Name   -> Function Insurgency.INSBlueprintBuildMetadata.GetGameVersion
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 */
	class FString UINSBlueprintBuildMetadata::STATIC_GetGameVersion()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSBlueprintBuildMetadata.GetGameVersion");
		
		UINSBlueprintBuildMetadata_GetGameVersion_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05673530
	 * 		Name   -> Function Insurgency.INSBlueprintBuildMetadata.GetChangelist
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 */
	int32_t UINSBlueprintBuildMetadata::STATIC_GetChangelist()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSBlueprintBuildMetadata.GetChangelist");
		
		UINSBlueprintBuildMetadata_GetChangelist_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UINSBlueprintBuildMetadata.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UINSBlueprintBuildMetadata::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.INSBlueprintBuildMetadata");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05675E30
	 * 		Name   -> Function Insurgency.INSBlueprintLibrary.WWiseGetListenerPositions
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		TArray<struct FVector>                             Positions                                                  (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UINSBlueprintLibrary::STATIC_WWiseGetListenerPositions(TArray<struct FVector>* Positions)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSBlueprintLibrary.WWiseGetListenerPositions");
		
		UINSBlueprintLibrary_WWiseGetListenerPositions_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (Positions != nullptr)
			*Positions = params.Positions;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05675D40
	 * 		Name   -> Function Insurgency.INSBlueprintLibrary.UpdateInertialEasing
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		struct FInertialEasingContainer1D                  Easing                                                     (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		class UObject*                                     WorldContextObject                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UINSBlueprintLibrary::STATIC_UpdateInertialEasing(struct FInertialEasingContainer1D* Easing, class UObject* WorldContextObject)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSBlueprintLibrary.UpdateInertialEasing");
		
		UINSBlueprintLibrary_UpdateInertialEasing_Params params {};
		params.WorldContextObject = WorldContextObject;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (Easing != nullptr)
			*Easing = params.Easing;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05675C70
	 * 		Name   -> Function Insurgency.INSBlueprintLibrary.UpdateDampingEasing
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		struct FDampingEasingContainer3D                   Easing                                                     (Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 * 		class UObject*                                     WorldContextObject                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UINSBlueprintLibrary::STATIC_UpdateDampingEasing(struct FDampingEasingContainer3D* Easing, class UObject* WorldContextObject)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSBlueprintLibrary.UpdateDampingEasing");
		
		UINSBlueprintLibrary_UpdateDampingEasing_Params params {};
		params.WorldContextObject = WorldContextObject;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (Easing != nullptr)
			*Easing = params.Easing;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05675B80
	 * 		Name   -> Function Insurgency.INSBlueprintLibrary.StringLessThan
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class FString                                      Left                                                       (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FString                                      Right                                                      (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UINSBlueprintLibrary::STATIC_StringLessThan(const class FString& Left, const class FString& Right)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSBlueprintLibrary.StringLessThan");
		
		UINSBlueprintLibrary_StringLessThan_Params params {};
		params.Left = Left;
		params.Right = Right;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05675A40
	 * 		Name   -> Function Insurgency.INSBlueprintLibrary.SoftLimitVector
	 * 		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FVector                                     X                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     LimitStart                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     LimitEnd                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FVector UINSBlueprintLibrary::STATIC_SoftLimitVector(const struct FVector& X, const struct FVector& LimitStart, const struct FVector& LimitEnd)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSBlueprintLibrary.SoftLimitVector");
		
		UINSBlueprintLibrary_SoftLimitVector_Params params {};
		params.X = X;
		params.LimitStart = LimitStart;
		params.LimitEnd = LimitEnd;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05675930
	 * 		Name   -> Function Insurgency.INSBlueprintLibrary.SoftLimitFloat
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		float                                              X                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              LimitStart                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              LimitEnd                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	float UINSBlueprintLibrary::STATIC_SoftLimitFloat(float X, float LimitStart, float LimitEnd)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSBlueprintLibrary.SoftLimitFloat");
		
		UINSBlueprintLibrary_SoftLimitFloat_Params params {};
		params.X = X;
		params.LimitStart = LimitStart;
		params.LimitEnd = LimitEnd;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05675850
	 * 		Name   -> Function Insurgency.INSBlueprintLibrary.SimpleAssetUnload
	 * 		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FSoftObjectPath                             AssetToUnload                                              (ConstParm, Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UINSBlueprintLibrary::STATIC_SimpleAssetUnload(const struct FSoftObjectPath& AssetToUnload)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSBlueprintLibrary.SimpleAssetUnload");
		
		UINSBlueprintLibrary_SimpleAssetUnload_Params params {};
		params.AssetToUnload = AssetToUnload;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05675760
	 * 		Name   -> Function Insurgency.INSBlueprintLibrary.SimpleAssetSyncLoad
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 */
	void UINSBlueprintLibrary::STATIC_SimpleAssetSyncLoad()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSBlueprintLibrary.SimpleAssetSyncLoad");
		
		UINSBlueprintLibrary_SimpleAssetSyncLoad_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05675630
	 * 		Name   -> Function Insurgency.INSBlueprintLibrary.SetInertialEasingTarget
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		struct FInertialEasingContainer1D                  Easing                                                     (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		class UObject*                                     WorldContextObject                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              NewTarget                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UINSBlueprintLibrary::STATIC_SetInertialEasingTarget(struct FInertialEasingContainer1D* Easing, class UObject* WorldContextObject, float NewTarget)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSBlueprintLibrary.SetInertialEasingTarget");
		
		UINSBlueprintLibrary_SetInertialEasingTarget_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.NewTarget = NewTarget;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (Easing != nullptr)
			*Easing = params.Easing;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05675500
	 * 		Name   -> Function Insurgency.INSBlueprintLibrary.SetDampingEasingTarget
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FDampingEasingContainer3D                   Easing                                                     (Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 * 		class UObject*                                     WorldContextObject                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     NewTarget                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UINSBlueprintLibrary::STATIC_SetDampingEasingTarget(struct FDampingEasingContainer3D* Easing, class UObject* WorldContextObject, const struct FVector& NewTarget)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSBlueprintLibrary.SetDampingEasingTarget");
		
		UINSBlueprintLibrary_SetDampingEasingTarget_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.NewTarget = NewTarget;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (Easing != nullptr)
			*Easing = params.Easing;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05675410
	 * 		Name   -> Function Insurgency.INSBlueprintLibrary.RotatorAngularDistance
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FRotator                                    rotatorA                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		struct FRotator                                    rotatorB                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	float UINSBlueprintLibrary::STATIC_RotatorAngularDistance(const struct FRotator& rotatorA, const struct FRotator& rotatorB)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSBlueprintLibrary.RotatorAngularDistance");
		
		UINSBlueprintLibrary_RotatorAngularDistance_Params params {};
		params.rotatorA = rotatorA;
		params.rotatorB = rotatorB;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05675210
	 * 		Name   -> Function Insurgency.INSBlueprintLibrary.PlayWorldShellShock
	 * 		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     Epicenter                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              InnerRadius                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              OuterRadius                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              InnerDuration                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              OuterDuration                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      DamageCauser                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UINSBlueprintLibrary::STATIC_PlayWorldShellShock(class UObject* WorldContextObject, const struct FVector& Epicenter, float InnerRadius, float OuterRadius, float InnerDuration, float OuterDuration, class AActor* DamageCauser)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSBlueprintLibrary.PlayWorldShellShock");
		
		UINSBlueprintLibrary_PlayWorldShellShock_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.Epicenter = Epicenter;
		params.InnerRadius = InnerRadius;
		params.OuterRadius = OuterRadius;
		params.InnerDuration = InnerDuration;
		params.OuterDuration = OuterDuration;
		params.DamageCauser = DamageCauser;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05675180
	 * 		Name   -> Function Insurgency.INSBlueprintLibrary.MakeFromColorTemperature
	 * 		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		float                                              Temperature                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FLinearColor UINSBlueprintLibrary::STATIC_MakeFromColorTemperature(float Temperature)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSBlueprintLibrary.MakeFromColorTemperature");
		
		UINSBlueprintLibrary_MakeFromColorTemperature_Params params {};
		params.Temperature = Temperature;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0565F8F0
	 * 		Name   -> Function Insurgency.INSBlueprintLibrary.IsLoggedInToEOS
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 */
	bool UINSBlueprintLibrary::STATIC_IsLoggedInToEOS()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSBlueprintLibrary.IsLoggedInToEOS");
		
		UINSBlueprintLibrary_IsLoggedInToEOS_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05675100
	 * 		Name   -> Function Insurgency.INSBlueprintLibrary.IsLinkingEnabled
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class FName                                        InService                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UINSBlueprintLibrary::STATIC_IsLinkingEnabled(const class FName& InService)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSBlueprintLibrary.IsLinkingEnabled");
		
		UINSBlueprintLibrary_IsLinkingEnabled_Params params {};
		params.InService = InService;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056750D0
	 * 		Name   -> Function Insurgency.INSBlueprintLibrary.IsGamePadConnected
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 */
	bool UINSBlueprintLibrary::STATIC_IsGamePadConnected()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSBlueprintLibrary.IsGamePadConnected");
		
		UINSBlueprintLibrary_IsGamePadConnected_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056750A0
	 * 		Name   -> Function Insurgency.INSBlueprintLibrary.IsFreeWeekendUser
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 */
	bool UINSBlueprintLibrary::STATIC_IsFreeWeekendUser()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSBlueprintLibrary.IsFreeWeekendUser");
		
		UINSBlueprintLibrary_IsFreeWeekendUser_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x008EA6D0
	 * 		Name   -> Function Insurgency.INSBlueprintLibrary.IsEGSBuild
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 */
	bool UINSBlueprintLibrary::STATIC_IsEGSBuild()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSBlueprintLibrary.IsEGSBuild");
		
		UINSBlueprintLibrary_IsEGSBuild_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x008EA6D0
	 * 		Name   -> Function Insurgency.INSBlueprintLibrary.IsConsolePlatform
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 */
	bool UINSBlueprintLibrary::STATIC_IsConsolePlatform()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSBlueprintLibrary.IsConsolePlatform");
		
		UINSBlueprintLibrary_IsConsolePlatform_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05675070
	 * 		Name   -> Function Insurgency.INSBlueprintLibrary.HasNvidiaGPU
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 */
	bool UINSBlueprintLibrary::STATIC_HasNvidiaGPU()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSBlueprintLibrary.HasNvidiaGPU");
		
		UINSBlueprintLibrary_HasNvidiaGPU_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05675040
	 * 		Name   -> Function Insurgency.INSBlueprintLibrary.HasIntelGPU
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 */
	bool UINSBlueprintLibrary::STATIC_HasIntelGPU()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSBlueprintLibrary.HasIntelGPU");
		
		UINSBlueprintLibrary_HasIntelGPU_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05675010
	 * 		Name   -> Function Insurgency.INSBlueprintLibrary.HasAMDGPU
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 */
	bool UINSBlueprintLibrary::STATIC_HasAMDGPU()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSBlueprintLibrary.HasAMDGPU");
		
		UINSBlueprintLibrary_HasAMDGPU_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05674F00
	 * 		Name   -> Function Insurgency.INSBlueprintLibrary.GetTotalPlayableArea
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     Center                                                     (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FBox                                        Extents                                                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UINSBlueprintLibrary::STATIC_GetTotalPlayableArea(class UObject* WorldContextObject, struct FVector* Center, struct FBox* Extents)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSBlueprintLibrary.GetTotalPlayableArea");
		
		UINSBlueprintLibrary_GetTotalPlayableArea_Params params {};
		params.WorldContextObject = WorldContextObject;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (Center != nullptr)
			*Center = params.Center;
		if (Extents != nullptr)
			*Extents = params.Extents;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05674EC0
	 * 		Name   -> Function Insurgency.INSBlueprintLibrary.GetPlatformOSSName
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 */
	class FName UINSBlueprintLibrary::STATIC_GetPlatformOSSName()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSBlueprintLibrary.GetPlatformOSSName");
		
		UINSBlueprintLibrary_GetPlatformOSSName_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05674DF0
	 * 		Name   -> Function Insurgency.INSBlueprintLibrary.GetPenetrationPower
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UClass*                                      AmmoClass                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              EvaluationVelocity                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	float UINSBlueprintLibrary::STATIC_GetPenetrationPower(class UClass* AmmoClass, float EvaluationVelocity)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSBlueprintLibrary.GetPenetrationPower");
		
		UINSBlueprintLibrary_GetPenetrationPower_Params params {};
		params.AmmoClass = AmmoClass;
		params.EvaluationVelocity = EvaluationVelocity;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05674D30
	 * 		Name   -> Function Insurgency.INSBlueprintLibrary.GetPendingDialog
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bIsVisible                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UUserWidget* UINSBlueprintLibrary::STATIC_GetPendingDialog(class UObject* WorldContextObject, bool bIsVisible)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSBlueprintLibrary.GetPendingDialog");
		
		UINSBlueprintLibrary_GetPendingDialog_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.bIsVisible = bIsVisible;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05674D00
	 * 		Name   -> Function Insurgency.INSBlueprintLibrary.GetPartyManager
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 */
	class UINSParty* UINSBlueprintLibrary::STATIC_GetPartyManager()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSBlueprintLibrary.GetPartyManager");
		
		UINSBlueprintLibrary_GetPartyManager_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05674BF0
	 * 		Name   -> Function Insurgency.INSBlueprintLibrary.GetOverviewAreaScenario
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     Center                                                     (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FBox                                        Extents                                                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UINSBlueprintLibrary::STATIC_GetOverviewAreaScenario(class UObject* WorldContextObject, struct FVector* Center, struct FBox* Extents)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSBlueprintLibrary.GetOverviewAreaScenario");
		
		UINSBlueprintLibrary_GetOverviewAreaScenario_Params params {};
		params.WorldContextObject = WorldContextObject;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (Center != nullptr)
			*Center = params.Center;
		if (Extents != nullptr)
			*Extents = params.Extents;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05674B10
	 * 		Name   -> Function Insurgency.INSBlueprintLibrary.GetLocalizedTextForCharacterResponse
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		ECharacterResponse                                 Value                                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class FText UINSBlueprintLibrary::STATIC_GetLocalizedTextForCharacterResponse(ECharacterResponse Value)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSBlueprintLibrary.GetLocalizedTextForCharacterResponse");
		
		UINSBlueprintLibrary_GetLocalizedTextForCharacterResponse_Params params {};
		params.Value = Value;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05674AC0
	 * 		Name   -> Function Insurgency.INSBlueprintLibrary.GetLastMatchScoreChange
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 */
	struct FMatchScoreChange UINSBlueprintLibrary::STATIC_GetLastMatchScoreChange()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSBlueprintLibrary.GetLastMatchScoreChange");
		
		UINSBlueprintLibrary_GetLastMatchScoreChange_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05674A40
	 * 		Name   -> Function Insurgency.INSBlueprintLibrary.GetFirstLocalPlayerController
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class APlayerController* UINSBlueprintLibrary::STATIC_GetFirstLocalPlayerController(class UObject* WorldContextObject)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSBlueprintLibrary.GetFirstLocalPlayerController");
		
		UINSBlueprintLibrary_GetFirstLocalPlayerController_Params params {};
		params.WorldContextObject = WorldContextObject;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05674840
	 * 		Name   -> Function Insurgency.INSBlueprintLibrary.GetAllScenariosForMaps
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		TArray<class FString>                              MapNames                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		TArray<struct FScenarioAssetInfo>                  OutScenarioNames                                           (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UINSBlueprintLibrary::STATIC_GetAllScenariosForMaps(TArray<class FString> MapNames, TArray<struct FScenarioAssetInfo>* OutScenarioNames)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSBlueprintLibrary.GetAllScenariosForMaps");
		
		UINSBlueprintLibrary_GetAllScenariosForMaps_Params params {};
		params.MapNames = MapNames;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutScenarioNames != nullptr)
			*OutScenarioNames = params.OutScenarioNames;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05674680
	 * 		Name   -> Function Insurgency.INSBlueprintLibrary.GetAllScenariosForMap
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class FString                                      MapName                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		TArray<struct FScenarioAssetInfo>                  OutScenarioNames                                           (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UINSBlueprintLibrary::STATIC_GetAllScenariosForMap(const class FString& MapName, TArray<struct FScenarioAssetInfo>* OutScenarioNames)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSBlueprintLibrary.GetAllScenariosForMap");
		
		UINSBlueprintLibrary_GetAllScenariosForMap_Params params {};
		params.MapName = MapName;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutScenarioNames != nullptr)
			*OutScenarioNames = params.OutScenarioNames;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056745B0
	 * 		Name   -> Function Insurgency.INSBlueprintLibrary.GetAllMapNames
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		TArray<class FString>                              OutMapNames                                                (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UINSBlueprintLibrary::STATIC_GetAllMapNames(TArray<class FString>* OutMapNames)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSBlueprintLibrary.GetAllMapNames");
		
		UINSBlueprintLibrary_GetAllMapNames_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutMapNames != nullptr)
			*OutMapNames = params.OutMapNames;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056744E0
	 * 		Name   -> Function Insurgency.INSBlueprintLibrary.GetAllLocalizedMapNames
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		TArray<class FString>                              OutMapNames                                                (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UINSBlueprintLibrary::STATIC_GetAllLocalizedMapNames(TArray<class FString>* OutMapNames)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSBlueprintLibrary.GetAllLocalizedMapNames");
		
		UINSBlueprintLibrary_GetAllLocalizedMapNames_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutMapNames != nullptr)
			*OutMapNames = params.OutMapNames;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05674420
	 * 		Name   -> Function Insurgency.INSBlueprintLibrary.FirearmHasFiremode
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class UClass*                                      FirearmClass                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EFirearmFiremode                                   Firemode                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UINSBlueprintLibrary::STATIC_FirearmHasFiremode(class UClass* FirearmClass, EFirearmFiremode Firemode)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSBlueprintLibrary.FirearmHasFiremode");
		
		UINSBlueprintLibrary_FirearmHasFiremode_Params params {};
		params.FirearmClass = FirearmClass;
		params.Firemode = Firemode;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056743A0
	 * 		Name   -> Function Insurgency.INSBlueprintLibrary.CheckFirstPerson
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class UObject*                                     Target                                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UINSBlueprintLibrary::STATIC_CheckFirstPerson(class UObject* Target)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSBlueprintLibrary.CheckFirstPerson");
		
		UINSBlueprintLibrary_CheckFirstPerson_Params params {};
		params.Target = Target;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05674210
	 * 		Name   -> Function Insurgency.INSBlueprintLibrary.CalcInertialEasing
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FInertialEasingContainer1D                  Easing                                                     (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		class UObject*                                     WorldContextObject                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Position                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Velocity                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UINSBlueprintLibrary::STATIC_CalcInertialEasing(struct FInertialEasingContainer1D* Easing, class UObject* WorldContextObject, float* Position, float* Velocity)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSBlueprintLibrary.CalcInertialEasing");
		
		UINSBlueprintLibrary_CalcInertialEasing_Params params {};
		params.WorldContextObject = WorldContextObject;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (Easing != nullptr)
			*Easing = params.Easing;
		if (Position != nullptr)
			*Position = params.Position;
		if (Velocity != nullptr)
			*Velocity = params.Velocity;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056740F0
	 * 		Name   -> Function Insurgency.INSBlueprintLibrary.CalcDampingEasing
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FDampingEasingContainer3D                   Easing                                                     (Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 * 		class UObject*                                     WorldContextObject                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     Position                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UINSBlueprintLibrary::STATIC_CalcDampingEasing(struct FDampingEasingContainer3D* Easing, class UObject* WorldContextObject, struct FVector* Position)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSBlueprintLibrary.CalcDampingEasing");
		
		UINSBlueprintLibrary_CalcDampingEasing_Params params {};
		params.WorldContextObject = WorldContextObject;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (Easing != nullptr)
			*Easing = params.Easing;
		if (Position != nullptr)
			*Position = params.Position;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UINSBlueprintLibrary.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UINSBlueprintLibrary::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.INSBlueprintLibrary");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05676050
	 * 		Name   -> Function Insurgency.INSCaptureTheBaseGameMode.CheckCustomEliminationRules
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void AINSCaptureTheBaseGameMode::CheckCustomEliminationRules()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSCaptureTheBaseGameMode.CheckCustomEliminationRules");
		
		AINSCaptureTheBaseGameMode_CheckCustomEliminationRules_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AINSCaptureTheBaseGameMode.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AINSCaptureTheBaseGameMode::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.INSCaptureTheBaseGameMode");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0567A7A0
	 * 		Name   -> Function Insurgency.INSCheatManager.TestNavSpawning
	 * 		Flags  -> (Final, Exec, Native, Public)
	 */
	void UINSCheatManager::TestNavSpawning()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSCheatManager.TestNavSpawning");
		
		UINSCheatManager_TestNavSpawning_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0567A720
	 * 		Name   -> Function Insurgency.INSCheatManager.TeleportToObjective
	 * 		Flags  -> (Final, Exec, Native, Public)
	 * Parameters:
	 * 		int32_t                                            ObjectiveId                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UINSCheatManager::TeleportToObjective(int32_t ObjectiveId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSCheatManager.TeleportToObjective");
		
		UINSCheatManager_TeleportToObjective_Params params {};
		params.ObjectiveId = ObjectiveId;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0567A660
	 * 		Name   -> Function Insurgency.INSCheatManager.SuppressMe
	 * 		Flags  -> (Final, Exec, Native, Public)
	 * Parameters:
	 * 		float                                              Suppression                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              HoldTime                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UINSCheatManager::SuppressMe(float Suppression, float HoldTime)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSCheatManager.SuppressMe");
		
		UINSCheatManager_SuppressMe_Params params {};
		params.Suppression = Suppression;
		params.HoldTime = HoldTime;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0567A640
	 * 		Name   -> Function Insurgency.INSCheatManager.SpewSpawnZones
	 * 		Flags  -> (Final, Exec, Native, Public)
	 */
	void UINSCheatManager::SpewSpawnZones()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSCheatManager.SpewSpawnZones");
		
		UINSCheatManager_SpewSpawnZones_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0567A540
	 * 		Name   -> Function Insurgency.INSCheatManager.SpawnFireSupport
	 * 		Flags  -> (Final, Exec, Native, Public, HasOutParms)
	 * Parameters:
	 * 		class FString                                      FireSupportClassName                                       (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bEnemy                                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UINSCheatManager::SpawnFireSupport(class FString* FireSupportClassName, bool bEnemy)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSCheatManager.SpawnFireSupport");
		
		UINSCheatManager_SpawnFireSupport_Params params {};
		params.bEnemy = bEnemy;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (FireSupportClassName != nullptr)
			*FireSupportClassName = params.FireSupportClassName;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0567A4C0
	 * 		Name   -> Function Insurgency.INSCheatManager.SetRoundTimer
	 * 		Flags  -> (Final, Exec, Native, Public)
	 * Parameters:
	 * 		int32_t                                            Seconds                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UINSCheatManager::SetRoundTimer(int32_t Seconds)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSCheatManager.SetRoundTimer");
		
		UINSCheatManager_SetRoundTimer_Params params {};
		params.Seconds = Seconds;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0567A440
	 * 		Name   -> Function Insurgency.INSCheatManager.SetExperience
	 * 		Flags  -> (Final, Exec, Native, Public)
	 * Parameters:
	 * 		int32_t                                            Experience                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UINSCheatManager::SetExperience(int32_t Experience)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSCheatManager.SetExperience");
		
		UINSCheatManager_SetExperience_Params params {};
		params.Experience = Experience;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0567A3C0
	 * 		Name   -> Function Insurgency.INSCheatManager.SABER_SetMapDownloadSpeed
	 * 		Flags  -> (Final, Exec, Native, Public)
	 * Parameters:
	 * 		int32_t                                            SpeedType                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UINSCheatManager::SABER_SetMapDownloadSpeed(int32_t SpeedType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSCheatManager.SABER_SetMapDownloadSpeed");
		
		UINSCheatManager_SABER_SetMapDownloadSpeed_Params params {};
		params.SpeedType = SpeedType;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0567A2E0
	 * 		Name   -> Function Insurgency.INSCheatManager.SABER_SendInvite
	 * 		Flags  -> (Final, Exec, Native, Public)
	 * Parameters:
	 * 		class FString                                      TargetUserId                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UINSCheatManager::SABER_SendInvite(const class FString& TargetUserId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSCheatManager.SABER_SendInvite");
		
		UINSCheatManager_SABER_SendInvite_Params params {};
		params.TargetUserId = TargetUserId;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00C76AB0
	 * 		Name   -> Function Insurgency.INSCheatManager.SABER_QuerySanctions
	 * 		Flags  -> (Final, Exec, Native, Public)
	 */
	void UINSCheatManager::SABER_QuerySanctions()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSCheatManager.SABER_QuerySanctions");
		
		UINSCheatManager_SABER_QuerySanctions_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0567A200
	 * 		Name   -> Function Insurgency.INSCheatManager.SABER_QueryExternalAccountId
	 * 		Flags  -> (Final, Exec, Native, Public)
	 * Parameters:
	 * 		class FString                                      AccountId                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UINSCheatManager::SABER_QueryExternalAccountId(const class FString& AccountId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSCheatManager.SABER_QueryExternalAccountId");
		
		UINSCheatManager_SABER_QueryExternalAccountId_Params params {};
		params.AccountId = AccountId;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0567A1E0
	 * 		Name   -> Function Insurgency.INSCheatManager.SABER_OpenInviteUI
	 * 		Flags  -> (Final, Exec, Native, Public)
	 */
	void UINSCheatManager::SABER_OpenInviteUI()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSCheatManager.SABER_OpenInviteUI");
		
		UINSCheatManager_SABER_OpenInviteUI_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0567A1C0
	 * 		Name   -> Function Insurgency.INSCheatManager.SABER_LeaveParty
	 * 		Flags  -> (Final, Exec, Native, Public)
	 */
	void UINSCheatManager::SABER_LeaveParty()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSCheatManager.SABER_LeaveParty");
		
		UINSCheatManager_SABER_LeaveParty_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0567A1A0
	 * 		Name   -> Function Insurgency.INSCheatManager.SABER_DisplayInviteId
	 * 		Flags  -> (Final, Exec, Native, Public)
	 */
	void UINSCheatManager::SABER_DisplayInviteId()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSCheatManager.SABER_DisplayInviteId");
		
		UINSCheatManager_SABER_DisplayInviteId_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0567A180
	 * 		Name   -> Function Insurgency.INSCheatManager.SABER_CreateParty
	 * 		Flags  -> (Final, Exec, Native, Public)
	 */
	void UINSCheatManager::SABER_CreateParty()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSCheatManager.SABER_CreateParty");
		
		UINSCheatManager_SABER_CreateParty_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0567A160
	 * 		Name   -> Function Insurgency.INSCheatManager.RevertConfirmableEvents
	 * 		Flags  -> (Final, Exec, Native, Public)
	 */
	void UINSCheatManager::RevertConfirmableEvents()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSCheatManager.RevertConfirmableEvents");
		
		UINSCheatManager_RevertConfirmableEvents_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0567A140
	 * 		Name   -> Function Insurgency.INSCheatManager.ResupplyNow
	 * 		Flags  -> (Final, Exec, Native, Public)
	 */
	void UINSCheatManager::ResupplyNow()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSCheatManager.ResupplyNow");
		
		UINSCheatManager_ResupplyNow_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0567A120
	 * 		Name   -> Function Insurgency.INSCheatManager.RespawnMe
	 * 		Flags  -> (Final, Exec, Native, Public)
	 */
	void UINSCheatManager::RespawnMe()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSCheatManager.RespawnMe");
		
		UINSCheatManager_RespawnMe_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0567A070
	 * 		Name   -> Function Insurgency.INSCheatManager.RemoveWeaponUpgrade
	 * 		Flags  -> (Final, Exec, Native, Public, HasOutParms)
	 * Parameters:
	 * 		class FString                                      UpgradeClass                                               (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UINSCheatManager::RemoveWeaponUpgrade(class FString* UpgradeClass)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSCheatManager.RemoveWeaponUpgrade");
		
		UINSCheatManager_RemoveWeaponUpgrade_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (UpgradeClass != nullptr)
			*UpgradeClass = params.UpgradeClass;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> DelegateFunction Insurgency.INSCheatManager.OnDisplayLicenseAgreementDialog__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 */
	void UINSCheatManager::OnDisplayLicenseAgreementDialog__DelegateSignature()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction Insurgency.INSCheatManager.OnDisplayLicenseAgreementDialog__DelegateSignature");
		
		UINSCheatManager_OnDisplayLicenseAgreementDialog__DelegateSignature_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0567A050
	 * 		Name   -> Function Insurgency.INSCheatManager.Noclip
	 * 		Flags  -> (Final, Exec, Native, Public)
	 */
	void UINSCheatManager::Noclip()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSCheatManager.Noclip");
		
		UINSCheatManager_Noclip_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0567A030
	 * 		Name   -> Function Insurgency.INSCheatManager.InstaCap
	 * 		Flags  -> (Final, Exec, Native, Public)
	 */
	void UINSCheatManager::InstaCap()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSCheatManager.InstaCap");
		
		UINSCheatManager_InstaCap_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05679FA0
	 * 		Name   -> Function Insurgency.INSCheatManager.IgnoreRoundOver
	 * 		Flags  -> (Final, Exec, Native, Public)
	 * Parameters:
	 * 		bool                                               bIgnoreRoundOver                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UINSCheatManager::IgnoreRoundOver(bool bIgnoreRoundOver)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSCheatManager.IgnoreRoundOver");
		
		UINSCheatManager_IgnoreRoundOver_Params params {};
		params.bIgnoreRoundOver = bIgnoreRoundOver;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05679F20
	 * 		Name   -> Function Insurgency.INSCheatManager.HurtMe
	 * 		Flags  -> (Final, Exec, Native, Public)
	 * Parameters:
	 * 		float                                              DamageAmount                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UINSCheatManager::HurtMe(float DamageAmount)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSCheatManager.HurtMe");
		
		UINSCheatManager_HurtMe_Params params {};
		params.DamageAmount = DamageAmount;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05679E30
	 * 		Name   -> Function Insurgency.INSCheatManager.GoToLocation
	 * 		Flags  -> (Final, Exec, Native, Public, HasOutParms)
	 * Parameters:
	 * 		class FString                                      Location                                                   (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UINSCheatManager::GoToLocation(class FString* Location)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSCheatManager.GoToLocation");
		
		UINSCheatManager_GoToLocation_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (Location != nullptr)
			*Location = params.Location;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05679F00
	 * 		Name   -> Function Insurgency.INSCheatManager.GodModeAllPlayer
	 * 		Flags  -> (Final, Exec, Native, Public)
	 */
	void UINSCheatManager::GodModeAllPlayer()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSCheatManager.GodModeAllPlayer");
		
		UINSCheatManager_GodModeAllPlayer_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05679EE0
	 * 		Name   -> Function Insurgency.INSCheatManager.GodMode
	 * 		Flags  -> (Final, Exec, Native, Public)
	 */
	void UINSCheatManager::GodMode()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSCheatManager.GodMode");
		
		UINSCheatManager_GodMode_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05679D80
	 * 		Name   -> Function Insurgency.INSCheatManager.GiveWeaponUpgrade
	 * 		Flags  -> (Final, Exec, Native, Public, HasOutParms)
	 * Parameters:
	 * 		class FString                                      UpgradeClass                                               (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UINSCheatManager::GiveWeaponUpgrade(class FString* UpgradeClass)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSCheatManager.GiveWeaponUpgrade");
		
		UINSCheatManager_GiveWeaponUpgrade_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (UpgradeClass != nullptr)
			*UpgradeClass = params.UpgradeClass;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05679CD0
	 * 		Name   -> Function Insurgency.INSCheatManager.GiveWeapon
	 * 		Flags  -> (Final, Exec, Native, Public, HasOutParms)
	 * Parameters:
	 * 		class FString                                      WeaponClass                                                (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UINSCheatManager::GiveWeapon(class FString* WeaponClass)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSCheatManager.GiveWeapon");
		
		UINSCheatManager_GiveWeapon_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (WeaponClass != nullptr)
			*WeaponClass = params.WeaponClass;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05679C50
	 * 		Name   -> Function Insurgency.INSCheatManager.GiveSupplyPoints
	 * 		Flags  -> (Final, Exec, Native, Public)
	 * Parameters:
	 * 		int32_t                                            Count                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UINSCheatManager::GiveSupplyPoints(int32_t Count)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSCheatManager.GiveSupplyPoints");
		
		UINSCheatManager_GiveSupplyPoints_Params params {};
		params.Count = Count;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05679BA0
	 * 		Name   -> Function Insurgency.INSCheatManager.GiveItem
	 * 		Flags  -> (Final, Exec, Native, Public, HasOutParms)
	 * Parameters:
	 * 		class FString                                      ItemClass                                                  (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UINSCheatManager::GiveItem(class FString* ItemClass)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSCheatManager.GiveItem");
		
		UINSCheatManager_GiveItem_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (ItemClass != nullptr)
			*ItemClass = params.ItemClass;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05679B20
	 * 		Name   -> Function Insurgency.INSCheatManager.GiveAmmo
	 * 		Flags  -> (Final, Exec, Native, Public)
	 * Parameters:
	 * 		int32_t                                            Count                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UINSCheatManager::GiveAmmo(int32_t Count)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSCheatManager.GiveAmmo");
		
		UINSCheatManager_GiveAmmo_Params params {};
		params.Count = Count;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05679AF0
	 * 		Name   -> Function Insurgency.INSCheatManager.GetOuterSoldier
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
	 */
	class AINSSoldier* UINSCheatManager::GetOuterSoldier()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSCheatManager.GetOuterSoldier");
		
		UINSCheatManager_GetOuterSoldier_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05679AD0
	 * 		Name   -> Function Insurgency.INSCheatManager.ForceObjectiveCapture
	 * 		Flags  -> (Final, Exec, Native, Public)
	 */
	void UINSCheatManager::ForceObjectiveCapture()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSCheatManager.ForceObjectiveCapture");
		
		UINSCheatManager_ForceObjectiveCapture_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056799F0
	 * 		Name   -> Function Insurgency.INSCheatManager.Debug_UpdateAchievementProgress
	 * 		Flags  -> (Final, Exec, Native, Public)
	 * Parameters:
	 * 		class FString                                      ID                                                         (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Percent                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UINSCheatManager::Debug_UpdateAchievementProgress(const class FString& ID, float Percent)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSCheatManager.Debug_UpdateAchievementProgress");
		
		UINSCheatManager_Debug_UpdateAchievementProgress_Params params {};
		params.ID = ID;
		params.Percent = Percent;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056798E0
	 * 		Name   -> Function Insurgency.INSCheatManager.BlindMe
	 * 		Flags  -> (Final, Exec, Native, Public)
	 * Parameters:
	 * 		float                                              Duration                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              FadeTime                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Suppression                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UINSCheatManager::BlindMe(float Duration, float FadeTime, float Suppression)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSCheatManager.BlindMe");
		
		UINSCheatManager_BlindMe_Params params {};
		params.Duration = Duration;
		params.FadeTime = FadeTime;
		params.Suppression = Suppression;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05679880
	 * 		Name   -> Function Insurgency.INSCheatManager.AIToggle
	 * 		Flags  -> (Final, Exec, Native, Public)
	 */
	void UINSCheatManager::AIToggle()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSCheatManager.AIToggle");
		
		UINSCheatManager_AIToggle_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05679860
	 * 		Name   -> Function Insurgency.INSCheatManager.AISpawn
	 * 		Flags  -> (Final, Exec, Native, Public)
	 */
	void UINSCheatManager::AISpawn()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSCheatManager.AISpawn");
		
		UINSCheatManager_AISpawn_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056797E0
	 * 		Name   -> Function Insurgency.INSCheatManager.AISetBotsAmount
	 * 		Flags  -> (Final, Exec, Native, Public)
	 * Parameters:
	 * 		int32_t                                            Amount                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UINSCheatManager::AISetBotsAmount(int32_t Amount)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSCheatManager.AISetBotsAmount");
		
		UINSCheatManager_AISetBotsAmount_Params params {};
		params.Amount = Amount;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056797C0
	 * 		Name   -> Function Insurgency.INSCheatManager.AIRespawnFriendlyBots
	 * 		Flags  -> (Final, Exec, Native, Public)
	 */
	void UINSCheatManager::AIRespawnFriendlyBots()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSCheatManager.AIRespawnFriendlyBots");
		
		UINSCheatManager_AIRespawnFriendlyBots_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056797A0
	 * 		Name   -> Function Insurgency.INSCheatManager.AIRespawnEnemyBots
	 * 		Flags  -> (Final, Exec, Native, Public)
	 */
	void UINSCheatManager::AIRespawnEnemyBots()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSCheatManager.AIRespawnEnemyBots");
		
		UINSCheatManager_AIRespawnEnemyBots_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05679780
	 * 		Name   -> Function Insurgency.INSCheatManager.AIRespawnBots
	 * 		Flags  -> (Final, Exec, Native, Public)
	 */
	void UINSCheatManager::AIRespawnBots()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSCheatManager.AIRespawnBots");
		
		UINSCheatManager_AIRespawnBots_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00C76AB0
	 * 		Name   -> Function Insurgency.INSCheatManager.AIPurgeFriendly
	 * 		Flags  -> (Final, Exec, Native, Public)
	 */
	void UINSCheatManager::AIPurgeFriendly()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSCheatManager.AIPurgeFriendly");
		
		UINSCheatManager_AIPurgeFriendly_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00C76AB0
	 * 		Name   -> Function Insurgency.INSCheatManager.AIPurgeEnemy
	 * 		Flags  -> (Final, Exec, Native, Public)
	 */
	void UINSCheatManager::AIPurgeEnemy()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSCheatManager.AIPurgeEnemy");
		
		UINSCheatManager_AIPurgeEnemy_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05679760
	 * 		Name   -> Function Insurgency.INSCheatManager.AIPurge
	 * 		Flags  -> (Final, Exec, Native, Public)
	 */
	void UINSCheatManager::AIPurge()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSCheatManager.AIPurge");
		
		UINSCheatManager_AIPurge_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056798C0
	 * 		Name   -> Function Insurgency.INSCheatManager.AiPerceptionToggle
	 * 		Flags  -> (Final, Exec, Native, Public, Const)
	 */
	void UINSCheatManager::AiPerceptionToggle()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSCheatManager.AiPerceptionToggle");
		
		UINSCheatManager_AiPerceptionToggle_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05679740
	 * 		Name   -> Function Insurgency.INSCheatManager.AINoTargetPlayer
	 * 		Flags  -> (Final, Exec, Native, Public)
	 */
	void UINSCheatManager::AINoTargetPlayer()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSCheatManager.AINoTargetPlayer");
		
		UINSCheatManager_AINoTargetPlayer_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056796C0
	 * 		Name   -> Function Insurgency.INSCheatManager.AIModifyMorale
	 * 		Flags  -> (Final, Exec, Native, Public)
	 * Parameters:
	 * 		float                                              Amount                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UINSCheatManager::AIModifyMorale(float Amount)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSCheatManager.AIModifyMorale");
		
		UINSCheatManager_AIModifyMorale_Params params {};
		params.Amount = Amount;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05679640
	 * 		Name   -> Function Insurgency.INSCheatManager.AIDifficulty
	 * 		Flags  -> (Final, Exec, Native, Public)
	 * Parameters:
	 * 		float                                              NewDifficulty                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UINSCheatManager::AIDifficulty(float NewDifficulty)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSCheatManager.AIDifficulty");
		
		UINSCheatManager_AIDifficulty_Params params {};
		params.NewDifficulty = NewDifficulty;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05679620
	 * 		Name   -> Function Insurgency.INSCheatManager.AIDebugThreats
	 * 		Flags  -> (Final, Exec, Native, Public)
	 */
	void UINSCheatManager::AIDebugThreats()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSCheatManager.AIDebugThreats");
		
		UINSCheatManager_AIDebugThreats_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05679600
	 * 		Name   -> Function Insurgency.INSCheatManager.AIDebugHUDSpectate
	 * 		Flags  -> (Final, Exec, Native, Public)
	 */
	void UINSCheatManager::AIDebugHUDSpectate()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSCheatManager.AIDebugHUDSpectate");
		
		UINSCheatManager_AIDebugHUDSpectate_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056795E0
	 * 		Name   -> Function Insurgency.INSCheatManager.AIDebugHUD
	 * 		Flags  -> (Final, Exec, Native, Public)
	 */
	void UINSCheatManager::AIDebugHUD()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSCheatManager.AIDebugHUD");
		
		UINSCheatManager_AIDebugHUD_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056798A0
	 * 		Name   -> Function Insurgency.INSCheatManager.AddCompassTestMarker
	 * 		Flags  -> (Final, Exec, Native, Public)
	 */
	void UINSCheatManager::AddCompassTestMarker()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSCheatManager.AddCompassTestMarker");
		
		UINSCheatManager_AddCompassTestMarker_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UINSCheatManager.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UINSCheatManager::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.INSCheatManager");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UCheckpointCounterAttackTypes.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UCheckpointCounterAttackTypes::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.CheckpointCounterAttackTypes");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0567C370
	 * 		Name   -> Function Insurgency.INSCoopMode.UseSoloModeWaveRules
	 * 		Flags  -> (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AINSCoopMode::UseSoloModeWaveRules()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSCoopMode.UseSoloModeWaveRules");
		
		AINSCoopMode_UseSoloModeWaveRules_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x04DB54E0
	 * 		Name   -> Function Insurgency.INSCoopMode.StartAlarms
	 * 		Flags  -> (Native, Public)
	 */
	void AINSCoopMode::StartAlarms()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSCoopMode.StartAlarms");
		
		AINSCoopMode_StartAlarms_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0567C2B0
	 * 		Name   -> Function Insurgency.INSCoopMode.RetreatBotsFromObjective
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class AObjectiveBase*                              RetreatObjective                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EMoraleAdjustmentReason                            Reason                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSCoopMode::RetreatBotsFromObjective(class AObjectiveBase* RetreatObjective, EMoraleAdjustmentReason Reason)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSCoopMode.RetreatBotsFromObjective");
		
		AINSCoopMode_RetreatBotsFromObjective_Params params {};
		params.RetreatObjective = RetreatObjective;
		params.Reason = Reason;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x04DB4DC0
	 * 		Name   -> Function Insurgency.INSCoopMode.OnAllHumanPlayersEliminated
	 * 		Flags  -> (Native, Event, Public, BlueprintEvent)
	 */
	void AINSCoopMode::OnAllHumanPlayersEliminated()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSCoopMode.OnAllHumanPlayersEliminated");
		
		AINSCoopMode_OnAllHumanPlayersEliminated_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0567C280
	 * 		Name   -> Function Insurgency.INSCoopMode.IsSplitScreen
	 * 		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AINSCoopMode::IsSplitScreen()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSCoopMode.IsSplitScreen");
		
		AINSCoopMode_IsSplitScreen_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0567C260
	 * 		Name   -> Function Insurgency.INSCoopMode.EnableBotSenses
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void AINSCoopMode::EnableBotSenses()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSCoopMode.EnableBotSenses");
		
		AINSCoopMode_EnableBotSenses_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0567C240
	 * 		Name   -> Function Insurgency.INSCoopMode.DisableBotSenses
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void AINSCoopMode::DisableBotSenses()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSCoopMode.DisableBotSenses");
		
		AINSCoopMode_DisableBotSenses_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AINSCoopMode.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AINSCoopMode::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.INSCoopMode");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0567B1E0
	 * 		Name   -> Function Insurgency.INSCheckpointGameMode.TryPlaceBotsInSpawnedVehicle
	 * 		Flags  -> (Native, Public)
	 * Parameters:
	 * 		class AVehicleBase*                                Vehicle                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool AINSCheckpointGameMode::TryPlaceBotsInSpawnedVehicle(class AVehicleBase* Vehicle)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSCheckpointGameMode.TryPlaceBotsInSpawnedVehicle");
		
		AINSCheckpointGameMode_TryPlaceBotsInSpawnedVehicle_Params params {};
		params.Vehicle = Vehicle;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0567B1C0
	 * 		Name   -> Function Insurgency.INSCheckpointGameMode.RespawnBotTeamPostObjective
	 * 		Flags  -> (Final, Native, Private)
	 */
	void AINSCheckpointGameMode::RespawnBotTeamPostObjective()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSCheckpointGameMode.RespawnBotTeamPostObjective");
		
		AINSCheckpointGameMode_RespawnBotTeamPostObjective_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0567B1A0
	 * 		Name   -> Function Insurgency.INSCheckpointGameMode.PlayCounterAttackResponse
	 * 		Flags  -> (Final, Native, Protected)
	 */
	void AINSCheckpointGameMode::PlayCounterAttackResponse()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSCheckpointGameMode.PlayCounterAttackResponse");
		
		AINSCheckpointGameMode_PlayCounterAttackResponse_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> Function Insurgency.INSCheckpointGameMode.OnStartDefending
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 */
	void AINSCheckpointGameMode::OnStartDefending()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSCheckpointGameMode.OnStartDefending");
		
		AINSCheckpointGameMode_OnStartDefending_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> Function Insurgency.INSCheckpointGameMode.OnFinishRetreat
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 */
	void AINSCheckpointGameMode::OnFinishRetreat()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSCheckpointGameMode.OnFinishRetreat");
		
		AINSCheckpointGameMode_OnFinishRetreat_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> Function Insurgency.INSCheckpointGameMode.OnFinishDefending
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 */
	void AINSCheckpointGameMode::OnFinishDefending()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSCheckpointGameMode.OnFinishDefending");
		
		AINSCheckpointGameMode_OnFinishDefending_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0567B170
	 * 		Name   -> Function Insurgency.INSCheckpointGameMode.GetActiveObjective
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
	 */
	class AObjectiveBase* AINSCheckpointGameMode::GetActiveObjective()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSCheckpointGameMode.GetActiveObjective");
		
		AINSCheckpointGameMode_GetActiveObjective_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0567B150
	 * 		Name   -> Function Insurgency.INSCheckpointGameMode.CheatRespawnBotsRandomCounterAttackClass
	 * 		Flags  -> (Final, Exec, Native, Public)
	 */
	void AINSCheckpointGameMode::CheatRespawnBotsRandomCounterAttackClass()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSCheckpointGameMode.CheatRespawnBotsRandomCounterAttackClass");
		
		AINSCheckpointGameMode_CheatRespawnBotsRandomCounterAttackClass_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0567B130
	 * 		Name   -> Function Insurgency.INSCheckpointGameMode.CheatFinishCounterAttack
	 * 		Flags  -> (Exec, Native, Public)
	 */
	void AINSCheckpointGameMode::CheatFinishCounterAttack()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSCheckpointGameMode.CheatFinishCounterAttack");
		
		AINSCheckpointGameMode_CheatFinishCounterAttack_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0567B110
	 * 		Name   -> Function Insurgency.INSCheckpointGameMode.CheatCounterAttack
	 * 		Flags  -> (Exec, Native, Public)
	 */
	void AINSCheckpointGameMode::CheatCounterAttack()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSCheckpointGameMode.CheatCounterAttack");
		
		AINSCheckpointGameMode_CheatCounterAttack_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AINSCheckpointGameMode.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AINSCheckpointGameMode::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.INSCheckpointGameMode");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UCheckpointHardcoreLoadouts.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UCheckpointHardcoreLoadouts::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.CheckpointHardcoreLoadouts");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AINSCheckpointHardcoreGameMode.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AINSCheckpointHardcoreGameMode::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.INSCheckpointHardcoreGameMode");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0567BD60
	 * 		Name   -> Function Insurgency.INSCheckpointTutorialGameMode.ForceEnemyBotsToObjective
	 * 		Flags  -> (Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class AObjectiveBase*                              Objective                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSCheckpointTutorialGameMode::ForceEnemyBotsToObjective(class AObjectiveBase* Objective)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSCheckpointTutorialGameMode.ForceEnemyBotsToObjective");
		
		AINSCheckpointTutorialGameMode_ForceEnemyBotsToObjective_Params params {};
		params.Objective = Objective;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AINSCheckpointTutorialGameMode.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AINSCheckpointTutorialGameMode::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.INSCheckpointTutorialGameMode");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AINSConvoyGameMode.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AINSConvoyGameMode::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.INSConvoyGameMode");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UINSDamageTypeCheat.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UINSDamageTypeCheat::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.INSDamageTypeCheat");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UINSDemoNetDriver.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UINSDemoNetDriver::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.INSDemoNetDriver");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0567D120
	 * 		Name   -> Function Insurgency.INSDemoSpectator.TogglePauseReplay
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void AINSDemoSpectator::TogglePauseReplay()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSDemoSpectator.TogglePauseReplay");
		
		AINSDemoSpectator_TogglePauseReplay_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0567D100
	 * 		Name   -> Function Insurgency.INSDemoSpectator.ToggleInGameMenu
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void AINSDemoSpectator::ToggleInGameMenu()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSDemoSpectator.ToggleInGameMenu");
		
		AINSDemoSpectator_ToggleInGameMenu_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0567D0E0
	 * 		Name   -> Function Insurgency.INSDemoSpectator.SpectatePreviousPlayer
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void AINSDemoSpectator::SpectatePreviousPlayer()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSDemoSpectator.SpectatePreviousPlayer");
		
		AINSDemoSpectator_SpectatePreviousPlayer_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0567D0C0
	 * 		Name   -> Function Insurgency.INSDemoSpectator.SpectateNextPlayer
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void AINSDemoSpectator::SpectateNextPlayer()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSDemoSpectator.SpectateNextPlayer");
		
		AINSDemoSpectator_SpectateNextPlayer_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0567D0A0
	 * 		Name   -> Function Insurgency.INSDemoSpectator.ShowInGameMenu
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void AINSDemoSpectator::ShowInGameMenu()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSDemoSpectator.ShowInGameMenu");
		
		AINSDemoSpectator_ShowInGameMenu_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0567D020
	 * 		Name   -> Function Insurgency.INSDemoSpectator.SetViewTargetPlayerState
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class APlayerState*                                InPlayerState                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSDemoSpectator::SetViewTargetPlayerState(class APlayerState* InPlayerState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSDemoSpectator.SetViewTargetPlayerState");
		
		AINSDemoSpectator_SetViewTargetPlayerState_Params params {};
		params.InPlayerState = InPlayerState;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0567CFA0
	 * 		Name   -> Function Insurgency.INSDemoSpectator.ScrubToTime
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		float                                              TimeSeconds                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSDemoSpectator::ScrubToTime(float TimeSeconds)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSDemoSpectator.ScrubToTime");
		
		AINSDemoSpectator_ScrubToTime_Params params {};
		params.TimeSeconds = TimeSeconds;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0567CF10
	 * 		Name   -> Function Insurgency.INSDemoSpectator.PauseReplay
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bPaused                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSDemoSpectator::PauseReplay(bool bPaused)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSDemoSpectator.PauseReplay");
		
		AINSDemoSpectator_PauseReplay_Params params {};
		params.bPaused = bPaused;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> DelegateFunction Insurgency.INSDemoSpectator.OnScrubToTimeComplete__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 * Parameters:
	 * 		bool                                               bSuccessful                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSDemoSpectator::OnScrubToTimeComplete__DelegateSignature(bool bSuccessful)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction Insurgency.INSDemoSpectator.OnScrubToTimeComplete__DelegateSignature");
		
		AINSDemoSpectator_OnScrubToTimeComplete__DelegateSignature_Params params {};
		params.bSuccessful = bSuccessful;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> DelegateFunction Insurgency.INSDemoSpectator.OnScrubbingStateChangedDelegate__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 * Parameters:
	 * 		bool                                               bIsScrubbing                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSDemoSpectator::OnScrubbingStateChangedDelegate__DelegateSignature(bool bIsScrubbing)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction Insurgency.INSDemoSpectator.OnScrubbingStateChangedDelegate__DelegateSignature");
		
		AINSDemoSpectator_OnScrubbingStateChangedDelegate__DelegateSignature_Params params {};
		params.bIsScrubbing = bIsScrubbing;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0567CEE0
	 * 		Name   -> Function Insurgency.INSDemoSpectator.IsReplayPaused
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AINSDemoSpectator::IsReplayPaused()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSDemoSpectator.IsReplayPaused");
		
		AINSDemoSpectator_IsReplayPaused_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0567CEC0
	 * 		Name   -> Function Insurgency.INSDemoSpectator.IncreasePlaybackSpeed
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void AINSDemoSpectator::IncreasePlaybackSpeed()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSDemoSpectator.IncreasePlaybackSpeed");
		
		AINSDemoSpectator_IncreasePlaybackSpeed_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0567CEA0
	 * 		Name   -> Function Insurgency.INSDemoSpectator.HideInGameMenu
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void AINSDemoSpectator::HideInGameMenu()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSDemoSpectator.HideInGameMenu");
		
		AINSDemoSpectator_HideInGameMenu_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0567CE20
	 * 		Name   -> Function Insurgency.INSDemoSpectator.GoToBookmark
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class FName                                        Slot                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSDemoSpectator::GoToBookmark(const class FName& Slot)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSDemoSpectator.GoToBookmark");
		
		AINSDemoSpectator_GoToBookmark_Params params {};
		params.Slot = Slot;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0567CDF0
	 * 		Name   -> Function Insurgency.INSDemoSpectator.GetDemoTimeTotal
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	float AINSDemoSpectator::GetDemoTimeTotal()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSDemoSpectator.GetDemoTimeTotal");
		
		AINSDemoSpectator_GetDemoTimeTotal_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0567CDC0
	 * 		Name   -> Function Insurgency.INSDemoSpectator.GetDemoTimeCurrent
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	float AINSDemoSpectator::GetDemoTimeCurrent()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSDemoSpectator.GetDemoTimeCurrent");
		
		AINSDemoSpectator_GetDemoTimeCurrent_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0567CD90
	 * 		Name   -> Function Insurgency.INSDemoSpectator.GetCurrentPlaybackSpeed
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	float AINSDemoSpectator::GetCurrentPlaybackSpeed()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSDemoSpectator.GetCurrentPlaybackSpeed");
		
		AINSDemoSpectator_GetCurrentPlaybackSpeed_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0567CD70
	 * 		Name   -> Function Insurgency.INSDemoSpectator.DecreasePlaybackSpeed
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void AINSDemoSpectator::DecreasePlaybackSpeed()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSDemoSpectator.DecreasePlaybackSpeed");
		
		AINSDemoSpectator_DecreasePlaybackSpeed_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0567CD50
	 * 		Name   -> Function Insurgency.INSDemoSpectator.CheckScenarioLoad
	 * 		Flags  -> (Final, Native, Public)
	 */
	void AINSDemoSpectator::CheckScenarioLoad()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSDemoSpectator.CheckScenarioLoad");
		
		AINSDemoSpectator_CheckScenarioLoad_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0567CCD0
	 * 		Name   -> Function Insurgency.INSDemoSpectator.AssignBookmark
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class FName                                        Slot                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSDemoSpectator::AssignBookmark(const class FName& Slot)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSDemoSpectator.AssignBookmark");
		
		AINSDemoSpectator_AssignBookmark_Params params {};
		params.Slot = Slot;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AINSDemoSpectator.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AINSDemoSpectator::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.INSDemoSpectator");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AINSMissionGameMode.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AINSMissionGameMode::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.INSMissionGameMode");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AINSFilmingGameMode.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AINSFilmingGameMode::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.INSFilmingGameMode");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AINSFirefightGameMode.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AINSFirefightGameMode::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.INSFirefightGameMode");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0567D9A0
	 * 		Name   -> Function Insurgency.INSFrontlineGameMode.OnWavesDepleted_DisableAutoBalance
	 * 		Flags  -> (Final, Native, Private)
	 * Parameters:
	 * 		class UReinforcementSystemComponent*               Component                                                  (ConstParm, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSFrontlineGameMode::OnWavesDepleted_DisableAutoBalance(class UReinforcementSystemComponent* Component)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSFrontlineGameMode.OnWavesDepleted_DisableAutoBalance");
		
		AINSFrontlineGameMode_OnWavesDepleted_DisableAutoBalance_Params params {};
		params.Component = Component;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0567D8E0
	 * 		Name   -> Function Insurgency.INSFrontlineGameMode.OnWaveGained_ReenableAutoBalance
	 * 		Flags  -> (Final, Native, Private)
	 * Parameters:
	 * 		class UReinforcementSystemComponent*               Component                                                  (ConstParm, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            OldWaveCount                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSFrontlineGameMode::OnWaveGained_ReenableAutoBalance(class UReinforcementSystemComponent* Component, int32_t OldWaveCount)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSFrontlineGameMode.OnWaveGained_ReenableAutoBalance");
		
		AINSFrontlineGameMode_OnWaveGained_ReenableAutoBalance_Params params {};
		params.Component = Component;
		params.OldWaveCount = OldWaveCount;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0567D8C0
	 * 		Name   -> Function Insurgency.INSFrontlineGameMode.LastStandDisableSpawns
	 * 		Flags  -> (Final, Native, Protected)
	 */
	void AINSFrontlineGameMode::LastStandDisableSpawns()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSFrontlineGameMode.LastStandDisableSpawns");
		
		AINSFrontlineGameMode_LastStandDisableSpawns_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AINSFrontlineGameMode.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AINSFrontlineGameMode::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.INSFrontlineGameMode");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05689F50
	 * 		Name   -> Function Insurgency.INSGameState.OnTeamInfoReady
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		unsigned char                                      ID                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSGameState::OnTeamInfoReady(unsigned char ID)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameState.OnTeamInfoReady");
		
		AINSGameState_OnTeamInfoReady_Params params {};
		params.ID = ID;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05689F10
	 * 		Name   -> Function Insurgency.INSGameState.OnRep_UseAttributeOverrides
	 * 		Flags  -> (Final, Native, Private)
	 */
	void AINSGameState::OnRep_UseAttributeOverrides()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameState.OnRep_UseAttributeOverrides");
		
		AINSGameState_OnRep_UseAttributeOverrides_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05689F30
	 * 		Name   -> Function Insurgency.INSGameState.OnRep_TeamLockState
	 * 		Flags  -> (Final, Native, Public)
	 */
	void AINSGameState::OnRep_TeamLockState()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameState.OnRep_TeamLockState");
		
		AINSGameState_OnRep_TeamLockState_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x04DB41A0
	 * 		Name   -> Function Insurgency.INSGameState.OnRep_SubMatchState
	 * 		Flags  -> (Native, Public)
	 */
	void AINSGameState::OnRep_SubMatchState()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameState.OnRep_SubMatchState");
		
		AINSGameState_OnRep_SubMatchState_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05689F10
	 * 		Name   -> Function Insurgency.INSGameState.OnRep_RulesetAttributeOverrides
	 * 		Flags  -> (Final, Native, Private)
	 */
	void AINSGameState::OnRep_RulesetAttributeOverrides()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameState.OnRep_RulesetAttributeOverrides");
		
		AINSGameState_OnRep_RulesetAttributeOverrides_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00C76AB0
	 * 		Name   -> Function Insurgency.INSGameState.OnRep_IsCompetitiveSession
	 * 		Flags  -> (Final, Native, Public)
	 */
	void AINSGameState::OnRep_IsCompetitiveSession()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameState.OnRep_IsCompetitiveSession");
		
		AINSGameState_OnRep_IsCompetitiveSession_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05689EF0
	 * 		Name   -> Function Insurgency.INSGameState.OnRep_FreezeTime
	 * 		Flags  -> (Final, Native, Protected)
	 */
	void AINSGameState::OnRep_FreezeTime()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameState.OnRep_FreezeTime");
		
		AINSGameState_OnRep_FreezeTime_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05689ED0
	 * 		Name   -> Function Insurgency.INSGameState.OnRep_ActiveScenarioLocalized
	 * 		Flags  -> (Final, Native, Private)
	 */
	void AINSGameState::OnRep_ActiveScenarioLocalized()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameState.OnRep_ActiveScenarioLocalized");
		
		AINSGameState_OnRep_ActiveScenarioLocalized_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05689EB0
	 * 		Name   -> Function Insurgency.INSGameState.OnRep_ActiveMutators
	 * 		Flags  -> (Final, Native, Private)
	 */
	void AINSGameState::OnRep_ActiveMutators()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameState.OnRep_ActiveMutators");
		
		AINSGameState_OnRep_ActiveMutators_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05689E90
	 * 		Name   -> Function Insurgency.INSGameState.OnMapVoteStarted
	 * 		Flags  -> (Final, Native, Public)
	 */
	void AINSGameState::OnMapVoteStarted()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameState.OnMapVoteStarted");
		
		AINSGameState_OnMapVoteStarted_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05689E70
	 * 		Name   -> Function Insurgency.INSGameState.OnMapVoteEnded
	 * 		Flags  -> (Final, Native, Public)
	 */
	void AINSGameState::OnMapVoteEnded()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameState.OnMapVoteEnded");
		
		AINSGameState_OnMapVoteEnded_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05689D70
	 * 		Name   -> Function Insurgency.INSGameState.MulticastTextMessage
	 * 		Flags  -> (Net, NetReliable, Native, Event, NetMulticast, Public)
	 * Parameters:
	 * 		class FText                                        Message                                                    (ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		class FName                                        Type                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSGameState::MulticastTextMessage(const class FText& Message, const class FName& Type)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameState.MulticastTextMessage");
		
		AINSGameState_MulticastTextMessage_Params params {};
		params.Message = Message;
		params.Type = Type;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05689CB0
	 * 		Name   -> Function Insurgency.INSGameState.MulticastSetActiveMutators
	 * 		Flags  -> (Net, NetReliable, Native, Event, NetMulticast, Public)
	 */
	void AINSGameState::MulticastSetActiveMutators()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameState.MulticastSetActiveMutators");
		
		AINSGameState_MulticastSetActiveMutators_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05689C20
	 * 		Name   -> Function Insurgency.INSGameState.IsTeamVisuallyLocked
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		unsigned char                                      TeamIndex                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool AINSGameState::IsTeamVisuallyLocked(unsigned char TeamIndex)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameState.IsTeamVisuallyLocked");
		
		AINSGameState_IsTeamVisuallyLocked_Params params {};
		params.TeamIndex = TeamIndex;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05689BF0
	 * 		Name   -> Function Insurgency.INSGameState.IsRoundRunning
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AINSGameState::IsRoundRunning()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameState.IsRoundRunning");
		
		AINSGameState_IsRoundRunning_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05689BC0
	 * 		Name   -> Function Insurgency.INSGameState.IsPostRoundOrGame
	 * 		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AINSGameState::IsPostRoundOrGame()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameState.IsPostRoundOrGame");
		
		AINSGameState_IsPostRoundOrGame_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05689B90
	 * 		Name   -> Function Insurgency.INSGameState.IsPostRound
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AINSGameState::IsPostRound()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameState.IsPostRound");
		
		AINSGameState_IsPostRound_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05689B60
	 * 		Name   -> Function Insurgency.INSGameState.IsMapVoteInProgress
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AINSGameState::IsMapVoteInProgress()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameState.IsMapVoteInProgress");
		
		AINSGameState_IsMapVoteInProgress_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05689B30
	 * 		Name   -> Function Insurgency.INSGameState.IsGameOver
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AINSGameState::IsGameOver()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameState.IsGameOver");
		
		AINSGameState_IsGameOver_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05689B00
	 * 		Name   -> Function Insurgency.INSGameState.InRoundIntermission
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AINSGameState::InRoundIntermission()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameState.InRoundIntermission");
		
		AINSGameState_InRoundIntermission_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05689A70
	 * 		Name   -> Function Insurgency.INSGameState.GetTeam
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		unsigned char                                      ID                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class ATeamInfo* AINSGameState::GetTeam(unsigned char ID)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameState.GetTeam");
		
		AINSGameState_GetTeam_Params params {};
		params.ID = ID;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05689A70
	 * 		Name   -> Function Insurgency.INSGameState.GetFaction
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		unsigned char                                      FactionId                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class ATeamInfo* AINSGameState::GetFaction(unsigned char FactionId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameState.GetFaction");
		
		AINSGameState_GetFaction_Params params {};
		params.FactionId = FactionId;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x04DB3FA0
	 * 		Name   -> Function Insurgency.INSGameState.DebugStartMapVoteFromCycle
	 * 		Flags  -> (Exec, Native, Public)
	 */
	void AINSGameState::DebugStartMapVoteFromCycle()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameState.DebugStartMapVoteFromCycle");
		
		AINSGameState_DebugStartMapVoteFromCycle_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056899C0
	 * 		Name   -> Function Insurgency.INSGameState.CollectInterestingTaglines
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		TArray<struct FOtherPlayerAwardedTagline>          OutTaglines                                                (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSGameState::CollectInterestingTaglines(TArray<struct FOtherPlayerAwardedTagline>* OutTaglines)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameState.CollectInterestingTaglines");
		
		AINSGameState_CollectInterestingTaglines_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutTaglines != nullptr)
			*OutTaglines = params.OutTaglines;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05689920
	 * 		Name   -> Function Insurgency.INSGameState.CanResupplyInCurrentGameState
	 * 		Flags  -> (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
	 * Parameters:
	 * 		class AINSSoldier*                                 Soldier                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool AINSGameState::CanResupplyInCurrentGameState(class AINSSoldier* Soldier)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameState.CanResupplyInCurrentGameState");
		
		AINSGameState_CanResupplyInCurrentGameState_Params params {};
		params.Soldier = Soldier;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05689900
	 * 		Name   -> Function Insurgency.INSGameState.BroadcastShowPlayerExperience
	 * 		Flags  -> (Net, NetReliable, Native, Event, NetMulticast, Public)
	 */
	void AINSGameState::BroadcastShowPlayerExperience()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameState.BroadcastShowPlayerExperience");
		
		AINSGameState_BroadcastShowPlayerExperience_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x04DB4500
	 * 		Name   -> Function Insurgency.INSGameState.BroadcastRoundReset
	 * 		Flags  -> (Net, NetReliable, Native, Event, NetMulticast, Public)
	 */
	void AINSGameState::BroadcastRoundReset()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameState.BroadcastRoundReset");
		
		AINSGameState_BroadcastRoundReset_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056897E0
	 * 		Name   -> Function Insurgency.INSGameState.BroadcastRoundOver
	 * 		Flags  -> (Net, NetReliable, Native, Event, NetMulticast, Public)
	 * Parameters:
	 * 		ERoundConclusion                                   RoundEndReason                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		unsigned char                                      WinningFaction                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		TArray<struct FOtherPlayerAwardedTagline>          Taglines                                                   (ConstParm, Parm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSGameState::BroadcastRoundOver(ERoundConclusion RoundEndReason, unsigned char WinningFaction, TArray<struct FOtherPlayerAwardedTagline> Taglines)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameState.BroadcastRoundOver");
		
		AINSGameState_BroadcastRoundOver_Params params {};
		params.RoundEndReason = RoundEndReason;
		params.WinningFaction = WinningFaction;
		params.Taglines = Taglines;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05689760
	 * 		Name   -> Function Insurgency.INSGameState.BroadcastMatchEnded
	 * 		Flags  -> (Net, NetReliable, Native, Event, NetMulticast, Public)
	 * Parameters:
	 * 		unsigned char                                      WinningFaction                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSGameState::BroadcastMatchEnded(unsigned char WinningFaction)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameState.BroadcastMatchEnded");
		
		AINSGameState_BroadcastMatchEnded_Params params {};
		params.WinningFaction = WinningFaction;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056896D0
	 * 		Name   -> Function Insurgency.INSGameState.AddTeam
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class ATeamInfo*                                   InTeam                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	int32_t AINSGameState::AddTeam(class ATeamInfo* InTeam)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameState.AddTeam");
		
		AINSGameState_AddTeam_Params params {};
		params.InTeam = InTeam;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AINSGameState.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AINSGameState::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.INSGameState");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056942D0
	 * 		Name   -> Function Insurgency.INSMultiplayerGameState.SetRoundTimer
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		int32_t                                            Seconds                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSMultiplayerGameState::SetRoundTimer(int32_t Seconds)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSMultiplayerGameState.SetRoundTimer");
		
		AINSMultiplayerGameState_SetRoundTimer_Params params {};
		params.Seconds = Seconds;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x04DB40E0
	 * 		Name   -> Function Insurgency.INSMultiplayerGameState.OnRoundStarted
	 * 		Flags  -> (Native, Public, BlueprintCallable)
	 */
	void AINSMultiplayerGameState::OnRoundStarted()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSMultiplayerGameState.OnRoundStarted");
		
		AINSMultiplayerGameState_OnRoundStarted_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x04DB4320
	 * 		Name   -> Function Insurgency.INSMultiplayerGameState.OnRoundEnded
	 * 		Flags  -> (Native, Public, BlueprintCallable)
	 */
	void AINSMultiplayerGameState::OnRoundEnded()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSMultiplayerGameState.OnRoundEnded");
		
		AINSMultiplayerGameState_OnRoundEnded_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x04DB3CA0
	 * 		Name   -> Function Insurgency.INSMultiplayerGameState.OnRep_EndRoundTime
	 * 		Flags  -> (Native, Protected)
	 */
	void AINSMultiplayerGameState::OnRep_EndRoundTime()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSMultiplayerGameState.OnRep_EndRoundTime");
		
		AINSMultiplayerGameState_OnRep_EndRoundTime_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x04DB4060
	 * 		Name   -> Function Insurgency.INSMultiplayerGameState.OnPreRoundStarted
	 * 		Flags  -> (Native, Public, BlueprintCallable)
	 */
	void AINSMultiplayerGameState::OnPreRoundStarted()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSMultiplayerGameState.OnPreRoundStarted");
		
		AINSMultiplayerGameState_OnPreRoundStarted_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056942A0
	 * 		Name   -> Function Insurgency.INSMultiplayerGameState.IsWaitingForPlayers
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AINSMultiplayerGameState::IsWaitingForPlayers()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSMultiplayerGameState.IsWaitingForPlayers");
		
		AINSMultiplayerGameState_IsWaitingForPlayers_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05694270
	 * 		Name   -> Function Insurgency.INSMultiplayerGameState.IsThirdPersonSpectatorAllowed
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AINSMultiplayerGameState::IsThirdPersonSpectatorAllowed()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSMultiplayerGameState.IsThirdPersonSpectatorAllowed");
		
		AINSMultiplayerGameState_IsThirdPersonSpectatorAllowed_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05689BF0
	 * 		Name   -> Function Insurgency.INSMultiplayerGameState.IsRoundActive
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AINSMultiplayerGameState::IsRoundActive()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSMultiplayerGameState.IsRoundActive");
		
		AINSMultiplayerGameState_IsRoundActive_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05694240
	 * 		Name   -> Function Insurgency.INSMultiplayerGameState.IsInPreRound
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AINSMultiplayerGameState::IsInPreRound()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSMultiplayerGameState.IsInPreRound");
		
		AINSMultiplayerGameState_IsInPreRound_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05694210
	 * 		Name   -> Function Insurgency.INSMultiplayerGameState.IsGameStarting
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AINSMultiplayerGameState::IsGameStarting()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSMultiplayerGameState.IsGameStarting");
		
		AINSMultiplayerGameState_IsGameStarting_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056941E0
	 * 		Name   -> Function Insurgency.INSMultiplayerGameState.IsDeathCameraEnabled
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AINSMultiplayerGameState::IsDeathCameraEnabled()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSMultiplayerGameState.IsDeathCameraEnabled");
		
		AINSMultiplayerGameState_IsDeathCameraEnabled_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056941C0
	 * 		Name   -> Function Insurgency.INSMultiplayerGameState.InvalidateRoundTimer
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void AINSMultiplayerGameState::InvalidateRoundTimer()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSMultiplayerGameState.InvalidateRoundTimer");
		
		AINSMultiplayerGameState_InvalidateRoundTimer_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05694190
	 * 		Name   -> Function Insurgency.INSMultiplayerGameState.GetRoundTimeRemaining
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	float AINSMultiplayerGameState::GetRoundTimeRemaining()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSMultiplayerGameState.GetRoundTimeRemaining");
		
		AINSMultiplayerGameState_GetRoundTimeRemaining_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05694160
	 * 		Name   -> Function Insurgency.INSMultiplayerGameState.GetRoundTimeElapsed
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	float AINSMultiplayerGameState::GetRoundTimeElapsed()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSMultiplayerGameState.GetRoundTimeElapsed");
		
		AINSMultiplayerGameState_GetRoundTimeElapsed_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056940E0
	 * 		Name   -> Function Insurgency.INSMultiplayerGameState.ExtendRoundTimer
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		int32_t                                            Seconds                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSMultiplayerGameState::ExtendRoundTimer(int32_t Seconds)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSMultiplayerGameState.ExtendRoundTimer");
		
		AINSMultiplayerGameState_ExtendRoundTimer_Params params {};
		params.Seconds = Seconds;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056940B0
	 * 		Name   -> Function Insurgency.INSMultiplayerGameState.AreClassLevelRestrictionsEnabled
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AINSMultiplayerGameState::AreClassLevelRestrictionsEnabled()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSMultiplayerGameState.AreClassLevelRestrictionsEnabled");
		
		AINSMultiplayerGameState_AreClassLevelRestrictionsEnabled_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05694080
	 * 		Name   -> Function Insurgency.INSMultiplayerGameState.AllowPlayerMove
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AINSMultiplayerGameState::AllowPlayerMove()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSMultiplayerGameState.AllowPlayerMove");
		
		AINSMultiplayerGameState_AllowPlayerMove_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AINSMultiplayerGameState.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AINSMultiplayerGameState::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.INSMultiplayerGameState");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AINSFrontlineGameState.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AINSFrontlineGameState::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.INSFrontlineGameState");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0573D7C0
	 * 		Name   -> Function Insurgency.TeamInfo.UpdateQueuedRadioEvents
	 * 		Flags  -> (Final, Native, Private)
	 */
	void ATeamInfo::UpdateQueuedRadioEvents()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.TeamInfo.UpdateQueuedRadioEvents");
		
		ATeamInfo_UpdateQueuedRadioEvents_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0573D6F0
	 * 		Name   -> Function Insurgency.TeamInfo.SetFireSupportDisabled
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UFireSupportDefinition*                      FireSupportDefinition                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bDisabled                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ATeamInfo::SetFireSupportDisabled(class UFireSupportDefinition* FireSupportDefinition, bool bDisabled)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.TeamInfo.SetFireSupportDisabled");
		
		ATeamInfo_SetFireSupportDisabled_Params params {};
		params.FireSupportDefinition = FireSupportDefinition;
		params.bDisabled = bDisabled;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0573D6D0
	 * 		Name   -> Function Insurgency.TeamInfo.ResetPointsScore
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void ATeamInfo::ResetPointsScore()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.TeamInfo.ResetPointsScore");
		
		ATeamInfo_ResetPointsScore_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0573D6B0
	 * 		Name   -> Function Insurgency.TeamInfo.ResetFireSupportTimers
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void ATeamInfo::ResetFireSupportTimers()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.TeamInfo.ResetFireSupportTimers");
		
		ATeamInfo_ResetFireSupportTimers_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0573D690
	 * 		Name   -> Function Insurgency.TeamInfo.RemoveInvalidPlayerEntries
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void ATeamInfo::RemoveInvalidPlayerEntries()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.TeamInfo.RemoveInvalidPlayerEntries");
		
		ATeamInfo_RemoveInvalidPlayerEntries_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0573D670
	 * 		Name   -> Function Insurgency.TeamInfo.RemoveEmptyPlayerEntries
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void ATeamInfo::RemoveEmptyPlayerEntries()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.TeamInfo.RemoveEmptyPlayerEntries");
		
		ATeamInfo_RemoveEmptyPlayerEntries_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0573D5E0
	 * 		Name   -> Function Insurgency.TeamInfo.ReadyPlayerCount
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		bool                                               bExcludeBots                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	int32_t ATeamInfo::ReadyPlayerCount(bool bExcludeBots)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.TeamInfo.ReadyPlayerCount");
		
		ATeamInfo_ReadyPlayerCount_Params params {};
		params.bExcludeBots = bExcludeBots;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0573D520
	 * 		Name   -> Function Insurgency.TeamInfo.PlayerCountInClass
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		class UPlayerClass*                                PlayerClass                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bExcludeBots                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	int32_t ATeamInfo::PlayerCountInClass(class UPlayerClass* PlayerClass, bool bExcludeBots)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.TeamInfo.PlayerCountInClass");
		
		ATeamInfo_PlayerCountInClass_Params params {};
		params.PlayerClass = PlayerClass;
		params.bExcludeBots = bExcludeBots;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0573D340
	 * 		Name   -> Function Insurgency.TeamInfo.PlayerCountByClass
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		TMap<class UPlayerClass*, int32_t>                 OutMappedCount                                             (Parm, OutParm, NativeAccessSpecifierPublic)
	 * 		bool                                               bExcludeBots                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ATeamInfo::PlayerCountByClass(TMap<class UPlayerClass*, int32_t>* OutMappedCount, bool bExcludeBots)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.TeamInfo.PlayerCountByClass");
		
		ATeamInfo_PlayerCountByClass_Params params {};
		params.bExcludeBots = bExcludeBots;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutMappedCount != nullptr)
			*OutMappedCount = params.OutMappedCount;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0573D2B0
	 * 		Name   -> Function Insurgency.TeamInfo.PlayerCount
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		bool                                               bExcludeBots                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	int32_t ATeamInfo::PlayerCount(bool bExcludeBots)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.TeamInfo.PlayerCount");
		
		ATeamInfo_PlayerCount_Params params {};
		params.bExcludeBots = bExcludeBots;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> DelegateFunction Insurgency.TeamInfo.OnWaveShouldBlinkDelegate__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 * Parameters:
	 * 		bool                                               bBlink                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ATeamInfo::OnWaveShouldBlinkDelegate__DelegateSignature(bool bBlink)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction Insurgency.TeamInfo.OnWaveShouldBlinkDelegate__DelegateSignature");
		
		ATeamInfo_OnWaveShouldBlinkDelegate__DelegateSignature_Params params {};
		params.bBlink = bBlink;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> DelegateFunction Insurgency.TeamInfo.OnReplicatedTeamSettingsUpdatedDelegate__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate, HasOutParms)
	 * Parameters:
	 * 		class ATeamInfo*                                   Team                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FReplicatedTeamSettings                     NewSettings                                                (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void ATeamInfo::OnReplicatedTeamSettingsUpdatedDelegate__DelegateSignature(class ATeamInfo* Team, const struct FReplicatedTeamSettings& NewSettings)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction Insurgency.TeamInfo.OnReplicatedTeamSettingsUpdatedDelegate__DelegateSignature");
		
		ATeamInfo_OnReplicatedTeamSettingsUpdatedDelegate__DelegateSignature_Params params {};
		params.Team = Team;
		params.NewSettings = NewSettings;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0573D290
	 * 		Name   -> Function Insurgency.TeamInfo.OnRep_TeamSettings
	 * 		Flags  -> (Final, Native, Private)
	 */
	void ATeamInfo::OnRep_TeamSettings()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.TeamInfo.OnRep_TeamSettings");
		
		ATeamInfo_OnRep_TeamSettings_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x04DB3DC0
	 * 		Name   -> Function Insurgency.TeamInfo.OnRep_TeamId
	 * 		Flags  -> (Native, Public)
	 */
	void ATeamInfo::OnRep_TeamId()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.TeamInfo.OnRep_TeamId");
		
		ATeamInfo_OnRep_TeamId_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0573D270
	 * 		Name   -> Function Insurgency.TeamInfo.OnRep_LastOneStanding
	 * 		Flags  -> (Final, Native, Public)
	 */
	void ATeamInfo::OnRep_LastOneStanding()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.TeamInfo.OnRep_LastOneStanding");
		
		ATeamInfo_OnRep_LastOneStanding_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0573D250
	 * 		Name   -> Function Insurgency.TeamInfo.OnRep_Faction
	 * 		Flags  -> (Final, Native, Private)
	 */
	void ATeamInfo::OnRep_Faction()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.TeamInfo.OnRep_Faction");
		
		ATeamInfo_OnRep_Faction_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> DelegateFunction Insurgency.TeamInfo.OnReinforcedDelegate__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 * Parameters:
	 * 		int32_t                                            PlayersSpawned                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ATeamInfo::OnReinforcedDelegate__DelegateSignature(int32_t PlayersSpawned)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction Insurgency.TeamInfo.OnReinforcedDelegate__DelegateSignature");
		
		ATeamInfo_OnReinforcedDelegate__DelegateSignature_Params params {};
		params.PlayersSpawned = PlayersSpawned;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0573D180
	 * 		Name   -> Function Insurgency.TeamInfo.LockFireSupport
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UFireSupportDefinition*                      FireSupportDefinition                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Duration                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ATeamInfo::LockFireSupport(class UFireSupportDefinition* FireSupportDefinition, float Duration)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.TeamInfo.LockFireSupport");
		
		ATeamInfo_LockFireSupport_Params params {};
		params.FireSupportDefinition = FireSupportDefinition;
		params.Duration = Duration;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0573D150
	 * 		Name   -> Function Insurgency.TeamInfo.IsWavePending
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool ATeamInfo::IsWavePending()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.TeamInfo.IsWavePending");
		
		ATeamInfo_IsWavePending_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0573D120
	 * 		Name   -> Function Insurgency.TeamInfo.IsVotingEnabled
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool ATeamInfo::IsVotingEnabled()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.TeamInfo.IsVotingEnabled");
		
		ATeamInfo_IsVotingEnabled_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0573D090
	 * 		Name   -> Function Insurgency.TeamInfo.IsPlayerOnTeam
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class AController*                                 Player                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool ATeamInfo::IsPlayerOnTeam(class AController* Player)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.TeamInfo.IsPlayerOnTeam");
		
		ATeamInfo_IsPlayerOnTeam_Params params {};
		params.Player = Player;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0573D000
	 * 		Name   -> Function Insurgency.TeamInfo.IsFireSupportOnCooldown
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class UFireSupportDefinition*                      FireSupportDefinition                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool ATeamInfo::IsFireSupportOnCooldown(class UFireSupportDefinition* FireSupportDefinition)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.TeamInfo.IsFireSupportOnCooldown");
		
		ATeamInfo_IsFireSupportOnCooldown_Params params {};
		params.FireSupportDefinition = FireSupportDefinition;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0573CF70
	 * 		Name   -> Function Insurgency.TeamInfo.IsFireSupportDisabled
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class UFireSupportDefinition*                      FireSupportDefinition                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool ATeamInfo::IsFireSupportDisabled(class UFireSupportDefinition* FireSupportDefinition)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.TeamInfo.IsFireSupportDisabled");
		
		ATeamInfo_IsFireSupportDisabled_Params params {};
		params.FireSupportDefinition = FireSupportDefinition;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0573CEB0
	 * 		Name   -> Function Insurgency.TeamInfo.IncrementScore
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		int32_t                                            Amount                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EScoreType                                         ScoreType                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ATeamInfo::IncrementScore(int32_t Amount, EScoreType ScoreType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.TeamInfo.IncrementScore");
		
		ATeamInfo_IncrementScore_Params params {};
		params.Amount = Amount;
		params.ScoreType = ScoreType;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0573CE30
	 * 		Name   -> Function Insurgency.TeamInfo.IncrementPointsScore
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		int32_t                                            Amount                                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ATeamInfo::IncrementPointsScore(int32_t Amount)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.TeamInfo.IncrementPointsScore");
		
		ATeamInfo_IncrementPointsScore_Params params {};
		params.Amount = Amount;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0573CDB0
	 * 		Name   -> Function Insurgency.TeamInfo.IncrementFireSupportUse
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UFireSupportDefinition*                      FireSupportDefinition                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ATeamInfo::IncrementFireSupportUse(class UFireSupportDefinition* FireSupportDefinition)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.TeamInfo.IncrementFireSupportUse");
		
		ATeamInfo_IncrementFireSupportUse_Params params {};
		params.FireSupportDefinition = FireSupportDefinition;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0573CD80
	 * 		Name   -> Function Insurgency.TeamInfo.HumanCount
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	int32_t ATeamInfo::HumanCount()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.TeamInfo.HumanCount");
		
		ATeamInfo_HumanCount_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0573CD50
	 * 		Name   -> Function Insurgency.TeamInfo.HasLastOneStanding
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool ATeamInfo::HasLastOneStanding()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.TeamInfo.HasLastOneStanding");
		
		ATeamInfo_HasLastOneStanding_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0573CD20
	 * 		Name   -> Function Insurgency.TeamInfo.HasEnabledSpawnZones
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool ATeamInfo::HasEnabledSpawnZones()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.TeamInfo.HasEnabledSpawnZones");
		
		ATeamInfo_HasEnabledSpawnZones_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0573CCF0
	 * 		Name   -> Function Insurgency.TeamInfo.GetWaveTimeRemaining
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	float ATeamInfo::GetWaveTimeRemaining()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.TeamInfo.GetWaveTimeRemaining");
		
		ATeamInfo_GetWaveTimeRemaining_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0573CC50
	 * 		Name   -> Function Insurgency.TeamInfo.GetTimeUntilNextFireSupportRatio
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class UFireSupportDefinition*                      FireSupportDefinition                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	float ATeamInfo::GetTimeUntilNextFireSupportRatio(class UFireSupportDefinition* FireSupportDefinition)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.TeamInfo.GetTimeUntilNextFireSupportRatio");
		
		ATeamInfo_GetTimeUntilNextFireSupportRatio_Params params {};
		params.FireSupportDefinition = FireSupportDefinition;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0573CBB0
	 * 		Name   -> Function Insurgency.TeamInfo.GetTimeUntilNextFireSupport
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class UFireSupportDefinition*                      FireSupportDefinition                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	float ATeamInfo::GetTimeUntilNextFireSupport(class UFireSupportDefinition* FireSupportDefinition)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.TeamInfo.GetTimeUntilNextFireSupport");
		
		ATeamInfo_GetTimeUntilNextFireSupport_Params params {};
		params.FireSupportDefinition = FireSupportDefinition;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0573CB00
	 * 		Name   -> Function Insurgency.TeamInfo.GetSpectatorTargets
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		TArray<class AINSPlayerState*>                     OutTargets                                                 (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ATeamInfo::GetSpectatorTargets(TArray<class AINSPlayerState*>* OutTargets)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.TeamInfo.GetSpectatorTargets");
		
		ATeamInfo_GetSpectatorTargets_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutTargets != nullptr)
			*OutTargets = params.OutTargets;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0573CA50
	 * 		Name   -> Function Insurgency.TeamInfo.GetSortedPlayerList
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		TArray<class AINSPlayerState*>                     OutPlayers                                                 (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ATeamInfo::GetSortedPlayerList(TArray<class AINSPlayerState*>* OutPlayers)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.TeamInfo.GetSortedPlayerList");
		
		ATeamInfo_GetSortedPlayerList_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutPlayers != nullptr)
			*OutPlayers = params.OutPlayers;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0573C9C0
	 * 		Name   -> Function Insurgency.TeamInfo.GetRemainingFireSupportUses
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class UFireSupportDefinition*                      FireSupportDefinition                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	int32_t ATeamInfo::GetRemainingFireSupportUses(class UFireSupportDefinition* FireSupportDefinition)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.TeamInfo.GetRemainingFireSupportUses");
		
		ATeamInfo_GetRemainingFireSupportUses_Params params {};
		params.FireSupportDefinition = FireSupportDefinition;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0573C920
	 * 		Name   -> Function Insurgency.TeamInfo.GetPercentageTeamAlive
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		bool                                               bExcludeBots                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	float ATeamInfo::GetPercentageTeamAlive(bool bExcludeBots)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.TeamInfo.GetPercentageTeamAlive");
		
		ATeamInfo_GetPercentageTeamAlive_Params params {};
		params.bExcludeBots = bExcludeBots;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0573C820
	 * 		Name   -> Function Insurgency.TeamInfo.GetFireSupportGameModeOverrideParams
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class UFireSupportDefinition*                      FireSupportDefinition                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FFireSupportGameModeOverrideDefinition      Params                                                     (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	bool ATeamInfo::GetFireSupportGameModeOverrideParams(class UFireSupportDefinition* FireSupportDefinition, struct FFireSupportGameModeOverrideDefinition* Params)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.TeamInfo.GetFireSupportGameModeOverrideParams");
		
		ATeamInfo_GetFireSupportGameModeOverrideParams_Params params {};
		params.FireSupportDefinition = FireSupportDefinition;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (Params != nullptr)
			*Params = params.Params;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0573C720
	 * 		Name   -> Function Insurgency.TeamInfo.GetFactionName
	 * 		Flags  -> (Final, Native, Public, Const)
	 */
	class FText ATeamInfo::GetFactionName()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.TeamInfo.GetFactionName");
		
		ATeamInfo_GetFactionName_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0573C680
	 * 		Name   -> Function Insurgency.TeamInfo.GetFactionColor
	 * 		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		class AINSPlayerState*                             RelativePlayer                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FLinearColor ATeamInfo::GetFactionColor(class AINSPlayerState* RelativePlayer)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.TeamInfo.GetFactionColor");
		
		ATeamInfo_GetFactionColor_Params params {};
		params.RelativePlayer = RelativePlayer;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0573C660
	 * 		Name   -> Function Insurgency.TeamInfo.DisableAllSpawnZones
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void ATeamInfo::DisableAllSpawnZones()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.TeamInfo.DisableAllSpawnZones");
		
		ATeamInfo_DisableAllSpawnZones_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0573C580
	 * 		Name   -> Function Insurgency.TeamInfo.DeadPlayerCount
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		bool                                               bExcludeBots                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bIncludeNotReady                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	int32_t ATeamInfo::DeadPlayerCount(bool bExcludeBots, bool bIncludeNotReady)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.TeamInfo.DeadPlayerCount");
		
		ATeamInfo_DeadPlayerCount_Params params {};
		params.bExcludeBots = bExcludeBots;
		params.bIncludeNotReady = bIncludeNotReady;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05703BB0
	 * 		Name   -> Function Insurgency.TeamInfo.CanPlayerJoinTeam
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class AController*                                 Player                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool ATeamInfo::CanPlayerJoinTeam(class AController* Player)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.TeamInfo.CanPlayerJoinTeam");
		
		ATeamInfo_CanPlayerJoinTeam_Params params {};
		params.Player = Player;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0573C460
	 * 		Name   -> Function Insurgency.TeamInfo.BroadcastTextMessage
	 * 		Flags  -> (Final, BlueprintAuthorityOnly, Native, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		class FText                                        Message                                                    (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		class FName                                        Type                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ATeamInfo::BroadcastTextMessage(const class FText& Message, const class FName& Type)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.TeamInfo.BroadcastTextMessage");
		
		ATeamInfo_BroadcastTextMessage_Params params {};
		params.Message = Message;
		params.Type = Type;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0573C430
	 * 		Name   -> Function Insurgency.TeamInfo.BotCount
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	int32_t ATeamInfo::BotCount()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.TeamInfo.BotCount");
		
		ATeamInfo_BotCount_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0573C360
	 * 		Name   -> Function Insurgency.TeamInfo.BlueprintGetFactionName
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		class FText                                        OutFactionName                                             (Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void ATeamInfo::BlueprintGetFactionName(class FText* OutFactionName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.TeamInfo.BlueprintGetFactionName");
		
		ATeamInfo_BlueprintGetFactionName_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutFactionName != nullptr)
			*OutFactionName = params.OutFactionName;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0573C210
	 * 		Name   -> Function Insurgency.TeamInfo.AwardTaglineToTeamWithFloatContext
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UClass*                                      TaglineClass                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              ContextValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bRequireAlive                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bAsPercentage                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ATeamInfo::AwardTaglineToTeamWithFloatContext(class UClass* TaglineClass, float ContextValue, bool bRequireAlive, bool bAsPercentage)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.TeamInfo.AwardTaglineToTeamWithFloatContext");
		
		ATeamInfo_AwardTaglineToTeamWithFloatContext_Params params {};
		params.TaglineClass = TaglineClass;
		params.ContextValue = ContextValue;
		params.bRequireAlive = bRequireAlive;
		params.bAsPercentage = bAsPercentage;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0573C110
	 * 		Name   -> Function Insurgency.TeamInfo.AwardTaglineToTeamWithContext
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UClass*                                      TaglineClass                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            ContextValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bRequireAlive                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ATeamInfo::AwardTaglineToTeamWithContext(class UClass* TaglineClass, int32_t ContextValue, bool bRequireAlive)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.TeamInfo.AwardTaglineToTeamWithContext");
		
		ATeamInfo_AwardTaglineToTeamWithContext_Params params {};
		params.TaglineClass = TaglineClass;
		params.ContextValue = ContextValue;
		params.bRequireAlive = bRequireAlive;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0573C040
	 * 		Name   -> Function Insurgency.TeamInfo.AwardTaglineToTeam
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UClass*                                      TaglineClass                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bRequireAlive                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ATeamInfo::AwardTaglineToTeam(class UClass* TaglineClass, bool bRequireAlive)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.TeamInfo.AwardTaglineToTeam");
		
		ATeamInfo_AwardTaglineToTeam_Params params {};
		params.TaglineClass = TaglineClass;
		params.bRequireAlive = bRequireAlive;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0573BFB0
	 * 		Name   -> Function Insurgency.TeamInfo.AlivePlayerCount
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		bool                                               bExcludeBots                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	int32_t ATeamInfo::AlivePlayerCount(bool bExcludeBots)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.TeamInfo.AlivePlayerCount");
		
		ATeamInfo_AlivePlayerCount_Params params {};
		params.bExcludeBots = bExcludeBots;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0573BEB0
	 * 		Name   -> Function Insurgency.TeamInfo.AddCompassMarkerOnActor
	 * 		Flags  -> (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class AActor*                                      Actor                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		ECompassMarkerType                                 MarkerType                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AINSPlayerController*                        IgnorePlayer                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ATeamInfo::AddCompassMarkerOnActor(class AActor* Actor, ECompassMarkerType MarkerType, class AINSPlayerController* IgnorePlayer)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.TeamInfo.AddCompassMarkerOnActor");
		
		ATeamInfo_AddCompassMarkerOnActor_Params params {};
		params.Actor = Actor;
		params.MarkerType = MarkerType;
		params.IgnorePlayer = IgnorePlayer;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0573BDA0
	 * 		Name   -> Function Insurgency.TeamInfo.AddCompassMarker
	 * 		Flags  -> (Final, BlueprintAuthorityOnly, Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FVector                                     WorldLocation                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		ECompassMarkerType                                 MarkerType                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AINSPlayerController*                        IgnorePlayer                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ATeamInfo::AddCompassMarker(const struct FVector& WorldLocation, ECompassMarkerType MarkerType, class AINSPlayerController* IgnorePlayer)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.TeamInfo.AddCompassMarker");
		
		ATeamInfo_AddCompassMarker_Params params {};
		params.WorldLocation = WorldLocation;
		params.MarkerType = MarkerType;
		params.IgnorePlayer = IgnorePlayer;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ATeamInfo.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ATeamInfo::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.TeamInfo");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0567DFB0
	 * 		Name   -> Function Insurgency.INSFrontlineTeamInfo.SetNextWaveDrainTime
	 * 		Flags  -> (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		float                                              InTime                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSFrontlineTeamInfo::SetNextWaveDrainTime(float InTime)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSFrontlineTeamInfo.SetNextWaveDrainTime");
		
		AINSFrontlineTeamInfo_SetNextWaveDrainTime_Params params {};
		params.InTime = InTime;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0567DF90
	 * 		Name   -> Function Insurgency.INSFrontlineTeamInfo.ResetNextWaveDrainTime
	 * 		Flags  -> (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
	 */
	void AINSFrontlineTeamInfo::ResetNextWaveDrainTime()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSFrontlineTeamInfo.ResetNextWaveDrainTime");
		
		AINSFrontlineTeamInfo_ResetNextWaveDrainTime_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> DelegateFunction Insurgency.INSFrontlineTeamInfo.OnWaveDrainTimeUpdatedDelegate__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 * Parameters:
	 * 		class AINSFrontlineTeamInfo*                       TeamInfo                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              NewDrainTime                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSFrontlineTeamInfo::OnWaveDrainTimeUpdatedDelegate__DelegateSignature(class AINSFrontlineTeamInfo* TeamInfo, float NewDrainTime)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction Insurgency.INSFrontlineTeamInfo.OnWaveDrainTimeUpdatedDelegate__DelegateSignature");
		
		AINSFrontlineTeamInfo_OnWaveDrainTimeUpdatedDelegate__DelegateSignature_Params params {};
		params.TeamInfo = TeamInfo;
		params.NewDrainTime = NewDrainTime;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0567DF70
	 * 		Name   -> Function Insurgency.INSFrontlineTeamInfo.OnRep_NextWaveDrainTime
	 * 		Flags  -> (Final, Native, Private)
	 */
	void AINSFrontlineTeamInfo::OnRep_NextWaveDrainTime()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSFrontlineTeamInfo.OnRep_NextWaveDrainTime");
		
		AINSFrontlineTeamInfo_OnRep_NextWaveDrainTime_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0567DF40
	 * 		Name   -> Function Insurgency.INSFrontlineTeamInfo.HasWaveDrainTime
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AINSFrontlineTeamInfo::HasWaveDrainTime()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSFrontlineTeamInfo.HasWaveDrainTime");
		
		AINSFrontlineTeamInfo_HasWaveDrainTime_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0567DF10
	 * 		Name   -> Function Insurgency.INSFrontlineTeamInfo.GetTimeUntilNextWaveDrain
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	float AINSFrontlineTeamInfo::GetTimeUntilNextWaveDrain()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSFrontlineTeamInfo.GetTimeUntilNextWaveDrain");
		
		AINSFrontlineTeamInfo_GetTimeUntilNextWaveDrain_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0567DEE0
	 * 		Name   -> Function Insurgency.INSFrontlineTeamInfo.GetNextWaveDrainTime
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	float AINSFrontlineTeamInfo::GetNextWaveDrainTime()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSFrontlineTeamInfo.GetNextWaveDrainTime");
		
		AINSFrontlineTeamInfo_GetNextWaveDrainTime_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AINSFrontlineTeamInfo.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AINSFrontlineTeamInfo::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.INSFrontlineTeamInfo");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UINSGameEngine.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UINSGameEngine::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.INSGameEngine");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056813D0
	 * 		Name   -> Function Insurgency.INSGameInstance.UpdateRealtimeMultiplayAndUpdateUserPrivilege
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               RealtimeMultiplay                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               UpdateUserPrivilege                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UINSGameInstance::UpdateRealtimeMultiplayAndUpdateUserPrivilege(bool RealtimeMultiplay, bool UpdateUserPrivilege)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameInstance.UpdateRealtimeMultiplayAndUpdateUserPrivilege");
		
		UINSGameInstance_UpdateRealtimeMultiplayAndUpdateUserPrivilege_Params params {};
		params.RealtimeMultiplay = RealtimeMultiplay;
		params.UpdateUserPrivilege = UpdateUserPrivilege;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056813B0
	 * 		Name   -> Function Insurgency.INSGameInstance.TimerCheckModSubscriptions
	 * 		Flags  -> (Final, Native, Private)
	 */
	void UINSGameInstance::TimerCheckModSubscriptions()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameInstance.TimerCheckModSubscriptions");
		
		UINSGameInstance_TimerCheckModSubscriptions_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05681390
	 * 		Name   -> Function Insurgency.INSGameInstance.ShowAccountPicker
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void UINSGameInstance::ShowAccountPicker()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameInstance.ShowAccountPicker");
		
		UINSGameInstance_ShowAccountPicker_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05681300
	 * 		Name   -> Function Insurgency.INSGameInstance.SetTacticalMapVisibility
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bVisibility                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UINSGameInstance::SetTacticalMapVisibility(bool bVisibility)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameInstance.SetTacticalMapVisibility");
		
		UINSGameInstance_SetTacticalMapVisibility_Params params {};
		params.bVisibility = bVisibility;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056812E0
	 * 		Name   -> Function Insurgency.INSGameInstance.SeamlessLoadingScreen
	 * 		Flags  -> (Final, Native, Public)
	 */
	void UINSGameInstance::SeamlessLoadingScreen()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameInstance.SeamlessLoadingScreen");
		
		UINSGameInstance_SeamlessLoadingScreen_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x04DB41C0
	 * 		Name   -> Function Insurgency.INSGameInstance.ReturnToMainMenu
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void UINSGameInstance::ReturnToMainMenu()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameInstance.ReturnToMainMenu");
		
		UINSGameInstance_ReturnToMainMenu_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056812C0
	 * 		Name   -> Function Insurgency.INSGameInstance.RemoveViewportLoadingScreenWidget
	 * 		Flags  -> (Final, Native, Public)
	 */
	void UINSGameInstance::RemoveViewportLoadingScreenWidget()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameInstance.RemoveViewportLoadingScreenWidget");
		
		UINSGameInstance_RemoveViewportLoadingScreenWidget_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056811E0
	 * 		Name   -> Function Insurgency.INSGameInstance.PlayReplayByName
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class FString                                      InName                                                     (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bHttp                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UINSGameInstance::PlayReplayByName(const class FString& InName, bool bHttp)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameInstance.PlayReplayByName");
		
		UINSGameInstance_PlayReplayByName_Params params {};
		params.InName = InName;
		params.bHttp = bHttp;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05681110
	 * 		Name   -> Function Insurgency.INSGameInstance.OnTaglinesLoaded
	 * 		Flags  -> (Final, Native, Public, HasOutParms)
	 */
	void UINSGameInstance::OnTaglinesLoaded()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameInstance.OnTaglinesLoaded");
		
		UINSGameInstance_OnTaglinesLoaded_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> DelegateFunction Insurgency.INSGameInstance.OnReadyCheckUpdate__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 * Parameters:
	 * 		bool                                               bActive                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bLocalReady                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UINSGameInstance::OnReadyCheckUpdate__DelegateSignature(bool bActive, bool bLocalReady)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction Insurgency.INSGameInstance.OnReadyCheckUpdate__DelegateSignature");
		
		UINSGameInstance_OnReadyCheckUpdate__DelegateSignature_Params params {};
		params.bActive = bActive;
		params.bLocalReady = bLocalReady;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05681070
	 * 		Name   -> Function Insurgency.INSGameInstance.OnPreLoadMap
	 * 		Flags  -> (Final, Native, Private)
	 * Parameters:
	 * 		class FString                                      LevelName                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UINSGameInstance::OnPreLoadMap(const class FString& LevelName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameInstance.OnPreLoadMap");
		
		UINSGameInstance_OnPreLoadMap_Params params {};
		params.LevelName = LevelName;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05680F50
	 * 		Name   -> Function Insurgency.INSGameInstance.OnPreClientTravel
	 * 		Flags  -> (Final, Native, Private)
	 * Parameters:
	 * 		class FString                                      PendingURL                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		ETravelType                                        TravelType                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bIsSeamlessTravel                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UINSGameInstance::OnPreClientTravel(const class FString& PendingURL, ETravelType TravelType, bool bIsSeamlessTravel)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameInstance.OnPreClientTravel");
		
		UINSGameInstance_OnPreClientTravel_Params params {};
		params.PendingURL = PendingURL;
		params.TravelType = TravelType;
		params.bIsSeamlessTravel = bIsSeamlessTravel;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05680ED0
	 * 		Name   -> Function Insurgency.INSGameInstance.OnPostLoadMapWithWorld
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		class UWorld*                                      World                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UINSGameInstance::OnPostLoadMapWithWorld(class UWorld* World)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameInstance.OnPostLoadMapWithWorld");
		
		UINSGameInstance_OnPostLoadMapWithWorld_Params params {};
		params.World = World;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> DelegateFunction Insurgency.INSGameInstance.OnPlatformConnectionStatusChanged__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 * Parameters:
	 * 		bool                                               bConnected                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UINSGameInstance::OnPlatformConnectionStatusChanged__DelegateSignature(bool bConnected)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction Insurgency.INSGameInstance.OnPlatformConnectionStatusChanged__DelegateSignature");
		
		UINSGameInstance_OnPlatformConnectionStatusChanged__DelegateSignature_Params params {};
		params.bConnected = bConnected;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> DelegateFunction Insurgency.INSGameInstance.OnNetTimingOutUpdateDelegate__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 * Parameters:
	 * 		bool                                               bTimingOut                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UINSGameInstance::OnNetTimingOutUpdateDelegate__DelegateSignature(bool bTimingOut)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction Insurgency.INSGameInstance.OnNetTimingOutUpdateDelegate__DelegateSignature");
		
		UINSGameInstance_OnNetTimingOutUpdateDelegate__DelegateSignature_Params params {};
		params.bTimingOut = bTimingOut;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> DelegateFunction Insurgency.INSGameInstance.OnNetStatsUpdated__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 * Parameters:
	 * 		struct FClientNetStats                             Stats                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UINSGameInstance::OnNetStatsUpdated__DelegateSignature(const struct FClientNetStats& Stats)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction Insurgency.INSGameInstance.OnNetStatsUpdated__DelegateSignature");
		
		UINSGameInstance_OnNetStatsUpdated__DelegateSignature_Params params {};
		params.Stats = Stats;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> DelegateFunction Insurgency.INSGameInstance.OnNetStatEnabled__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 * Parameters:
	 * 		bool                                               bEnabled                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UINSGameInstance::OnNetStatEnabled__DelegateSignature(bool bEnabled)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction Insurgency.INSGameInstance.OnNetStatEnabled__DelegateSignature");
		
		UINSGameInstance_OnNetStatEnabled__DelegateSignature_Params params {};
		params.bEnabled = bEnabled;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> DelegateFunction Insurgency.INSGameInstance.OnMatchmakingSearchBegin__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 */
	void UINSGameInstance::OnMatchmakingSearchBegin__DelegateSignature()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction Insurgency.INSGameInstance.OnMatchmakingSearchBegin__DelegateSignature");
		
		UINSGameInstance_OnMatchmakingSearchBegin__DelegateSignature_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> DelegateFunction Insurgency.INSGameInstance.OnMatchmakingError__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 * Parameters:
	 * 		class FText                                        Error                                                      (Parm, NativeAccessSpecifierPublic)
	 * 		EMatchmakingFailure                                MatchmakingFailureType                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UINSGameInstance::OnMatchmakingError__DelegateSignature(const class FText& Error, EMatchmakingFailure MatchmakingFailureType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction Insurgency.INSGameInstance.OnMatchmakingError__DelegateSignature");
		
		UINSGameInstance_OnMatchmakingError__DelegateSignature_Params params {};
		params.Error = Error;
		params.MatchmakingFailureType = MatchmakingFailureType;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05680E10
	 * 		Name   -> Function Insurgency.INSGameInstance.OnMatchmakerStateChanged
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		EMatchmakingState                                  OldState                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EMatchmakingState                                  NewState                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UINSGameInstance::OnMatchmakerStateChanged(EMatchmakingState OldState, EMatchmakingState NewState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameInstance.OnMatchmakerStateChanged");
		
		UINSGameInstance_OnMatchmakerStateChanged_Params params {};
		params.OldState = OldState;
		params.NewState = NewState;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05680D90
	 * 		Name   -> Function Insurgency.INSGameInstance.OnMatchmakerFailed
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		EMatchmakingFailure                                Reason                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UINSGameInstance::OnMatchmakerFailed(EMatchmakingFailure Reason)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameInstance.OnMatchmakerFailed");
		
		UINSGameInstance_OnMatchmakerFailed_Params params {};
		params.Reason = Reason;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> DelegateFunction Insurgency.INSGameInstance.OnLinkAccountComplete__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 * Parameters:
	 * 		bool                                               bSuccessful                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FName                                        InServiceName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UINSGameInstance::OnLinkAccountComplete__DelegateSignature(bool bSuccessful, const class FName& InServiceName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction Insurgency.INSGameInstance.OnLinkAccountComplete__DelegateSignature");
		
		UINSGameInstance_OnLinkAccountComplete__DelegateSignature_Params params {};
		params.bSuccessful = bSuccessful;
		params.InServiceName = InServiceName;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05680D10
	 * 		Name   -> Function Insurgency.INSGameInstance.OnForceLogout
	 * 		Flags  -> (Final, Exec, Native, Public)
	 * Parameters:
	 * 		int32_t                                            LocalUserNum                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UINSGameInstance::OnForceLogout(int32_t LocalUserNum)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameInstance.OnForceLogout");
		
		UINSGameInstance_OnForceLogout_Params params {};
		params.LocalUserNum = LocalUserNum;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> DelegateFunction Insurgency.INSGameInstance.OnDisplayRestrictionDialog__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 * Parameters:
	 * 		EUserPrivilegeResult                               PrivilegeResult                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UINSGameInstance::OnDisplayRestrictionDialog__DelegateSignature(EUserPrivilegeResult PrivilegeResult)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction Insurgency.INSGameInstance.OnDisplayRestrictionDialog__DelegateSignature");
		
		UINSGameInstance_OnDisplayRestrictionDialog__DelegateSignature_Params params {};
		params.PrivilegeResult = PrivilegeResult;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05680BE0
	 * 		Name   -> Function Insurgency.INSGameInstance.OnCheckHasAbandonedGameComplete
	 * 		Flags  -> (Final, Native, Protected)
	 * Parameters:
	 * 		bool                                               bSuccessful                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FString                                      Data                                                       (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UINSGameInstance::OnCheckHasAbandonedGameComplete(bool bSuccessful, const class FString& Data)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameInstance.OnCheckHasAbandonedGameComplete");
		
		UINSGameInstance_OnCheckHasAbandonedGameComplete_Params params {};
		params.bSuccessful = bSuccessful;
		params.Data = Data;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> DelegateFunction Insurgency.INSGameInstance.OnAvailablePlaylistUpdated__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate, HasOutParms)
	 * Parameters:
	 * 		struct FAvailablePlaylists                         Data                                                       (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UINSGameInstance::OnAvailablePlaylistUpdated__DelegateSignature(const struct FAvailablePlaylists& Data)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction Insurgency.INSGameInstance.OnAvailablePlaylistUpdated__DelegateSignature");
		
		UINSGameInstance_OnAvailablePlaylistUpdated__DelegateSignature_Params params {};
		params.Data = Data;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05680A30
	 * 		Name   -> Function Insurgency.INSGameInstance.OnAvailablePlaylistsFetched
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		bool                                               bSuccess                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FQueryOpenPoolsResults                      Results                                                    (Parm, NativeAccessSpecifierPublic)
	 */
	void UINSGameInstance::OnAvailablePlaylistsFetched(bool bSuccess, const struct FQueryOpenPoolsResults& Results)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameInstance.OnAvailablePlaylistsFetched");
		
		UINSGameInstance_OnAvailablePlaylistsFetched_Params params {};
		params.bSuccess = bSuccess;
		params.Results = Results;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05680990
	 * 		Name   -> Function Insurgency.INSGameInstance.MountPaksInDirectory
	 * 		Flags  -> (Final, Exec, Native, Public)
	 * Parameters:
	 * 		class FString                                      Directory                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UINSGameInstance::MountPaksInDirectory(const class FString& Directory)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameInstance.MountPaksInDirectory");
		
		UINSGameInstance_MountPaksInDirectory_Params params {};
		params.Directory = Directory;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056808F0
	 * 		Name   -> Function Insurgency.INSGameInstance.MountPak
	 * 		Flags  -> (Final, Exec, Native, Public)
	 * Parameters:
	 * 		class FString                                      PakPath                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UINSGameInstance::MountPak(const class FString& PakPath)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameInstance.MountPak");
		
		UINSGameInstance_MountPak_Params params {};
		params.PakPath = PakPath;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05680800
	 * 		Name   -> Function Insurgency.INSGameInstance.MountMod
	 * 		Flags  -> (Final, Exec, Native, Public)
	 * Parameters:
	 * 		class FString                                      PluginName                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FString                                      Path                                                       (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UINSGameInstance::MountMod(const class FString& PluginName, const class FString& Path)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameInstance.MountMod");
		
		UINSGameInstance_MountMod_Params params {};
		params.PluginName = PluginName;
		params.Path = Path;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056807E0
	 * 		Name   -> Function Insurgency.INSGameInstance.MinimizeGameWindow
	 * 		Flags  -> (Final, Exec, Native, Public, BlueprintCallable)
	 */
	void UINSGameInstance::MinimizeGameWindow()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameInstance.MinimizeGameWindow");
		
		UINSGameInstance_MinimizeGameWindow_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056807C0
	 * 		Name   -> Function Insurgency.INSGameInstance.MatchmakingRequeue
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void UINSGameInstance::MatchmakingRequeue()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameInstance.MatchmakingRequeue");
		
		UINSGameInstance_MatchmakingRequeue_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056807A0
	 * 		Name   -> Function Insurgency.INSGameInstance.MatchmakingAcceptReadyCheck
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void UINSGameInstance::MatchmakingAcceptReadyCheck()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameInstance.MatchmakingAcceptReadyCheck");
		
		UINSGameInstance_MatchmakingAcceptReadyCheck_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05680720
	 * 		Name   -> Function Insurgency.INSGameInstance.LinkUserAccount
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class FName                                        ServiceToLink                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UINSGameInstance::LinkUserAccount(const class FName& ServiceToLink)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameInstance.LinkUserAccount");
		
		UINSGameInstance_LinkUserAccount_Params params {};
		params.ServiceToLink = ServiceToLink;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05680460
	 * 		Name   -> Function Insurgency.INSGameInstance.JoinSearchResult
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		class ULocalPlayer*                                LocalPlayer                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FBlueprintFindSessionResult                 SearchResult                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		class FString                                      ServerPassword                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UINSGameInstance::JoinSearchResult(class ULocalPlayer* LocalPlayer, const struct FBlueprintFindSessionResult& SearchResult, const class FString& ServerPassword)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameInstance.JoinSearchResult");
		
		UINSGameInstance_JoinSearchResult_Params params {};
		params.LocalPlayer = LocalPlayer;
		params.SearchResult = SearchResult;
		params.ServerPassword = ServerPassword;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056803B0
	 * 		Name   -> Function Insurgency.INSGameInstance.IsMatchmakingInPool
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		class FString                                      PoolName                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UINSGameInstance::IsMatchmakingInPool(const class FString& PoolName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameInstance.IsMatchmakingInPool");
		
		UINSGameInstance_IsMatchmakingInPool_Params params {};
		params.PoolName = PoolName;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05680380
	 * 		Name   -> Function Insurgency.INSGameInstance.IsMatchmaking
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool UINSGameInstance::IsMatchmaking()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameInstance.IsMatchmaking");
		
		UINSGameInstance_IsMatchmaking_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05680350
	 * 		Name   -> Function Insurgency.INSGameInstance.IsLoggedInNewWorld
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool UINSGameInstance::IsLoggedInNewWorld()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameInstance.IsLoggedInNewWorld");
		
		UINSGameInstance_IsLoggedInNewWorld_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05680320
	 * 		Name   -> Function Insurgency.INSGameInstance.IsLocalGame
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool UINSGameInstance::IsLocalGame()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameInstance.IsLocalGame");
		
		UINSGameInstance_IsLocalGame_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056802F0
	 * 		Name   -> Function Insurgency.INSGameInstance.IsConnectedToOnlineServices
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool UINSGameInstance::IsConnectedToOnlineServices()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameInstance.IsConnectedToOnlineServices");
		
		UINSGameInstance_IsConnectedToOnlineServices_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056802C0
	 * 		Name   -> Function Insurgency.INSGameInstance.IsClientNetStatsEnabled
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool UINSGameInstance::IsClientNetStatsEnabled()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameInstance.IsClientNetStatsEnabled");
		
		UINSGameInstance_IsClientNetStatsEnabled_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05680290
	 * 		Name   -> Function Insurgency.INSGameInstance.IsAboutToJoinMatch
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool UINSGameInstance::IsAboutToJoinMatch()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameInstance.IsAboutToJoinMatch");
		
		UINSGameInstance_IsAboutToJoinMatch_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05680270
	 * 		Name   -> Function Insurgency.INSGameInstance.IndicateGameLoaded
	 * 		Flags  -> (Final, Native, Public)
	 */
	void UINSGameInstance::IndicateGameLoaded()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameInstance.IndicateGameLoaded");
		
		UINSGameInstance_IndicateGameLoaded_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05680180
	 * 		Name   -> Function Insurgency.INSGameInstance.HostGame
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class ULocalPlayer*                                LocalPlayer                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FString                                      InTravelURL                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UINSGameInstance::HostGame(class ULocalPlayer* LocalPlayer, const class FString& InTravelURL)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameInstance.HostGame");
		
		UINSGameInstance_HostGame_Params params {};
		params.LocalPlayer = LocalPlayer;
		params.InTravelURL = InTravelURL;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05680150
	 * 		Name   -> Function Insurgency.INSGameInstance.HasAllMapsDownloaded
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool UINSGameInstance::HasAllMapsDownloaded()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameInstance.HasAllMapsDownloaded");
		
		UINSGameInstance_HasAllMapsDownloaded_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05680020
	 * 		Name   -> Function Insurgency.INSGameInstance.GetThumbnailTextureForLevel
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		class FString                                      Name                                                       (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FString                                      LightingName                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UINSGameInstance::GetThumbnailTextureForLevel(const class FString& Name, const class FString& LightingName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameInstance.GetThumbnailTextureForLevel");
		
		UINSGameInstance_GetThumbnailTextureForLevel_Params params {};
		params.Name = Name;
		params.LightingName = LightingName;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0567FFF0
	 * 		Name   -> Function Insurgency.INSGameInstance.GetTacticalMapVisibility
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
	 */
	bool UINSGameInstance::GetTacticalMapVisibility()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameInstance.GetTacticalMapVisibility");
		
		UINSGameInstance_GetTacticalMapVisibility_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0567FFC0
	 * 		Name   -> Function Insurgency.INSGameInstance.GetState
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	class FName UINSGameInstance::GetState()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameInstance.GetState");
		
		UINSGameInstance_GetState_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0567FED0
	 * 		Name   -> Function Insurgency.INSGameInstance.GetNetPacketLoss
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		float                                              InPacketLoss                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              OutPacketLoss                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UINSGameInstance::GetNetPacketLoss(float* InPacketLoss, float* OutPacketLoss)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameInstance.GetNetPacketLoss");
		
		UINSGameInstance_GetNetPacketLoss_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (InPacketLoss != nullptr)
			*InPacketLoss = params.InPacketLoss;
		if (OutPacketLoss != nullptr)
			*OutPacketLoss = params.OutPacketLoss;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0567FEA0
	 * 		Name   -> Function Insurgency.INSGameInstance.GetMatchmakingTimer
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	float UINSGameInstance::GetMatchmakingTimer()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameInstance.GetMatchmakingTimer");
		
		UINSGameInstance_GetMatchmakingTimer_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0567FE00
	 * 		Name   -> Function Insurgency.INSGameInstance.GetMatchmakingProgressText
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	class FText UINSGameInstance::GetMatchmakingProgressText()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameInstance.GetMatchmakingProgressText");
		
		UINSGameInstance_GetMatchmakingProgressText_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0567FDD0
	 * 		Name   -> Function Insurgency.INSGameInstance.GetMatchmakingEstimatedTimer
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	int32_t UINSGameInstance::GetMatchmakingEstimatedTimer()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameInstance.GetMatchmakingEstimatedTimer");
		
		UINSGameInstance_GetMatchmakingEstimatedTimer_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0567FD10
	 * 		Name   -> Function Insurgency.INSGameInstance.GetMapCycleTravelUrl
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		class FString                                      TravelUrl                                                  (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UINSGameInstance::GetMapCycleTravelUrl(class FString* TravelUrl)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameInstance.GetMapCycleTravelUrl");
		
		UINSGameInstance_GetMapCycleTravelUrl_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (TravelUrl != nullptr)
			*TravelUrl = params.TravelUrl;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0567FC20
	 * 		Name   -> Function Insurgency.INSGameInstance.GetLeaverBanTimer
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		float                                              Minutes                                                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Seconds                                                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UINSGameInstance::GetLeaverBanTimer(float* Minutes, float* Seconds)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameInstance.GetLeaverBanTimer");
		
		UINSGameInstance_GetLeaverBanTimer_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (Minutes != nullptr)
			*Minutes = params.Minutes;
		if (Seconds != nullptr)
			*Seconds = params.Seconds;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0567FB80
	 * 		Name   -> Function Insurgency.INSGameInstance.GetLeaverBanText
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	class FText UINSGameInstance::GetLeaverBanText()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameInstance.GetLeaverBanText");
		
		UINSGameInstance_GetLeaverBanText_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0567FB00
	 * 		Name   -> Function Insurgency.INSGameInstance.GetAppId
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	class FString UINSGameInstance::GetAppId()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameInstance.GetAppId");
		
		UINSGameInstance_GetAppId_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0567FAE0
	 * 		Name   -> Function Insurgency.INSGameInstance.ForceStopFPSChart
	 * 		Flags  -> (Final, Exec, Native, Public)
	 */
	void UINSGameInstance::ForceStopFPSChart()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameInstance.ForceStopFPSChart");
		
		UINSGameInstance_ForceStopFPSChart_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0567FAC0
	 * 		Name   -> Function Insurgency.INSGameInstance.ForceStartFPSChart
	 * 		Flags  -> (Final, Exec, Native, Public)
	 */
	void UINSGameInstance::ForceStartFPSChart()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameInstance.ForceStartFPSChart");
		
		UINSGameInstance_ForceStartFPSChart_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0567FAA0
	 * 		Name   -> Function Insurgency.INSGameInstance.FadeLoadingScreen
	 * 		Flags  -> (Final, Native, Public)
	 */
	void UINSGameInstance::FadeLoadingScreen()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameInstance.FadeLoadingScreen");
		
		UINSGameInstance_FadeLoadingScreen_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0567FA80
	 * 		Name   -> Function Insurgency.INSGameInstance.EndLoadingScreen
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void UINSGameInstance::EndLoadingScreen()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameInstance.EndLoadingScreen");
		
		UINSGameInstance_EndLoadingScreen_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0567F970
	 * 		Name   -> Function Insurgency.INSGameInstance.DoesContainProfaneWord
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		class FString                                      inString                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FString                                      OutString                                                  (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UINSGameInstance::DoesContainProfaneWord(const class FString& inString, class FString* OutString)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameInstance.DoesContainProfaneWord");
		
		UINSGameInstance_DoesContainProfaneWord_Params params {};
		params.inString = inString;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutString != nullptr)
			*OutString = params.OutString;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00C76AB0
	 * 		Name   -> Function Insurgency.INSGameInstance.DisplayHydraDebugInfo
	 * 		Flags  -> (Final, Exec, Native, Public)
	 */
	void UINSGameInstance::DisplayHydraDebugInfo()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameInstance.DisplayHydraDebugInfo");
		
		UINSGameInstance_DisplayHydraDebugInfo_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0567F830
	 * 		Name   -> Function Insurgency.INSGameInstance.DirectConnectToIP
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class FString                                      IpPort                                                     (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FString                                      Password                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UINSGameInstance::DirectConnectToIP(const class FString& IpPort, const class FString& Password)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameInstance.DirectConnectToIP");
		
		UINSGameInstance_DirectConnectToIP_Params params {};
		params.IpPort = IpPort;
		params.Password = Password;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0567F810
	 * 		Name   -> Function Insurgency.INSGameInstance.CreateParty
	 * 		Flags  -> (Final, Exec, Native, Public)
	 */
	void UINSGameInstance::CreateParty()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameInstance.CreateParty");
		
		UINSGameInstance_CreateParty_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0567F7A0
	 * 		Name   -> Function Insurgency.INSGameInstance.CanJoinQueue
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool UINSGameInstance::CanJoinQueue()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameInstance.CanJoinQueue");
		
		UINSGameInstance_CanJoinQueue_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0567F7D0
	 * 		Name   -> Function Insurgency.INSGameInstance.CancelMatchRequeue
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void UINSGameInstance::CancelMatchRequeue()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameInstance.CancelMatchRequeue");
		
		UINSGameInstance_CancelMatchRequeue_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0567F7F0
	 * 		Name   -> Function Insurgency.INSGameInstance.CancelMatchmakingSearch
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void UINSGameInstance::CancelMatchmakingSearch()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameInstance.CancelMatchmakingSearch");
		
		UINSGameInstance_CancelMatchmakingSearch_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0567F6C0
	 * 		Name   -> Function Insurgency.INSGameInstance.BeginMatchmakingForPlaylists
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		TArray<class UPlaylist*>                           Playlist                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UINSGameInstance::BeginMatchmakingForPlaylists(TArray<class UPlaylist*> Playlist)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameInstance.BeginMatchmakingForPlaylists");
		
		UINSGameInstance_BeginMatchmakingForPlaylists_Params params {};
		params.Playlist = Playlist;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0567F5A0
	 * 		Name   -> Function Insurgency.INSGameInstance.BeginLoadingScreenURL
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class FString                                      URL                                                        (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bSeamless                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bMatchTransition                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UINSGameInstance::BeginLoadingScreenURL(const class FString& URL, bool bSeamless, bool bMatchTransition)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameInstance.BeginLoadingScreenURL");
		
		UINSGameInstance_BeginLoadingScreenURL_Params params {};
		params.URL = URL;
		params.bSeamless = bSeamless;
		params.bMatchTransition = bMatchTransition;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0567F390
	 * 		Name   -> Function Insurgency.INSGameInstance.BeginLoadingScreen
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		class FString                                      Name                                                       (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FString                                      Mode                                                       (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FString                                      Scenario                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FString                                      LightingName                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bSeamless                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bMatchTransition                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UINSGameInstance::BeginLoadingScreen(const class FString& Name, const class FString& Mode, const class FString& Scenario, const class FString& LightingName, bool bSeamless, bool bMatchTransition)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameInstance.BeginLoadingScreen");
		
		UINSGameInstance_BeginLoadingScreen_Params params {};
		params.Name = Name;
		params.Mode = Mode;
		params.Scenario = Scenario;
		params.LightingName = LightingName;
		params.bSeamless = bSeamless;
		params.bMatchTransition = bMatchTransition;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UINSGameInstance.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UINSGameInstance::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.INSGameInstance");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05687BE0
	 * 		Name   -> Function Insurgency.INSGameSession.OnGameStatsServerLoginChanged
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		bool                                               bLoggedIn                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSGameSession::OnGameStatsServerLoginChanged(bool bLoggedIn)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameSession.OnGameStatsServerLoginChanged");
		
		AINSGameSession_OnGameStatsServerLoginChanged_Params params {};
		params.bLoggedIn = bLoggedIn;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AINSGameSession.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AINSGameSession::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.INSGameSession");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AINSGameSessionMatchmaking.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AINSGameSessionMatchmaking::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.INSGameSessionMatchmaking");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05690530
	 * 		Name   -> Function Insurgency.INSGameUserSettings.UpdateLastAnnouncementPanelDate
	 * 		Flags  -> (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FDateTime                                   CurrentAnnouncementDateTime                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UINSGameUserSettings::UpdateLastAnnouncementPanelDate(const struct FDateTime& CurrentAnnouncementDateTime)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameUserSettings.UpdateLastAnnouncementPanelDate");
		
		UINSGameUserSettings_UpdateLastAnnouncementPanelDate_Params params {};
		params.CurrentAnnouncementDateTime = CurrentAnnouncementDateTime;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05690490
	 * 		Name   -> Function Insurgency.INSGameUserSettings.ShouldShowAnnouncementPopup
	 * 		Flags  -> (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		struct FDateTime                                   CurrentAnnouncementDateTime                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UINSGameUserSettings::ShouldShowAnnouncementPopup(const struct FDateTime& CurrentAnnouncementDateTime)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameUserSettings.ShouldShowAnnouncementPopup");
		
		UINSGameUserSettings_ShouldShowAnnouncementPopup_Params params {};
		params.CurrentAnnouncementDateTime = CurrentAnnouncementDateTime;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05690410
	 * 		Name   -> Function Insurgency.INSGameUserSettings.SetVoiceVolume
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		float                                              Volume                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UINSGameUserSettings::SetVoiceVolume(float Volume)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameUserSettings.SetVoiceVolume");
		
		UINSGameUserSettings_SetVoiceVolume_Params params {};
		params.Volume = Volume;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05690390
	 * 		Name   -> Function Insurgency.INSGameUserSettings.SetVoiceInputGain
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		float                                              NewInputGain                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UINSGameUserSettings::SetVoiceInputGain(float NewInputGain)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameUserSettings.SetVoiceInputGain");
		
		UINSGameUserSettings_SetVoiceInputGain_Params params {};
		params.NewInputGain = NewInputGain;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056902F0
	 * 		Name   -> Function Insurgency.INSGameUserSettings.SetVoiceInputDevice
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class FString                                      NewDevice                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UINSGameUserSettings::SetVoiceInputDevice(const class FString& NewDevice)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameUserSettings.SetVoiceInputDevice");
		
		UINSGameUserSettings_SetVoiceInputDevice_Params params {};
		params.NewDevice = NewDevice;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05690260
	 * 		Name   -> Function Insurgency.INSGameUserSettings.SetViewBobEnabled
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bVal                                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UINSGameUserSettings::SetViewBobEnabled(bool bVal)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameUserSettings.SetViewBobEnabled");
		
		UINSGameUserSettings_SetViewBobEnabled_Params params {};
		params.bVal = bVal;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05690240
	 * 		Name   -> Function Insurgency.INSGameUserSettings.SetToDefaultsVideoSettings
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void UINSGameUserSettings::SetToDefaultsVideoSettings()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameUserSettings.SetToDefaultsVideoSettings");
		
		UINSGameUserSettings_SetToDefaultsVideoSettings_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05690220
	 * 		Name   -> Function Insurgency.INSGameUserSettings.SetToDefaultsGameSettings
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void UINSGameUserSettings::SetToDefaultsGameSettings()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameUserSettings.SetToDefaultsGameSettings");
		
		UINSGameUserSettings_SetToDefaultsGameSettings_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05690200
	 * 		Name   -> Function Insurgency.INSGameUserSettings.SetToDefaultsControlSettings
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void UINSGameUserSettings::SetToDefaultsControlSettings()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameUserSettings.SetToDefaultsControlSettings");
		
		UINSGameUserSettings_SetToDefaultsControlSettings_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056901E0
	 * 		Name   -> Function Insurgency.INSGameUserSettings.SetToDefaultsAudioSettings
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void UINSGameUserSettings::SetToDefaultsAudioSettings()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameUserSettings.SetToDefaultsAudioSettings");
		
		UINSGameUserSettings_SetToDefaultsAudioSettings_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05690160
	 * 		Name   -> Function Insurgency.INSGameUserSettings.SetTeammateIndicatorOpacity
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		float                                              Alpha                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UINSGameUserSettings::SetTeammateIndicatorOpacity(float Alpha)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameUserSettings.SetTeammateIndicatorOpacity");
		
		UINSGameUserSettings_SetTeammateIndicatorOpacity_Params params {};
		params.Alpha = Alpha;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056900D0
	 * 		Name   -> Function Insurgency.INSGameUserSettings.SetSpectatorXrayTailsPlayerOnlyEnabled
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bEnable                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UINSGameUserSettings::SetSpectatorXrayTailsPlayerOnlyEnabled(bool bEnable)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameUserSettings.SetSpectatorXrayTailsPlayerOnlyEnabled");
		
		UINSGameUserSettings_SetSpectatorXrayTailsPlayerOnlyEnabled_Params params {};
		params.bEnable = bEnable;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05690040
	 * 		Name   -> Function Insurgency.INSGameUserSettings.SetSpectatorXrayTailsEnabled
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bEnable                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UINSGameUserSettings::SetSpectatorXrayTailsEnabled(bool bEnable)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameUserSettings.SetSpectatorXrayTailsEnabled");
		
		UINSGameUserSettings_SetSpectatorXrayTailsEnabled_Params params {};
		params.bEnable = bEnable;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0568FFB0
	 * 		Name   -> Function Insurgency.INSGameUserSettings.SetSpectatorXrayEnabled
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bEnable                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UINSGameUserSettings::SetSpectatorXrayEnabled(bool bEnable)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameUserSettings.SetSpectatorXrayEnabled");
		
		UINSGameUserSettings_SetSpectatorXrayEnabled_Params params {};
		params.bEnable = bEnable;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0568FF20
	 * 		Name   -> Function Insurgency.INSGameUserSettings.SetSpectatorControlHintsEnabled
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bEnable                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UINSGameUserSettings::SetSpectatorControlHintsEnabled(bool bEnable)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameUserSettings.SetSpectatorControlHintsEnabled");
		
		UINSGameUserSettings_SetSpectatorControlHintsEnabled_Params params {};
		params.bEnable = bEnable;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0568FE90
	 * 		Name   -> Function Insurgency.INSGameUserSettings.SetSoundInBackground
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bEnabledInBG                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UINSGameUserSettings::SetSoundInBackground(bool bEnabledInBG)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameUserSettings.SetSoundInBackground");
		
		UINSGameUserSettings_SetSoundInBackground_Params params {};
		params.bEnabledInBG = bEnabledInBG;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0568FE10
	 * 		Name   -> Function Insurgency.INSGameUserSettings.SetSoldierFOV
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		float                                              Val                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UINSGameUserSettings::SetSoldierFOV(float Val)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameUserSettings.SetSoldierFOV");
		
		UINSGameUserSettings_SetSoldierFOV_Params params {};
		params.Val = Val;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0568FD80
	 * 		Name   -> Function Insurgency.INSGameUserSettings.SetShowFPS
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bEnabled                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UINSGameUserSettings::SetShowFPS(bool bEnabled)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameUserSettings.SetShowFPS");
		
		UINSGameUserSettings_SetShowFPS_Params params {};
		params.bEnabled = bEnabled;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0568FCF0
	 * 		Name   -> Function Insurgency.INSGameUserSettings.SetShowDevTag
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bEnabled                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UINSGameUserSettings::SetShowDevTag(bool bEnabled)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameUserSettings.SetShowDevTag");
		
		UINSGameUserSettings_SetShowDevTag_Params params {};
		params.bEnabled = bEnabled;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0568FC60
	 * 		Name   -> Function Insurgency.INSGameUserSettings.SetShowContextualVaultHints
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bNewVal                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UINSGameUserSettings::SetShowContextualVaultHints(bool bNewVal)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameUserSettings.SetShowContextualVaultHints");
		
		UINSGameUserSettings_SetShowContextualVaultHints_Params params {};
		params.bNewVal = bNewVal;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0568FBD0
	 * 		Name   -> Function Insurgency.INSGameUserSettings.SetShowContextualKeyHints
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bNewVal                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UINSGameUserSettings::SetShowContextualKeyHints(bool bNewVal)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameUserSettings.SetShowContextualKeyHints");
		
		UINSGameUserSettings_SetShowContextualKeyHints_Params params {};
		params.bNewVal = bNewVal;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0568FB40
	 * 		Name   -> Function Insurgency.INSGameUserSettings.SetShowContextualCycleOpticsHint
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bNewVal                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UINSGameUserSettings::SetShowContextualCycleOpticsHint(bool bNewVal)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameUserSettings.SetShowContextualCycleOpticsHint");
		
		UINSGameUserSettings_SetShowContextualCycleOpticsHint_Params params {};
		params.bNewVal = bNewVal;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0568FAB0
	 * 		Name   -> Function Insurgency.INSGameUserSettings.SetShoutcasterTeamScoresEnabled
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bEnabled                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UINSGameUserSettings::SetShoutcasterTeamScoresEnabled(bool bEnabled)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameUserSettings.SetShoutcasterTeamScoresEnabled");
		
		UINSGameUserSettings_SetShoutcasterTeamScoresEnabled_Params params {};
		params.bEnabled = bEnabled;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0568FA20
	 * 		Name   -> Function Insurgency.INSGameUserSettings.SetShoutcasterPlayerVitalsEnabled
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bEnabled                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UINSGameUserSettings::SetShoutcasterPlayerVitalsEnabled(bool bEnabled)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameUserSettings.SetShoutcasterPlayerVitalsEnabled");
		
		UINSGameUserSettings_SetShoutcasterPlayerVitalsEnabled_Params params {};
		params.bEnabled = bEnabled;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0568F990
	 * 		Name   -> Function Insurgency.INSGameUserSettings.SetShoutcasterMinimapEnabled
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bEnabled                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UINSGameUserSettings::SetShoutcasterMinimapEnabled(bool bEnabled)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameUserSettings.SetShoutcasterMinimapEnabled");
		
		UINSGameUserSettings_SetShoutcasterMinimapEnabled_Params params {};
		params.bEnabled = bEnabled;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0568F910
	 * 		Name   -> Function Insurgency.INSGameUserSettings.SetScreenPercentage
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		float                                              ScreenPercentage                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UINSGameUserSettings::SetScreenPercentage(float ScreenPercentage)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameUserSettings.SetScreenPercentage");
		
		UINSGameUserSettings_SetScreenPercentage_Params params {};
		params.ScreenPercentage = ScreenPercentage;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0568F890
	 * 		Name   -> Function Insurgency.INSGameUserSettings.SetRespawnStatusLocationSetting
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		unsigned char                                      RespawnLocationIndex                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UINSGameUserSettings::SetRespawnStatusLocationSetting(unsigned char RespawnLocationIndex)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameUserSettings.SetRespawnStatusLocationSetting");
		
		UINSGameUserSettings_SetRespawnStatusLocationSetting_Params params {};
		params.RespawnLocationIndex = RespawnLocationIndex;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0568F800
	 * 		Name   -> Function Insurgency.INSGameUserSettings.SetRelativeTeamColors
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bVal                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UINSGameUserSettings::SetRelativeTeamColors(bool bVal)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameUserSettings.SetRelativeTeamColors");
		
		UINSGameUserSettings_SetRelativeTeamColors_Params params {};
		params.bVal = bVal;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0568F780
	 * 		Name   -> Function Insurgency.INSGameUserSettings.SetQualityPreset
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		int32_t                                            Quality                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UINSGameUserSettings::SetQualityPreset(int32_t Quality)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameUserSettings.SetQualityPreset");
		
		UINSGameUserSettings_SetQualityPreset_Params params {};
		params.Quality = Quality;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0568F6F0
	 * 		Name   -> Function Insurgency.INSGameUserSettings.SetProfanityFilterEnabled
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bVal                                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UINSGameUserSettings::SetProfanityFilterEnabled(bool bVal)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameUserSettings.SetProfanityFilterEnabled");
		
		UINSGameUserSettings_SetProfanityFilterEnabled_Params params {};
		params.bVal = bVal;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0568F660
	 * 		Name   -> Function Insurgency.INSGameUserSettings.SetPartyLinearColor
	 * 		Flags  -> (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FLinearColor                                NewColor                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UINSGameUserSettings::SetPartyLinearColor(const struct FLinearColor& NewColor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameUserSettings.SetPartyLinearColor");
		
		UINSGameUserSettings_SetPartyLinearColor_Params params {};
		params.NewColor = NewColor;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0568F550
	 * 		Name   -> Function Insurgency.INSGameUserSettings.SetPartyColor
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		float                                              R                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              G                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              B                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UINSGameUserSettings::SetPartyColor(float R, float G, float B)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameUserSettings.SetPartyColor");
		
		UINSGameUserSettings_SetPartyColor_Params params {};
		params.R = R;
		params.G = G;
		params.B = B;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0568F4D0
	 * 		Name   -> Function Insurgency.INSGameUserSettings.SetPanningRule
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		unsigned char                                      Rule                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UINSGameUserSettings::SetPanningRule(unsigned char Rule)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameUserSettings.SetPanningRule");
		
		UINSGameUserSettings_SetPanningRule_Params params {};
		params.Rule = Rule;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0568F3D0
	 * 		Name   -> Function Insurgency.INSGameUserSettings.SetOverrideVideoOption
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class FName                                        ConsoleVariableName                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            Value                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bMakeDefault                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UINSGameUserSettings::SetOverrideVideoOption(const class FName& ConsoleVariableName, int32_t Value, bool bMakeDefault)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameUserSettings.SetOverrideVideoOption");
		
		UINSGameUserSettings_SetOverrideVideoOption_Params params {};
		params.ConsoleVariableName = ConsoleVariableName;
		params.Value = Value;
		params.bMakeDefault = bMakeDefault;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0568F350
	 * 		Name   -> Function Insurgency.INSGameUserSettings.SetObjectiveIndicatorOpacity
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		float                                              Alpha                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UINSGameUserSettings::SetObjectiveIndicatorOpacity(float Alpha)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameUserSettings.SetObjectiveIndicatorOpacity");
		
		UINSGameUserSettings_SetObjectiveIndicatorOpacity_Params params {};
		params.Alpha = Alpha;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0568F2C0
	 * 		Name   -> Function Insurgency.INSGameUserSettings.SetMuteVOTransmitBeep
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bNewMute                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UINSGameUserSettings::SetMuteVOTransmitBeep(bool bNewMute)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameUserSettings.SetMuteVOTransmitBeep");
		
		UINSGameUserSettings_SetMuteVOTransmitBeep_Params params {};
		params.bNewMute = bNewMute;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0568F230
	 * 		Name   -> Function Insurgency.INSGameUserSettings.SetMuteTinitusEffect
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bNewMute                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UINSGameUserSettings::SetMuteTinitusEffect(bool bNewMute)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameUserSettings.SetMuteTinitusEffect");
		
		UINSGameUserSettings_SetMuteTinitusEffect_Params params {};
		params.bNewMute = bNewMute;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0568F1A0
	 * 		Name   -> Function Insurgency.INSGameUserSettings.SetMuteRadioTransmitBeep
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bNewMute                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UINSGameUserSettings::SetMuteRadioTransmitBeep(bool bNewMute)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameUserSettings.SetMuteRadioTransmitBeep");
		
		UINSGameUserSettings_SetMuteRadioTransmitBeep_Params params {};
		params.bNewMute = bNewMute;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0568F120
	 * 		Name   -> Function Insurgency.INSGameUserSettings.SetMusicVolume
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		float                                              Volume                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UINSGameUserSettings::SetMusicVolume(float Volume)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameUserSettings.SetMusicVolume");
		
		UINSGameUserSettings_SetMusicVolume_Params params {};
		params.Volume = Volume;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0568F090
	 * 		Name   -> Function Insurgency.INSGameUserSettings.SetMouseSmoothing
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bEnabled                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UINSGameUserSettings::SetMouseSmoothing(bool bEnabled)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameUserSettings.SetMouseSmoothing");
		
		UINSGameUserSettings_SetMouseSmoothing_Params params {};
		params.bEnabled = bEnabled;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0568EFC0
	 * 		Name   -> Function Insurgency.INSGameUserSettings.SetMatchRegionEnabled
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class FName                                        Mode                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bEnabled                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UINSGameUserSettings::SetMatchRegionEnabled(const class FName& Mode, bool bEnabled)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameUserSettings.SetMatchRegionEnabled");
		
		UINSGameUserSettings_SetMatchRegionEnabled_Params params {};
		params.Mode = Mode;
		params.bEnabled = bEnabled;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0568EEF0
	 * 		Name   -> Function Insurgency.INSGameUserSettings.SetMatchGamemodeEnabled
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class FName                                        GameModeName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bEnabled                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UINSGameUserSettings::SetMatchGamemodeEnabled(const class FName& GameModeName, bool bEnabled)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameUserSettings.SetMatchGamemodeEnabled");
		
		UINSGameUserSettings_SetMatchGamemodeEnabled_Params params {};
		params.GameModeName = GameModeName;
		params.bEnabled = bEnabled;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0568EE70
	 * 		Name   -> Function Insurgency.INSGameUserSettings.SetMasterVolume
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		float                                              Volume                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UINSGameUserSettings::SetMasterVolume(float Volume)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameUserSettings.SetMasterVolume");
		
		UINSGameUserSettings_SetMasterVolume_Params params {};
		params.Volume = Volume;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0568EDE0
	 * 		Name   -> Function Insurgency.INSGameUserSettings.SetIsAllowVIP
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bNewState                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UINSGameUserSettings::SetIsAllowVIP(bool bNewState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameUserSettings.SetIsAllowVIP");
		
		UINSGameUserSettings_SetIsAllowVIP_Params params {};
		params.bNewState = bNewState;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0568ED50
	 * 		Name   -> Function Insurgency.INSGameUserSettings.SetHasSelectedRegions
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bEnabled                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UINSGameUserSettings::SetHasSelectedRegions(bool bEnabled)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameUserSettings.SetHasSelectedRegions");
		
		UINSGameUserSettings_SetHasSelectedRegions_Params params {};
		params.bEnabled = bEnabled;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0568ECC0
	 * 		Name   -> Function Insurgency.INSGameUserSettings.SetFrameRateSmoothing
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bEnabled                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UINSGameUserSettings::SetFrameRateSmoothing(bool bEnabled)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameUserSettings.SetFrameRateSmoothing");
		
		UINSGameUserSettings_SetFrameRateSmoothing_Params params {};
		params.bEnabled = bEnabled;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0568EC40
	 * 		Name   -> Function Insurgency.INSGameUserSettings.SetFrameLimit
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		int32_t                                            FPS                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UINSGameUserSettings::SetFrameLimit(int32_t FPS)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameUserSettings.SetFrameLimit");
		
		UINSGameUserSettings_SetFrameLimit_Params params {};
		params.FPS = FPS;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0568EBB0
	 * 		Name   -> Function Insurgency.INSGameUserSettings.SetEnableObjectiveBriefing
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bEnable                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UINSGameUserSettings::SetEnableObjectiveBriefing(bool bEnable)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameUserSettings.SetEnableObjectiveBriefing");
		
		UINSGameUserSettings_SetEnableObjectiveBriefing_Params params {};
		params.bEnable = bEnable;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0568EB20
	 * 		Name   -> Function Insurgency.INSGameUserSettings.SetEnableNVIDIAHighlights
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bEnabled                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UINSGameUserSettings::SetEnableNVIDIAHighlights(bool bEnabled)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameUserSettings.SetEnableNVIDIAHighlights");
		
		UINSGameUserSettings_SetEnableNVIDIAHighlights_Params params {};
		params.bEnabled = bEnabled;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0568EA90
	 * 		Name   -> Function Insurgency.INSGameUserSettings.SetEnableHUD
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bEnable                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UINSGameUserSettings::SetEnableHUD(bool bEnable)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameUserSettings.SetEnableHUD");
		
		UINSGameUserSettings_SetEnableHUD_Params params {};
		params.bEnable = bEnable;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0568EA10
	 * 		Name   -> Function Insurgency.INSGameUserSettings.SetEffectsVolume
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		float                                              Volume                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UINSGameUserSettings::SetEffectsVolume(float Volume)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameUserSettings.SetEffectsVolume");
		
		UINSGameUserSettings_SetEffectsVolume_Params params {};
		params.Volume = Volume;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0568E990
	 * 		Name   -> Function Insurgency.INSGameUserSettings.SetDisplayGamma
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		float                                              Gamma                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UINSGameUserSettings::SetDisplayGamma(float Gamma)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameUserSettings.SetDisplayGamma");
		
		UINSGameUserSettings_SetDisplayGamma_Params params {};
		params.Gamma = Gamma;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0568E970
	 * 		Name   -> Function Insurgency.INSGameUserSettings.SetDefaultColorScheme
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void UINSGameUserSettings::SetDefaultColorScheme()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameUserSettings.SetDefaultColorScheme");
		
		UINSGameUserSettings_SetDefaultColorScheme_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0568E8E0
	 * 		Name   -> Function Insurgency.INSGameUserSettings.SetDeathCameraEnabled
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bEnabled                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UINSGameUserSettings::SetDeathCameraEnabled(bool bEnabled)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameUserSettings.SetDeathCameraEnabled");
		
		UINSGameUserSettings_SetDeathCameraEnabled_Params params {};
		params.bEnabled = bEnabled;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0568E850
	 * 		Name   -> Function Insurgency.INSGameUserSettings.SetCustomNeutralLinearColor
	 * 		Flags  -> (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FLinearColor                                NewColor                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UINSGameUserSettings::SetCustomNeutralLinearColor(const struct FLinearColor& NewColor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameUserSettings.SetCustomNeutralLinearColor");
		
		UINSGameUserSettings_SetCustomNeutralLinearColor_Params params {};
		params.NewColor = NewColor;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0568E740
	 * 		Name   -> Function Insurgency.INSGameUserSettings.SetCustomNeutralColor
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		float                                              R                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              G                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              B                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UINSGameUserSettings::SetCustomNeutralColor(float R, float G, float B)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameUserSettings.SetCustomNeutralColor");
		
		UINSGameUserSettings_SetCustomNeutralColor_Params params {};
		params.R = R;
		params.G = G;
		params.B = B;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0568E600
	 * 		Name   -> Function Insurgency.INSGameUserSettings.SetCustomLanguage
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class FString                                      InValue                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bSaveToConfig                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UINSGameUserSettings::SetCustomLanguage(const class FString& InValue, bool bSaveToConfig)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameUserSettings.SetCustomLanguage");
		
		UINSGameUserSettings_SetCustomLanguage_Params params {};
		params.InValue = InValue;
		params.bSaveToConfig = bSaveToConfig;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0568E570
	 * 		Name   -> Function Insurgency.INSGameUserSettings.SetCustomFriendlyLinearColor
	 * 		Flags  -> (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FLinearColor                                NewColor                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UINSGameUserSettings::SetCustomFriendlyLinearColor(const struct FLinearColor& NewColor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameUserSettings.SetCustomFriendlyLinearColor");
		
		UINSGameUserSettings_SetCustomFriendlyLinearColor_Params params {};
		params.NewColor = NewColor;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0568E460
	 * 		Name   -> Function Insurgency.INSGameUserSettings.SetCustomFriendlyColor
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		float                                              R                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              G                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              B                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UINSGameUserSettings::SetCustomFriendlyColor(float R, float G, float B)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameUserSettings.SetCustomFriendlyColor");
		
		UINSGameUserSettings_SetCustomFriendlyColor_Params params {};
		params.R = R;
		params.G = G;
		params.B = B;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0568E3D0
	 * 		Name   -> Function Insurgency.INSGameUserSettings.SetCustomEnemyLinearColor
	 * 		Flags  -> (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FLinearColor                                NewColor                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UINSGameUserSettings::SetCustomEnemyLinearColor(const struct FLinearColor& NewColor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameUserSettings.SetCustomEnemyLinearColor");
		
		UINSGameUserSettings_SetCustomEnemyLinearColor_Params params {};
		params.NewColor = NewColor;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0568E2C0
	 * 		Name   -> Function Insurgency.INSGameUserSettings.SetCustomEnemyColor
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		float                                              R                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              G                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              B                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UINSGameUserSettings::SetCustomEnemyColor(float R, float G, float B)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameUserSettings.SetCustomEnemyColor");
		
		UINSGameUserSettings_SetCustomEnemyColor_Params params {};
		params.R = R;
		params.G = G;
		params.B = B;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0568E240
	 * 		Name   -> Function Insurgency.INSGameUserSettings.SetConnectionStatusLocationSetting
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		unsigned char                                      ConnectionLocationIndex                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UINSGameUserSettings::SetConnectionStatusLocationSetting(unsigned char ConnectionLocationIndex)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameUserSettings.SetConnectionStatusLocationSetting");
		
		UINSGameUserSettings_SetConnectionStatusLocationSetting_Params params {};
		params.ConnectionLocationIndex = ConnectionLocationIndex;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0568E1B0
	 * 		Name   -> Function Insurgency.INSGameUserSettings.SetCommanderObserverLinearColor
	 * 		Flags  -> (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FLinearColor                                NewColor                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UINSGameUserSettings::SetCommanderObserverLinearColor(const struct FLinearColor& NewColor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameUserSettings.SetCommanderObserverLinearColor");
		
		UINSGameUserSettings_SetCommanderObserverLinearColor_Params params {};
		params.NewColor = NewColor;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0568E0A0
	 * 		Name   -> Function Insurgency.INSGameUserSettings.SetCommanderObserverColor
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		float                                              R                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              G                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              B                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UINSGameUserSettings::SetCommanderObserverColor(float R, float G, float B)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameUserSettings.SetCommanderObserverColor");
		
		UINSGameUserSettings_SetCommanderObserverColor_Params params {};
		params.R = R;
		params.G = G;
		params.B = B;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0568E020
	 * 		Name   -> Function Insurgency.INSGameUserSettings.SetColorSchemeSetting
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		unsigned char                                      ColorSchemeIndex                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UINSGameUserSettings::SetColorSchemeSetting(unsigned char ColorSchemeIndex)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameUserSettings.SetColorSchemeSetting");
		
		UINSGameUserSettings_SetColorSchemeSetting_Params params {};
		params.ColorSchemeIndex = ColorSchemeIndex;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0568DF90
	 * 		Name   -> Function Insurgency.INSGameUserSettings.SetClientStatsOverlayEnabled
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bEnabled                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UINSGameUserSettings::SetClientStatsOverlayEnabled(bool bEnabled)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameUserSettings.SetClientStatsOverlayEnabled");
		
		UINSGameUserSettings_SetClientStatsOverlayEnabled_Params params {};
		params.bEnabled = bEnabled;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0568DF00
	 * 		Name   -> Function Insurgency.INSGameUserSettings.SetClientStatLocation
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bEnabled                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UINSGameUserSettings::SetClientStatLocation(bool bEnabled)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameUserSettings.SetClientStatLocation");
		
		UINSGameUserSettings_SetClientStatLocation_Params params {};
		params.bEnabled = bEnabled;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0568DE70
	 * 		Name   -> Function Insurgency.INSGameUserSettings.SetCameraAnimationEnabled
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bVal                                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UINSGameUserSettings::SetCameraAnimationEnabled(bool bVal)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameUserSettings.SetCameraAnimationEnabled");
		
		UINSGameUserSettings_SetCameraAnimationEnabled_Params params {};
		params.bVal = bVal;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0568DDE0
	 * 		Name   -> Function Insurgency.INSGameUserSettings.SetBuddyOverridesCommanderObserverColor
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bVal                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UINSGameUserSettings::SetBuddyOverridesCommanderObserverColor(bool bVal)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameUserSettings.SetBuddyOverridesCommanderObserverColor");
		
		UINSGameUserSettings_SetBuddyOverridesCommanderObserverColor_Params params {};
		params.bVal = bVal;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0568DD50
	 * 		Name   -> Function Insurgency.INSGameUserSettings.SetBuddyLinearColor
	 * 		Flags  -> (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FLinearColor                                NewColor                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UINSGameUserSettings::SetBuddyLinearColor(const struct FLinearColor& NewColor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameUserSettings.SetBuddyLinearColor");
		
		UINSGameUserSettings_SetBuddyLinearColor_Params params {};
		params.NewColor = NewColor;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0568DC40
	 * 		Name   -> Function Insurgency.INSGameUserSettings.SetBuddyColor
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		float                                              R                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              G                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              B                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UINSGameUserSettings::SetBuddyColor(float R, float G, float B)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameUserSettings.SetBuddyColor");
		
		UINSGameUserSettings_SetBuddyColor_Params params {};
		params.R = R;
		params.G = G;
		params.B = B;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0568DBC0
	 * 		Name   -> Function Insurgency.INSGameUserSettings.SetBackgroundVolumeMultiplier
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		float                                              Amount                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UINSGameUserSettings::SetBackgroundVolumeMultiplier(float Amount)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameUserSettings.SetBackgroundVolumeMultiplier");
		
		UINSGameUserSettings_SetBackgroundVolumeMultiplier_Params params {};
		params.Amount = Amount;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0568DB30
	 * 		Name   -> Function Insurgency.INSGameUserSettings.SetAlwaysShowFiremode
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bNewVal                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UINSGameUserSettings::SetAlwaysShowFiremode(bool bNewVal)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameUserSettings.SetAlwaysShowFiremode");
		
		UINSGameUserSettings_SetAlwaysShowFiremode_Params params {};
		params.bNewVal = bNewVal;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0568DAA0
	 * 		Name   -> Function Insurgency.INSGameUserSettings.SetAlwaysShowCosmeticSelection
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bNewVal                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UINSGameUserSettings::SetAlwaysShowCosmeticSelection(bool bNewVal)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameUserSettings.SetAlwaysShowCosmeticSelection");
		
		UINSGameUserSettings_SetAlwaysShowCosmeticSelection_Params params {};
		params.bNewVal = bNewVal;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0568DA10
	 * 		Name   -> Function Insurgency.INSGameUserSettings.SetAlwaysShowCompass
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bNewVal                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UINSGameUserSettings::SetAlwaysShowCompass(bool bNewVal)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameUserSettings.SetAlwaysShowCompass");
		
		UINSGameUserSettings_SetAlwaysShowCompass_Params params {};
		params.bNewVal = bNewVal;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0568D980
	 * 		Name   -> Function Insurgency.INSGameUserSettings.SetAllowIngameLessons
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bVal                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UINSGameUserSettings::SetAllowIngameLessons(bool bVal)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameUserSettings.SetAllowIngameLessons");
		
		UINSGameUserSettings_SetAllowIngameLessons_Params params {};
		params.bVal = bVal;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0568D8F0
	 * 		Name   -> Function Insurgency.INSGameUserSettings.ResetOverrideVideoOptions
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		bool                                               bPartialRefresh                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UINSGameUserSettings::ResetOverrideVideoOptions(bool bPartialRefresh)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameUserSettings.ResetOverrideVideoOptions");
		
		UINSGameUserSettings_ResetOverrideVideoOptions_Params params {};
		params.bPartialRefresh = bPartialRefresh;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0568D870
	 * 		Name   -> Function Insurgency.INSGameUserSettings.ResetOverrideVideoOption
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class FName                                        ConsoleVariableName                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UINSGameUserSettings::ResetOverrideVideoOption(const class FName& ConsoleVariableName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameUserSettings.ResetOverrideVideoOption");
		
		UINSGameUserSettings_ResetOverrideVideoOption_Params params {};
		params.ConsoleVariableName = ConsoleVariableName;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0568D850
	 * 		Name   -> Function Insurgency.INSGameUserSettings.ResetOriginalOverrideVideoOptions
	 * 		Flags  -> (Final, Native, Public)
	 */
	void UINSGameUserSettings::ResetOriginalOverrideVideoOptions()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameUserSettings.ResetOriginalOverrideVideoOptions");
		
		UINSGameUserSettings_ResetOriginalOverrideVideoOptions_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0568D830
	 * 		Name   -> Function Insurgency.INSGameUserSettings.RefreshOverrideVideoOptions
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void UINSGameUserSettings::RefreshOverrideVideoOptions()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameUserSettings.RefreshOverrideVideoOptions");
		
		UINSGameUserSettings_RefreshOverrideVideoOptions_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> DelegateFunction Insurgency.INSGameUserSettings.OnVoiceChatInputDeviceChanged__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 * Parameters:
	 * 		class FString                                      NewInputDevice                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UINSGameUserSettings::OnVoiceChatInputDeviceChanged__DelegateSignature(const class FString& NewInputDevice)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction Insurgency.INSGameUserSettings.OnVoiceChatInputDeviceChanged__DelegateSignature");
		
		UINSGameUserSettings_OnVoiceChatInputDeviceChanged__DelegateSignature_Params params {};
		params.NewInputDevice = NewInputDevice;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> DelegateFunction Insurgency.INSGameUserSettings.OnVoiceChatGainSettingChanged__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 * Parameters:
	 * 		float                                              NewGain                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UINSGameUserSettings::OnVoiceChatGainSettingChanged__DelegateSignature(float NewGain)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction Insurgency.INSGameUserSettings.OnVoiceChatGainSettingChanged__DelegateSignature");
		
		UINSGameUserSettings_OnVoiceChatGainSettingChanged__DelegateSignature_Params params {};
		params.NewGain = NewGain;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> DelegateFunction Insurgency.INSGameUserSettings.OnSettingsUpdated__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 */
	void UINSGameUserSettings::OnSettingsUpdated__DelegateSignature()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction Insurgency.INSGameUserSettings.OnSettingsUpdated__DelegateSignature");
		
		UINSGameUserSettings_OnSettingsUpdated__DelegateSignature_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> DelegateFunction Insurgency.INSGameUserSettings.OnRespawnStatusLocationSettingUpdated__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 * Parameters:
	 * 		unsigned char                                      NewIndex                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UINSGameUserSettings::OnRespawnStatusLocationSettingUpdated__DelegateSignature(unsigned char NewIndex)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction Insurgency.INSGameUserSettings.OnRespawnStatusLocationSettingUpdated__DelegateSignature");
		
		UINSGameUserSettings_OnRespawnStatusLocationSettingUpdated__DelegateSignature_Params params {};
		params.NewIndex = NewIndex;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> DelegateFunction Insurgency.INSGameUserSettings.OnNVIDIAHighlightPreferencesChanged__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 */
	void UINSGameUserSettings::OnNVIDIAHighlightPreferencesChanged__DelegateSignature()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction Insurgency.INSGameUserSettings.OnNVIDIAHighlightPreferencesChanged__DelegateSignature");
		
		UINSGameUserSettings_OnNVIDIAHighlightPreferencesChanged__DelegateSignature_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> DelegateFunction Insurgency.INSGameUserSettings.OnMatchRegionsChanged__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 */
	void UINSGameUserSettings::OnMatchRegionsChanged__DelegateSignature()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction Insurgency.INSGameUserSettings.OnMatchRegionsChanged__DelegateSignature");
		
		UINSGameUserSettings_OnMatchRegionsChanged__DelegateSignature_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> DelegateFunction Insurgency.INSGameUserSettings.OnMatchGamemodesChanged__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 */
	void UINSGameUserSettings::OnMatchGamemodesChanged__DelegateSignature()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction Insurgency.INSGameUserSettings.OnMatchGamemodesChanged__DelegateSignature");
		
		UINSGameUserSettings_OnMatchGamemodesChanged__DelegateSignature_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> DelegateFunction Insurgency.INSGameUserSettings.OnLanguageChanged__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 */
	void UINSGameUserSettings::OnLanguageChanged__DelegateSignature()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction Insurgency.INSGameUserSettings.OnLanguageChanged__DelegateSignature");
		
		UINSGameUserSettings_OnLanguageChanged__DelegateSignature_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> DelegateFunction Insurgency.INSGameUserSettings.OnHUDDisplayOptionChanged__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 */
	void UINSGameUserSettings::OnHUDDisplayOptionChanged__DelegateSignature()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction Insurgency.INSGameUserSettings.OnHUDDisplayOptionChanged__DelegateSignature");
		
		UINSGameUserSettings_OnHUDDisplayOptionChanged__DelegateSignature_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> DelegateFunction Insurgency.INSGameUserSettings.OnConnectionStatusLocationSettingUpdated__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 * Parameters:
	 * 		unsigned char                                      NewIndex                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UINSGameUserSettings::OnConnectionStatusLocationSettingUpdated__DelegateSignature(unsigned char NewIndex)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction Insurgency.INSGameUserSettings.OnConnectionStatusLocationSettingUpdated__DelegateSignature");
		
		UINSGameUserSettings_OnConnectionStatusLocationSettingUpdated__DelegateSignature_Params params {};
		params.NewIndex = NewIndex;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> DelegateFunction Insurgency.INSGameUserSettings.OnClientStatLocationChanged__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 */
	void UINSGameUserSettings::OnClientStatLocationChanged__DelegateSignature()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction Insurgency.INSGameUserSettings.OnClientStatLocationChanged__DelegateSignature");
		
		UINSGameUserSettings_OnClientStatLocationChanged__DelegateSignature_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0568D780
	 * 		Name   -> Function Insurgency.INSGameUserSettings.MarkMenuPromptAsSeen
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		class FString                                      Prompt                                                     (Parm, OutParm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UINSGameUserSettings::MarkMenuPromptAsSeen(class FString* Prompt)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameUserSettings.MarkMenuPromptAsSeen");
		
		UINSGameUserSettings_MarkMenuPromptAsSeen_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (Prompt != nullptr)
			*Prompt = params.Prompt;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0568D6B0
	 * 		Name   -> Function Insurgency.INSGameUserSettings.MarkEventAsConfirmed
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		EConfirmableEvent                                  Event                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bPersistIfUpdated                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UINSGameUserSettings::MarkEventAsConfirmed(EConfirmableEvent Event, bool bPersistIfUpdated)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameUserSettings.MarkEventAsConfirmed");
		
		UINSGameUserSettings_MarkEventAsConfirmed_Params params {};
		params.Event = Event;
		params.bPersistIfUpdated = bPersistIfUpdated;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0568D680
	 * 		Name   -> Function Insurgency.INSGameUserSettings.IsViewBobEnabled
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool UINSGameUserSettings::IsViewBobEnabled()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameUserSettings.IsViewBobEnabled");
		
		UINSGameUserSettings_IsViewBobEnabled_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0568D650
	 * 		Name   -> Function Insurgency.INSGameUserSettings.IsProfanityFilterEnabled
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool UINSGameUserSettings::IsProfanityFilterEnabled()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameUserSettings.IsProfanityFilterEnabled");
		
		UINSGameUserSettings_IsProfanityFilterEnabled_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0568D620
	 * 		Name   -> Function Insurgency.INSGameUserSettings.IsObjectiveBriefingEnabled
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
	 */
	bool UINSGameUserSettings::IsObjectiveBriefingEnabled()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameUserSettings.IsObjectiveBriefingEnabled");
		
		UINSGameUserSettings_IsObjectiveBriefingEnabled_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0568D5F0
	 * 		Name   -> Function Insurgency.INSGameUserSettings.IsHUDEnabled
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
	 */
	bool UINSGameUserSettings::IsHUDEnabled()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameUserSettings.IsHUDEnabled");
		
		UINSGameUserSettings_IsHUDEnabled_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0568D5C0
	 * 		Name   -> Function Insurgency.INSGameUserSettings.IsFrameRateSmoothingEnabled
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
	 */
	bool UINSGameUserSettings::IsFrameRateSmoothingEnabled()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameUserSettings.IsFrameRateSmoothingEnabled");
		
		UINSGameUserSettings_IsFrameRateSmoothingEnabled_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0568D590
	 * 		Name   -> Function Insurgency.INSGameUserSettings.IsFirstTimeSaving
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool UINSGameUserSettings::IsFirstTimeSaving()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameUserSettings.IsFirstTimeSaving");
		
		UINSGameUserSettings_IsFirstTimeSaving_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0568D560
	 * 		Name   -> Function Insurgency.INSGameUserSettings.IsDeathCameraEnabled
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool UINSGameUserSettings::IsDeathCameraEnabled()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameUserSettings.IsDeathCameraEnabled");
		
		UINSGameUserSettings_IsDeathCameraEnabled_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0568D530
	 * 		Name   -> Function Insurgency.INSGameUserSettings.IsCameraAnimationEnabled
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool UINSGameUserSettings::IsCameraAnimationEnabled()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameUserSettings.IsCameraAnimationEnabled");
		
		UINSGameUserSettings_IsCameraAnimationEnabled_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0568D470
	 * 		Name   -> Function Insurgency.INSGameUserSettings.HasSeenMenuPrompt
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		class FString                                      Prompt                                                     (Parm, OutParm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UINSGameUserSettings::HasSeenMenuPrompt(class FString* Prompt)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameUserSettings.HasSeenMenuPrompt");
		
		UINSGameUserSettings_HasSeenMenuPrompt_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (Prompt != nullptr)
			*Prompt = params.Prompt;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0568D3E0
	 * 		Name   -> Function Insurgency.INSGameUserSettings.HasConfirmedEvent
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		EConfirmableEvent                                  Event                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UINSGameUserSettings::HasConfirmedEvent(EConfirmableEvent Event)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameUserSettings.HasConfirmedEvent");
		
		UINSGameUserSettings_HasConfirmedEvent_Params params {};
		params.Event = Event;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0568D3B0
	 * 		Name   -> Function Insurgency.INSGameUserSettings.GetVoiceVolume
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	float UINSGameUserSettings::GetVoiceVolume()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameUserSettings.GetVoiceVolume");
		
		UINSGameUserSettings_GetVoiceVolume_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0568D380
	 * 		Name   -> Function Insurgency.INSGameUserSettings.GetVoiceInputGain
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	float UINSGameUserSettings::GetVoiceInputGain()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameUserSettings.GetVoiceInputGain");
		
		UINSGameUserSettings_GetVoiceInputGain_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0568D300
	 * 		Name   -> Function Insurgency.INSGameUserSettings.GetVoiceInputDevice
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	class FString UINSGameUserSettings::GetVoiceInputDevice()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameUserSettings.GetVoiceInputDevice");
		
		UINSGameUserSettings_GetVoiceInputDevice_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0568D2D0
	 * 		Name   -> Function Insurgency.INSGameUserSettings.GetSpectatorXrayTailsPlayerOnlyEnabled
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool UINSGameUserSettings::GetSpectatorXrayTailsPlayerOnlyEnabled()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameUserSettings.GetSpectatorXrayTailsPlayerOnlyEnabled");
		
		UINSGameUserSettings_GetSpectatorXrayTailsPlayerOnlyEnabled_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0568D2A0
	 * 		Name   -> Function Insurgency.INSGameUserSettings.GetSpectatorXrayTailsEnabled
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool UINSGameUserSettings::GetSpectatorXrayTailsEnabled()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameUserSettings.GetSpectatorXrayTailsEnabled");
		
		UINSGameUserSettings_GetSpectatorXrayTailsEnabled_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0568D270
	 * 		Name   -> Function Insurgency.INSGameUserSettings.GetSpectatorXrayEnabled
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool UINSGameUserSettings::GetSpectatorXrayEnabled()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameUserSettings.GetSpectatorXrayEnabled");
		
		UINSGameUserSettings_GetSpectatorXrayEnabled_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0568D240
	 * 		Name   -> Function Insurgency.INSGameUserSettings.GetSpectatorControlHintsEnabled
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool UINSGameUserSettings::GetSpectatorControlHintsEnabled()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameUserSettings.GetSpectatorControlHintsEnabled");
		
		UINSGameUserSettings_GetSpectatorControlHintsEnabled_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0568D210
	 * 		Name   -> Function Insurgency.INSGameUserSettings.GetSoundInBackground
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool UINSGameUserSettings::GetSoundInBackground()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameUserSettings.GetSoundInBackground");
		
		UINSGameUserSettings_GetSoundInBackground_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0568D1E0
	 * 		Name   -> Function Insurgency.INSGameUserSettings.GetSoldierFOV
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	float UINSGameUserSettings::GetSoldierFOV()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameUserSettings.GetSoldierFOV");
		
		UINSGameUserSettings_GetSoldierFOV_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0568D1B0
	 * 		Name   -> Function Insurgency.INSGameUserSettings.GetShowFPS
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool UINSGameUserSettings::GetShowFPS()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameUserSettings.GetShowFPS");
		
		UINSGameUserSettings_GetShowFPS_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0568D180
	 * 		Name   -> Function Insurgency.INSGameUserSettings.GetShowDevTag
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool UINSGameUserSettings::GetShowDevTag()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameUserSettings.GetShowDevTag");
		
		UINSGameUserSettings_GetShowDevTag_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0568D150
	 * 		Name   -> Function Insurgency.INSGameUserSettings.GetShowContextualVaultHints
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool UINSGameUserSettings::GetShowContextualVaultHints()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameUserSettings.GetShowContextualVaultHints");
		
		UINSGameUserSettings_GetShowContextualVaultHints_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0568D120
	 * 		Name   -> Function Insurgency.INSGameUserSettings.GetShowContextualKeyHints
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool UINSGameUserSettings::GetShowContextualKeyHints()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameUserSettings.GetShowContextualKeyHints");
		
		UINSGameUserSettings_GetShowContextualKeyHints_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0568D0F0
	 * 		Name   -> Function Insurgency.INSGameUserSettings.GetShowContextualCycleOpticsHint
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool UINSGameUserSettings::GetShowContextualCycleOpticsHint()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameUserSettings.GetShowContextualCycleOpticsHint");
		
		UINSGameUserSettings_GetShowContextualCycleOpticsHint_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0568D0C0
	 * 		Name   -> Function Insurgency.INSGameUserSettings.GetShoutcasterTeamScoresEnabled
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool UINSGameUserSettings::GetShoutcasterTeamScoresEnabled()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameUserSettings.GetShoutcasterTeamScoresEnabled");
		
		UINSGameUserSettings_GetShoutcasterTeamScoresEnabled_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0568D090
	 * 		Name   -> Function Insurgency.INSGameUserSettings.GetShoutcasterPlayerVitalsEnabled
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool UINSGameUserSettings::GetShoutcasterPlayerVitalsEnabled()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameUserSettings.GetShoutcasterPlayerVitalsEnabled");
		
		UINSGameUserSettings_GetShoutcasterPlayerVitalsEnabled_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0568D060
	 * 		Name   -> Function Insurgency.INSGameUserSettings.GetShoutcasterMinimapEnabled
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool UINSGameUserSettings::GetShoutcasterMinimapEnabled()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameUserSettings.GetShoutcasterMinimapEnabled");
		
		UINSGameUserSettings_GetShoutcasterMinimapEnabled_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0568D030
	 * 		Name   -> Function Insurgency.INSGameUserSettings.GetScreenPercentage
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	float UINSGameUserSettings::GetScreenPercentage()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameUserSettings.GetScreenPercentage");
		
		UINSGameUserSettings_GetScreenPercentage_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0568CE90
	 * 		Name   -> Function Insurgency.INSGameUserSettings.GetResolutionScaleInformationSane
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		float                                              CurrentScaleNormalized                                     (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              CurrentScaleValue                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              MinScaleValue                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              MaxScaleValue                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UINSGameUserSettings::GetResolutionScaleInformationSane(float* CurrentScaleNormalized, float* CurrentScaleValue, float* MinScaleValue, float* MaxScaleValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameUserSettings.GetResolutionScaleInformationSane");
		
		UINSGameUserSettings_GetResolutionScaleInformationSane_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (CurrentScaleNormalized != nullptr)
			*CurrentScaleNormalized = params.CurrentScaleNormalized;
		if (CurrentScaleValue != nullptr)
			*CurrentScaleValue = params.CurrentScaleValue;
		if (MinScaleValue != nullptr)
			*MinScaleValue = params.MinScaleValue;
		if (MaxScaleValue != nullptr)
			*MaxScaleValue = params.MaxScaleValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0568CE60
	 * 		Name   -> Function Insurgency.INSGameUserSettings.GetRelativeTeamColors
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool UINSGameUserSettings::GetRelativeTeamColors()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameUserSettings.GetRelativeTeamColors");
		
		UINSGameUserSettings_GetRelativeTeamColors_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0568CE30
	 * 		Name   -> Function Insurgency.INSGameUserSettings.GetQualityPreset
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	int32_t UINSGameUserSettings::GetQualityPreset()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameUserSettings.GetQualityPreset");
		
		UINSGameUserSettings_GetQualityPreset_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0568CE00
	 * 		Name   -> Function Insurgency.INSGameUserSettings.GetPanningRule
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	unsigned char UINSGameUserSettings::GetPanningRule()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameUserSettings.GetPanningRule");
		
		UINSGameUserSettings_GetPanningRule_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0568CDD0
	 * 		Name   -> Function Insurgency.INSGameUserSettings.GetNVIDIAHighlightEnabled
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool UINSGameUserSettings::GetNVIDIAHighlightEnabled()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameUserSettings.GetNVIDIAHighlightEnabled");
		
		UINSGameUserSettings_GetNVIDIAHighlightEnabled_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0568CDA0
	 * 		Name   -> Function Insurgency.INSGameUserSettings.GetMuteVOTransmitBeep
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool UINSGameUserSettings::GetMuteVOTransmitBeep()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameUserSettings.GetMuteVOTransmitBeep");
		
		UINSGameUserSettings_GetMuteVOTransmitBeep_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0568CD70
	 * 		Name   -> Function Insurgency.INSGameUserSettings.GetMuteTinitusEffect
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool UINSGameUserSettings::GetMuteTinitusEffect()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameUserSettings.GetMuteTinitusEffect");
		
		UINSGameUserSettings_GetMuteTinitusEffect_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0568CD40
	 * 		Name   -> Function Insurgency.INSGameUserSettings.GetMuteRadioTransmitBeep
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool UINSGameUserSettings::GetMuteRadioTransmitBeep()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameUserSettings.GetMuteRadioTransmitBeep");
		
		UINSGameUserSettings_GetMuteRadioTransmitBeep_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0568CD10
	 * 		Name   -> Function Insurgency.INSGameUserSettings.GetMusicVolume
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	float UINSGameUserSettings::GetMusicVolume()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameUserSettings.GetMusicVolume");
		
		UINSGameUserSettings_GetMusicVolume_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0568CCE0
	 * 		Name   -> Function Insurgency.INSGameUserSettings.GetMouseSmoothing
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool UINSGameUserSettings::GetMouseSmoothing()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameUserSettings.GetMouseSmoothing");
		
		UINSGameUserSettings_GetMouseSmoothing_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0568CBC0
	 * 		Name   -> Function Insurgency.INSGameUserSettings.GetMatchRegions
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		TArray<class FName>                                Regions                                                    (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		TArray<class FName>                                EnabledRegions                                             (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UINSGameUserSettings::GetMatchRegions(TArray<class FName>* Regions, TArray<class FName>* EnabledRegions)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameUserSettings.GetMatchRegions");
		
		UINSGameUserSettings_GetMatchRegions_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (Regions != nullptr)
			*Regions = params.Regions;
		if (EnabledRegions != nullptr)
			*EnabledRegions = params.EnabledRegions;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0568CA60
	 * 		Name   -> Function Insurgency.INSGameUserSettings.GetMatchGamemodes
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bCoop                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		TArray<class FName>                                Modes                                                      (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		TArray<class FName>                                EnabledModes                                               (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UINSGameUserSettings::GetMatchGamemodes(bool bCoop, TArray<class FName>* Modes, TArray<class FName>* EnabledModes)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameUserSettings.GetMatchGamemodes");
		
		UINSGameUserSettings_GetMatchGamemodes_Params params {};
		params.bCoop = bCoop;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (Modes != nullptr)
			*Modes = params.Modes;
		if (EnabledModes != nullptr)
			*EnabledModes = params.EnabledModes;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0568CA30
	 * 		Name   -> Function Insurgency.INSGameUserSettings.GetMasterVolume
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	float UINSGameUserSettings::GetMasterVolume()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameUserSettings.GetMasterVolume");
		
		UINSGameUserSettings_GetMasterVolume_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0568CA00
	 * 		Name   -> Function Insurgency.INSGameUserSettings.GetIsAllowVIP
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
	 */
	bool UINSGameUserSettings::GetIsAllowVIP()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameUserSettings.GetIsAllowVIP");
		
		UINSGameUserSettings_GetIsAllowVIP_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0568C9D0
	 * 		Name   -> Function Insurgency.INSGameUserSettings.GetInsurgencyGameUserSettings
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 */
	class UINSGameUserSettings* UINSGameUserSettings::STATIC_GetInsurgencyGameUserSettings()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameUserSettings.GetInsurgencyGameUserSettings");
		
		UINSGameUserSettings_GetInsurgencyGameUserSettings_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0568C9A0
	 * 		Name   -> Function Insurgency.INSGameUserSettings.GetHasSelectedRegions
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool UINSGameUserSettings::GetHasSelectedRegions()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameUserSettings.GetHasSelectedRegions");
		
		UINSGameUserSettings_GetHasSelectedRegions_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0568C970
	 * 		Name   -> Function Insurgency.INSGameUserSettings.GetFrameLimit
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	int32_t UINSGameUserSettings::GetFrameLimit()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameUserSettings.GetFrameLimit");
		
		UINSGameUserSettings_GetFrameLimit_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0568C8C0
	 * 		Name   -> Function Insurgency.INSGameUserSettings.GetExcludedMatchRegions
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		TArray<class FName>                                Regions                                                    (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UINSGameUserSettings::GetExcludedMatchRegions(TArray<class FName>* Regions)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameUserSettings.GetExcludedMatchRegions");
		
		UINSGameUserSettings_GetExcludedMatchRegions_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (Regions != nullptr)
			*Regions = params.Regions;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0568C810
	 * 		Name   -> Function Insurgency.INSGameUserSettings.GetExcludedMatchGamemodes
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		TArray<class FName>                                Modes                                                      (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UINSGameUserSettings::GetExcludedMatchGamemodes(TArray<class FName>* Modes)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameUserSettings.GetExcludedMatchGamemodes");
		
		UINSGameUserSettings_GetExcludedMatchGamemodes_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (Modes != nullptr)
			*Modes = params.Modes;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0568C7E0
	 * 		Name   -> Function Insurgency.INSGameUserSettings.GetEffectsVolume
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	float UINSGameUserSettings::GetEffectsVolume()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameUserSettings.GetEffectsVolume");
		
		UINSGameUserSettings_GetEffectsVolume_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0568C7B0
	 * 		Name   -> Function Insurgency.INSGameUserSettings.GetDisplayGamma
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	float UINSGameUserSettings::GetDisplayGamma()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameUserSettings.GetDisplayGamma");
		
		UINSGameUserSettings_GetDisplayGamma_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0568C6F0
	 * 		Name   -> Function Insurgency.INSGameUserSettings.GetCustomLanguage
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	class FString UINSGameUserSettings::GetCustomLanguage()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameUserSettings.GetCustomLanguage");
		
		UINSGameUserSettings_GetCustomLanguage_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0568C5E0
	 * 		Name   -> Function Insurgency.INSGameUserSettings.GetColorScheme
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		unsigned char                                      ColorSchemeIndex                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FColorScheme                                OutColorScheme                                             (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	bool UINSGameUserSettings::GetColorScheme(unsigned char ColorSchemeIndex, struct FColorScheme* OutColorScheme)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameUserSettings.GetColorScheme");
		
		UINSGameUserSettings_GetColorScheme_Params params {};
		params.ColorSchemeIndex = ColorSchemeIndex;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutColorScheme != nullptr)
			*OutColorScheme = params.OutColorScheme;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0568C5B0
	 * 		Name   -> Function Insurgency.INSGameUserSettings.GetClientStatsOverlayEnabled
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool UINSGameUserSettings::GetClientStatsOverlayEnabled()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameUserSettings.GetClientStatsOverlayEnabled");
		
		UINSGameUserSettings_GetClientStatsOverlayEnabled_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0568C580
	 * 		Name   -> Function Insurgency.INSGameUserSettings.GetClientStatLocation
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool UINSGameUserSettings::GetClientStatLocation()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameUserSettings.GetClientStatLocation");
		
		UINSGameUserSettings_GetClientStatLocation_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0568C550
	 * 		Name   -> Function Insurgency.INSGameUserSettings.GetBackgroundVolumeMultiplier
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	float UINSGameUserSettings::GetBackgroundVolumeMultiplier()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameUserSettings.GetBackgroundVolumeMultiplier");
		
		UINSGameUserSettings_GetBackgroundVolumeMultiplier_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0568C520
	 * 		Name   -> Function Insurgency.INSGameUserSettings.GetAlwaysShowFiremode
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool UINSGameUserSettings::GetAlwaysShowFiremode()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameUserSettings.GetAlwaysShowFiremode");
		
		UINSGameUserSettings_GetAlwaysShowFiremode_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0568C4F0
	 * 		Name   -> Function Insurgency.INSGameUserSettings.GetAlwaysShowCosmeticSelection
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool UINSGameUserSettings::GetAlwaysShowCosmeticSelection()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameUserSettings.GetAlwaysShowCosmeticSelection");
		
		UINSGameUserSettings_GetAlwaysShowCosmeticSelection_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0568C4C0
	 * 		Name   -> Function Insurgency.INSGameUserSettings.GetAlwaysShowCompass
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool UINSGameUserSettings::GetAlwaysShowCompass()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameUserSettings.GetAlwaysShowCompass");
		
		UINSGameUserSettings_GetAlwaysShowCompass_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0568C490
	 * 		Name   -> Function Insurgency.INSGameUserSettings.GetAllowIngameLessons
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool UINSGameUserSettings::GetAllowIngameLessons()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameUserSettings.GetAllowIngameLessons");
		
		UINSGameUserSettings_GetAllowIngameLessons_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0568C410
	 * 		Name   -> Function Insurgency.INSGameUserSettings.CreateOverrideVideoOption
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class FName                                        ConsoleVariableName                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UINSGameUserSettings::CreateOverrideVideoOption(const class FName& ConsoleVariableName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameUserSettings.CreateOverrideVideoOption");
		
		UINSGameUserSettings_CreateOverrideVideoOption_Params params {};
		params.ConsoleVariableName = ConsoleVariableName;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0568C340
	 * 		Name   -> Function Insurgency.INSGameUserSettings.ClearEventConfirmedState
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		EConfirmableEvent                                  Event                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bPersistIfUpdated                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UINSGameUserSettings::ClearEventConfirmedState(EConfirmableEvent Event, bool bPersistIfUpdated)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameUserSettings.ClearEventConfirmedState");
		
		UINSGameUserSettings_ClearEventConfirmedState_Params params {};
		params.Event = Event;
		params.bPersistIfUpdated = bPersistIfUpdated;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UINSGameUserSettings.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UINSGameUserSettings::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.INSGameUserSettings");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05690820
	 * 		Name   -> Function Insurgency.INSGameViewportClient.SSForceKeyboardId
	 * 		Flags  -> (Final, Exec, Native, Private)
	 * Parameters:
	 * 		int32_t                                            NewControllerId                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UINSGameViewportClient::SSForceKeyboardId(int32_t NewControllerId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameViewportClient.SSForceKeyboardId");
		
		UINSGameViewportClient_SSForceKeyboardId_Params params {};
		params.NewControllerId = NewControllerId;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05690790
	 * 		Name   -> Function Insurgency.INSGameViewportClient.SSForceGamepadId
	 * 		Flags  -> (Final, Exec, Native, Private)
	 * Parameters:
	 * 		int32_t                                            NewControllerId                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UINSGameViewportClient::SSForceGamepadId(int32_t NewControllerId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSGameViewportClient.SSForceGamepadId");
		
		UINSGameViewportClient_SSForceGamepadId_Params params {};
		params.NewControllerId = NewControllerId;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UINSGameViewportClient.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UINSGameViewportClient::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.INSGameViewportClient");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AINSLevelScriptActor.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AINSLevelScriptActor::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.INSLevelScriptActor");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05692700
	 * 		Name   -> Function Insurgency.INSLocalPlayer.UpdatePoolCounts
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void UINSLocalPlayer::UpdatePoolCounts()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSLocalPlayer.UpdatePoolCounts");
		
		UINSLocalPlayer_UpdatePoolCounts_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05692670
	 * 		Name   -> Function Insurgency.INSLocalPlayer.UpdatePlayerProfile
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bForceUpdate                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UINSLocalPlayer::UpdatePlayerProfile(bool bForceUpdate)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSLocalPlayer.UpdatePlayerProfile");
		
		UINSLocalPlayer_UpdatePlayerProfile_Params params {};
		params.bForceUpdate = bForceUpdate;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05692650
	 * 		Name   -> Function Insurgency.INSLocalPlayer.UpdateMatchHistory
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void UINSLocalPlayer::UpdateMatchHistory()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSLocalPlayer.UpdateMatchHistory");
		
		UINSLocalPlayer_UpdateMatchHistory_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05692590
	 * 		Name   -> Function Insurgency.INSLocalPlayer.UpdateArmorAndCarrierLevels
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class FName                                        ArmorLevel                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FName                                        CarrierLevel                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UINSLocalPlayer::UpdateArmorAndCarrierLevels(const class FName& ArmorLevel, const class FName& CarrierLevel)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSLocalPlayer.UpdateArmorAndCarrierLevels");
		
		UINSLocalPlayer_UpdateArmorAndCarrierLevels_Params params {};
		params.ArmorLevel = ArmorLevel;
		params.CarrierLevel = CarrierLevel;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056924B0
	 * 		Name   -> Function Insurgency.INSLocalPlayer.SetNextJoinPassword
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class FString                                      Password                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UINSLocalPlayer::SetNextJoinPassword(const class FString& Password)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSLocalPlayer.SetNextJoinPassword");
		
		UINSLocalPlayer_SetNextJoinPassword_Params params {};
		params.Password = Password;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05692420
	 * 		Name   -> Function Insurgency.INSLocalPlayer.SetChatRestricted
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bInResctricted                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UINSLocalPlayer::SetChatRestricted(bool bInResctricted)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSLocalPlayer.SetChatRestricted");
		
		UINSLocalPlayer_SetChatRestricted_Params params {};
		params.bInResctricted = bInResctricted;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05692400
	 * 		Name   -> Function Insurgency.INSLocalPlayer.SaveLocalProfile
	 * 		Flags  -> (Final, Exec, Native, Public)
	 */
	void UINSLocalPlayer::SaveLocalProfile()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSLocalPlayer.SaveLocalProfile");
		
		UINSLocalPlayer_SaveLocalProfile_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00C76AB0
	 * 		Name   -> Function Insurgency.INSLocalPlayer.RequestPostMatchStats
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void UINSLocalPlayer::RequestPostMatchStats()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSLocalPlayer.RequestPostMatchStats");
		
		UINSLocalPlayer_RequestPostMatchStats_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00C76AB0
	 * 		Name   -> Function Insurgency.INSLocalPlayer.RequestPlayerProfile
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void UINSLocalPlayer::RequestPlayerProfile()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSLocalPlayer.RequestPlayerProfile");
		
		UINSLocalPlayer_RequestPlayerProfile_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05692340
	 * 		Name   -> Function Insurgency.INSLocalPlayer.RequestPlayerGames
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		int32_t                                            CurrentPage                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            CountPerPage                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UINSLocalPlayer::RequestPlayerGames(int32_t CurrentPage, int32_t CountPerPage)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSLocalPlayer.RequestPlayerGames");
		
		UINSLocalPlayer_RequestPlayerGames_Params params {};
		params.CurrentPage = CurrentPage;
		params.CountPerPage = CountPerPage;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056922B0
	 * 		Name   -> Function Insurgency.INSLocalPlayer.QueryAchievements
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bRefresh                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UINSLocalPlayer::QueryAchievements(bool bRefresh)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSLocalPlayer.QueryAchievements");
		
		UINSLocalPlayer_QueryAchievements_Params params {};
		params.bRefresh = bRefresh;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> DelegateFunction Insurgency.INSLocalPlayer.OnUsingControllerUpdate__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 * Parameters:
	 * 		bool                                               UsingController                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EeInputIconType                                    NewIconType                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UINSLocalPlayer::OnUsingControllerUpdate__DelegateSignature(bool UsingController, EeInputIconType NewIconType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction Insurgency.INSLocalPlayer.OnUsingControllerUpdate__DelegateSignature");
		
		UINSLocalPlayer_OnUsingControllerUpdate__DelegateSignature_Params params {};
		params.UsingController = UsingController;
		params.NewIconType = NewIconType;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> DelegateFunction Insurgency.INSLocalPlayer.OnUpdateProfileBlockLoadedDelegate__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 * Parameters:
	 * 		EProfileBlockType                                  Type                                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bFromCloud                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UINSLocalPlayer::OnUpdateProfileBlockLoadedDelegate__DelegateSignature(EProfileBlockType Type, bool bFromCloud)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction Insurgency.INSLocalPlayer.OnUpdateProfileBlockLoadedDelegate__DelegateSignature");
		
		UINSLocalPlayer_OnUpdateProfileBlockLoadedDelegate__DelegateSignature_Params params {};
		params.Type = Type;
		params.bFromCloud = bFromCloud;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05692290
	 * 		Name   -> Function Insurgency.INSLocalPlayer.OnTutorialComplete
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void UINSLocalPlayer::OnTutorialComplete()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSLocalPlayer.OnTutorialComplete");
		
		UINSLocalPlayer_OnTutorialComplete_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056921C0
	 * 		Name   -> Function Insurgency.INSLocalPlayer.OnTaglinesLoaded
	 * 		Flags  -> (Final, Native, Public, HasOutParms)
	 */
	void UINSLocalPlayer::OnTaglinesLoaded()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSLocalPlayer.OnTaglinesLoaded");
		
		UINSLocalPlayer_OnTaglinesLoaded_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> DelegateFunction Insurgency.INSLocalPlayer.OnRequestPlayerProfileUpdated__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 */
	void UINSLocalPlayer::OnRequestPlayerProfileUpdated__DelegateSignature()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction Insurgency.INSLocalPlayer.OnRequestPlayerProfileUpdated__DelegateSignature");
		
		UINSLocalPlayer_OnRequestPlayerProfileUpdated__DelegateSignature_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> DelegateFunction Insurgency.INSLocalPlayer.OnRequestPlayerGamesUpdated__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 */
	void UINSLocalPlayer::OnRequestPlayerGamesUpdated__DelegateSignature()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction Insurgency.INSLocalPlayer.OnRequestPlayerGamesUpdated__DelegateSignature");
		
		UINSLocalPlayer_OnRequestPlayerGamesUpdated__DelegateSignature_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> DelegateFunction Insurgency.INSLocalPlayer.OnQueryAchievementsComplete__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 */
	void UINSLocalPlayer::OnQueryAchievementsComplete__DelegateSignature()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction Insurgency.INSLocalPlayer.OnQueryAchievementsComplete__DelegateSignature");
		
		UINSLocalPlayer_OnQueryAchievementsComplete__DelegateSignature_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056920F0
	 * 		Name   -> Function Insurgency.INSLocalPlayer.OnProfileBlockLoaded
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		EProfileBlockType                                  Type                                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bFromCloud                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UINSLocalPlayer::OnProfileBlockLoaded(EProfileBlockType Type, bool bFromCloud)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSLocalPlayer.OnProfileBlockLoaded");
		
		UINSLocalPlayer_OnProfileBlockLoaded_Params params {};
		params.Type = Type;
		params.bFromCloud = bFromCloud;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> DelegateFunction Insurgency.INSLocalPlayer.OnPostMatchStatsUpdated__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 */
	void UINSLocalPlayer::OnPostMatchStatsUpdated__DelegateSignature()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction Insurgency.INSLocalPlayer.OnPostMatchStatsUpdated__DelegateSignature");
		
		UINSLocalPlayer_OnPostMatchStatsUpdated__DelegateSignature_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05691F50
	 * 		Name   -> Function Insurgency.INSLocalPlayer.OnPoolCountsUpdatedCallback
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		bool                                               bSuccess                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FQueryPoolCountResults                      Results                                                    (Parm, NativeAccessSpecifierPublic)
	 */
	void UINSLocalPlayer::OnPoolCountsUpdatedCallback(bool bSuccess, const struct FQueryPoolCountResults& Results)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSLocalPlayer.OnPoolCountsUpdatedCallback");
		
		UINSLocalPlayer_OnPoolCountsUpdatedCallback_Params params {};
		params.bSuccess = bSuccess;
		params.Results = Results;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> DelegateFunction Insurgency.INSLocalPlayer.OnPoolCountsUpdated__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate, HasOutParms)
	 * Parameters:
	 * 		struct FQueryPoolCountResults                      Counts                                                     (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UINSLocalPlayer::OnPoolCountsUpdated__DelegateSignature(const struct FQueryPoolCountResults& Counts)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction Insurgency.INSLocalPlayer.OnPoolCountsUpdated__DelegateSignature");
		
		UINSLocalPlayer_OnPoolCountsUpdated__DelegateSignature_Params params {};
		params.Counts = Counts;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> DelegateFunction Insurgency.INSLocalPlayer.OnPlayerRatingUpdated__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate, HasOutParms)
	 * Parameters:
	 * 		struct FCompetitiveRating                          Rating                                                     (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UINSLocalPlayer::OnPlayerRatingUpdated__DelegateSignature(const struct FCompetitiveRating& Rating)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction Insurgency.INSLocalPlayer.OnPlayerRatingUpdated__DelegateSignature");
		
		UINSLocalPlayer_OnPlayerRatingUpdated__DelegateSignature_Params params {};
		params.Rating = Rating;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> DelegateFunction Insurgency.INSLocalPlayer.OnPlayerProfileUpdated__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate, HasOutParms)
	 * Parameters:
	 * 		struct FSandstormPlayerProfile                     NewData                                                    (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UINSLocalPlayer::OnPlayerProfileUpdated__DelegateSignature(const struct FSandstormPlayerProfile& NewData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction Insurgency.INSLocalPlayer.OnPlayerProfileUpdated__DelegateSignature");
		
		UINSLocalPlayer_OnPlayerProfileUpdated__DelegateSignature_Params params {};
		params.NewData = NewData;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> DelegateFunction Insurgency.INSLocalPlayer.OnPlayerGearLevelChanged__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 * Parameters:
	 * 		class FName                                        ArmorLevel                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FName                                        CarrierLevel                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UINSLocalPlayer::OnPlayerGearLevelChanged__DelegateSignature(const class FName& ArmorLevel, const class FName& CarrierLevel)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction Insurgency.INSLocalPlayer.OnPlayerGearLevelChanged__DelegateSignature");
		
		UINSLocalPlayer_OnPlayerGearLevelChanged__DelegateSignature_Params params {};
		params.ArmorLevel = ArmorLevel;
		params.CarrierLevel = CarrierLevel;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> DelegateFunction Insurgency.INSLocalPlayer.OnPlayerAvatarLoaded__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 * Parameters:
	 * 		class UTexture2D*                                  Texture                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UINSLocalPlayer::OnPlayerAvatarLoaded__DelegateSignature(class UTexture2D* Texture)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction Insurgency.INSLocalPlayer.OnPlayerAvatarLoaded__DelegateSignature");
		
		UINSLocalPlayer_OnPlayerAvatarLoaded__DelegateSignature_Params params {};
		params.Texture = Texture;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> DelegateFunction Insurgency.INSLocalPlayer.OnMatchHistoryUpdated__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate, HasOutParms)
	 * Parameters:
	 * 		struct FMatchHistory                               NewHistory                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UINSLocalPlayer::OnMatchHistoryUpdated__DelegateSignature(const struct FMatchHistory& NewHistory)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction Insurgency.INSLocalPlayer.OnMatchHistoryUpdated__DelegateSignature");
		
		UINSLocalPlayer_OnMatchHistoryUpdated__DelegateSignature_Params params {};
		params.NewHistory = NewHistory;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> DelegateFunction Insurgency.INSLocalPlayer.OnLocalProfileLoaded__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 */
	void UINSLocalPlayer::OnLocalProfileLoaded__DelegateSignature()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction Insurgency.INSLocalPlayer.OnLocalProfileLoaded__DelegateSignature");
		
		UINSLocalPlayer_OnLocalProfileLoaded__DelegateSignature_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05691ED0
	 * 		Name   -> Function Insurgency.INSLocalPlayer.OnExperienceUpdated
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		int64_t                                            NewExperience                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UINSLocalPlayer::OnExperienceUpdated(int64_t NewExperience)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSLocalPlayer.OnExperienceUpdated");
		
		UINSLocalPlayer_OnExperienceUpdated_Params params {};
		params.NewExperience = NewExperience;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> DelegateFunction Insurgency.INSLocalPlayer.OnAccountStatusUpdatedDelegate__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate, HasOutParms)
	 * Parameters:
	 * 		struct FGetAccountStatusResult                     Status                                                     (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UINSLocalPlayer::OnAccountStatusUpdatedDelegate__DelegateSignature(const struct FGetAccountStatusResult& Status)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction Insurgency.INSLocalPlayer.OnAccountStatusUpdatedDelegate__DelegateSignature");
		
		UINSLocalPlayer_OnAccountStatusUpdatedDelegate__DelegateSignature_Params params {};
		params.Status = Status;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> DelegateFunction Insurgency.INSLocalPlayer.OnAbandonedMatchUpdate__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 */
	void UINSLocalPlayer::OnAbandonedMatchUpdate__DelegateSignature()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction Insurgency.INSLocalPlayer.OnAbandonedMatchUpdate__DelegateSignature");
		
		UINSLocalPlayer_OnAbandonedMatchUpdate__DelegateSignature_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05691EB0
	 * 		Name   -> Function Insurgency.INSLocalPlayer.LoadPlayerAvatar
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void UINSLocalPlayer::LoadPlayerAvatar()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSLocalPlayer.LoadPlayerAvatar");
		
		UINSLocalPlayer_LoadPlayerAvatar_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05691E80
	 * 		Name   -> Function Insurgency.INSLocalPlayer.IsChatRestricted
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool UINSLocalPlayer::IsChatRestricted()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSLocalPlayer.IsChatRestricted");
		
		UINSLocalPlayer_IsChatRestricted_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05691D90
	 * 		Name   -> Function Insurgency.INSLocalPlayer.HasAbandonedMatchInPool
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		class FString                                      PoolName                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UINSLocalPlayer::HasAbandonedMatchInPool(const class FString& PoolName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSLocalPlayer.HasAbandonedMatchInPool");
		
		UINSLocalPlayer_HasAbandonedMatchInPool_Params params {};
		params.PoolName = PoolName;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05691C80
	 * 		Name   -> Function Insurgency.INSLocalPlayer.GetVoiceInputDevices
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		TArray<struct FVoiceChatAvailableDevice>           OutInputDevices                                            (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UINSLocalPlayer::GetVoiceInputDevices(TArray<struct FVoiceChatAvailableDevice>* OutInputDevices)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSLocalPlayer.GetVoiceInputDevices");
		
		UINSLocalPlayer_GetVoiceInputDevices_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutInputDevices != nullptr)
			*OutInputDevices = params.OutInputDevices;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05691B50
	 * 		Name   -> Function Insurgency.INSLocalPlayer.GetTaglinesCount
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		TMap<class FString, int32_t>                       TaglineCountMap                                            (Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UINSLocalPlayer::GetTaglinesCount(TMap<class FString, int32_t>* TaglineCountMap)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSLocalPlayer.GetTaglinesCount");
		
		UINSLocalPlayer_GetTaglinesCount_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (TaglineCountMap != nullptr)
			*TaglineCountMap = params.TaglineCountMap;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05691A60
	 * 		Name   -> Function Insurgency.INSLocalPlayer.GetTaglineClassPtr
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		class FString                                      ClassName                                                  (Parm, OutParm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UINSLocalPlayer::GetTaglineClassPtr(class FString* ClassName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSLocalPlayer.GetTaglineClassPtr");
		
		UINSLocalPlayer_GetTaglineClassPtr_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (ClassName != nullptr)
			*ClassName = params.ClassName;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05691A30
	 * 		Name   -> Function Insurgency.INSLocalPlayer.GetPlayerProfile
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	class UStatisticsProfile* UINSLocalPlayer::GetPlayerProfile()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSLocalPlayer.GetPlayerProfile");
		
		UINSLocalPlayer_GetPlayerProfile_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05691A00
	 * 		Name   -> Function Insurgency.INSLocalPlayer.GetLocalProfile
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	class UINSPlayerLocalProfile* UINSLocalPlayer::GetLocalProfile()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSLocalPlayer.GetLocalProfile");
		
		UINSLocalPlayer_GetLocalProfile_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056919D0
	 * 		Name   -> Function Insurgency.INSLocalPlayer.GetEntitledScoreboardBadgeIndex
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	int32_t UINSLocalPlayer::GetEntitledScoreboardBadgeIndex()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSLocalPlayer.GetEntitledScoreboardBadgeIndex");
		
		UINSLocalPlayer_GetEntitledScoreboardBadgeIndex_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056919A0
	 * 		Name   -> Function Insurgency.INSLocalPlayer.GetControllerIconType
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	EeInputIconType UINSLocalPlayer::GetControllerIconType()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSLocalPlayer.GetControllerIconType");
		
		UINSLocalPlayer_GetControllerIconType_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056918C0
	 * 		Name   -> Function Insurgency.INSLocalPlayer.GetAchievementsCount
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		int32_t                                            AchievementsAchieved                                       (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            AchievementsTotal                                          (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UINSLocalPlayer::GetAchievementsCount(int32_t* AchievementsAchieved, int32_t* AchievementsTotal)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSLocalPlayer.GetAchievementsCount");
		
		UINSLocalPlayer_GetAchievementsCount_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (AchievementsAchieved != nullptr)
			*AchievementsAchieved = params.AchievementsAchieved;
		if (AchievementsTotal != nullptr)
			*AchievementsTotal = params.AchievementsTotal;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056917D0
	 * 		Name   -> Function Insurgency.INSLocalPlayer.CreateCustomGame
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bLocal                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FString                                      Scenario                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UINSLocalPlayer::CreateCustomGame(bool bLocal, const class FString& Scenario)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSLocalPlayer.CreateCustomGame");
		
		UINSLocalPlayer_CreateCustomGame_Params params {};
		params.bLocal = bLocal;
		params.Scenario = Scenario;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056917B0
	 * 		Name   -> Function Insurgency.INSLocalPlayer.BroadcastKeyIconUpdate
	 * 		Flags  -> (Final, Native, Public)
	 */
	void UINSLocalPlayer::BroadcastKeyIconUpdate()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSLocalPlayer.BroadcastKeyIconUpdate");
		
		UINSLocalPlayer_BroadcastKeyIconUpdate_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UINSLocalPlayer.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UINSLocalPlayer::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.INSLocalPlayer");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x04DB4060
	 * 		Name   -> Function Insurgency.INSMatchBeaconClient.ClientAllowedToProceedFromReservationTimeout
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetClient)
	 */
	void AINSMatchBeaconClient::ClientAllowedToProceedFromReservationTimeout()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSMatchBeaconClient.ClientAllowedToProceedFromReservationTimeout");
		
		AINSMatchBeaconClient_ClientAllowedToProceedFromReservationTimeout_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x04DB40E0
	 * 		Name   -> Function Insurgency.INSMatchBeaconClient.ClientAllowedToProceedFromReservation
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetClient)
	 */
	void AINSMatchBeaconClient::ClientAllowedToProceedFromReservation()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSMatchBeaconClient.ClientAllowedToProceedFromReservation");
		
		AINSMatchBeaconClient_ClientAllowedToProceedFromReservation_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AINSMatchBeaconClient.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AINSMatchBeaconClient::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.INSMatchBeaconClient");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AINSMatchBeaconHost.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AINSMatchBeaconHost::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.INSMatchBeaconHost");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UINSMatchBeaconState.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UINSMatchBeaconState::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.INSMatchBeaconState");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> DelegateFunction Insurgency.INSMatchmaking.OnMatchmakerSuccess__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 */
	void UINSMatchmaking::OnMatchmakerSuccess__DelegateSignature()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction Insurgency.INSMatchmaking.OnMatchmakerSuccess__DelegateSignature");
		
		UINSMatchmaking_OnMatchmakerSuccess__DelegateSignature_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> DelegateFunction Insurgency.INSMatchmaking.OnMatchmakerStateChange__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 * Parameters:
	 * 		EMatchmakingState                                  OldState                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EMatchmakingState                                  NewState                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UINSMatchmaking::OnMatchmakerStateChange__DelegateSignature(EMatchmakingState OldState, EMatchmakingState NewState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction Insurgency.INSMatchmaking.OnMatchmakerStateChange__DelegateSignature");
		
		UINSMatchmaking_OnMatchmakerStateChange__DelegateSignature_Params params {};
		params.OldState = OldState;
		params.NewState = NewState;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> DelegateFunction Insurgency.INSMatchmaking.OnMatchmakerFailure__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 * Parameters:
	 * 		EMatchmakingFailure                                Error                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UINSMatchmaking::OnMatchmakerFailure__DelegateSignature(EMatchmakingFailure Error)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction Insurgency.INSMatchmaking.OnMatchmakerFailure__DelegateSignature");
		
		UINSMatchmaking_OnMatchmakerFailure__DelegateSignature_Params params {};
		params.Error = Error;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056932F0
	 * 		Name   -> Function Insurgency.INSMatchmaking.IsMatchmakingLateJoin
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool UINSMatchmaking::IsMatchmakingLateJoin()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSMatchmaking.IsMatchmakingLateJoin");
		
		UINSMatchmaking_IsMatchmakingLateJoin_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UINSMatchmaking.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UINSMatchmaking::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.INSMatchmaking");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AINSMatchmakingServerMode.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AINSMatchmakingServerMode::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.INSMatchmakingServerMode");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AINSMultiplayerTestGameMode.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AINSMultiplayerTestGameMode::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.INSMultiplayerTestGameMode");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05697F10
	 * 		Name   -> Function Insurgency.INSOccupyGameMode.ShouldDeductReinforcementWave
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		class UReinforcementSystemComponent*               ReinforcementSystemComponent                               (ConstParm, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool AINSOccupyGameMode::ShouldDeductReinforcementWave(class UReinforcementSystemComponent* ReinforcementSystemComponent)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSOccupyGameMode.ShouldDeductReinforcementWave");
		
		AINSOccupyGameMode_ShouldDeductReinforcementWave_Params params {};
		params.ReinforcementSystemComponent = ReinforcementSystemComponent;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AINSOccupyGameMode.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AINSOccupyGameMode::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.INSOccupyGameMode");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05698170
	 * 		Name   -> Function Insurgency.INSOperationGameMode.SpawnPlayerTeam
	 * 		Flags  -> (Final, Native, Public)
	 */
	void AINSOperationGameMode::SpawnPlayerTeam()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSOperationGameMode.SpawnPlayerTeam");
		
		AINSOperationGameMode_SpawnPlayerTeam_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05698150
	 * 		Name   -> Function Insurgency.INSOperationGameMode.EvacSuccessful
	 * 		Flags  -> (Final, Native, Public)
	 */
	void AINSOperationGameMode::EvacSuccessful()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSOperationGameMode.EvacSuccessful");
		
		AINSOperationGameMode_EvacSuccessful_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AINSOperationGameMode.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AINSOperationGameMode::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.INSOperationGameMode");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UOutpostWaveConfig.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UOutpostWaveConfig::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.OutpostWaveConfig");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05699000
	 * 		Name   -> Function Insurgency.INSOutpostGameMode.IsFinalWave
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AINSOutpostGameMode::IsFinalWave()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSOutpostGameMode.IsFinalWave");
		
		AINSOutpostGameMode_IsFinalWave_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05698FD0
	 * 		Name   -> Function Insurgency.INSOutpostGameMode.GetRemainingWaves
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	int32_t AINSOutpostGameMode::GetRemainingWaves()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSOutpostGameMode.GetRemainingWaves");
		
		AINSOutpostGameMode_GetRemainingWaves_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05698FB0
	 * 		Name   -> Function Insurgency.INSOutpostGameMode.ForceRetreat
	 * 		Flags  -> (Final, Native, Private)
	 */
	void AINSOutpostGameMode::ForceRetreat()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSOutpostGameMode.ForceRetreat");
		
		AINSOutpostGameMode_ForceRetreat_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AINSOutpostGameMode.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AINSOutpostGameMode::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.INSOutpostGameMode");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05699660
	 * 		Name   -> Function Insurgency.INSOutpostGameState.SetCurrentWave
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		int32_t                                            NewCurrentWave                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSOutpostGameState::SetCurrentWave(int32_t NewCurrentWave)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSOutpostGameState.SetCurrentWave");
		
		AINSOutpostGameState_SetCurrentWave_Params params {};
		params.NewCurrentWave = NewCurrentWave;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05699640
	 * 		Name   -> Function Insurgency.INSOutpostGameState.OnRep_TotalWaves
	 * 		Flags  -> (Final, Native, Private)
	 */
	void AINSOutpostGameState::OnRep_TotalWaves()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSOutpostGameState.OnRep_TotalWaves");
		
		AINSOutpostGameState_OnRep_TotalWaves_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05699620
	 * 		Name   -> Function Insurgency.INSOutpostGameState.OnRep_CurrentWave
	 * 		Flags  -> (Final, Native, Private)
	 */
	void AINSOutpostGameState::OnRep_CurrentWave()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSOutpostGameState.OnRep_CurrentWave");
		
		AINSOutpostGameState_OnRep_CurrentWave_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> DelegateFunction Insurgency.INSOutpostGameState.OnOutpostWaveChangedDelegate__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 * Parameters:
	 * 		int32_t                                            NewWave                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSOutpostGameState::OnOutpostWaveChangedDelegate__DelegateSignature(int32_t NewWave)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction Insurgency.INSOutpostGameState.OnOutpostWaveChangedDelegate__DelegateSignature");
		
		AINSOutpostGameState_OnOutpostWaveChangedDelegate__DelegateSignature_Params params {};
		params.NewWave = NewWave;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> DelegateFunction Insurgency.INSOutpostGameState.OnOutpostPrepareNextWaveDelegate__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 */
	void AINSOutpostGameState::OnOutpostPrepareNextWaveDelegate__DelegateSignature()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction Insurgency.INSOutpostGameState.OnOutpostPrepareNextWaveDelegate__DelegateSignature");
		
		AINSOutpostGameState_OnOutpostPrepareNextWaveDelegate__DelegateSignature_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> DelegateFunction Insurgency.INSOutpostGameState.OnOutpostLostObjectiveDelegate__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 */
	void AINSOutpostGameState::OnOutpostLostObjectiveDelegate__DelegateSignature()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction Insurgency.INSOutpostGameState.OnOutpostLostObjectiveDelegate__DelegateSignature");
		
		AINSOutpostGameState_OnOutpostLostObjectiveDelegate__DelegateSignature_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> DelegateFunction Insurgency.INSOutpostGameState.OnOutpostIncomingWaveDelegate__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 * Parameters:
	 * 		EOutpostWaveType                                   WaveType                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSOutpostGameState::OnOutpostIncomingWaveDelegate__DelegateSignature(EOutpostWaveType WaveType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction Insurgency.INSOutpostGameState.OnOutpostIncomingWaveDelegate__DelegateSignature");
		
		AINSOutpostGameState_OnOutpostIncomingWaveDelegate__DelegateSignature_Params params {};
		params.WaveType = WaveType;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x04DB3AE0
	 * 		Name   -> Function Insurgency.INSOutpostGameState.Multicast_OutpostPrepareNextWaveEvent
	 * 		Flags  -> (Net, NetReliable, Native, Event, NetMulticast, Public)
	 */
	void AINSOutpostGameState::Multicast_OutpostPrepareNextWaveEvent()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSOutpostGameState.Multicast_OutpostPrepareNextWaveEvent");
		
		AINSOutpostGameState_Multicast_OutpostPrepareNextWaveEvent_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x04DB3C40
	 * 		Name   -> Function Insurgency.INSOutpostGameState.Multicast_OutpostLostObjectiveEvent
	 * 		Flags  -> (Net, NetReliable, Native, Event, NetMulticast, Public)
	 */
	void AINSOutpostGameState::Multicast_OutpostLostObjectiveEvent()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSOutpostGameState.Multicast_OutpostLostObjectiveEvent");
		
		AINSOutpostGameState_Multicast_OutpostLostObjectiveEvent_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056995A0
	 * 		Name   -> Function Insurgency.INSOutpostGameState.Multicast_OutpostIncomingWaveEvent
	 * 		Flags  -> (Net, NetReliable, Native, Event, NetMulticast, Public)
	 * Parameters:
	 * 		EOutpostWaveType                                   NewCurrentWaveType                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSOutpostGameState::Multicast_OutpostIncomingWaveEvent(EOutpostWaveType NewCurrentWaveType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSOutpostGameState.Multicast_OutpostIncomingWaveEvent");
		
		AINSOutpostGameState_Multicast_OutpostIncomingWaveEvent_Params params {};
		params.NewCurrentWaveType = NewCurrentWaveType;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AINSOutpostGameState.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AINSOutpostGameState::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.INSOutpostGameState");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0569A8A0
	 * 		Name   -> Function Insurgency.INSParty.UpdatePendingInvites
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void UINSParty::UpdatePendingInvites()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSParty.UpdatePendingInvites");
		
		UINSParty_UpdatePendingInvites_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0569A880
	 * 		Name   -> Function Insurgency.INSParty.UpdateFriendsList
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void UINSParty::UpdateFriendsList()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSParty.UpdateFriendsList");
		
		UINSParty_UpdateFriendsList_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0569A860
	 * 		Name   -> Function Insurgency.INSParty.StartLateJoinQueue
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void UINSParty::StartLateJoinQueue()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSParty.StartLateJoinQueue");
		
		UINSParty_StartLateJoinQueue_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0569A780
	 * 		Name   -> Function Insurgency.INSParty.PromoteToPartyLeader
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class FString                                      PlatformId                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UINSParty::PromoteToPartyLeader(const class FString& PlatformId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSParty.PromoteToPartyLeader");
		
		UINSParty_PromoteToPartyLeader_Params params {};
		params.PlatformId = PlatformId;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0569A700
	 * 		Name   -> Function Insurgency.INSParty.OpenInviteInterface
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class FName                                        InService                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UINSParty::OpenInviteInterface(const class FName& InService)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSParty.OpenInviteInterface");
		
		UINSParty_OpenInviteInterface_Params params {};
		params.InService = InService;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0569A6E0
	 * 		Name   -> Function Insurgency.INSParty.LeaveParty
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void UINSParty::LeaveParty()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSParty.LeaveParty");
		
		UINSParty_LeaveParty_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0569A600
	 * 		Name   -> Function Insurgency.INSParty.KickMember
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class FString                                      PlatformId                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UINSParty::KickMember(const class FString& PlatformId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSParty.KickMember");
		
		UINSParty_KickMember_Params params {};
		params.PlatformId = PlatformId;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0569A510
	 * 		Name   -> Function Insurgency.INSParty.IsUserInParty
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class FString                                      UserId                                                     (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UINSParty::IsUserInParty(const class FString& UserId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSParty.IsUserInParty");
		
		UINSParty_IsUserInParty_Params params {};
		params.UserId = UserId;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0569A4E0
	 * 		Name   -> Function Insurgency.INSParty.IsPartyInGame
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool UINSParty::IsPartyInGame()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSParty.IsPartyInGame");
		
		UINSParty_IsPartyInGame_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0569A4B0
	 * 		Name   -> Function Insurgency.INSParty.IsLocalPlayerLeader
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool UINSParty::IsLocalPlayerLeader()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSParty.IsLocalPlayerLeader");
		
		UINSParty_IsLocalPlayerLeader_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0569A480
	 * 		Name   -> Function Insurgency.INSParty.IsLateJoinPossible
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool UINSParty::IsLateJoinPossible()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSParty.IsLateJoinPossible");
		
		UINSParty_IsLateJoinPossible_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0569A450
	 * 		Name   -> Function Insurgency.INSParty.IsInParty
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool UINSParty::IsInParty()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSParty.IsInParty");
		
		UINSParty_IsInParty_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> DelegateFunction Insurgency.INSParty.INSPartyStateUpdate__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate, HasOutParms)
	 * Parameters:
	 * 		struct FINSPartyState                              State                                                      (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		struct FPartySettings                              Settings                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UINSParty::INSPartyStateUpdate__DelegateSignature(const struct FINSPartyState& State, const struct FPartySettings& Settings)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction Insurgency.INSParty.INSPartyStateUpdate__DelegateSignature");
		
		UINSParty_INSPartyStateUpdate__DelegateSignature_Params params {};
		params.State = State;
		params.Settings = Settings;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> DelegateFunction Insurgency.INSParty.INSPartyPlatformSessionStarted__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 */
	void UINSParty::INSPartyPlatformSessionStarted__DelegateSignature()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction Insurgency.INSParty.INSPartyPlatformSessionStarted__DelegateSignature");
		
		UINSParty_INSPartyPlatformSessionStarted__DelegateSignature_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> DelegateFunction Insurgency.INSParty.INSPartyMemberPromoted__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 */
	void UINSParty::INSPartyMemberPromoted__DelegateSignature()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction Insurgency.INSParty.INSPartyMemberPromoted__DelegateSignature");
		
		UINSParty_INSPartyMemberPromoted__DelegateSignature_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> DelegateFunction Insurgency.INSParty.INSPartyLeft__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 */
	void UINSParty::INSPartyLeft__DelegateSignature()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction Insurgency.INSParty.INSPartyLeft__DelegateSignature");
		
		UINSParty_INSPartyLeft__DelegateSignature_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> DelegateFunction Insurgency.INSParty.INSPartyJoined__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate, HasOutParms)
	 * Parameters:
	 * 		struct FINSPartyState                              State                                                      (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UINSParty::INSPartyJoined__DelegateSignature(const struct FINSPartyState& State)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction Insurgency.INSParty.INSPartyJoined__DelegateSignature");
		
		UINSParty_INSPartyJoined__DelegateSignature_Params params {};
		params.State = State;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> DelegateFunction Insurgency.INSParty.INSPartyFriendsUpdated__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate, HasOutParms)
	 * Parameters:
	 * 		TArray<class FString>                              FriendsNetId                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UINSParty::INSPartyFriendsUpdated__DelegateSignature(TArray<class FString> FriendsNetId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction Insurgency.INSParty.INSPartyFriendsUpdated__DelegateSignature");
		
		UINSParty_INSPartyFriendsUpdated__DelegateSignature_Params params {};
		params.FriendsNetId = FriendsNetId;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0569A320
	 * 		Name   -> Function Insurgency.INSParty.GetFriendNameById
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class FString                                      FriendNetId                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class FString UINSParty::GetFriendNameById(const class FString& FriendNetId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSParty.GetFriendNameById");
		
		UINSParty_GetFriendNameById_Params params {};
		params.FriendNetId = FriendNetId;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0569A260
	 * 		Name   -> Function Insurgency.INSParty.Delegate_OnMatchmakerStateChange
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		EMatchmakingState                                  OldState                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EMatchmakingState                                  NewState                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UINSParty::Delegate_OnMatchmakerStateChange(EMatchmakingState OldState, EMatchmakingState NewState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSParty.Delegate_OnMatchmakerStateChange");
		
		UINSParty_Delegate_OnMatchmakerStateChange_Params params {};
		params.OldState = OldState;
		params.NewState = NewState;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0569A1E0
	 * 		Name   -> Function Insurgency.INSParty.CreateParty
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class FName                                        InService                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UINSParty::CreateParty(const class FName& InService)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSParty.CreateParty");
		
		UINSParty_CreateParty_Params params {};
		params.InService = InService;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UINSParty.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UINSParty::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.INSParty");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AINSPatrolArea.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AINSPatrolArea::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.INSPatrolArea");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UINSPawnSensingComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UINSPawnSensingComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.INSPawnSensingComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0569AE40
	 * 		Name   -> Function Insurgency.INSPlayerCameraManager.UpdateDefaultFOV
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void AINSPlayerCameraManager::UpdateDefaultFOV()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerCameraManager.UpdateDefaultFOV");
		
		AINSPlayerCameraManager_UpdateDefaultFOV_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0569AD80
	 * 		Name   -> Function Insurgency.INSPlayerCameraManager.OnOwnerChangeTeam
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		unsigned char                                      TeamId                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class ATeamInfo*                                   TeamInfo                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSPlayerCameraManager::OnOwnerChangeTeam(unsigned char TeamId, class ATeamInfo* TeamInfo)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerCameraManager.OnOwnerChangeTeam");
		
		AINSPlayerCameraManager_OnOwnerChangeTeam_Params params {};
		params.TeamId = TeamId;
		params.TeamInfo = TeamInfo;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0569AD50
	 * 		Name   -> Function Insurgency.INSPlayerCameraManager.IsFirstPersonCamera
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AINSPlayerCameraManager::IsFirstPersonCamera()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerCameraManager.IsFirstPersonCamera");
		
		AINSPlayerCameraManager_IsFirstPersonCamera_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AINSPlayerCameraManager.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AINSPlayerCameraManager::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.INSPlayerCameraManager");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056A3D30
	 * 		Name   -> Function Insurgency.INSPlayerController.UpdateVoiceChatChannels
	 * 		Flags  -> (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
	 */
	void AINSPlayerController::UpdateVoiceChatChannels()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerController.UpdateVoiceChatChannels");
		
		AINSPlayerController_UpdateVoiceChatChannels_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056A4790
	 * 		Name   -> Function Insurgency.INSPlayerController.UpdatePointShootPreference
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               Mode                                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSPlayerController::UpdatePointShootPreference(bool Mode)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerController.UpdatePointShootPreference");
		
		AINSPlayerController_UpdatePointShootPreference_Params params {};
		params.Mode = Mode;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> DelegateFunction Insurgency.INSPlayerController.UpdatePointShootDelegate__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 * Parameters:
	 * 		bool                                               Mode                                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSPlayerController::UpdatePointShootDelegate__DelegateSignature(bool Mode)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction Insurgency.INSPlayerController.UpdatePointShootDelegate__DelegateSignature");
		
		AINSPlayerController_UpdatePointShootDelegate__DelegateSignature_Params params {};
		params.Mode = Mode;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056A4650
	 * 		Name   -> Function Insurgency.INSPlayerController.UpdateOpticPreference
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		int32_t                                            Mode                                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSPlayerController::UpdateOpticPreference(int32_t Mode)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerController.UpdateOpticPreference");
		
		AINSPlayerController_UpdateOpticPreference_Params params {};
		params.Mode = Mode;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> DelegateFunction Insurgency.INSPlayerController.UpdateOpticDelegate__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 * Parameters:
	 * 		int32_t                                            Mode                                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSPlayerController::UpdateOpticDelegate__DelegateSignature(int32_t Mode)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction Insurgency.INSPlayerController.UpdateOpticDelegate__DelegateSignature");
		
		AINSPlayerController_UpdateOpticDelegate__DelegateSignature_Params params {};
		params.Mode = Mode;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056A4510
	 * 		Name   -> Function Insurgency.INSPlayerController.UpdateFiremodePreference
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		EFirearmFiremode                                   Firemode                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSPlayerController::UpdateFiremodePreference(EFirearmFiremode Firemode)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerController.UpdateFiremodePreference");
		
		AINSPlayerController_UpdateFiremodePreference_Params params {};
		params.Firemode = Firemode;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> DelegateFunction Insurgency.INSPlayerController.UpdateFiremodeDelegate__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 * Parameters:
	 * 		EFirearmFiremode                                   Firemode                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSPlayerController::UpdateFiremodeDelegate__DelegateSignature(EFirearmFiremode Firemode)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction Insurgency.INSPlayerController.UpdateFiremodeDelegate__DelegateSignature");
		
		AINSPlayerController_UpdateFiremodeDelegate__DelegateSignature_Params params {};
		params.Firemode = Firemode;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056A44F0
	 * 		Name   -> Function Insurgency.INSPlayerController.ToggleLoadoutMenu
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void AINSPlayerController::ToggleLoadoutMenu()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerController.ToggleLoadoutMenu");
		
		AINSPlayerController_ToggleLoadoutMenu_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056A4470
	 * 		Name   -> Function Insurgency.INSPlayerController.ToggleInGameMenu
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		EIngameMenuType                                    Menu                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSPlayerController::ToggleInGameMenu(EIngameMenuType Menu)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerController.ToggleInGameMenu");
		
		AINSPlayerController_ToggleInGameMenu_Params params {};
		params.Menu = Menu;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056A43E0
	 * 		Name   -> Function Insurgency.INSPlayerController.StopShellShock
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bTerminate                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSPlayerController::StopShellShock(bool bTerminate)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerController.StopShellShock");
		
		AINSPlayerController_StopShellShock_Params params {};
		params.bTerminate = bTerminate;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056A4350
	 * 		Name   -> Function Insurgency.INSPlayerController.StopDeafen
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bTerminate                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSPlayerController::StopDeafen(bool bTerminate)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerController.StopDeafen");
		
		AINSPlayerController_StopDeafen_Params params {};
		params.bTerminate = bTerminate;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056A4330
	 * 		Name   -> Function Insurgency.INSPlayerController.SpotEnemy
	 * 		Flags  -> (Final, Native, Public)
	 */
	void AINSPlayerController::SpotEnemy()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerController.SpotEnemy");
		
		AINSPlayerController_SpotEnemy_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056A42B0
	 * 		Name   -> Function Insurgency.INSPlayerController.SpectatePlayer
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class AActor*                                      Actor                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSPlayerController::SpectatePlayer(class AActor* Actor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerController.SpectatePlayer");
		
		AINSPlayerController_SpectatePlayer_Params params {};
		params.Actor = Actor;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056A4230
	 * 		Name   -> Function Insurgency.INSPlayerController.ShowRangeComputerMenu
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UUserWidget*                                 RangeWidget                                                (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSPlayerController::ShowRangeComputerMenu(class UUserWidget* RangeWidget)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerController.ShowRangeComputerMenu");
		
		AINSPlayerController_ShowRangeComputerMenu_Params params {};
		params.RangeWidget = RangeWidget;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> DelegateFunction Insurgency.INSPlayerController.ShowPlayerExperienceDelegate__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 */
	void AINSPlayerController::ShowPlayerExperienceDelegate__DelegateSignature()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction Insurgency.INSPlayerController.ShowPlayerExperienceDelegate__DelegateSignature");
		
		AINSPlayerController_ShowPlayerExperienceDelegate__DelegateSignature_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> DelegateFunction Insurgency.INSPlayerController.ShowKillerInfoDelegate__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate, HasOutParms)
	 * Parameters:
	 * 		struct FPlayerKillNotice                           Notice                                                     (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 * 		struct FNemesisStats                               NemesisStats                                               (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void AINSPlayerController::ShowKillerInfoDelegate__DelegateSignature(const struct FPlayerKillNotice& Notice, const struct FNemesisStats& NemesisStats)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction Insurgency.INSPlayerController.ShowKillerInfoDelegate__DelegateSignature");
		
		AINSPlayerController_ShowKillerInfoDelegate__DelegateSignature_Params params {};
		params.Notice = Notice;
		params.NemesisStats = NemesisStats;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056A4170
	 * 		Name   -> Function Insurgency.INSPlayerController.ShowInGameMenu
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		EIngameMenuType                                    Menu                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EIngameMenuEntryState                              FromState                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSPlayerController::ShowInGameMenu(EIngameMenuType Menu, EIngameMenuEntryState FromState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerController.ShowInGameMenu");
		
		AINSPlayerController_ShowInGameMenu_Params params {};
		params.Menu = Menu;
		params.FromState = FromState;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056A40A0
	 * 		Name   -> Function Insurgency.INSPlayerController.ShowGenericWidget
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UClass*                                      NewWidget                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bConsumesInput                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UUserWidget* AINSPlayerController::ShowGenericWidget(class UClass* NewWidget, bool bConsumesInput)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerController.ShowGenericWidget");
		
		AINSPlayerController_ShowGenericWidget_Params params {};
		params.NewWidget = NewWidget;
		params.bConsumesInput = bConsumesInput;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056A4080
	 * 		Name   -> Function Insurgency.INSPlayerController.ShowFireSupportMenu
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void AINSPlayerController::ShowFireSupportMenu()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerController.ShowFireSupportMenu");
		
		AINSPlayerController_ShowFireSupportMenu_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056A4000
	 * 		Name   -> Function Insurgency.INSPlayerController.ShowCustomRadial
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UUserWidget*                                 CustomRadialWidget                                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSPlayerController::ShowCustomRadial(class UUserWidget* CustomRadialWidget)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerController.ShowCustomRadial");
		
		AINSPlayerController_ShowCustomRadial_Params params {};
		params.CustomRadialWidget = CustomRadialWidget;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056A3FE0
	 * 		Name   -> Function Insurgency.INSPlayerController.ShowCommsMenu
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void AINSPlayerController::ShowCommsMenu()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerController.ShowCommsMenu");
		
		AINSPlayerController_ShowCommsMenu_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> DelegateFunction Insurgency.INSPlayerController.ShowAmmoDisplayDelegate__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 */
	void AINSPlayerController::ShowAmmoDisplayDelegate__DelegateSignature()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction Insurgency.INSPlayerController.ShowAmmoDisplayDelegate__DelegateSignature");
		
		AINSPlayerController_ShowAmmoDisplayDelegate__DelegateSignature_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056A3FC0
	 * 		Name   -> Function Insurgency.INSPlayerController.ShowAmmoDisplay
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void AINSPlayerController::ShowAmmoDisplay()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerController.ShowAmmoDisplay");
		
		AINSPlayerController_ShowAmmoDisplay_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056A3F30
	 * 		Name   -> Function Insurgency.INSPlayerController.SetVotedForKick
	 * 		Flags  -> (Final, Exec, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               SetVotedForKick                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSPlayerController::SetVotedForKick(bool SetVotedForKick)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerController.SetVotedForKick");
		
		AINSPlayerController_SetVotedForKick_Params params {};
		params.SetVotedForKick = SetVotedForKick;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056A3EB0
	 * 		Name   -> Function Insurgency.INSPlayerController.SetSelectedFireSupport
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UFireSupportDefinition*                      FireSupportClass                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSPlayerController::SetSelectedFireSupport(class UFireSupportDefinition* FireSupportClass)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerController.SetSelectedFireSupport");
		
		AINSPlayerController_SetSelectedFireSupport_Params params {};
		params.FireSupportClass = FireSupportClass;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056A3E20
	 * 		Name   -> Function Insurgency.INSPlayerController.SetLeaveGameMenuState
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bIsLeaveMenuOpenedParam                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSPlayerController::SetLeaveGameMenuState(bool bIsLeaveMenuOpenedParam)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerController.SetLeaveGameMenuState");
		
		AINSPlayerController_SetLeaveGameMenuState_Params params {};
		params.bIsLeaveMenuOpenedParam = bIsLeaveMenuOpenedParam;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056A3D50
	 * 		Name   -> Function Insurgency.INSPlayerController.SetCameraForUI
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, Const)
	 * Parameters:
	 * 		bool                                               SoldierCamera                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              TransitionTime                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSPlayerController::SetCameraForUI(bool SoldierCamera, float TransitionTime)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerController.SetCameraForUI");
		
		AINSPlayerController_SetCameraForUI_Params params {};
		params.SoldierCamera = SoldierCamera;
		params.TransitionTime = TransitionTime;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056A3D30
	 * 		Name   -> Function Insurgency.INSPlayerController.ServerVoiceChatLoggedIn
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetServer)
	 */
	void AINSPlayerController::ServerVoiceChatLoggedIn()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerController.ServerVoiceChatLoggedIn");
		
		AINSPlayerController_ServerVoiceChatLoggedIn_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056A3C80
	 * 		Name   -> Function Insurgency.INSPlayerController.ServerUpdateShowDevTag
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetServer, BlueprintCallable, NetValidate)
	 * Parameters:
	 * 		bool                                               bNewShowDevTag                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSPlayerController::ServerUpdateShowDevTag(bool bNewShowDevTag)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerController.ServerUpdateShowDevTag");
		
		AINSPlayerController_ServerUpdateShowDevTag_Params params {};
		params.bNewShowDevTag = bNewShowDevTag;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056A3C00
	 * 		Name   -> Function Insurgency.INSPlayerController.ServerUpdateScoreboardBadge
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetServer, BlueprintCallable)
	 * Parameters:
	 * 		int32_t                                            NewScoreboardBadge                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSPlayerController::ServerUpdateScoreboardBadge(int32_t NewScoreboardBadge)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerController.ServerUpdateScoreboardBadge");
		
		AINSPlayerController_ServerUpdateScoreboardBadge_Params params {};
		params.NewScoreboardBadge = NewScoreboardBadge;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056A3AF0
	 * 		Name   -> Function Insurgency.INSPlayerController.ServerUpdateFactionCosmetics
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetServer, BlueprintCallable, NetValidate)
	 * Parameters:
	 * 		class FString                                      FactionName                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		TArray<int32_t>                                    Cosmetics                                                  (ConstParm, Parm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSPlayerController::ServerUpdateFactionCosmetics(const class FString& FactionName, TArray<int32_t> Cosmetics)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerController.ServerUpdateFactionCosmetics");
		
		AINSPlayerController_ServerUpdateFactionCosmetics_Params params {};
		params.FactionName = FactionName;
		params.Cosmetics = Cosmetics;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056A3A60
	 * 		Name   -> Function Insurgency.INSPlayerController.ServerUpdateAllowVIP
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetServer)
	 * Parameters:
	 * 		bool                                               bNewAllowVIP                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSPlayerController::ServerUpdateAllowVIP(bool bNewAllowVIP)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerController.ServerUpdateAllowVIP");
		
		AINSPlayerController_ServerUpdateAllowVIP_Params params {};
		params.bNewAllowVIP = bNewAllowVIP;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056A39A0
	 * 		Name   -> Function Insurgency.INSPlayerController.ServerSpectatePlayer
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetServer, BlueprintCallable, NetValidate)
	 * Parameters:
	 * 		class AActor*                                      Actor                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSPlayerController::ServerSpectatePlayer(class AActor* Actor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerController.ServerSpectatePlayer");
		
		AINSPlayerController_ServerSpectatePlayer_Params params {};
		params.Actor = Actor;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056A38E0
	 * 		Name   -> Function Insurgency.INSPlayerController.ServerSetTalkingOverRadio
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
	 * Parameters:
	 * 		bool                                               bState                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSPlayerController::ServerSetTalkingOverRadio(bool bState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerController.ServerSetTalkingOverRadio");
		
		AINSPlayerController_ServerSetTalkingOverRadio_Params params {};
		params.bState = bState;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056A3830
	 * 		Name   -> Function Insurgency.INSPlayerController.ServerSetMapVoteSelection
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
	 * Parameters:
	 * 		EMapVoteSelection                                  VoteIndex                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSPlayerController::ServerSetMapVoteSelection(EMapVoteSelection VoteIndex)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerController.ServerSetMapVoteSelection");
		
		AINSPlayerController_ServerSetMapVoteSelection_Params params {};
		params.VoteIndex = VoteIndex;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056A3780
	 * 		Name   -> Function Insurgency.INSPlayerController.ServerSendFireSupportRadialCommand
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
	 * Parameters:
	 * 		ERadialMenuDirection                               Direction                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSPlayerController::ServerSendFireSupportRadialCommand(ERadialMenuDirection Direction)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerController.ServerSendFireSupportRadialCommand");
		
		AINSPlayerController_ServerSendFireSupportRadialCommand_Params params {};
		params.Direction = Direction;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056A36D0
	 * 		Name   -> Function Insurgency.INSPlayerController.ServerSendCommsRadialCommand
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
	 * Parameters:
	 * 		ERadialMenuDirection                               Direction                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSPlayerController::ServerSendCommsRadialCommand(ERadialMenuDirection Direction)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerController.ServerSendCommsRadialCommand");
		
		AINSPlayerController_ServerSendCommsRadialCommand_Params params {};
		params.Direction = Direction;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056A3590
	 * 		Name   -> Function Insurgency.INSPlayerController.ServerSendChatMessage
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
	 * Parameters:
	 * 		class FText                                        Message                                                    (ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		bool                                               bTeamOnly                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSPlayerController::ServerSendChatMessage(const class FText& Message, bool bTeamOnly)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerController.ServerSendChatMessage");
		
		AINSPlayerController_ServerSendChatMessage_Params params {};
		params.Message = Message;
		params.bTeamOnly = bTeamOnly;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056A3490
	 * 		Name   -> Function Insurgency.INSPlayerController.ServerSABER_PlayDialogueForObjective
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
	 * Parameters:
	 * 		ECharacterResponse                                 DialogueType                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            ObjectiveId                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSPlayerController::ServerSABER_PlayDialogueForObjective(ECharacterResponse DialogueType, int32_t ObjectiveId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerController.ServerSABER_PlayDialogueForObjective");
		
		AINSPlayerController_ServerSABER_PlayDialogueForObjective_Params params {};
		params.DialogueType = DialogueType;
		params.ObjectiveId = ObjectiveId;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056A3380
	 * 		Name   -> Function Insurgency.INSPlayerController.ServerRequestViewTarget
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetServer, BlueprintCallable, NetValidate)
	 * Parameters:
	 * 		class AActor*                                      Target                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FViewTargetTransitionParams                 TransitionParams                                           (ConstParm, Parm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void AINSPlayerController::ServerRequestViewTarget(class AActor* Target, const struct FViewTargetTransitionParams& TransitionParams)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerController.ServerRequestViewTarget");
		
		AINSPlayerController_ServerRequestViewTarget_Params params {};
		params.Target = Target;
		params.TransitionParams = TransitionParams;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056A3300
	 * 		Name   -> Function Insurgency.INSPlayerController.ServerRequestSelectedFireSupport
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetServer)
	 * Parameters:
	 * 		float                                              YawOffset                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSPlayerController::ServerRequestSelectedFireSupport(float YawOffset)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerController.ServerRequestSelectedFireSupport");
		
		AINSPlayerController_ServerRequestSelectedFireSupport_Params params {};
		params.YawOffset = YawOffset;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056A3260
	 * 		Name   -> Function Insurgency.INSPlayerController.ServerRequestGameChannelToken
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetServer)
	 * Parameters:
	 * 		class FString                                      Channel                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSPlayerController::ServerRequestGameChannelToken(const class FString& Channel)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerController.ServerRequestGameChannelToken");
		
		AINSPlayerController_ServerRequestGameChannelToken_Params params {};
		params.Channel = Channel;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056A3210
	 * 		Name   -> Function Insurgency.INSPlayerController.ServerPossessViewTarget
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
	 */
	void AINSPlayerController::ServerPossessViewTarget()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerController.ServerPossessViewTarget");
		
		AINSPlayerController_ServerPossessViewTarget_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056A31C0
	 * 		Name   -> Function Insurgency.INSPlayerController.ServerKill
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
	 */
	void AINSPlayerController::ServerKill()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerController.ServerKill");
		
		AINSPlayerController_ServerKill_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056A3170
	 * 		Name   -> Function Insurgency.INSPlayerController.ServerJoinSpectators
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetServer, BlueprintCallable, NetValidate)
	 */
	void AINSPlayerController::ServerJoinSpectators()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerController.ServerJoinSpectators");
		
		AINSPlayerController_ServerJoinSpectators_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056A30B0
	 * 		Name   -> Function Insurgency.INSPlayerController.ServerJoinPlayerClass
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
	 * Parameters:
	 * 		class UPlayerClass*                                DesiredClass                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSPlayerController::ServerJoinPlayerClass(class UPlayerClass* DesiredClass)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerController.ServerJoinPlayerClass");
		
		AINSPlayerController_ServerJoinPlayerClass_Params params {};
		params.DesiredClass = DesiredClass;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056A3000
	 * 		Name   -> Function Insurgency.INSPlayerController.ServerJoinFaction
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
	 * Parameters:
	 * 		unsigned char                                      FactionId                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSPlayerController::ServerJoinFaction(unsigned char FactionId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerController.ServerJoinFaction");
		
		AINSPlayerController_ServerJoinFaction_Params params {};
		params.FactionId = FactionId;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056A2FB0
	 * 		Name   -> Function Insurgency.INSPlayerController.ServerEjectToSpectator
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
	 */
	void AINSPlayerController::ServerEjectToSpectator()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerController.ServerEjectToSpectator");
		
		AINSPlayerController_ServerEjectToSpectator_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056A2F60
	 * 		Name   -> Function Insurgency.INSPlayerController.ServerConfirmLoadout
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
	 */
	void AINSPlayerController::ServerConfirmLoadout()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerController.ServerConfirmLoadout");
		
		AINSPlayerController_ServerConfirmLoadout_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056A2EB0
	 * 		Name   -> Function Insurgency.INSPlayerController.ServerChangeFaction
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
	 * Parameters:
	 * 		unsigned char                                      NewFactionId                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSPlayerController::ServerChangeFaction(unsigned char NewFactionId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerController.ServerChangeFaction");
		
		AINSPlayerController_ServerChangeFaction_Params params {};
		params.NewFactionId = NewFactionId;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056A2DC0
	 * 		Name   -> Function Insurgency.INSPlayerController.ServerCastVote
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetServer, BlueprintCallable, NetValidate)
	 * Parameters:
	 * 		int32_t                                            ChoiceIndex                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bTeamOnlyVote                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSPlayerController::ServerCastVote(int32_t ChoiceIndex, bool bTeamOnlyVote)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerController.ServerCastVote");
		
		AINSPlayerController_ServerCastVote_Params params {};
		params.ChoiceIndex = ChoiceIndex;
		params.bTeamOnlyVote = bTeamOnlyVote;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056A2C30
	 * 		Name   -> Function Insurgency.INSPlayerController.ServerCallVote
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetServer, BlueprintCallable, NetValidate)
	 * Parameters:
	 * 		class UClass*                                      Issue                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FString                                      Option                                                     (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class APlayerState*                                TargetPlayer                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bTeamOnlyVote                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSPlayerController::ServerCallVote(class UClass* Issue, const class FString& Option, class APlayerState* TargetPlayer, bool bTeamOnlyVote)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerController.ServerCallVote");
		
		AINSPlayerController_ServerCallVote_Params params {};
		params.Issue = Issue;
		params.Option = Option;
		params.TargetPlayer = TargetPlayer;
		params.bTeamOnlyVote = bTeamOnlyVote;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056A2B50
	 * 		Name   -> Function Insurgency.INSPlayerController.ServerAckScenarioAudioBanksLoaded
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
	 */
	void AINSPlayerController::ServerAckScenarioAudioBanksLoaded()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerController.ServerAckScenarioAudioBanksLoaded");
		
		AINSPlayerController_ServerAckScenarioAudioBanksLoaded_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056A2A70
	 * 		Name   -> Function Insurgency.INSPlayerController.ServerAckScenarioAssetsLoaded
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
	 * Parameters:
	 * 		TArray<struct FSoftObjectPath>                     LoadedByClient                                             (ConstParm, Parm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSPlayerController::ServerAckScenarioAssetsLoaded(TArray<struct FSoftObjectPath> LoadedByClient)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerController.ServerAckScenarioAssetsLoaded");
		
		AINSPlayerController_ServerAckScenarioAssetsLoaded_Params params {};
		params.LoadedByClient = LoadedByClient;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056A29F0
	 * 		Name   -> Function Insurgency.INSPlayerController.SendFireSupportRadialCommand
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		ERadialMenuDirection                               Direction                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSPlayerController::SendFireSupportRadialCommand(ERadialMenuDirection Direction)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerController.SendFireSupportRadialCommand");
		
		AINSPlayerController_SendFireSupportRadialCommand_Params params {};
		params.Direction = Direction;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056A29D0
	 * 		Name   -> Function Insurgency.INSPlayerController.SendCurrentCosmeticPreset
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void AINSPlayerController::SendCurrentCosmeticPreset()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerController.SendCurrentCosmeticPreset");
		
		AINSPlayerController_SendCurrentCosmeticPreset_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056A2950
	 * 		Name   -> Function Insurgency.INSPlayerController.SendCommsRadialCommand
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		ERadialMenuDirection                               Direction                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSPlayerController::SendCommsRadialCommand(ERadialMenuDirection Direction)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerController.SendCommsRadialCommand");
		
		AINSPlayerController_SendCommsRadialCommand_Params params {};
		params.Direction = Direction;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056A2870
	 * 		Name   -> Function Insurgency.INSPlayerController.SavePlayerClassLoadout
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		class FText                                        LoadoutName                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	bool AINSPlayerController::SavePlayerClassLoadout(const class FText& LoadoutName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerController.SavePlayerClassLoadout");
		
		AINSPlayerController_SavePlayerClassLoadout_Params params {};
		params.LoadoutName = LoadoutName;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056A2850
	 * 		Name   -> Function Insurgency.INSPlayerController.SaveCurrentLoadout
	 * 		Flags  -> (Final, Exec, Native, Public, BlueprintCallable)
	 */
	void AINSPlayerController::SaveCurrentLoadout()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerController.SaveCurrentLoadout");
		
		AINSPlayerController_SaveCurrentLoadout_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056A2790
	 * 		Name   -> Function Insurgency.INSPlayerController.SABER_PlayDialogueForObjective
	 * 		Flags  -> (Final, Exec, Native, Public)
	 * Parameters:
	 * 		ECharacterResponse                                 DialogueType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            ObjectiveId                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSPlayerController::SABER_PlayDialogueForObjective(ECharacterResponse DialogueType, int32_t ObjectiveId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerController.SABER_PlayDialogueForObjective");
		
		AINSPlayerController_SABER_PlayDialogueForObjective_Params params {};
		params.DialogueType = DialogueType;
		params.ObjectiveId = ObjectiveId;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056A2710
	 * 		Name   -> Function Insurgency.INSPlayerController.SABER_PlayDialogue
	 * 		Flags  -> (Final, Exec, Native, Public)
	 * Parameters:
	 * 		ECharacterResponse                                 DialogueType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSPlayerController::SABER_PlayDialogue(ECharacterResponse DialogueType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerController.SABER_PlayDialogue");
		
		AINSPlayerController_SABER_PlayDialogue_Params params {};
		params.DialogueType = DialogueType;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056A2680
	 * 		Name   -> Function Insurgency.INSPlayerController.ResetCameraFocus
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bShouldAttemptToViewPlayer                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSPlayerController::ResetCameraFocus(bool bShouldAttemptToViewPlayer)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerController.ResetCameraFocus");
		
		AINSPlayerController_ResetCameraFocus_Params params {};
		params.bShouldAttemptToViewPlayer = bShouldAttemptToViewPlayer;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056A2660
	 * 		Name   -> Function Insurgency.INSPlayerController.RenewTutorialPause
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void AINSPlayerController::RenewTutorialPause()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerController.RenewTutorialPause");
		
		AINSPlayerController_RenewTutorialPause_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056A2640
	 * 		Name   -> Function Insurgency.INSPlayerController.ReleaseCommsMenu
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void AINSPlayerController::ReleaseCommsMenu()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerController.ReleaseCommsMenu");
		
		AINSPlayerController_ReleaseCommsMenu_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056A2580
	 * 		Name   -> Function Insurgency.INSPlayerController.QueueHQObjectiveAnnouncement
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UAkAudioEvent*                               AudioEvent                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            ObjectiveId                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSPlayerController::QueueHQObjectiveAnnouncement(class UAkAudioEvent* AudioEvent, int32_t ObjectiveId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerController.QueueHQObjectiveAnnouncement");
		
		AINSPlayerController_QueueHQObjectiveAnnouncement_Params params {};
		params.AudioEvent = AudioEvent;
		params.ObjectiveId = ObjectiveId;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056A2500
	 * 		Name   -> Function Insurgency.INSPlayerController.QueueHQAnnouncement
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UAkAudioEvent*                               AudioEvent                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSPlayerController::QueueHQAnnouncement(class UAkAudioEvent* AudioEvent)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerController.QueueHQAnnouncement");
		
		AINSPlayerController_QueueHQAnnouncement_Params params {};
		params.AudioEvent = AudioEvent;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056A2470
	 * 		Name   -> Function Insurgency.INSPlayerController.QAGetPos
	 * 		Flags  -> (Final, Exec, Native, Public)
	 * Parameters:
	 * 		bool                                               bCopyToClipboard                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSPlayerController::QAGetPos(bool bCopyToClipboard)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerController.QAGetPos");
		
		AINSPlayerController_QAGetPos_Params params {};
		params.bCopyToClipboard = bCopyToClipboard;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056A2450
	 * 		Name   -> Function Insurgency.INSPlayerController.PressCommsMenu
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void AINSPlayerController::PressCommsMenu()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerController.PressCommsMenu");
		
		AINSPlayerController_PressCommsMenu_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056A2430
	 * 		Name   -> Function Insurgency.INSPlayerController.PossessViewTarget
	 * 		Flags  -> (Native, Public)
	 */
	void AINSPlayerController::PossessViewTarget()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerController.PossessViewTarget");
		
		AINSPlayerController_PossessViewTarget_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056A23B0
	 * 		Name   -> Function Insurgency.INSPlayerController.PlayShellShock
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		float                                              Duration                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSPlayerController::PlayShellShock(float Duration)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerController.PlayShellShock");
		
		AINSPlayerController_PlayShellShock_Params params {};
		params.Duration = Duration;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> DelegateFunction Insurgency.INSPlayerController.PlayingMusicUpdated__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate, HasOutParms)
	 * Parameters:
	 * 		struct FPlayingMusic                               NewMusic                                                   (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void AINSPlayerController::PlayingMusicUpdated__DelegateSignature(const struct FPlayingMusic& NewMusic)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction Insurgency.INSPlayerController.PlayingMusicUpdated__DelegateSignature");
		
		AINSPlayerController_PlayingMusicUpdated__DelegateSignature_Params params {};
		params.NewMusic = NewMusic;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> DelegateFunction Insurgency.INSPlayerController.PlayerClassChangedDelegate__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 * Parameters:
	 * 		class UPlayerClass*                                PlayerClass                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSPlayerController::PlayerClassChangedDelegate__DelegateSignature(class UPlayerClass* PlayerClass)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction Insurgency.INSPlayerController.PlayerClassChangedDelegate__DelegateSignature");
		
		AINSPlayerController_PlayerClassChangedDelegate__DelegateSignature_Params params {};
		params.PlayerClass = PlayerClass;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056A2330
	 * 		Name   -> Function Insurgency.INSPlayerController.PlayDeafen
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		float                                              Duration                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSPlayerController::PlayDeafen(float Duration)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerController.PlayDeafen");
		
		AINSPlayerController_PlayDeafen_Params params {};
		params.Duration = Duration;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> DelegateFunction Insurgency.INSPlayerController.PendingMenuActionChangedDelegate__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 */
	void AINSPlayerController::PendingMenuActionChangedDelegate__DelegateSignature()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction Insurgency.INSPlayerController.PendingMenuActionChangedDelegate__DelegateSignature");
		
		AINSPlayerController_PendingMenuActionChangedDelegate__DelegateSignature_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056A2310
	 * 		Name   -> Function Insurgency.INSPlayerController.OnUpdatedLocalProfileHUDPreferences
	 * 		Flags  -> (Final, Native, Public)
	 */
	void AINSPlayerController::OnUpdatedLocalProfileHUDPreferences()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerController.OnUpdatedLocalProfileHUDPreferences");
		
		AINSPlayerController_OnUpdatedLocalProfileHUDPreferences_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056A22F0
	 * 		Name   -> Function Insurgency.INSPlayerController.OnUpdatedHUDPreferences
	 * 		Flags  -> (Final, Native, Public)
	 */
	void AINSPlayerController::OnUpdatedHUDPreferences()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerController.OnUpdatedHUDPreferences");
		
		AINSPlayerController_OnUpdatedHUDPreferences_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056A22D0
	 * 		Name   -> Function Insurgency.INSPlayerController.OnStopShellShock
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void AINSPlayerController::OnStopShellShock()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerController.OnStopShellShock");
		
		AINSPlayerController_OnStopShellShock_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056A22B0
	 * 		Name   -> Function Insurgency.INSPlayerController.OnStopDeafen
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void AINSPlayerController::OnStopDeafen()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerController.OnStopDeafen");
		
		AINSPlayerController_OnStopDeafen_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> DelegateFunction Insurgency.INSPlayerController.OnSpawnZoneDelegate__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 */
	void AINSPlayerController::OnSpawnZoneDelegate__DelegateSignature()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction Insurgency.INSPlayerController.OnSpawnZoneDelegate__DelegateSignature");
		
		AINSPlayerController_OnSpawnZoneDelegate__DelegateSignature_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> DelegateFunction Insurgency.INSPlayerController.OnSoldierSpawnDelegate__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 */
	void AINSPlayerController::OnSoldierSpawnDelegate__DelegateSignature()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction Insurgency.INSPlayerController.OnSoldierSpawnDelegate__DelegateSignature");
		
		AINSPlayerController_OnSoldierSpawnDelegate__DelegateSignature_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> DelegateFunction Insurgency.INSPlayerController.OnShowRadialMenuDelegate__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 * Parameters:
	 * 		class UUserWidget*                                 ShownRadial                                                (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSPlayerController::OnShowRadialMenuDelegate__DelegateSignature(class UUserWidget* ShownRadial)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction Insurgency.INSPlayerController.OnShowRadialMenuDelegate__DelegateSignature");
		
		AINSPlayerController_OnShowRadialMenuDelegate__DelegateSignature_Params params {};
		params.ShownRadial = ShownRadial;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056A2290
	 * 		Name   -> Function Insurgency.INSPlayerController.OnRep_PlayingMusic
	 * 		Flags  -> (Final, Native, Public)
	 */
	void AINSPlayerController::OnRep_PlayingMusic()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerController.OnRep_PlayingMusic");
		
		AINSPlayerController_OnRep_PlayingMusic_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056A2270
	 * 		Name   -> Function Insurgency.INSPlayerController.OnRep_PendingMenuActions
	 * 		Flags  -> (Final, Native, Public)
	 */
	void AINSPlayerController::OnRep_PendingMenuActions()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerController.OnRep_PendingMenuActions");
		
		AINSPlayerController_OnRep_PendingMenuActions_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056A2250
	 * 		Name   -> Function Insurgency.INSPlayerController.OnPlayerSettingsUpdate
	 * 		Flags  -> (Final, Native, Private)
	 */
	void AINSPlayerController::OnPlayerSettingsUpdate()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerController.OnPlayerSettingsUpdate");
		
		AINSPlayerController_OnPlayerSettingsUpdate_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> DelegateFunction Insurgency.INSPlayerController.OnPlayerMapVotingStart__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 */
	void AINSPlayerController::OnPlayerMapVotingStart__DelegateSignature()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction Insurgency.INSPlayerController.OnPlayerMapVotingStart__DelegateSignature");
		
		AINSPlayerController_OnPlayerMapVotingStart__DelegateSignature_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> DelegateFunction Insurgency.INSPlayerController.OnMenuWidgetOpenedDelegate__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 * Parameters:
	 * 		EIngameMenuType                                    Entered                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSPlayerController::OnMenuWidgetOpenedDelegate__DelegateSignature(EIngameMenuType Entered)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction Insurgency.INSPlayerController.OnMenuWidgetOpenedDelegate__DelegateSignature");
		
		AINSPlayerController_OnMenuWidgetOpenedDelegate__DelegateSignature_Params params {};
		params.Entered = Entered;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> DelegateFunction Insurgency.INSPlayerController.OnMenuWidgetExitDelegate__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 */
	void AINSPlayerController::OnMenuWidgetExitDelegate__DelegateSignature()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction Insurgency.INSPlayerController.OnMenuWidgetExitDelegate__DelegateSignature");
		
		AINSPlayerController_OnMenuWidgetExitDelegate__DelegateSignature_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> DelegateFunction Insurgency.INSPlayerController.OnInventorySelectActiveDelegate__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 * Parameters:
	 * 		bool                                               bNewInventorySelectActive                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSPlayerController::OnInventorySelectActiveDelegate__DelegateSignature(bool bNewInventorySelectActive)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction Insurgency.INSPlayerController.OnInventorySelectActiveDelegate__DelegateSignature");
		
		AINSPlayerController_OnInventorySelectActiveDelegate__DelegateSignature_Params params {};
		params.bNewInventorySelectActive = bNewInventorySelectActive;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> DelegateFunction Insurgency.INSPlayerController.OnInventoryMenuVisibleDelegate__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 * Parameters:
	 * 		bool                                               bNewInventorySelectActive                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bUsingGamepad                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSPlayerController::OnInventoryMenuVisibleDelegate__DelegateSignature(bool bNewInventorySelectActive, bool bUsingGamepad)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction Insurgency.INSPlayerController.OnInventoryMenuVisibleDelegate__DelegateSignature");
		
		AINSPlayerController_OnInventoryMenuVisibleDelegate__DelegateSignature_Params params {};
		params.bNewInventorySelectActive = bNewInventorySelectActive;
		params.bUsingGamepad = bUsingGamepad;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> DelegateFunction Insurgency.INSPlayerController.OnInGameMenuVisibleDelegate__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 * Parameters:
	 * 		bool                                               bNewVisibility                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSPlayerController::OnInGameMenuVisibleDelegate__DelegateSignature(bool bNewVisibility)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction Insurgency.INSPlayerController.OnInGameMenuVisibleDelegate__DelegateSignature");
		
		AINSPlayerController_OnInGameMenuVisibleDelegate__DelegateSignature_Params params {};
		params.bNewVisibility = bNewVisibility;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056A2230
	 * 		Name   -> Function Insurgency.INSPlayerController.OnHQAnnouncementFinished
	 * 		Flags  -> (Final, Native, Public)
	 */
	void AINSPlayerController::OnHQAnnouncementFinished()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerController.OnHQAnnouncementFinished");
		
		AINSPlayerController_OnHQAnnouncementFinished_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> DelegateFunction Insurgency.INSPlayerController.OnHideRadialMenuDelegate__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 * Parameters:
	 * 		class UUserWidget*                                 HiddenRadial                                               (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSPlayerController::OnHideRadialMenuDelegate__DelegateSignature(class UUserWidget* HiddenRadial)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction Insurgency.INSPlayerController.OnHideRadialMenuDelegate__DelegateSignature");
		
		AINSPlayerController_OnHideRadialMenuDelegate__DelegateSignature_Params params {};
		params.HiddenRadial = HiddenRadial;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056A2210
	 * 		Name   -> Function Insurgency.INSPlayerController.OnFireSupportPersonalCooldownElapsed
	 * 		Flags  -> (Final, Native, Private)
	 */
	void AINSPlayerController::OnFireSupportPersonalCooldownElapsed()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerController.OnFireSupportPersonalCooldownElapsed");
		
		AINSPlayerController_OnFireSupportPersonalCooldownElapsed_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> DelegateFunction Insurgency.INSPlayerController.OnFireSupportConfirmedDelegate__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate, HasOutParms)
	 * Parameters:
	 * 		struct FFireSupportRequest                         Request                                                    (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void AINSPlayerController::OnFireSupportConfirmedDelegate__DelegateSignature(const struct FFireSupportRequest& Request)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction Insurgency.INSPlayerController.OnFireSupportConfirmedDelegate__DelegateSignature");
		
		AINSPlayerController_OnFireSupportConfirmedDelegate__DelegateSignature_Params params {};
		params.Request = Request;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056A21F0
	 * 		Name   -> Function Insurgency.INSPlayerController.OnFadeFinished
	 * 		Flags  -> (Final, Native, Public)
	 */
	void AINSPlayerController::OnFadeFinished()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerController.OnFadeFinished");
		
		AINSPlayerController_OnFadeFinished_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05630E50
	 * 		Name   -> Function Insurgency.INSPlayerController.NotifyOfUsingMultiplayerFeatures
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bIsUsingMP                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSPlayerController::NotifyOfUsingMultiplayerFeatures(bool bIsUsingMP)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerController.NotifyOfUsingMultiplayerFeatures");
		
		AINSPlayerController_NotifyOfUsingMultiplayerFeatures_Params params {};
		params.bIsUsingMP = bIsUsingMP;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056A21D0
	 * 		Name   -> Function Insurgency.INSPlayerController.LocalProfileSaveOpportunity
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void AINSPlayerController::LocalProfileSaveOpportunity()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerController.LocalProfileSaveOpportunity");
		
		AINSPlayerController_LocalProfileSaveOpportunity_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056A21A0
	 * 		Name   -> Function Insurgency.INSPlayerController.LoadInventoryItem
	 * 		Flags  -> (Final, Native, Protected, BlueprintCallable)
	 */
	bool AINSPlayerController::LoadInventoryItem()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerController.LoadInventoryItem");
		
		AINSPlayerController_LoadInventoryItem_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056A2110
	 * 		Name   -> Function Insurgency.INSPlayerController.LoadAndInstanceIngameMenu
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bHideAfterLoad                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSPlayerController::LoadAndInstanceIngameMenu(bool bHideAfterLoad)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerController.LoadAndInstanceIngameMenu");
		
		AINSPlayerController_LoadAndInstanceIngameMenu_Params params {};
		params.bHideAfterLoad = bHideAfterLoad;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056A20F0
	 * 		Name   -> Function Insurgency.INSPlayerController.Kill
	 * 		Flags  -> (Final, Exec, Native, Public)
	 */
	void AINSPlayerController::Kill()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerController.Kill");
		
		AINSPlayerController_Kill_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056A20D0
	 * 		Name   -> Function Insurgency.INSPlayerController.JoinSpectators
	 * 		Flags  -> (Final, Native, Public)
	 */
	void AINSPlayerController::JoinSpectators()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerController.JoinSpectators");
		
		AINSPlayerController_JoinSpectators_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056A2050
	 * 		Name   -> Function Insurgency.INSPlayerController.JoinPlayerClass
	 * 		Flags  -> (Final, Exec, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UPlayerClass*                                DesiredClass                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSPlayerController::JoinPlayerClass(class UPlayerClass* DesiredClass)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerController.JoinPlayerClass");
		
		AINSPlayerController_JoinPlayerClass_Params params {};
		params.DesiredClass = DesiredClass;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056A1FD0
	 * 		Name   -> Function Insurgency.INSPlayerController.JoinFaction
	 * 		Flags  -> (Final, Exec, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		unsigned char                                      FactionId                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSPlayerController::JoinFaction(unsigned char FactionId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerController.JoinFaction");
		
		AINSPlayerController_JoinFaction_Params params {};
		params.FactionId = FactionId;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056A1F50
	 * 		Name   -> Function Insurgency.INSPlayerController.JoinClassBySlot
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		int32_t                                            ClassSlotIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSPlayerController::JoinClassBySlot(int32_t ClassSlotIndex)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerController.JoinClassBySlot");
		
		AINSPlayerController_JoinClassBySlot_Params params {};
		params.ClassSlotIndex = ClassSlotIndex;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056A1F20
	 * 		Name   -> Function Insurgency.INSPlayerController.IsVaultKeyBound
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AINSPlayerController::IsVaultKeyBound()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerController.IsVaultKeyBound");
		
		AINSPlayerController_IsVaultKeyBound_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056A1EF0
	 * 		Name   -> Function Insurgency.INSPlayerController.IsTextChatOnCooldown
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AINSPlayerController::IsTextChatOnCooldown()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerController.IsTextChatOnCooldown");
		
		AINSPlayerController_IsTextChatOnCooldown_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056A1EC0
	 * 		Name   -> Function Insurgency.INSPlayerController.IsPlayingShellShock
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AINSPlayerController::IsPlayingShellShock()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerController.IsPlayingShellShock");
		
		AINSPlayerController_IsPlayingShellShock_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056A1E30
	 * 		Name   -> Function Insurgency.INSPlayerController.IsPlayerAudioInProximity
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		int32_t                                            PlayerId                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool AINSPlayerController::IsPlayerAudioInProximity(int32_t PlayerId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerController.IsPlayerAudioInProximity");
		
		AINSPlayerController_IsPlayerAudioInProximity_Params params {};
		params.PlayerId = PlayerId;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056A1E00
	 * 		Name   -> Function Insurgency.INSPlayerController.IsInTutorialSession
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	bool AINSPlayerController::IsInTutorialSession()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerController.IsInTutorialSession");
		
		AINSPlayerController_IsInTutorialSession_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056A1DD0
	 * 		Name   -> Function Insurgency.INSPlayerController.IsInSpectatorFaction
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
	 */
	bool AINSPlayerController::IsInSpectatorFaction()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerController.IsInSpectatorFaction");
		
		AINSPlayerController_IsInSpectatorFaction_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056A1DA0
	 * 		Name   -> Function Insurgency.INSPlayerController.IsFireSupportOnCooldown
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AINSPlayerController::IsFireSupportOnCooldown()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerController.IsFireSupportOnCooldown");
		
		AINSPlayerController_IsFireSupportOnCooldown_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056A1D80
	 * 		Name   -> Function Insurgency.INSPlayerController.IsFadingInOrOut
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
	 */
	bool AINSPlayerController::IsFadingInOrOut()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerController.IsFadingInOrOut");
		
		AINSPlayerController_IsFadingInOrOut_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056A1D50
	 * 		Name   -> Function Insurgency.INSPlayerController.IsDeafened
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AINSPlayerController::IsDeafened()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerController.IsDeafened");
		
		AINSPlayerController_IsDeafened_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056A1D30
	 * 		Name   -> Function Insurgency.INSPlayerController.InventorySelectReleased
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void AINSPlayerController::InventorySelectReleased()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerController.InventorySelectReleased");
		
		AINSPlayerController_InventorySelectReleased_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056A1D10
	 * 		Name   -> Function Insurgency.INSPlayerController.InventorySelectPressed
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void AINSPlayerController::InventorySelectPressed()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerController.InventorySelectPressed");
		
		AINSPlayerController_InventorySelectPressed_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> DelegateFunction Insurgency.INSPlayerController.InventoryItemLoaded__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 */
	void AINSPlayerController::InventoryItemLoaded__DelegateSignature()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction Insurgency.INSPlayerController.InventoryItemLoaded__DelegateSignature");
		
		AINSPlayerController_InventoryItemLoaded__DelegateSignature_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056A1CF0
	 * 		Name   -> Function Insurgency.INSPlayerController.InitAchievements
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetClient)
	 */
	void AINSPlayerController::InitAchievements()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerController.InitAchievements");
		
		AINSPlayerController_InitAchievements_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056A1CD0
	 * 		Name   -> Function Insurgency.INSPlayerController.HideInGameMenu
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void AINSPlayerController::HideInGameMenu()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerController.HideInGameMenu");
		
		AINSPlayerController_HideInGameMenu_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056A1CB0
	 * 		Name   -> Function Insurgency.INSPlayerController.HideGenericWidget
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void AINSPlayerController::HideGenericWidget()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerController.HideGenericWidget");
		
		AINSPlayerController_HideGenericWidget_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056A1C90
	 * 		Name   -> Function Insurgency.INSPlayerController.HideFireSupportMenu
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void AINSPlayerController::HideFireSupportMenu()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerController.HideFireSupportMenu");
		
		AINSPlayerController_HideFireSupportMenu_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056A1C70
	 * 		Name   -> Function Insurgency.INSPlayerController.HideCommsMenu
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void AINSPlayerController::HideCommsMenu()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerController.HideCommsMenu");
		
		AINSPlayerController_HideCommsMenu_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056A1C50
	 * 		Name   -> Function Insurgency.INSPlayerController.HideActiveRadialWidget
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void AINSPlayerController::HideActiveRadialWidget()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerController.HideActiveRadialWidget");
		
		AINSPlayerController_HideActiveRadialWidget_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056A1BC0
	 * 		Name   -> Function Insurgency.INSPlayerController.HasPendingMenuAction
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		EPendingMenuAction                                 Action                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool AINSPlayerController::HasPendingMenuAction(EPendingMenuAction Action)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerController.HasPendingMenuAction");
		
		AINSPlayerController_HasPendingMenuAction_Params params {};
		params.Action = Action;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056A1B90
	 * 		Name   -> Function Insurgency.INSPlayerController.HasLocalProfile
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AINSPlayerController::HasLocalProfile()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerController.HasLocalProfile");
		
		AINSPlayerController_HasLocalProfile_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056A1B60
	 * 		Name   -> Function Insurgency.INSPlayerController.HasConfirmedLoadout
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
	 */
	bool AINSPlayerController::HasConfirmedLoadout()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerController.HasConfirmedLoadout");
		
		AINSPlayerController_HasConfirmedLoadout_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056A1B30
	 * 		Name   -> Function Insurgency.INSPlayerController.HasAlivePawn
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
	 */
	bool AINSPlayerController::HasAlivePawn()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerController.HasAlivePawn");
		
		AINSPlayerController_HasAlivePawn_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056A1A30
	 * 		Name   -> Function Insurgency.INSPlayerController.GetVoteIssues
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		TArray<struct FVotableIssue>                       OutVotableIssues                                           (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bTeamOnlyVote                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSPlayerController::GetVoteIssues(TArray<struct FVotableIssue>* OutVotableIssues, bool bTeamOnlyVote)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerController.GetVoteIssues");
		
		AINSPlayerController_GetVoteIssues_Params params {};
		params.bTeamOnlyVote = bTeamOnlyVote;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutVotableIssues != nullptr)
			*OutVotableIssues = params.OutVotableIssues;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056A1A00
	 * 		Name   -> Function Insurgency.INSPlayerController.GetTimeUntilPersonalCooldownFinished
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	float AINSPlayerController::GetTimeUntilPersonalCooldownFinished()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerController.GetTimeUntilPersonalCooldownFinished");
		
		AINSPlayerController_GetTimeUntilPersonalCooldownFinished_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056A19D0
	 * 		Name   -> Function Insurgency.INSPlayerController.GetTimeSinceLastChatMessage
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	float AINSPlayerController::GetTimeSinceLastChatMessage()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerController.GetTimeSinceLastChatMessage");
		
		AINSPlayerController_GetTimeSinceLastChatMessage_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056A1990
	 * 		Name   -> Function Insurgency.INSPlayerController.GetTeamId
	 * 		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	unsigned char AINSPlayerController::GetTeamId()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerController.GetTeamId");
		
		AINSPlayerController_GetTeamId_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056A1960
	 * 		Name   -> Function Insurgency.INSPlayerController.GetTeam
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	class ATeamInfo* AINSPlayerController::GetTeam()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerController.GetTeam");
		
		AINSPlayerController_GetTeam_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056A1940
	 * 		Name   -> Function Insurgency.INSPlayerController.GetSelectedFireSupport
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
	 */
	class UFireSupportDefinition* AINSPlayerController::GetSelectedFireSupport()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerController.GetSelectedFireSupport");
		
		AINSPlayerController_GetSelectedFireSupport_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056A17D0
	 * 		Name   -> Function Insurgency.INSPlayerController.GetKeysForActionUsingInputMethod
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		class FName                                        Action                                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		TArray<struct FInputActionKeyMapping>              OutKeys                                                    (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bGamepad                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSPlayerController::GetKeysForActionUsingInputMethod(const class FName& Action, TArray<struct FInputActionKeyMapping>* OutKeys, bool bGamepad)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerController.GetKeysForActionUsingInputMethod");
		
		AINSPlayerController_GetKeysForActionUsingInputMethod_Params params {};
		params.Action = Action;
		params.bGamepad = bGamepad;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutKeys != nullptr)
			*OutKeys = params.OutKeys;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056A16A0
	 * 		Name   -> Function Insurgency.INSPlayerController.GetKeysForActionActiveInputMethod
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		class FName                                        Action                                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		TArray<struct FInputActionKeyMapping>              OutKeys                                                    (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSPlayerController::GetKeysForActionActiveInputMethod(const class FName& Action, TArray<struct FInputActionKeyMapping>* OutKeys)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerController.GetKeysForActionActiveInputMethod");
		
		AINSPlayerController_GetKeysForActionActiveInputMethod_Params params {};
		params.Action = Action;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutKeys != nullptr)
			*OutKeys = params.OutKeys;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056A1570
	 * 		Name   -> Function Insurgency.INSPlayerController.GetKeysForAction
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		class FName                                        Action                                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		TArray<struct FInputActionKeyMapping>              OutKeys                                                    (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSPlayerController::GetKeysForAction(const class FName& Action, TArray<struct FInputActionKeyMapping>* OutKeys)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerController.GetKeysForAction");
		
		AINSPlayerController_GetKeysForAction_Params params {};
		params.Action = Action;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutKeys != nullptr)
			*OutKeys = params.OutKeys;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056A1540
	 * 		Name   -> Function Insurgency.INSPlayerController.GetFireSupportPersonalCooldownDuration
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	float AINSPlayerController::GetFireSupportPersonalCooldownDuration()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerController.GetFireSupportPersonalCooldownDuration");
		
		AINSPlayerController_GetFireSupportPersonalCooldownDuration_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056A1510
	 * 		Name   -> Function Insurgency.INSPlayerController.GetFactionDefinition
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	class UFactionDefinition* AINSPlayerController::GetFactionDefinition()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerController.GetFactionDefinition");
		
		AINSPlayerController_GetFactionDefinition_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056A1470
	 * 		Name   -> Function Insurgency.INSPlayerController.GetCurrentPlayerClass
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		bool                                               bUseCurrentPawnClass                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UPlayerClass* AINSPlayerController::GetCurrentPlayerClass(bool bUseCurrentPawnClass)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerController.GetCurrentPlayerClass");
		
		AINSPlayerController_GetCurrentPlayerClass_Params params {};
		params.bUseCurrentPawnClass = bUseCurrentPawnClass;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056A1450
	 * 		Name   -> Function Insurgency.INSPlayerController.ForwardInventoryPreferences
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void AINSPlayerController::ForwardInventoryPreferences()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerController.ForwardInventoryPreferences");
		
		AINSPlayerController_ForwardInventoryPreferences_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> DelegateFunction Insurgency.INSPlayerController.EquipableItemSelectedDelegate__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 * Parameters:
	 * 		class AItemEquipable*                              NewItem                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AItemEquipable*                              PreviousItem                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSPlayerController::EquipableItemSelectedDelegate__DelegateSignature(class AItemEquipable* NewItem, class AItemEquipable* PreviousItem)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction Insurgency.INSPlayerController.EquipableItemSelectedDelegate__DelegateSignature");
		
		AINSPlayerController_EquipableItemSelectedDelegate__DelegateSignature_Params params {};
		params.NewItem = NewItem;
		params.PreviousItem = PreviousItem;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056A1410
	 * 		Name   -> Function Insurgency.INSPlayerController.DPadUpPressed
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void AINSPlayerController::DPadUpPressed()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerController.DPadUpPressed");
		
		AINSPlayerController_DPadUpPressed_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056A13F0
	 * 		Name   -> Function Insurgency.INSPlayerController.DPadRightPressed
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void AINSPlayerController::DPadRightPressed()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerController.DPadRightPressed");
		
		AINSPlayerController_DPadRightPressed_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056A13D0
	 * 		Name   -> Function Insurgency.INSPlayerController.DPadLeftPressed
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void AINSPlayerController::DPadLeftPressed()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerController.DPadLeftPressed");
		
		AINSPlayerController_DPadLeftPressed_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056A13B0
	 * 		Name   -> Function Insurgency.INSPlayerController.DPadDownPressed
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void AINSPlayerController::DPadDownPressed()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerController.DPadDownPressed");
		
		AINSPlayerController_DPadDownPressed_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056A1430
	 * 		Name   -> Function Insurgency.INSPlayerController.DebugFireSupportRadialMenu
	 * 		Flags  -> (Final, Exec, Native, Public)
	 */
	void AINSPlayerController::DebugFireSupportRadialMenu()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerController.DebugFireSupportRadialMenu");
		
		AINSPlayerController_DebugFireSupportRadialMenu_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00C76AB0
	 * 		Name   -> Function Insurgency.INSPlayerController.CycleDebugCamera
	 * 		Flags  -> (Final, Exec, Native, Public)
	 */
	void AINSPlayerController::CycleDebugCamera()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerController.CycleDebugCamera");
		
		AINSPlayerController_CycleDebugCamera_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056A1320
	 * 		Name   -> Function Insurgency.INSPlayerController.CreateRangeComputerMenu
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UClass*                                      NewRangeWidget                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UUserWidget* AINSPlayerController::CreateRangeComputerMenu(class UClass* NewRangeWidget)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerController.CreateRangeComputerMenu");
		
		AINSPlayerController_CreateRangeComputerMenu_Params params {};
		params.NewRangeWidget = NewRangeWidget;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056A12A0
	 * 		Name   -> Function Insurgency.INSPlayerController.CreateIndividualAchievement
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UClass*                                      AchievementClass                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSPlayerController::CreateIndividualAchievement(class UClass* AchievementClass)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerController.CreateIndividualAchievement");
		
		AINSPlayerController_CreateIndividualAchievement_Params params {};
		params.AchievementClass = AchievementClass;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056A1210
	 * 		Name   -> Function Insurgency.INSPlayerController.CreateCustomRadial
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UClass*                                      NewWidget                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UUserWidget* AINSPlayerController::CreateCustomRadial(class UClass* NewWidget)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerController.CreateCustomRadial");
		
		AINSPlayerController_CreateCustomRadial_Params params {};
		params.NewWidget = NewWidget;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056A11F0
	 * 		Name   -> Function Insurgency.INSPlayerController.ConfirmLoadout
	 * 		Flags  -> (Final, Exec, Native, Public, BlueprintCallable)
	 */
	void AINSPlayerController::ConfirmLoadout()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerController.ConfirmLoadout");
		
		AINSPlayerController_ConfirmLoadout_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056A1120
	 * 		Name   -> Function Insurgency.INSPlayerController.ClientVoteResult
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetClient)
	 * Parameters:
	 * 		ECallVoteResult                                    Result                                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bTeamOnlyVote                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSPlayerController::ClientVoteResult(ECallVoteResult Result, bool bTeamOnlyVote)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerController.ClientVoteResult");
		
		AINSPlayerController_ClientVoteResult_Params params {};
		params.Result = Result;
		params.bTeamOnlyVote = bTeamOnlyVote;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056A1100
	 * 		Name   -> Function Insurgency.INSPlayerController.ClientStartOnlineGame
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetClient)
	 */
	void AINSPlayerController::ClientStartOnlineGame()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerController.ClientStartOnlineGame");
		
		AINSPlayerController_ClientStartOnlineGame_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056A0F10
	 * 		Name   -> Function Insurgency.INSPlayerController.ClientShowMapVoteScreen
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetClient)
	 * Parameters:
	 * 		TArray<struct FMapVoteOption>                      Maps                                                       (ConstParm, Parm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              EndTime                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bCanVoteRefresh                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSPlayerController::ClientShowMapVoteScreen(TArray<struct FMapVoteOption> Maps, float EndTime, bool bCanVoteRefresh)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerController.ClientShowMapVoteScreen");
		
		AINSPlayerController_ClientShowMapVoteScreen_Params params {};
		params.Maps = Maps;
		params.EndTime = EndTime;
		params.bCanVoteRefresh = bCanVoteRefresh;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056A0E20
	 * 		Name   -> Function Insurgency.INSPlayerController.ClientShowKillerInfo
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetClient)
	 * Parameters:
	 * 		struct FPlayerKillNotice                           Notice                                                     (ConstParm, Parm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 * 		struct FNemesisStats                               NemesisStats                                               (ConstParm, Parm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void AINSPlayerController::ClientShowKillerInfo(const struct FPlayerKillNotice& Notice, const struct FNemesisStats& NemesisStats)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerController.ClientShowKillerInfo");
		
		AINSPlayerController_ClientShowKillerInfo_Params params {};
		params.Notice = Notice;
		params.NemesisStats = NemesisStats;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056A0C70
	 * 		Name   -> Function Insurgency.INSPlayerController.ClientSetVoiceState
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetClient)
	 * Parameters:
	 * 		int32_t                                            PlayerId                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bAudibleProximity                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bAudibleRadio                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bIsEnemy                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bRadioFilter                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSPlayerController::ClientSetVoiceState(int32_t PlayerId, bool bAudibleProximity, bool bAudibleRadio, bool bIsEnemy, bool bRadioFilter)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerController.ClientSetVoiceState");
		
		AINSPlayerController_ClientSetVoiceState_Params params {};
		params.PlayerId = PlayerId;
		params.bAudibleProximity = bAudibleProximity;
		params.bAudibleRadio = bAudibleRadio;
		params.bIsEnemy = bIsEnemy;
		params.bRadioFilter = bRadioFilter;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056A0BF0
	 * 		Name   -> Function Insurgency.INSPlayerController.ClientSetMapVoteWinner
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetClient)
	 * Parameters:
	 * 		EMapVoteSelection                                  Selection                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSPlayerController::ClientSetMapVoteWinner(EMapVoteSelection Selection)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerController.ClientSetMapVoteWinner");
		
		AINSPlayerController_ClientSetMapVoteWinner_Params params {};
		params.Selection = Selection;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056A0B50
	 * 		Name   -> Function Insurgency.INSPlayerController.ClientSetMapVoteCount
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetClient)
	 * Parameters:
	 * 		TArray<struct FMapVoteCount>                       Data                                                       (ConstParm, Parm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSPlayerController::ClientSetMapVoteCount(TArray<struct FMapVoteCount> Data)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerController.ClientSetMapVoteCount");
		
		AINSPlayerController_ClientSetMapVoteCount_Params params {};
		params.Data = Data;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056A0A80
	 * 		Name   -> Function Insurgency.INSPlayerController.ClientSetDeathFade
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetClient, BlueprintCallable)
	 * Parameters:
	 * 		float                                              FadeTime                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bApplyHeadshotSwitch                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSPlayerController::ClientSetDeathFade(float FadeTime, bool bApplyHeadshotSwitch)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerController.ClientSetDeathFade");
		
		AINSPlayerController_ClientSetDeathFade_Params params {};
		params.FadeTime = FadeTime;
		params.bApplyHeadshotSwitch = bApplyHeadshotSwitch;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056A0A60
	 * 		Name   -> Function Insurgency.INSPlayerController.ClientReturnToQueueFromMatch
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetClient)
	 */
	void AINSPlayerController::ClientReturnToQueueFromMatch()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerController.ClientReturnToQueueFromMatch");
		
		AINSPlayerController_ClientReturnToQueueFromMatch_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056A0870
	 * 		Name   -> Function Insurgency.INSPlayerController.ClientReceiveScenarioAssets
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetClient)
	 * Parameters:
	 * 		TArray<struct FSoftObjectPath>                     AssetsToLoad                                               (ConstParm, Parm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bFirst                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSPlayerController::ClientReceiveScenarioAssets(TArray<struct FSoftObjectPath> AssetsToLoad, bool bFirst)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerController.ClientReceiveScenarioAssets");
		
		AINSPlayerController_ClientReceiveScenarioAssets_Params params {};
		params.AssetsToLoad = AssetsToLoad;
		params.bFirst = bFirst;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056A0970
	 * 		Name   -> Function Insurgency.INSPlayerController.ClientReceivedGameChannelToken
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetClient)
	 * Parameters:
	 * 		class FString                                      Channel                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FString                                      JoinToken                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSPlayerController::ClientReceivedGameChannelToken(const class FString& Channel, const class FString& JoinToken)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerController.ClientReceivedGameChannelToken");
		
		AINSPlayerController_ClientReceivedGameChannelToken_Params params {};
		params.Channel = Channel;
		params.JoinToken = JoinToken;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056A07B0
	 * 		Name   -> Function Insurgency.INSPlayerController.ClientReceiveAudioBanks
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetClient)
	 */
	void AINSPlayerController::ClientReceiveAudioBanks()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerController.ClientReceiveAudioBanks");
		
		AINSPlayerController_ClientReceiveAudioBanks_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056A06E0
	 * 		Name   -> Function Insurgency.INSPlayerController.ClientQueueHQObjectiveAnnouncement
	 * 		Flags  -> (Net, Native, Event, Public, NetClient, BlueprintCallable)
	 * Parameters:
	 * 		class UAkAudioEvent*                               AudioEvent                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            ObjectiveId                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSPlayerController::ClientQueueHQObjectiveAnnouncement(class UAkAudioEvent* AudioEvent, int32_t ObjectiveId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerController.ClientQueueHQObjectiveAnnouncement");
		
		AINSPlayerController_ClientQueueHQObjectiveAnnouncement_Params params {};
		params.AudioEvent = AudioEvent;
		params.ObjectiveId = ObjectiveId;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056A0650
	 * 		Name   -> Function Insurgency.INSPlayerController.ClientQueueHQAnnouncement
	 * 		Flags  -> (Net, Native, Event, Public, NetClient, BlueprintCallable)
	 * Parameters:
	 * 		class UAkAudioEvent*                               AudioEvent                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSPlayerController::ClientQueueHQAnnouncement(class UAkAudioEvent* AudioEvent)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerController.ClientQueueHQAnnouncement");
		
		AINSPlayerController_ClientQueueHQAnnouncement_Params params {};
		params.AudioEvent = AudioEvent;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056A0630
	 * 		Name   -> Function Insurgency.INSPlayerController.ClientPromptTeamMenu
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetClient, BlueprintCallable)
	 */
	void AINSPlayerController::ClientPromptTeamMenu()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerController.ClientPromptTeamMenu");
		
		AINSPlayerController_ClientPromptTeamMenu_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056A0610
	 * 		Name   -> Function Insurgency.INSPlayerController.ClientPromptLoadout
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetClient, BlueprintCallable)
	 */
	void AINSPlayerController::ClientPromptLoadout()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerController.ClientPromptLoadout");
		
		AINSPlayerController_ClientPromptLoadout_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056A05F0
	 * 		Name   -> Function Insurgency.INSPlayerController.ClientPromptCosmeticsMenuIfNeeded
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetClient, BlueprintCallable)
	 */
	void AINSPlayerController::ClientPromptCosmeticsMenuIfNeeded()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerController.ClientPromptCosmeticsMenuIfNeeded");
		
		AINSPlayerController_ClientPromptCosmeticsMenuIfNeeded_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056A05D0
	 * 		Name   -> Function Insurgency.INSPlayerController.ClientProfileSaveOpportunity
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetClient)
	 */
	void AINSPlayerController::ClientProfileSaveOpportunity()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerController.ClientProfileSaveOpportunity");
		
		AINSPlayerController_ClientProfileSaveOpportunity_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056A0550
	 * 		Name   -> Function Insurgency.INSPlayerController.ClientOnPlayerResupplied
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetClient)
	 * Parameters:
	 * 		class AINSSoldier*                                 Soldier                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSPlayerController::ClientOnPlayerResupplied(class AINSSoldier* Soldier)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerController.ClientOnPlayerResupplied");
		
		AINSPlayerController_ClientOnPlayerResupplied_Params params {};
		params.Soldier = Soldier;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056A04D0
	 * 		Name   -> Function Insurgency.INSPlayerController.ClientNotifyKickReason
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetClient)
	 * Parameters:
	 * 		EPlayerKickReason                                  KickReason                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSPlayerController::ClientNotifyKickReason(EPlayerKickReason KickReason)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerController.ClientNotifyKickReason");
		
		AINSPlayerController_ClientNotifyKickReason_Params params {};
		params.KickReason = KickReason;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056A0450
	 * 		Name   -> Function Insurgency.INSPlayerController.ClientIdleKickWarning
	 * 		Flags  -> (Net, Native, Event, Public, NetClient)
	 * Parameters:
	 * 		int32_t                                            SecondsRemaining                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSPlayerController::ClientIdleKickWarning(int32_t SecondsRemaining)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerController.ClientIdleKickWarning");
		
		AINSPlayerController_ClientIdleKickWarning_Params params {};
		params.SecondsRemaining = SecondsRemaining;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056A0350
	 * 		Name   -> Function Insurgency.INSPlayerController.ClientFadeOut
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, HasDefaults, NetClient, BlueprintCallable)
	 * Parameters:
	 * 		struct FColor                                      FadeColor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              FadeTime                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              HoldTime                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSPlayerController::ClientFadeOut(const struct FColor& FadeColor, float FadeTime, float HoldTime)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerController.ClientFadeOut");
		
		AINSPlayerController_ClientFadeOut_Params params {};
		params.FadeColor = FadeColor;
		params.FadeTime = FadeTime;
		params.HoldTime = HoldTime;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056A0250
	 * 		Name   -> Function Insurgency.INSPlayerController.ClientFadeIn
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, HasDefaults, NetClient, BlueprintCallable)
	 * Parameters:
	 * 		struct FColor                                      FadeColor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              FadeTime                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              HoldTime                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSPlayerController::ClientFadeIn(const struct FColor& FadeColor, float FadeTime, float HoldTime)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerController.ClientFadeIn");
		
		AINSPlayerController_ClientFadeIn_Params params {};
		params.FadeColor = FadeColor;
		params.FadeTime = FadeTime;
		params.HoldTime = HoldTime;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056A0110
	 * 		Name   -> Function Insurgency.INSPlayerController.ClientEnterMatchTransitionState
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, HasDefaults, NetClient)
	 * Parameters:
	 * 		struct FGuid                                       TicketId                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FString                                      Scenario                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FString                                      Options                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSPlayerController::ClientEnterMatchTransitionState(const struct FGuid& TicketId, const class FString& Scenario, const class FString& Options)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerController.ClientEnterMatchTransitionState");
		
		AINSPlayerController_ClientEnterMatchTransitionState_Params params {};
		params.TicketId = TicketId;
		params.Scenario = Scenario;
		params.Options = Options;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056A0030
	 * 		Name   -> Function Insurgency.INSPlayerController.ClientEndOnlineRatedMatch
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetClient)
	 * Parameters:
	 * 		bool                                               bHasRatingUpdate                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FMatchScoreChange                           PlayerChange                                               (ConstParm, Parm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void AINSPlayerController::ClientEndOnlineRatedMatch(bool bHasRatingUpdate, const struct FMatchScoreChange& PlayerChange)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerController.ClientEndOnlineRatedMatch");
		
		AINSPlayerController_ClientEndOnlineRatedMatch_Params params {};
		params.bHasRatingUpdate = bHasRatingUpdate;
		params.PlayerChange = PlayerChange;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0569FF40
	 * 		Name   -> Function Insurgency.INSPlayerController.ClientConnectVoiceChat
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetClient)
	 * Parameters:
	 * 		class FString                                      VoiceSessionId                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FString                                      ConnectToken                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSPlayerController::ClientConnectVoiceChat(const class FString& VoiceSessionId, const class FString& ConnectToken)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerController.ClientConnectVoiceChat");
		
		AINSPlayerController_ClientConnectVoiceChat_Params params {};
		params.VoiceSessionId = VoiceSessionId;
		params.ConnectToken = ConnectToken;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0569FEF0
	 * 		Name   -> Function Insurgency.INSPlayerController.ClientConfirmScenarioAssetsLoaded
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetClient, NetValidate)
	 */
	void AINSPlayerController::ClientConfirmScenarioAssetsLoaded()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerController.ClientConfirmScenarioAssetsLoaded");
		
		AINSPlayerController_ClientConfirmScenarioAssetsLoaded_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0569FE70
	 * 		Name   -> Function Insurgency.INSPlayerController.ClientConfirmMapVoteSelection
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetClient)
	 * Parameters:
	 * 		EMapVoteSelection                                  VotedIndex                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSPlayerController::ClientConfirmMapVoteSelection(EMapVoteSelection VotedIndex)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerController.ClientConfirmMapVoteSelection");
		
		AINSPlayerController_ClientConfirmMapVoteSelection_Params params {};
		params.VotedIndex = VotedIndex;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0569FDF0
	 * 		Name   -> Function Insurgency.INSPlayerController.ClientClearDeathFade
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetClient, BlueprintCallable)
	 * Parameters:
	 * 		float                                              FadeTime                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSPlayerController::ClientClearDeathFade(float FadeTime)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerController.ClientClearDeathFade");
		
		AINSPlayerController_ClientClearDeathFade_Params params {};
		params.FadeTime = FadeTime;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0569FD30
	 * 		Name   -> Function Insurgency.INSPlayerController.ClientChangeVoiceChatChannels
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetClient)
	 * Parameters:
	 * 		unsigned char                                      TeamId                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EVoiceChatChannelFlags                             Flags                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSPlayerController::ClientChangeVoiceChatChannels(unsigned char TeamId, EVoiceChatChannelFlags Flags)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerController.ClientChangeVoiceChatChannels");
		
		AINSPlayerController_ClientChangeVoiceChatChannels_Params params {};
		params.TeamId = TeamId;
		params.Flags = Flags;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0569FC60
	 * 		Name   -> Function Insurgency.INSPlayerController.ClientCastVoteResult
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetClient)
	 * Parameters:
	 * 		ECastVoteResult                                    Result                                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bTeamOnlyVote                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSPlayerController::ClientCastVoteResult(ECastVoteResult Result, bool bTeamOnlyVote)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerController.ClientCastVoteResult");
		
		AINSPlayerController_ClientCastVoteResult_Params params {};
		params.Result = Result;
		params.bTeamOnlyVote = bTeamOnlyVote;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0569FC40
	 * 		Name   -> Function Insurgency.INSPlayerController.ClientBroadcastPendingMenuAction
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetClient)
	 */
	void AINSPlayerController::ClientBroadcastPendingMenuAction()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerController.ClientBroadcastPendingMenuAction");
		
		AINSPlayerController_ClientBroadcastPendingMenuAction_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0569FB40
	 * 		Name   -> Function Insurgency.INSPlayerController.ClientAddCompassMarker
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetClient, BlueprintCallable)
	 * Parameters:
	 * 		struct FVector_NetQuantize                         WorldLocation                                              (ConstParm, Parm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      FollowActor                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		ECompassMarkerType                                 MarkerType                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSPlayerController::ClientAddCompassMarker(const struct FVector_NetQuantize& WorldLocation, class AActor* FollowActor, ECompassMarkerType MarkerType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerController.ClientAddCompassMarker");
		
		AINSPlayerController_ClientAddCompassMarker_Params params {};
		params.WorldLocation = WorldLocation;
		params.FollowActor = FollowActor;
		params.MarkerType = MarkerType;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0569FAC0
	 * 		Name   -> Function Insurgency.INSPlayerController.ChoosePlayerClassLoadout
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		int32_t                                            LoadoutIndex                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSPlayerController::ChoosePlayerClassLoadout(int32_t LoadoutIndex)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerController.ChoosePlayerClassLoadout");
		
		AINSPlayerController_ChoosePlayerClassLoadout_Params params {};
		params.LoadoutIndex = LoadoutIndex;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0569FAA0
	 * 		Name   -> Function Insurgency.INSPlayerController.CheckInventorySelectType
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void AINSPlayerController::CheckInventorySelectType()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerController.CheckInventorySelectType");
		
		AINSPlayerController_CheckInventorySelectType_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0569FA20
	 * 		Name   -> Function Insurgency.INSPlayerController.ChangeFaction
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		unsigned char                                      NewFactionId                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSPlayerController::ChangeFaction(unsigned char NewFactionId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerController.ChangeFaction");
		
		AINSPlayerController_ChangeFaction_Params params {};
		params.NewFactionId = NewFactionId;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0569F960
	 * 		Name   -> Function Insurgency.INSPlayerController.CastVoteChecked
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		int32_t                                            ChoiceIndex                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bTeamOnlyVote                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSPlayerController::CastVoteChecked(int32_t ChoiceIndex, bool bTeamOnlyVote)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerController.CastVoteChecked");
		
		AINSPlayerController_CastVoteChecked_Params params {};
		params.ChoiceIndex = ChoiceIndex;
		params.bTeamOnlyVote = bTeamOnlyVote;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0569F8C0
	 * 		Name   -> Function Insurgency.INSPlayerController.CanRequestSelectedFireSupport
	 * 		Flags  -> (Final, Native, Public, HasDefaults)
	 * Parameters:
	 * 		struct FVector                                     RequestLocation                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FFireSupportRequestResult AINSPlayerController::CanRequestSelectedFireSupport(const struct FVector& RequestLocation)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerController.CanRequestSelectedFireSupport");
		
		AINSPlayerController_CanRequestSelectedFireSupport_Params params {};
		params.RequestLocation = RequestLocation;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0569F890
	 * 		Name   -> Function Insurgency.INSPlayerController.CanCallVote
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AINSPlayerController::CanCallVote()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerController.CanCallVote");
		
		AINSPlayerController_CanCallVote_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0569F810
	 * 		Name   -> Function Insurgency.INSPlayerController.BroadcastMenuStateChange
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, Const)
	 * Parameters:
	 * 		EIngameMenuType                                    EnteredState                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSPlayerController::BroadcastMenuStateChange(EIngameMenuType EnteredState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerController.BroadcastMenuStateChange");
		
		AINSPlayerController_BroadcastMenuStateChange_Params params {};
		params.EnteredState = EnteredState;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0569F7F0
	 * 		Name   -> Function Insurgency.INSPlayerController.BreakTutorialPause
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void AINSPlayerController::BreakTutorialPause()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerController.BreakTutorialPause");
		
		AINSPlayerController_BreakTutorialPause_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0569F7D0
	 * 		Name   -> Function Insurgency.INSPlayerController.BindToggleMenuInsteadToggleLessons
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void AINSPlayerController::BindToggleMenuInsteadToggleLessons()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerController.BindToggleMenuInsteadToggleLessons");
		
		AINSPlayerController_BindToggleMenuInsteadToggleLessons_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0569F7B0
	 * 		Name   -> Function Insurgency.INSPlayerController.BindToggleLessonsInsteadToggleMenu
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void AINSPlayerController::BindToggleLessonsInsteadToggleMenu()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerController.BindToggleLessonsInsteadToggleMenu");
		
		AINSPlayerController_BindToggleLessonsInsteadToggleMenu_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0569F790
	 * 		Name   -> Function Insurgency.INSPlayerController.BenchmarkStart
	 * 		Flags  -> (Final, Exec, Native, Public)
	 */
	void AINSPlayerController::BenchmarkStart()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerController.BenchmarkStart");
		
		AINSPlayerController_BenchmarkStart_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0569F690
	 * 		Name   -> Function Insurgency.INSPlayerController.BeginQueuedFadeIn
	 * 		Flags  -> (Final, Native, Private, HasDefaults)
	 * Parameters:
	 * 		struct FColor                                      Color                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Duration                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              TargetAlpha                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSPlayerController::BeginQueuedFadeIn(const struct FColor& Color, float Duration, float TargetAlpha)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerController.BeginQueuedFadeIn");
		
		AINSPlayerController_BeginQueuedFadeIn_Params params {};
		params.Color = Color;
		params.Duration = Duration;
		params.TargetAlpha = TargetAlpha;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> DelegateFunction Insurgency.INSPlayerController.AmmoUpdatedDelegate__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 */
	void AINSPlayerController::AmmoUpdatedDelegate__DelegateSignature()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction Insurgency.INSPlayerController.AmmoUpdatedDelegate__DelegateSignature");
		
		AINSPlayerController_AmmoUpdatedDelegate__DelegateSignature_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0569F5F0
	 * 		Name   -> Function Insurgency.INSPlayerController.AddHQAnnouncement
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		struct FAudioAnnouncementCue                       Cue                                                        (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void AINSPlayerController::AddHQAnnouncement(const struct FAudioAnnouncementCue& Cue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerController.AddHQAnnouncement");
		
		AINSPlayerController_AddHQAnnouncement_Params params {};
		params.Cue = Cue;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0569F530
	 * 		Name   -> Function Insurgency.INSPlayerController.AddCompassMarkerOnActor
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class AActor*                                      Actor                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		ECompassMarkerType                                 MarkerType                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSPlayerController::AddCompassMarkerOnActor(class AActor* Actor, ECompassMarkerType MarkerType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerController.AddCompassMarkerOnActor");
		
		AINSPlayerController_AddCompassMarkerOnActor_Params params {};
		params.Actor = Actor;
		params.MarkerType = MarkerType;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> DelegateFunction Insurgency.INSPlayerController.AddCompassMarkerDelegate__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate, HasOutParms, HasDefaults)
	 * Parameters:
	 * 		struct FVector                                     WorldLocation                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      FollowActor                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		ECompassMarkerType                                 MarkerType                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSPlayerController::AddCompassMarkerDelegate__DelegateSignature(const struct FVector& WorldLocation, class AActor* FollowActor, ECompassMarkerType MarkerType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction Insurgency.INSPlayerController.AddCompassMarkerDelegate__DelegateSignature");
		
		AINSPlayerController_AddCompassMarkerDelegate__DelegateSignature_Params params {};
		params.WorldLocation = WorldLocation;
		params.FollowActor = FollowActor;
		params.MarkerType = MarkerType;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0569F450
	 * 		Name   -> Function Insurgency.INSPlayerController.AddCompassMarker
	 * 		Flags  -> (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FVector                                     WorldLocation                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		ECompassMarkerType                                 MarkerType                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSPlayerController::AddCompassMarker(const struct FVector& WorldLocation, ECompassMarkerType MarkerType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerController.AddCompassMarker");
		
		AINSPlayerController_AddCompassMarker_Params params {};
		params.WorldLocation = WorldLocation;
		params.MarkerType = MarkerType;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AINSPlayerController.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AINSPlayerController::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.INSPlayerController");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UINSPlayerInput.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UINSPlayerInput::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.INSPlayerInput");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056AE720
	 * 		Name   -> Function Insurgency.INSPlayerLocalProfile.UpdateServerBrowserPreferences
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		struct FServerBrowserPreferences                   NewPreferences                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UINSPlayerLocalProfile::UpdateServerBrowserPreferences(const struct FServerBrowserPreferences& NewPreferences)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerLocalProfile.UpdateServerBrowserPreferences");
		
		UINSPlayerLocalProfile_UpdateServerBrowserPreferences_Params params {};
		params.NewPreferences = NewPreferences;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056AE5D0
	 * 		Name   -> Function Insurgency.INSPlayerLocalProfile.UpdatePointShootPreference
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               Mode                                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UINSPlayerLocalProfile::UpdatePointShootPreference(bool Mode)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerLocalProfile.UpdatePointShootPreference");
		
		UINSPlayerLocalProfile_UpdatePointShootPreference_Params params {};
		params.Mode = Mode;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056AE3E0
	 * 		Name   -> Function Insurgency.INSPlayerLocalProfile.UpdatePlayerClassDefaultLoadout
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		TArray<struct FBasicLoadoutItem>                   Items                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bIsNight                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UINSPlayerLocalProfile::UpdatePlayerClassDefaultLoadout(TArray<struct FBasicLoadoutItem> Items, bool bIsNight)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerLocalProfile.UpdatePlayerClassDefaultLoadout");
		
		UINSPlayerLocalProfile_UpdatePlayerClassDefaultLoadout_Params params {};
		params.Items = Items;
		params.bIsNight = bIsNight;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056AE2A0
	 * 		Name   -> Function Insurgency.INSPlayerLocalProfile.UpdateOpticPreference
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		int32_t                                            Mode                                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UINSPlayerLocalProfile::UpdateOpticPreference(int32_t Mode)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerLocalProfile.UpdateOpticPreference");
		
		UINSPlayerLocalProfile_UpdateOpticPreference_Params params {};
		params.Mode = Mode;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056AE170
	 * 		Name   -> Function Insurgency.INSPlayerLocalProfile.UpdateLastEquippedPrimary
	 * 		Flags  -> (Final, Native, Public, HasOutParms)
	 * Parameters:
	 * 		class FName                                        InFactionName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FBasicLoadoutItem                           InItem                                                     (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UINSPlayerLocalProfile::UpdateLastEquippedPrimary(const class FName& InFactionName, const struct FBasicLoadoutItem& InItem)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerLocalProfile.UpdateLastEquippedPrimary");
		
		UINSPlayerLocalProfile_UpdateLastEquippedPrimary_Params params {};
		params.InFactionName = InFactionName;
		params.InItem = InItem;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056AE030
	 * 		Name   -> Function Insurgency.INSPlayerLocalProfile.UpdateFiremodePreference
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		EFirearmFiremode                                   Firemode                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UINSPlayerLocalProfile::UpdateFiremodePreference(EFirearmFiremode Firemode)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerLocalProfile.UpdateFiremodePreference");
		
		UINSPlayerLocalProfile_UpdateFiremodePreference_Params params {};
		params.Firemode = Firemode;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056ADFA0
	 * 		Name   -> Function Insurgency.INSPlayerLocalProfile.ShouldHideReplayFromHistory
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		int32_t                                            ReplayID                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UINSPlayerLocalProfile::ShouldHideReplayFromHistory(int32_t ReplayID)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerLocalProfile.ShouldHideReplayFromHistory");
		
		UINSPlayerLocalProfile_ShouldHideReplayFromHistory_Params params {};
		params.ReplayID = ReplayID;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056ADED0
	 * 		Name   -> Function Insurgency.INSPlayerLocalProfile.SetUseScopeSensitivityScale
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bGamepad                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bNewSetting                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UINSPlayerLocalProfile::SetUseScopeSensitivityScale(bool bGamepad, bool bNewSetting)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerLocalProfile.SetUseScopeSensitivityScale");
		
		UINSPlayerLocalProfile_SetUseScopeSensitivityScale_Params params {};
		params.bGamepad = bGamepad;
		params.bNewSetting = bNewSetting;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056ADEB0
	 * 		Name   -> Function Insurgency.INSPlayerLocalProfile.SetToDefaults
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void UINSPlayerLocalProfile::SetToDefaults()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerLocalProfile.SetToDefaults");
		
		UINSPlayerLocalProfile_SetToDefaults_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056ADDA0
	 * 		Name   -> Function Insurgency.INSPlayerLocalProfile.SetSensitivityScaleForOpticZoom
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bGamepad                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EOpticZoomLevel                                    ZoomLevel                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              NewVal                                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UINSPlayerLocalProfile::SetSensitivityScaleForOpticZoom(bool bGamepad, EOpticZoomLevel ZoomLevel, float NewVal)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerLocalProfile.SetSensitivityScaleForOpticZoom");
		
		UINSPlayerLocalProfile_SetSensitivityScaleForOpticZoom_Params params {};
		params.bGamepad = bGamepad;
		params.ZoomLevel = ZoomLevel;
		params.NewVal = NewVal;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056ADD20
	 * 		Name   -> Function Insurgency.INSPlayerLocalProfile.SetScoreboardBadgeFromItemId
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		int32_t                                            NewScoreboardBadgeItemId                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UINSPlayerLocalProfile::SetScoreboardBadgeFromItemId(int32_t NewScoreboardBadgeItemId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerLocalProfile.SetScoreboardBadgeFromItemId");
		
		UINSPlayerLocalProfile_SetScoreboardBadgeFromItemId_Params params {};
		params.NewScoreboardBadgeItemId = NewScoreboardBadgeItemId;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056ADCA0
	 * 		Name   -> Function Insurgency.INSPlayerLocalProfile.SetScoreboardBadge
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		int32_t                                            NewScoreboardBadge                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UINSPlayerLocalProfile::SetScoreboardBadge(int32_t NewScoreboardBadge)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerLocalProfile.SetScoreboardBadge");
		
		UINSPlayerLocalProfile_SetScoreboardBadge_Params params {};
		params.NewScoreboardBadge = NewScoreboardBadge;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056ADBD0
	 * 		Name   -> Function Insurgency.INSPlayerLocalProfile.SetScopeSensitivityScaleUsesWorldFOV
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bGamepad                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bNewSetting                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UINSPlayerLocalProfile::SetScopeSensitivityScaleUsesWorldFOV(bool bGamepad, bool bNewSetting)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerLocalProfile.SetScopeSensitivityScaleUsesWorldFOV");
		
		UINSPlayerLocalProfile_SetScopeSensitivityScaleUsesWorldFOV_Params params {};
		params.bGamepad = bGamepad;
		params.bNewSetting = bNewSetting;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056ADB00
	 * 		Name   -> Function Insurgency.INSPlayerLocalProfile.SetScopeSensitivityScale
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bGamepad                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              NewSetting                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UINSPlayerLocalProfile::SetScopeSensitivityScale(bool bGamepad, float NewSetting)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerLocalProfile.SetScopeSensitivityScale");
		
		UINSPlayerLocalProfile_SetScopeSensitivityScale_Params params {};
		params.bGamepad = bGamepad;
		params.NewSetting = NewSetting;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056ADA70
	 * 		Name   -> Function Insurgency.INSPlayerLocalProfile.SetRadialToggle
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bSetting                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UINSPlayerLocalProfile::SetRadialToggle(bool bSetting)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerLocalProfile.SetRadialToggle");
		
		UINSPlayerLocalProfile_SetRadialToggle_Params params {};
		params.bSetting = bSetting;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056AD9F0
	 * 		Name   -> Function Insurgency.INSPlayerLocalProfile.SetPreferredFaction
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class FName                                        FactionPref                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UINSPlayerLocalProfile::SetPreferredFaction(const class FName& FactionPref)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerLocalProfile.SetPreferredFaction");
		
		UINSPlayerLocalProfile_SetPreferredFaction_Params params {};
		params.FactionPref = FactionPref;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056AD8E0
	 * 		Name   -> Function Insurgency.INSPlayerLocalProfile.SetPlaylistSelected
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		EPlaylistType                                      Type                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UPlaylist*                                   Playlist                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bSelected                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UINSPlayerLocalProfile::SetPlaylistSelected(EPlaylistType Type, class UPlaylist* Playlist, bool bSelected)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerLocalProfile.SetPlaylistSelected");
		
		UINSPlayerLocalProfile_SetPlaylistSelected_Params params {};
		params.Type = Type;
		params.Playlist = Playlist;
		params.bSelected = bSelected;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056AD860
	 * 		Name   -> Function Insurgency.INSPlayerLocalProfile.SetMouseSensitivity
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		float                                              Val                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UINSPlayerLocalProfile::SetMouseSensitivity(float Val)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerLocalProfile.SetMouseSensitivity");
		
		UINSPlayerLocalProfile_SetMouseSensitivity_Params params {};
		params.Val = Val;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056AD7D0
	 * 		Name   -> Function Insurgency.INSPlayerLocalProfile.SetManualBipod
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bSetting                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UINSPlayerLocalProfile::SetManualBipod(bool bSetting)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerLocalProfile.SetManualBipod");
		
		UINSPlayerLocalProfile_SetManualBipod_Params params {};
		params.bSetting = bSetting;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056AD7B0
	 * 		Name   -> Function Insurgency.INSPlayerLocalProfile.SetKeyBindingsToDefaults
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void UINSPlayerLocalProfile::SetKeyBindingsToDefaults()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerLocalProfile.SetKeyBindingsToDefaults");
		
		UINSPlayerLocalProfile_SetKeyBindingsToDefaults_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056AD720
	 * 		Name   -> Function Insurgency.INSPlayerLocalProfile.SetInvertedYAxisMouse
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bSetting                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UINSPlayerLocalProfile::SetInvertedYAxisMouse(bool bSetting)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerLocalProfile.SetInvertedYAxisMouse");
		
		UINSPlayerLocalProfile_SetInvertedYAxisMouse_Params params {};
		params.bSetting = bSetting;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056AD690
	 * 		Name   -> Function Insurgency.INSPlayerLocalProfile.SetInvertedYAxis
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bSetting                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UINSPlayerLocalProfile::SetInvertedYAxis(bool bSetting)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerLocalProfile.SetInvertedYAxis");
		
		UINSPlayerLocalProfile_SetInvertedYAxis_Params params {};
		params.bSetting = bSetting;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056AD610
	 * 		Name   -> Function Insurgency.INSPlayerLocalProfile.SetGamepadYSensitivity
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		float                                              Val                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UINSPlayerLocalProfile::SetGamepadYSensitivity(float Val)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerLocalProfile.SetGamepadYSensitivity");
		
		UINSPlayerLocalProfile_SetGamepadYSensitivity_Params params {};
		params.Val = Val;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056AD590
	 * 		Name   -> Function Insurgency.INSPlayerLocalProfile.SetGamepadXSensitivity
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		float                                              Val                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UINSPlayerLocalProfile::SetGamepadXSensitivity(float Val)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerLocalProfile.SetGamepadXSensitivity");
		
		UINSPlayerLocalProfile_SetGamepadXSensitivity_Params params {};
		params.Val = Val;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056AD510
	 * 		Name   -> Function Insurgency.INSPlayerLocalProfile.SetGamepadDeadzoneInnerRight
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		float                                              InValue                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UINSPlayerLocalProfile::SetGamepadDeadzoneInnerRight(float InValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerLocalProfile.SetGamepadDeadzoneInnerRight");
		
		UINSPlayerLocalProfile_SetGamepadDeadzoneInnerRight_Params params {};
		params.InValue = InValue;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056AD490
	 * 		Name   -> Function Insurgency.INSPlayerLocalProfile.SetGamepadDeadzoneInnerLeft
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		float                                              InValue                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UINSPlayerLocalProfile::SetGamepadDeadzoneInnerLeft(float InValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerLocalProfile.SetGamepadDeadzoneInnerLeft");
		
		UINSPlayerLocalProfile_SetGamepadDeadzoneInnerLeft_Params params {};
		params.InValue = InValue;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056AD380
	 * 		Name   -> Function Insurgency.INSPlayerLocalProfile.SetGamepadDampeningSettings
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		float                                              NewDampeningStrength                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              NewDampeningSize                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              NewDampeningEaseIn                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UINSPlayerLocalProfile::SetGamepadDampeningSettings(float NewDampeningStrength, float NewDampeningSize, float NewDampeningEaseIn)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerLocalProfile.SetGamepadDampeningSettings");
		
		UINSPlayerLocalProfile_SetGamepadDampeningSettings_Params params {};
		params.NewDampeningStrength = NewDampeningStrength;
		params.NewDampeningSize = NewDampeningSize;
		params.NewDampeningEaseIn = NewDampeningEaseIn;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056AD300
	 * 		Name   -> Function Insurgency.INSPlayerLocalProfile.SetGamepadAimSensitivityCurve
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		EGamepadSensitivityCurve                           NewCurve                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UINSPlayerLocalProfile::SetGamepadAimSensitivityCurve(EGamepadSensitivityCurve NewCurve)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerLocalProfile.SetGamepadAimSensitivityCurve");
		
		UINSPlayerLocalProfile_SetGamepadAimSensitivityCurve_Params params {};
		params.NewCurve = NewCurve;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056AD1F0
	 * 		Name   -> Function Insurgency.INSPlayerLocalProfile.SetGamepadAccelerationSettings
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		float                                              NewTimeThreshold                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              NewTimeToReachMax                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              NewMaxMultiplier                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UINSPlayerLocalProfile::SetGamepadAccelerationSettings(float NewTimeThreshold, float NewTimeToReachMax, float NewMaxMultiplier)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerLocalProfile.SetGamepadAccelerationSettings");
		
		UINSPlayerLocalProfile_SetGamepadAccelerationSettings_Params params {};
		params.NewTimeThreshold = NewTimeThreshold;
		params.NewTimeToReachMax = NewTimeToReachMax;
		params.NewMaxMultiplier = NewMaxMultiplier;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056AD160
	 * 		Name   -> Function Insurgency.INSPlayerLocalProfile.SetGamepadAccelerationEnabled
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bEnabled                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UINSPlayerLocalProfile::SetGamepadAccelerationEnabled(bool bEnabled)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerLocalProfile.SetGamepadAccelerationEnabled");
		
		UINSPlayerLocalProfile_SetGamepadAccelerationEnabled_Params params {};
		params.bEnabled = bEnabled;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056AD0E0
	 * 		Name   -> Function Insurgency.INSPlayerLocalProfile.SetFreeaimDeadzoneScale
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		float                                              NewScale                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UINSPlayerLocalProfile::SetFreeaimDeadzoneScale(float NewScale)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerLocalProfile.SetFreeaimDeadzoneScale");
		
		UINSPlayerLocalProfile_SetFreeaimDeadzoneScale_Params params {};
		params.NewScale = NewScale;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056AD060
	 * 		Name   -> Function Insurgency.INSPlayerLocalProfile.SetFreeaimDeadzoneMinimumSensitivity
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		float                                              NewSensitivity                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UINSPlayerLocalProfile::SetFreeaimDeadzoneMinimumSensitivity(float NewSensitivity)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerLocalProfile.SetFreeaimDeadzoneMinimumSensitivity");
		
		UINSPlayerLocalProfile_SetFreeaimDeadzoneMinimumSensitivity_Params params {};
		params.NewSensitivity = NewSensitivity;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056ACFD0
	 * 		Name   -> Function Insurgency.INSPlayerLocalProfile.SetFreeaimDeadzoneEnabled
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bNewEnabled                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UINSPlayerLocalProfile::SetFreeaimDeadzoneEnabled(bool bNewEnabled)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerLocalProfile.SetFreeaimDeadzoneEnabled");
		
		UINSPlayerLocalProfile_SetFreeaimDeadzoneEnabled_Params params {};
		params.bNewEnabled = bNewEnabled;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056ACDB0
	 * 		Name   -> Function Insurgency.INSPlayerLocalProfile.SetFOVSensitivityScaling
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bGamepad                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bNewSetting                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UINSPlayerLocalProfile::SetFOVSensitivityScaling(bool bGamepad, bool bNewSetting)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerLocalProfile.SetFOVSensitivityScaling");
		
		UINSPlayerLocalProfile_SetFOVSensitivityScaling_Params params {};
		params.bGamepad = bGamepad;
		params.bNewSetting = bNewSetting;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056ACF50
	 * 		Name   -> Function Insurgency.INSPlayerLocalProfile.SetForceFeedbackIntensity
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		float                                              Val                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UINSPlayerLocalProfile::SetForceFeedbackIntensity(float Val)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerLocalProfile.SetForceFeedbackIntensity");
		
		UINSPlayerLocalProfile_SetForceFeedbackIntensity_Params params {};
		params.Val = Val;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056ACE80
	 * 		Name   -> Function Insurgency.INSPlayerLocalProfile.SetFocusSensitivityScale
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bGamepad                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Val                                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UINSPlayerLocalProfile::SetFocusSensitivityScale(bool bGamepad, float Val)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerLocalProfile.SetFocusSensitivityScale");
		
		UINSPlayerLocalProfile_SetFocusSensitivityScale_Params params {};
		params.bGamepad = bGamepad;
		params.Val = Val;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056ACC30
	 * 		Name   -> Function Insurgency.INSPlayerLocalProfile.SetControlSettingsToDefaults
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void UINSPlayerLocalProfile::SetControlSettingsToDefaults()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerLocalProfile.SetControlSettingsToDefaults");
		
		UINSPlayerLocalProfile_SetControlSettingsToDefaults_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056ACCD0
	 * 		Name   -> Function Insurgency.INSPlayerLocalProfile.SetControllerLayoutName
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class FString                                      InName                                                     (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UINSPlayerLocalProfile::SetControllerLayoutName(const class FString& InName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerLocalProfile.SetControllerLayoutName");
		
		UINSPlayerLocalProfile_SetControllerLayoutName_Params params {};
		params.InName = InName;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056ACC50
	 * 		Name   -> Function Insurgency.INSPlayerLocalProfile.SetControllerLayout
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UControllerLayout*                           Layout                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UINSPlayerLocalProfile::SetControllerLayout(class UControllerLayout* Layout)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerLocalProfile.SetControllerLayout");
		
		UINSPlayerLocalProfile_SetControllerLayout_Params params {};
		params.Layout = Layout;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056ACBA0
	 * 		Name   -> Function Insurgency.INSPlayerLocalProfile.SetAutoLean
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bState                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UINSPlayerLocalProfile::SetAutoLean(bool bState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerLocalProfile.SetAutoLean");
		
		UINSPlayerLocalProfile_SetAutoLean_Params params {};
		params.bState = bState;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056ACAD0
	 * 		Name   -> Function Insurgency.INSPlayerLocalProfile.SetAimingSensitivityScale
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bGamepad                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              NewSetting                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UINSPlayerLocalProfile::SetAimingSensitivityScale(bool bGamepad, float NewSetting)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerLocalProfile.SetAimingSensitivityScale");
		
		UINSPlayerLocalProfile_SetAimingSensitivityScale_Params params {};
		params.bGamepad = bGamepad;
		params.NewSetting = NewSetting;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056ACA50
	 * 		Name   -> Function Insurgency.INSPlayerLocalProfile.SaveToCloud
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		int32_t                                            SpecificBlocks                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UINSPlayerLocalProfile::SaveToCloud(int32_t SpecificBlocks)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerLocalProfile.SaveToCloud");
		
		UINSPlayerLocalProfile_SaveToCloud_Params params {};
		params.SpecificBlocks = SpecificBlocks;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056AC930
	 * 		Name   -> Function Insurgency.INSPlayerLocalProfile.SaveProfileBlockToCloud
	 * 		Flags  -> (Final, Native, Public, HasOutParms)
	 * Parameters:
	 * 		struct FProfileSaveBlock                           ProfileBlock                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UINSPlayerLocalProfile::SaveProfileBlockToCloud(const struct FProfileSaveBlock& ProfileBlock)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerLocalProfile.SaveProfileBlockToCloud");
		
		UINSPlayerLocalProfile_SaveProfileBlockToCloud_Params params {};
		params.ProfileBlock = ProfileBlock;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056AC820
	 * 		Name   -> Function Insurgency.INSPlayerLocalProfile.SaveProfileBlock
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		EProfileBlockType                                  Type                                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bToCloud                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bIncrementRevision                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UINSPlayerLocalProfile::SaveProfileBlock(EProfileBlockType Type, bool bToCloud, bool bIncrementRevision)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerLocalProfile.SaveProfileBlock");
		
		UINSPlayerLocalProfile_SaveProfileBlock_Params params {};
		params.Type = Type;
		params.bToCloud = bToCloud;
		params.bIncrementRevision = bIncrementRevision;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056AC5B0
	 * 		Name   -> Function Insurgency.INSPlayerLocalProfile.SavePlayerClassLoadout
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		class FText                                        LoadoutName                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		TArray<struct FBasicLoadoutItem>                   Items                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bNightMode                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UINSPlayerLocalProfile::SavePlayerClassLoadout(const class FText& LoadoutName, TArray<struct FBasicLoadoutItem> Items, bool bNightMode)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerLocalProfile.SavePlayerClassLoadout");
		
		UINSPlayerLocalProfile_SavePlayerClassLoadout_Params params {};
		params.LoadoutName = LoadoutName;
		params.Items = Items;
		params.bNightMode = bNightMode;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056AC590
	 * 		Name   -> Function Insurgency.INSPlayerLocalProfile.SaveLocalProfileIfDirty
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void UINSPlayerLocalProfile::SaveLocalProfileIfDirty()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerLocalProfile.SaveLocalProfileIfDirty");
		
		UINSPlayerLocalProfile_SaveLocalProfileIfDirty_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056AC570
	 * 		Name   -> Function Insurgency.INSPlayerLocalProfile.SaveLocalProfile
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void UINSPlayerLocalProfile::SaveLocalProfile()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerLocalProfile.SaveLocalProfile");
		
		UINSPlayerLocalProfile_SaveLocalProfile_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056AC3E0
	 * 		Name   -> Function Insurgency.INSPlayerLocalProfile.SaveActivePresetIndex
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		int32_t                                            ActivePresetIndex                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bNightMode                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UINSPlayerLocalProfile::SaveActivePresetIndex(int32_t ActivePresetIndex, bool bNightMode)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerLocalProfile.SaveActivePresetIndex");
		
		UINSPlayerLocalProfile_SaveActivePresetIndex_Params params {};
		params.ActivePresetIndex = ActivePresetIndex;
		params.bNightMode = bNightMode;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056AC2B0
	 * 		Name   -> Function Insurgency.INSPlayerLocalProfile.SaveAchievementPercent
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class FString                                      AchType                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Value                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UINSPlayerLocalProfile::SaveAchievementPercent(const class FString& AchType, float Value)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerLocalProfile.SaveAchievementPercent");
		
		UINSPlayerLocalProfile_SaveAchievementPercent_Params params {};
		params.AchType = AchType;
		params.Value = Value;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056AC290
	 * 		Name   -> Function Insurgency.INSPlayerLocalProfile.ResetServerBrowserPreferences
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void UINSPlayerLocalProfile::ResetServerBrowserPreferences()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerLocalProfile.ResetServerBrowserPreferences");
		
		UINSPlayerLocalProfile_ResetServerBrowserPreferences_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056AC270
	 * 		Name   -> Function Insurgency.INSPlayerLocalProfile.ResetLessons
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void UINSPlayerLocalProfile::ResetLessons()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerLocalProfile.ResetLessons");
		
		UINSPlayerLocalProfile_ResetLessons_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056AC250
	 * 		Name   -> Function Insurgency.INSPlayerLocalProfile.ResetLastMatchStats
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void UINSPlayerLocalProfile::ResetLastMatchStats()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerLocalProfile.ResetLastMatchStats");
		
		UINSPlayerLocalProfile_ResetLastMatchStats_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00C76AB0
	 * 		Name   -> Function Insurgency.INSPlayerLocalProfile.ResetFavoritedServers
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void UINSPlayerLocalProfile::ResetFavoritedServers()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerLocalProfile.ResetFavoritedServers");
		
		UINSPlayerLocalProfile_ResetFavoritedServers_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056AC190
	 * 		Name   -> Function Insurgency.INSPlayerLocalProfile.ReplaceActionMappings
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class FName                                        OldBinding                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FName                                        NewBinding                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UINSPlayerLocalProfile::ReplaceActionMappings(const class FName& OldBinding, const class FName& NewBinding)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerLocalProfile.ReplaceActionMappings");
		
		UINSPlayerLocalProfile_ReplaceActionMappings_Params params {};
		params.OldBinding = OldBinding;
		params.NewBinding = NewBinding;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056ABFE0
	 * 		Name   -> Function Insurgency.INSPlayerLocalProfile.ReplaceActionMappingKey
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class FName                                        MatchingBinding                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FKey                                        OldKey                                                     (ConstParm, Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FKey                                        NewKey                                                     (ConstParm, Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UINSPlayerLocalProfile::ReplaceActionMappingKey(const class FName& MatchingBinding, const struct FKey& OldKey, const struct FKey& NewKey)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerLocalProfile.ReplaceActionMappingKey");
		
		UINSPlayerLocalProfile_ReplaceActionMappingKey_Params params {};
		params.MatchingBinding = MatchingBinding;
		params.OldKey = OldKey;
		params.NewKey = NewKey;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056ABE80
	 * 		Name   -> Function Insurgency.INSPlayerLocalProfile.ReplaceActionMapping
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class FName                                        OldBinding                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FName                                        NewBinding                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FKey                                        Key                                                        (ConstParm, Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UINSPlayerLocalProfile::ReplaceActionMapping(const class FName& OldBinding, const class FName& NewBinding, const struct FKey& Key)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerLocalProfile.ReplaceActionMapping");
		
		UINSPlayerLocalProfile_ReplaceActionMapping_Params params {};
		params.OldBinding = OldBinding;
		params.NewBinding = NewBinding;
		params.Key = Key;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056ABC50
	 * 		Name   -> Function Insurgency.INSPlayerLocalProfile.RenameSavedLoadout
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		int32_t                                            PresetIndex                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FText                                        NewName                                                    (ConstParm, Parm, NativeAccessSpecifierPublic)
	 * 		bool                                               bNightMode                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UINSPlayerLocalProfile::RenameSavedLoadout(int32_t PresetIndex, const class FText& NewName, bool bNightMode)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerLocalProfile.RenameSavedLoadout");
		
		UINSPlayerLocalProfile_RenameSavedLoadout_Params params {};
		params.PresetIndex = PresetIndex;
		params.NewName = NewName;
		params.bNightMode = bNightMode;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056ABA80
	 * 		Name   -> Function Insurgency.INSPlayerLocalProfile.RemoveFavoritedServer
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		struct FBlueprintFindSessionResult                 NewRemovedServer                                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UINSPlayerLocalProfile::RemoveFavoritedServer(const struct FBlueprintFindSessionResult& NewRemovedServer)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerLocalProfile.RemoveFavoritedServer");
		
		UINSPlayerLocalProfile_RemoveFavoritedServer_Params params {};
		params.NewRemovedServer = NewRemovedServer;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056ABA60
	 * 		Name   -> Function Insurgency.INSPlayerLocalProfile.RemoveCloudDelegates
	 * 		Flags  -> (Final, Native, Public)
	 */
	void UINSPlayerLocalProfile::RemoveCloudDelegates()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerLocalProfile.RemoveCloudDelegates");
		
		UINSPlayerLocalProfile_RemoveCloudDelegates_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056AB930
	 * 		Name   -> Function Insurgency.INSPlayerLocalProfile.RemoveActionMapping
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		struct FInputActionKeyMapping                      KeyMapping                                                 (Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UINSPlayerLocalProfile::RemoveActionMapping(struct FInputActionKeyMapping* KeyMapping)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerLocalProfile.RemoveActionMapping");
		
		UINSPlayerLocalProfile_RemoveActionMapping_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (KeyMapping != nullptr)
			*KeyMapping = params.KeyMapping;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056AB8B0
	 * 		Name   -> Function Insurgency.INSPlayerLocalProfile.ReceiveLessonHint
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UClass*                                      Lesson                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UINSPlayerLocalProfile::ReceiveLessonHint(class UClass* Lesson)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerLocalProfile.ReceiveLessonHint");
		
		UINSPlayerLocalProfile_ReceiveLessonHint_Params params {};
		params.Lesson = Lesson;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056AB890
	 * 		Name   -> Function Insurgency.INSPlayerLocalProfile.OnUserConfirmedLicenseAgreement
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void UINSPlayerLocalProfile::OnUserConfirmedLicenseAgreement()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerLocalProfile.OnUserConfirmedLicenseAgreement");
		
		UINSPlayerLocalProfile_OnUserConfirmedLicenseAgreement_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> DelegateFunction Insurgency.INSPlayerLocalProfile.OnUnviewedStoreItemViewed__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 */
	void UINSPlayerLocalProfile::OnUnviewedStoreItemViewed__DelegateSignature()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction Insurgency.INSPlayerLocalProfile.OnUnviewedStoreItemViewed__DelegateSignature");
		
		UINSPlayerLocalProfile_OnUnviewedStoreItemViewed__DelegateSignature_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> DelegateFunction Insurgency.INSPlayerLocalProfile.OnUIOptionChangedDelegate__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 */
	void UINSPlayerLocalProfile::OnUIOptionChangedDelegate__DelegateSignature()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction Insurgency.INSPlayerLocalProfile.OnUIOptionChangedDelegate__DelegateSignature");
		
		UINSPlayerLocalProfile_OnUIOptionChangedDelegate__DelegateSignature_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> DelegateFunction Insurgency.INSPlayerLocalProfile.OnProfileBlockSavedDelegate__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 * Parameters:
	 * 		EProfileBlockType                                  Type                                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UINSPlayerLocalProfile::OnProfileBlockSavedDelegate__DelegateSignature(EProfileBlockType Type)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction Insurgency.INSPlayerLocalProfile.OnProfileBlockSavedDelegate__DelegateSignature");
		
		UINSPlayerLocalProfile_OnProfileBlockSavedDelegate__DelegateSignature_Params params {};
		params.Type = Type;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> DelegateFunction Insurgency.INSPlayerLocalProfile.OnProfileBlockLoadedDelegate__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 * Parameters:
	 * 		EProfileBlockType                                  Type                                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bFromCloud                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UINSPlayerLocalProfile::OnProfileBlockLoadedDelegate__DelegateSignature(EProfileBlockType Type, bool bFromCloud)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction Insurgency.INSPlayerLocalProfile.OnProfileBlockLoadedDelegate__DelegateSignature");
		
		UINSPlayerLocalProfile_OnProfileBlockLoadedDelegate__DelegateSignature_Params params {};
		params.Type = Type;
		params.bFromCloud = bFromCloud;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056AB810
	 * 		Name   -> Function Insurgency.INSPlayerLocalProfile.MarkProfileBlockDirty
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		EProfileBlockType                                  InBlock                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UINSPlayerLocalProfile::MarkProfileBlockDirty(EProfileBlockType InBlock)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerLocalProfile.MarkProfileBlockDirty");
		
		UINSPlayerLocalProfile_MarkProfileBlockDirty_Params params {};
		params.InBlock = InBlock;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056AB740
	 * 		Name   -> Function Insurgency.INSPlayerLocalProfile.LoadProfileBlock
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		EProfileBlockType                                  Type                                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bFromCloud                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UINSPlayerLocalProfile::LoadProfileBlock(EProfileBlockType Type, bool bFromCloud)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerLocalProfile.LoadProfileBlock");
		
		UINSPlayerLocalProfile_LoadProfileBlock_Params params {};
		params.Type = Type;
		params.bFromCloud = bFromCloud;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056AB720
	 * 		Name   -> Function Insurgency.INSPlayerLocalProfile.LoadFromCloud
	 * 		Flags  -> (Final, Native, Public)
	 */
	void UINSPlayerLocalProfile::LoadFromCloud()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerLocalProfile.LoadFromCloud");
		
		UINSPlayerLocalProfile_LoadFromCloud_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056AB6F0
	 * 		Name   -> Function Insurgency.INSPlayerLocalProfile.IsRadialToggle
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool UINSPlayerLocalProfile::IsRadialToggle()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerLocalProfile.IsRadialToggle");
		
		UINSPlayerLocalProfile_IsRadialToggle_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056AB630
	 * 		Name   -> Function Insurgency.INSPlayerLocalProfile.IsPlaylistSelected
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		EPlaylistType                                      Type                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UPlaylist*                                   Playlist                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UINSPlayerLocalProfile::IsPlaylistSelected(EPlaylistType Type, class UPlaylist* Playlist)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerLocalProfile.IsPlaylistSelected");
		
		UINSPlayerLocalProfile_IsPlaylistSelected_Params params {};
		params.Type = Type;
		params.Playlist = Playlist;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056AB600
	 * 		Name   -> Function Insurgency.INSPlayerLocalProfile.IsManualBipod
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool UINSPlayerLocalProfile::IsManualBipod()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerLocalProfile.IsManualBipod");
		
		UINSPlayerLocalProfile_IsManualBipod_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056AB420
	 * 		Name   -> Function Insurgency.INSPlayerLocalProfile.IsFavoritedServer
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		struct FBlueprintFindSessionResult                 CheckServer                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	bool UINSPlayerLocalProfile::IsFavoritedServer(const struct FBlueprintFindSessionResult& CheckServer)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerLocalProfile.IsFavoritedServer");
		
		UINSPlayerLocalProfile_IsFavoritedServer_Params params {};
		params.CheckServer = CheckServer;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056AB3F0
	 * 		Name   -> Function Insurgency.INSPlayerLocalProfile.IsDirty
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool UINSPlayerLocalProfile::IsDirty()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerLocalProfile.IsDirty");
		
		UINSPlayerLocalProfile_IsDirty_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056AB3D0
	 * 		Name   -> Function Insurgency.INSPlayerLocalProfile.IncrementNewHighlights
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void UINSPlayerLocalProfile::IncrementNewHighlights()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerLocalProfile.IncrementNewHighlights");
		
		UINSPlayerLocalProfile_IncrementNewHighlights_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056AB350
	 * 		Name   -> Function Insurgency.INSPlayerLocalProfile.HideReplayFromHistory
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		int32_t                                            ReplayID                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UINSPlayerLocalProfile::HideReplayFromHistory(int32_t ReplayID)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerLocalProfile.HideReplayFromHistory");
		
		UINSPlayerLocalProfile_HideReplayFromHistory_Params params {};
		params.ReplayID = ReplayID;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056AB320
	 * 		Name   -> Function Insurgency.INSPlayerLocalProfile.HasUserConfirmedLicenseAgreement
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool UINSPlayerLocalProfile::HasUserConfirmedLicenseAgreement()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerLocalProfile.HasUserConfirmedLicenseAgreement");
		
		UINSPlayerLocalProfile_HasUserConfirmedLicenseAgreement_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056AB290
	 * 		Name   -> Function Insurgency.INSPlayerLocalProfile.HasPreviewedStoreItem
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		int32_t                                            ItemId                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UINSPlayerLocalProfile::HasPreviewedStoreItem(int32_t ItemId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerLocalProfile.HasPreviewedStoreItem");
		
		UINSPlayerLocalProfile_HasPreviewedStoreItem_Params params {};
		params.ItemId = ItemId;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056AB200
	 * 		Name   -> Function Insurgency.INSPlayerLocalProfile.HasPreviewedCosmeticItem
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		int32_t                                            ItemId                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UINSPlayerLocalProfile::HasPreviewedCosmeticItem(int32_t ItemId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerLocalProfile.HasPreviewedCosmeticItem");
		
		UINSPlayerLocalProfile_HasPreviewedCosmeticItem_Params params {};
		params.ItemId = ItemId;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056AB020
	 * 		Name   -> Function Insurgency.INSPlayerLocalProfile.HasPlayerClassLoadoutNamed
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		class FText                                        LoadoutName                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		bool                                               bNightMode                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	int32_t UINSPlayerLocalProfile::HasPlayerClassLoadoutNamed(const class FText& LoadoutName, bool bNightMode)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerLocalProfile.HasPlayerClassLoadoutNamed");
		
		UINSPlayerLocalProfile_HasPlayerClassLoadoutNamed_Params params {};
		params.LoadoutName = LoadoutName;
		params.bNightMode = bNightMode;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056AAF10
	 * 		Name   -> Function Insurgency.INSPlayerLocalProfile.HasEquippedUpgrade
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	bool UINSPlayerLocalProfile::HasEquippedUpgrade()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerLocalProfile.HasEquippedUpgrade");
		
		UINSPlayerLocalProfile_HasEquippedUpgrade_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056AAE00
	 * 		Name   -> Function Insurgency.INSPlayerLocalProfile.HasEquippedItem
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	bool UINSPlayerLocalProfile::HasEquippedItem()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerLocalProfile.HasEquippedItem");
		
		UINSPlayerLocalProfile_HasEquippedItem_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056AAD50
	 * 		Name   -> Function Insurgency.INSPlayerLocalProfile.HasCosmeticPresetForFaction
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class FString                                      InFactionString                                            (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UINSPlayerLocalProfile::HasCosmeticPresetForFaction(const class FString& InFactionString)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerLocalProfile.HasCosmeticPresetForFaction");
		
		UINSPlayerLocalProfile_HasCosmeticPresetForFaction_Params params {};
		params.InFactionString = InFactionString;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056AACC0
	 * 		Name   -> Function Insurgency.INSPlayerLocalProfile.HasCompletedLessonHint
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		class UClass*                                      Lesson                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UINSPlayerLocalProfile::HasCompletedLessonHint(class UClass* Lesson)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerLocalProfile.HasCompletedLessonHint");
		
		UINSPlayerLocalProfile_HasCompletedLessonHint_Params params {};
		params.Lesson = Lesson;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056AAC30
	 * 		Name   -> Function Insurgency.INSPlayerLocalProfile.GetUseScopeSensitivityScale
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		bool                                               bGamepad                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UINSPlayerLocalProfile::GetUseScopeSensitivityScale(bool bGamepad)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerLocalProfile.GetUseScopeSensitivityScale");
		
		UINSPlayerLocalProfile_GetUseScopeSensitivityScale_Params params {};
		params.bGamepad = bGamepad;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056AAB50
	 * 		Name   -> Function Insurgency.INSPlayerLocalProfile.GetSensitivityScaleForOpticZoom
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		bool                                               bGamepad                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EOpticZoomLevel                                    ZoomLevel                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	float UINSPlayerLocalProfile::GetSensitivityScaleForOpticZoom(bool bGamepad, EOpticZoomLevel ZoomLevel)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerLocalProfile.GetSensitivityScaleForOpticZoom");
		
		UINSPlayerLocalProfile_GetSensitivityScaleForOpticZoom_Params params {};
		params.bGamepad = bGamepad;
		params.ZoomLevel = ZoomLevel;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056AAAC0
	 * 		Name   -> Function Insurgency.INSPlayerLocalProfile.GetScopeSensitivityScaleUsesWorldFOV
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		bool                                               bGamepad                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UINSPlayerLocalProfile::GetScopeSensitivityScaleUsesWorldFOV(bool bGamepad)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerLocalProfile.GetScopeSensitivityScaleUsesWorldFOV");
		
		UINSPlayerLocalProfile_GetScopeSensitivityScaleUsesWorldFOV_Params params {};
		params.bGamepad = bGamepad;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056AAA20
	 * 		Name   -> Function Insurgency.INSPlayerLocalProfile.GetScopeSensitivityScale
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		bool                                               bGamepad                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	float UINSPlayerLocalProfile::GetScopeSensitivityScale(bool bGamepad)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerLocalProfile.GetScopeSensitivityScale");
		
		UINSPlayerLocalProfile_GetScopeSensitivityScale_Params params {};
		params.bGamepad = bGamepad;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056AA800
	 * 		Name   -> Function Insurgency.INSPlayerLocalProfile.GetSavedLoadouts
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		TArray<struct FSavedLoadout>                       OutSavedLoadouts                                           (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bNightMode                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UINSPlayerLocalProfile::GetSavedLoadouts(TArray<struct FSavedLoadout>* OutSavedLoadouts, bool bNightMode)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerLocalProfile.GetSavedLoadouts");
		
		UINSPlayerLocalProfile_GetSavedLoadouts_Params params {};
		params.bNightMode = bNightMode;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutSavedLoadouts != nullptr)
			*OutSavedLoadouts = params.OutSavedLoadouts;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056AA5F0
	 * 		Name   -> Function Insurgency.INSPlayerLocalProfile.GetSavedLoadoutNames
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		TArray<class FText>                                OutLoadoutNames                                            (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bNightMode                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UINSPlayerLocalProfile::GetSavedLoadoutNames(TArray<class FText>* OutLoadoutNames, bool bNightMode)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerLocalProfile.GetSavedLoadoutNames");
		
		UINSPlayerLocalProfile_GetSavedLoadoutNames_Params params {};
		params.bNightMode = bNightMode;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutLoadoutNames != nullptr)
			*OutLoadoutNames = params.OutLoadoutNames;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056AA450
	 * 		Name   -> Function Insurgency.INSPlayerLocalProfile.GetSavedActivePresetIndex
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		int32_t                                            ActivePresetIndex                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bNightMode                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UINSPlayerLocalProfile::GetSavedActivePresetIndex(int32_t* ActivePresetIndex, bool bNightMode)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerLocalProfile.GetSavedActivePresetIndex");
		
		UINSPlayerLocalProfile_GetSavedActivePresetIndex_Params params {};
		params.bNightMode = bNightMode;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (ActivePresetIndex != nullptr)
			*ActivePresetIndex = params.ActivePresetIndex;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056AA420
	 * 		Name   -> Function Insurgency.INSPlayerLocalProfile.GetMouseSensitivity
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	float UINSPlayerLocalProfile::GetMouseSensitivity()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerLocalProfile.GetMouseSensitivity");
		
		UINSPlayerLocalProfile_GetMouseSensitivity_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056AA1F0
	 * 		Name   -> Function Insurgency.INSPlayerLocalProfile.GetItemsForSavedLoadout
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		int32_t                                            PresetIndex                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		TArray<struct FBasicLoadoutItem>                   Items                                                      (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bNightMode                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UINSPlayerLocalProfile::GetItemsForSavedLoadout(int32_t PresetIndex, TArray<struct FBasicLoadoutItem>* Items, bool bNightMode)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerLocalProfile.GetItemsForSavedLoadout");
		
		UINSPlayerLocalProfile_GetItemsForSavedLoadout_Params params {};
		params.PresetIndex = PresetIndex;
		params.bNightMode = bNightMode;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (Items != nullptr)
			*Items = params.Items;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056AA1C0
	 * 		Name   -> Function Insurgency.INSPlayerLocalProfile.GetInvertedYAxisMouse
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool UINSPlayerLocalProfile::GetInvertedYAxisMouse()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerLocalProfile.GetInvertedYAxisMouse");
		
		UINSPlayerLocalProfile_GetInvertedYAxisMouse_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056AA190
	 * 		Name   -> Function Insurgency.INSPlayerLocalProfile.GetInvertedYAxis
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool UINSPlayerLocalProfile::GetInvertedYAxis()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerLocalProfile.GetInvertedYAxis");
		
		UINSPlayerLocalProfile_GetInvertedYAxis_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056AA160
	 * 		Name   -> Function Insurgency.INSPlayerLocalProfile.GetGamepadYSensitivity
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	float UINSPlayerLocalProfile::GetGamepadYSensitivity()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerLocalProfile.GetGamepadYSensitivity");
		
		UINSPlayerLocalProfile_GetGamepadYSensitivity_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056AA130
	 * 		Name   -> Function Insurgency.INSPlayerLocalProfile.GetGamepadXSensitivity
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	float UINSPlayerLocalProfile::GetGamepadXSensitivity()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerLocalProfile.GetGamepadXSensitivity");
		
		UINSPlayerLocalProfile_GetGamepadXSensitivity_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056AA100
	 * 		Name   -> Function Insurgency.INSPlayerLocalProfile.GetGamepadDeadzoneInnerRight
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
	 */
	float UINSPlayerLocalProfile::GetGamepadDeadzoneInnerRight()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerLocalProfile.GetGamepadDeadzoneInnerRight");
		
		UINSPlayerLocalProfile_GetGamepadDeadzoneInnerRight_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056AA0D0
	 * 		Name   -> Function Insurgency.INSPlayerLocalProfile.GetGamepadDeadzoneInnerLeft
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
	 */
	float UINSPlayerLocalProfile::GetGamepadDeadzoneInnerLeft()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerLocalProfile.GetGamepadDeadzoneInnerLeft");
		
		UINSPlayerLocalProfile_GetGamepadDeadzoneInnerLeft_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056A9F90
	 * 		Name   -> Function Insurgency.INSPlayerLocalProfile.GetGamepadDampeningSettings
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		float                                              OutDampeningStrength                                       (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              OutDampeningSize                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              OutDampeningEaseIn                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UINSPlayerLocalProfile::GetGamepadDampeningSettings(float* OutDampeningStrength, float* OutDampeningSize, float* OutDampeningEaseIn)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerLocalProfile.GetGamepadDampeningSettings");
		
		UINSPlayerLocalProfile_GetGamepadDampeningSettings_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutDampeningStrength != nullptr)
			*OutDampeningStrength = params.OutDampeningStrength;
		if (OutDampeningSize != nullptr)
			*OutDampeningSize = params.OutDampeningSize;
		if (OutDampeningEaseIn != nullptr)
			*OutDampeningEaseIn = params.OutDampeningEaseIn;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056A9F60
	 * 		Name   -> Function Insurgency.INSPlayerLocalProfile.GetGamepadAimSensitivityCurve
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	EGamepadSensitivityCurve UINSPlayerLocalProfile::GetGamepadAimSensitivityCurve()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerLocalProfile.GetGamepadAimSensitivityCurve");
		
		UINSPlayerLocalProfile_GetGamepadAimSensitivityCurve_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056A9E20
	 * 		Name   -> Function Insurgency.INSPlayerLocalProfile.GetGamepadAccelerationSettings
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		float                                              TimeThreshold                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              TimeToReachMax                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              MaxMultiplier                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UINSPlayerLocalProfile::GetGamepadAccelerationSettings(float* TimeThreshold, float* TimeToReachMax, float* MaxMultiplier)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerLocalProfile.GetGamepadAccelerationSettings");
		
		UINSPlayerLocalProfile_GetGamepadAccelerationSettings_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (TimeThreshold != nullptr)
			*TimeThreshold = params.TimeThreshold;
		if (TimeToReachMax != nullptr)
			*TimeToReachMax = params.TimeToReachMax;
		if (MaxMultiplier != nullptr)
			*MaxMultiplier = params.MaxMultiplier;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056A9DF0
	 * 		Name   -> Function Insurgency.INSPlayerLocalProfile.GetGamepadAccelerationEnabled
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool UINSPlayerLocalProfile::GetGamepadAccelerationEnabled()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerLocalProfile.GetGamepadAccelerationEnabled");
		
		UINSPlayerLocalProfile_GetGamepadAccelerationEnabled_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056A9DC0
	 * 		Name   -> Function Insurgency.INSPlayerLocalProfile.GetFreeaimDeadzoneScale
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	float UINSPlayerLocalProfile::GetFreeaimDeadzoneScale()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerLocalProfile.GetFreeaimDeadzoneScale");
		
		UINSPlayerLocalProfile_GetFreeaimDeadzoneScale_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056A9D90
	 * 		Name   -> Function Insurgency.INSPlayerLocalProfile.GetFreeaimDeadzoneMinimumSensitivity
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	float UINSPlayerLocalProfile::GetFreeaimDeadzoneMinimumSensitivity()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerLocalProfile.GetFreeaimDeadzoneMinimumSensitivity");
		
		UINSPlayerLocalProfile_GetFreeaimDeadzoneMinimumSensitivity_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056A9D60
	 * 		Name   -> Function Insurgency.INSPlayerLocalProfile.GetFreeaimDeadzoneEnabled
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool UINSPlayerLocalProfile::GetFreeaimDeadzoneEnabled()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerLocalProfile.GetFreeaimDeadzoneEnabled");
		
		UINSPlayerLocalProfile_GetFreeaimDeadzoneEnabled_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056A9C00
	 * 		Name   -> Function Insurgency.INSPlayerLocalProfile.GetFOVSensitivityScaling
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		bool                                               bGamepad                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UINSPlayerLocalProfile::GetFOVSensitivityScaling(bool bGamepad)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerLocalProfile.GetFOVSensitivityScaling");
		
		UINSPlayerLocalProfile_GetFOVSensitivityScaling_Params params {};
		params.bGamepad = bGamepad;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056A9D30
	 * 		Name   -> Function Insurgency.INSPlayerLocalProfile.GetForceFeedbackIntensity
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	float UINSPlayerLocalProfile::GetForceFeedbackIntensity()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerLocalProfile.GetForceFeedbackIntensity");
		
		UINSPlayerLocalProfile_GetForceFeedbackIntensity_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056A9C90
	 * 		Name   -> Function Insurgency.INSPlayerLocalProfile.GetFocusSensitivityScale
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		bool                                               bGamepad                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	float UINSPlayerLocalProfile::GetFocusSensitivityScale(bool bGamepad)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerLocalProfile.GetFocusSensitivityScale");
		
		UINSPlayerLocalProfile_GetFocusSensitivityScale_Params params {};
		params.bGamepad = bGamepad;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056A9BA0
	 * 		Name   -> Function Insurgency.INSPlayerLocalProfile.GetCurrentCosmeticStateForPreferredFaction
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	struct FProfileCharacterCosmeticState UINSPlayerLocalProfile::GetCurrentCosmeticStateForPreferredFaction()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerLocalProfile.GetCurrentCosmeticStateForPreferredFaction");
		
		UINSPlayerLocalProfile_GetCurrentCosmeticStateForPreferredFaction_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056A9AD0
	 * 		Name   -> Function Insurgency.INSPlayerLocalProfile.GetCurrentCosmeticStateForFaction
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		class FName                                        FactionName                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FProfileCharacterCosmeticState UINSPlayerLocalProfile::GetCurrentCosmeticStateForFaction(const class FName& FactionName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerLocalProfile.GetCurrentCosmeticStateForFaction");
		
		UINSPlayerLocalProfile_GetCurrentCosmeticStateForFaction_Params params {};
		params.FactionName = FactionName;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056A9A70
	 * 		Name   -> Function Insurgency.INSPlayerLocalProfile.GetCurrentCosmeticShoppingCartForPreferredFaction
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	struct FProfileCharacterCosmeticState UINSPlayerLocalProfile::GetCurrentCosmeticShoppingCartForPreferredFaction()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerLocalProfile.GetCurrentCosmeticShoppingCartForPreferredFaction");
		
		UINSPlayerLocalProfile_GetCurrentCosmeticShoppingCartForPreferredFaction_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056A99A0
	 * 		Name   -> Function Insurgency.INSPlayerLocalProfile.GetCurrentCosmeticShoppingCartForFaction
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		class FName                                        FactionName                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FProfileCharacterCosmeticState UINSPlayerLocalProfile::GetCurrentCosmeticShoppingCartForFaction(const class FName& FactionName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerLocalProfile.GetCurrentCosmeticShoppingCartForFaction");
		
		UINSPlayerLocalProfile_GetCurrentCosmeticShoppingCartForFaction_Params params {};
		params.FactionName = FactionName;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056A9960
	 * 		Name   -> Function Insurgency.INSPlayerLocalProfile.GetControlsActionMappings
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
	 */
	TArray<struct FInputActionKeyMapping> UINSPlayerLocalProfile::GetControlsActionMappings()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerLocalProfile.GetControlsActionMappings");
		
		UINSPlayerLocalProfile_GetControlsActionMappings_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056A98E0
	 * 		Name   -> Function Insurgency.INSPlayerLocalProfile.GetControllerLayoutName
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	class FString UINSPlayerLocalProfile::GetControllerLayoutName()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerLocalProfile.GetControllerLayoutName");
		
		UINSPlayerLocalProfile_GetControllerLayoutName_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056A98B0
	 * 		Name   -> Function Insurgency.INSPlayerLocalProfile.GetControllerLayout
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	class UControllerLayout* UINSPlayerLocalProfile::GetControllerLayout()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerLocalProfile.GetControllerLayout");
		
		UINSPlayerLocalProfile_GetControllerLayout_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056A9880
	 * 		Name   -> Function Insurgency.INSPlayerLocalProfile.GetAutoLean
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool UINSPlayerLocalProfile::GetAutoLean()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerLocalProfile.GetAutoLean");
		
		UINSPlayerLocalProfile_GetAutoLean_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056A97E0
	 * 		Name   -> Function Insurgency.INSPlayerLocalProfile.GetAimingSensitivityScale
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		bool                                               bGamepad                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	float UINSPlayerLocalProfile::GetAimingSensitivityScale(bool bGamepad)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerLocalProfile.GetAimingSensitivityScale");
		
		UINSPlayerLocalProfile_GetAimingSensitivityScale_Params params {};
		params.bGamepad = bGamepad;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056A96A0
	 * 		Name   -> Function Insurgency.INSPlayerLocalProfile.GetAestheticForWeapon
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void UINSPlayerLocalProfile::GetAestheticForWeapon()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerLocalProfile.GetAestheticForWeapon");
		
		UINSPlayerLocalProfile_GetAestheticForWeapon_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056A9680
	 * 		Name   -> Function Insurgency.INSPlayerLocalProfile.ForwardControlSettings
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void UINSPlayerLocalProfile::ForwardControlSettings()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerLocalProfile.ForwardControlSettings");
		
		UINSPlayerLocalProfile_ForwardControlSettings_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056A9490
	 * 		Name   -> Function Insurgency.INSPlayerLocalProfile.FindPlayerClassDefaultLoadout
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		TArray<struct FBasicLoadoutItem>                   OutItems                                                   (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bIsNight                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UINSPlayerLocalProfile::FindPlayerClassDefaultLoadout(TArray<struct FBasicLoadoutItem>* OutItems, bool bIsNight)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerLocalProfile.FindPlayerClassDefaultLoadout");
		
		UINSPlayerLocalProfile_FindPlayerClassDefaultLoadout_Params params {};
		params.bIsNight = bIsNight;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutItems != nullptr)
			*OutItems = params.OutItems;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056A9300
	 * 		Name   -> Function Insurgency.INSPlayerLocalProfile.DeletePlayerClassLoadout
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		int32_t                                            LoadoutIndex                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bNightMode                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UINSPlayerLocalProfile::DeletePlayerClassLoadout(int32_t LoadoutIndex, bool bNightMode)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerLocalProfile.DeletePlayerClassLoadout");
		
		UINSPlayerLocalProfile_DeletePlayerClassLoadout_Params params {};
		params.LoadoutIndex = LoadoutIndex;
		params.bNightMode = bNightMode;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056A92D0
	 * 		Name   -> Function Insurgency.INSPlayerLocalProfile.CosmeticStateChanged
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	bool UINSPlayerLocalProfile::CosmeticStateChanged()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerLocalProfile.CosmeticStateChanged");
		
		UINSPlayerLocalProfile_CosmeticStateChanged_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056A9250
	 * 		Name   -> Function Insurgency.INSPlayerLocalProfile.CompleteLesson
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UClass*                                      Lesson                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UINSPlayerLocalProfile::CompleteLesson(class UClass* Lesson)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerLocalProfile.CompleteLesson");
		
		UINSPlayerLocalProfile_CompleteLesson_Params params {};
		params.Lesson = Lesson;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056A9230
	 * 		Name   -> Function Insurgency.INSPlayerLocalProfile.ClearNewHighlights
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void UINSPlayerLocalProfile::ClearNewHighlights()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerLocalProfile.ClearNewHighlights");
		
		UINSPlayerLocalProfile_ClearNewHighlights_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056A91B0
	 * 		Name   -> Function Insurgency.INSPlayerLocalProfile.ClearItemIdFromUnviewedStoreItems
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		int32_t                                            ItemId                                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UINSPlayerLocalProfile::ClearItemIdFromUnviewedStoreItems(int32_t ItemId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerLocalProfile.ClearItemIdFromUnviewedStoreItems");
		
		UINSPlayerLocalProfile_ClearItemIdFromUnviewedStoreItems_Params params {};
		params.ItemId = ItemId;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056A9130
	 * 		Name   -> Function Insurgency.INSPlayerLocalProfile.ClearItemIdFromUnviewedItems
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		int32_t                                            ItemId                                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UINSPlayerLocalProfile::ClearItemIdFromUnviewedItems(int32_t ItemId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerLocalProfile.ClearItemIdFromUnviewedItems");
		
		UINSPlayerLocalProfile_ClearItemIdFromUnviewedItems_Params params {};
		params.ItemId = ItemId;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056A9110
	 * 		Name   -> Function Insurgency.INSPlayerLocalProfile.ClearHighlights
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void UINSPlayerLocalProfile::ClearHighlights()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerLocalProfile.ClearHighlights");
		
		UINSPlayerLocalProfile_ClearHighlights_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056A9090
	 * 		Name   -> Function Insurgency.INSPlayerLocalProfile.AddPreviewedStoreItem
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		int32_t                                            ItemId                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UINSPlayerLocalProfile::AddPreviewedStoreItem(int32_t ItemId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerLocalProfile.AddPreviewedStoreItem");
		
		UINSPlayerLocalProfile_AddPreviewedStoreItem_Params params {};
		params.ItemId = ItemId;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056A9010
	 * 		Name   -> Function Insurgency.INSPlayerLocalProfile.AddPreviewedCosmeticItem
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		int32_t                                            ItemId                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UINSPlayerLocalProfile::AddPreviewedCosmeticItem(int32_t ItemId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerLocalProfile.AddPreviewedCosmeticItem");
		
		UINSPlayerLocalProfile_AddPreviewedCosmeticItem_Params params {};
		params.ItemId = ItemId;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056A8E40
	 * 		Name   -> Function Insurgency.INSPlayerLocalProfile.AddFavoritedServer
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		struct FBlueprintFindSessionResult                 NewFavoritedServer                                         (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UINSPlayerLocalProfile::AddFavoritedServer(const struct FBlueprintFindSessionResult& NewFavoritedServer)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerLocalProfile.AddFavoritedServer");
		
		UINSPlayerLocalProfile_AddFavoritedServer_Params params {};
		params.NewFavoritedServer = NewFavoritedServer;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056A8C80
	 * 		Name   -> Function Insurgency.INSPlayerLocalProfile.AddEquippedUpgrade
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void UINSPlayerLocalProfile::AddEquippedUpgrade()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerLocalProfile.AddEquippedUpgrade");
		
		UINSPlayerLocalProfile_AddEquippedUpgrade_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056A8B80
	 * 		Name   -> Function Insurgency.INSPlayerLocalProfile.AddEquippedItem
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void UINSPlayerLocalProfile::AddEquippedItem()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerLocalProfile.AddEquippedItem");
		
		UINSPlayerLocalProfile_AddEquippedItem_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056A8B60
	 * 		Name   -> Function Insurgency.INSPlayerLocalProfile.AddCloudDelegates
	 * 		Flags  -> (Final, Native, Public)
	 */
	void UINSPlayerLocalProfile::AddCloudDelegates()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerLocalProfile.AddCloudDelegates");
		
		UINSPlayerLocalProfile_AddCloudDelegates_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056A89D0
	 * 		Name   -> Function Insurgency.INSPlayerLocalProfile.AddAxisMappingIfNotExisting
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class FName                                        NewBinding                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FKey                                        DefaultKey                                                 (ConstParm, Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              NewScale                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bGamepad                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UINSPlayerLocalProfile::AddAxisMappingIfNotExisting(const class FName& NewBinding, const struct FKey& DefaultKey, float NewScale, bool bGamepad)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerLocalProfile.AddAxisMappingIfNotExisting");
		
		UINSPlayerLocalProfile_AddAxisMappingIfNotExisting_Params params {};
		params.NewBinding = NewBinding;
		params.DefaultKey = DefaultKey;
		params.NewScale = NewScale;
		params.bGamepad = bGamepad;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056A8870
	 * 		Name   -> Function Insurgency.INSPlayerLocalProfile.AddActionMappingIfNotExisting
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class FName                                        NewBinding                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FKey                                        DefaultKey                                                 (ConstParm, Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bGamepad                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UINSPlayerLocalProfile::AddActionMappingIfNotExisting(const class FName& NewBinding, const struct FKey& DefaultKey, bool bGamepad)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerLocalProfile.AddActionMappingIfNotExisting");
		
		UINSPlayerLocalProfile_AddActionMappingIfNotExisting_Params params {};
		params.NewBinding = NewBinding;
		params.DefaultKey = DefaultKey;
		params.bGamepad = bGamepad;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056A8740
	 * 		Name   -> Function Insurgency.INSPlayerLocalProfile.AddActionMapping
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		struct FInputActionKeyMapping                      KeyMapping                                                 (Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UINSPlayerLocalProfile::AddActionMapping(struct FInputActionKeyMapping* KeyMapping)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerLocalProfile.AddActionMapping");
		
		UINSPlayerLocalProfile_AddActionMapping_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (KeyMapping != nullptr)
			*KeyMapping = params.KeyMapping;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UINSPlayerLocalProfile.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UINSPlayerLocalProfile::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.INSPlayerLocalProfile");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056AEA70
	 * 		Name   -> Function Insurgency.INSPlayerStart.SetAssociatedSpawnZone
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class ASpawnZone*                                  Zone                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSPlayerStart::SetAssociatedSpawnZone(class ASpawnZone* Zone)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerStart.SetAssociatedSpawnZone");
		
		AINSPlayerStart_SetAssociatedSpawnZone_Params params {};
		params.Zone = Zone;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056AE9E0
	 * 		Name   -> Function Insurgency.INSPlayerStart.GetSpawnLocation
	 * 		Flags  -> (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		struct FVector                                     OutLocation                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSPlayerStart::GetSpawnLocation(struct FVector* OutLocation)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerStart.GetSpawnLocation");
		
		AINSPlayerStart_GetSpawnLocation_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutLocation != nullptr)
			*OutLocation = params.OutLocation;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AINSPlayerStart.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AINSPlayerStart::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.INSPlayerStart");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056B22F0
	 * 		Name   -> Function Insurgency.INSPlayerState.SetIsPlaying
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               InIsPlaying                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSPlayerState::SetIsPlaying(bool InIsPlaying)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerState.SetIsPlaying");
		
		AINSPlayerState_SetIsPlaying_Params params {};
		params.InIsPlaying = InIsPlaying;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056B22D0
	 * 		Name   -> Function Insurgency.INSPlayerState.ResetRoundStats
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void AINSPlayerState::ResetRoundStats()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerState.ResetRoundStats");
		
		AINSPlayerState_ResetRoundStats_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056B22B0
	 * 		Name   -> Function Insurgency.INSPlayerState.PreLoadCosmetics
	 * 		Flags  -> (Final, Native, Private)
	 */
	void AINSPlayerState::PreLoadCosmetics()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerState.PreLoadCosmetics");
		
		AINSPlayerState_PreLoadCosmetics_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056B2290
	 * 		Name   -> Function Insurgency.INSPlayerState.OnRep_TeamId
	 * 		Flags  -> (Final, Native, Public)
	 */
	void AINSPlayerState::OnRep_TeamId()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerState.OnRep_TeamId");
		
		AINSPlayerState_OnRep_TeamId_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056B2270
	 * 		Name   -> Function Insurgency.INSPlayerState.OnRep_ScoreboardBadge
	 * 		Flags  -> (Final, Native, Private)
	 */
	void AINSPlayerState::OnRep_ScoreboardBadge()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerState.OnRep_ScoreboardBadge");
		
		AINSPlayerState_OnRep_ScoreboardBadge_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056B2250
	 * 		Name   -> Function Insurgency.INSPlayerState.OnRep_PlayerExperience
	 * 		Flags  -> (Final, Native, Private)
	 */
	void AINSPlayerState::OnRep_PlayerExperience()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerState.OnRep_PlayerExperience");
		
		AINSPlayerState_OnRep_PlayerExperience_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056B2230
	 * 		Name   -> Function Insurgency.INSPlayerState.OnRep_PlayerClass
	 * 		Flags  -> (Final, Native, Public)
	 */
	void AINSPlayerState::OnRep_PlayerClass()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerState.OnRep_PlayerClass");
		
		AINSPlayerState_OnRep_PlayerClass_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056B2210
	 * 		Name   -> Function Insurgency.INSPlayerState.OnRep_HasDeveloperTag
	 * 		Flags  -> (Final, Native, Private)
	 */
	void AINSPlayerState::OnRep_HasDeveloperTag()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerState.OnRep_HasDeveloperTag");
		
		AINSPlayerState_OnRep_HasDeveloperTag_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056B21F0
	 * 		Name   -> Function Insurgency.INSPlayerState.OnRep_Cosmetics
	 * 		Flags  -> (Final, Native, Private)
	 */
	void AINSPlayerState::OnRep_Cosmetics()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerState.OnRep_Cosmetics");
		
		AINSPlayerState_OnRep_Cosmetics_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056B21D0
	 * 		Name   -> Function Insurgency.INSPlayerState.OnRep_ActiveObjectiveId
	 * 		Flags  -> (Final, Native, Private)
	 */
	void AINSPlayerState::OnRep_ActiveObjectiveId()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerState.OnRep_ActiveObjectiveId");
		
		AINSPlayerState_OnRep_ActiveObjectiveId_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056B20F0
	 * 		Name   -> Function Insurgency.INSPlayerState.OnKilledOther
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetClient)
	 * Parameters:
	 * 		struct FSoldierKillInfo                            SoldierKillInfo                                            (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void AINSPlayerState::OnKilledOther(const struct FSoldierKillInfo& SoldierKillInfo)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerState.OnKilledOther");
		
		AINSPlayerState_OnKilledOther_Params params {};
		params.SoldierKillInfo = SoldierKillInfo;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056B20C0
	 * 		Name   -> Function Insurgency.INSPlayerState.IsSpectatingSpectator
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AINSPlayerState::IsSpectatingSpectator()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerState.IsSpectatingSpectator");
		
		AINSPlayerState_IsSpectatingSpectator_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056B2090
	 * 		Name   -> Function Insurgency.INSPlayerState.IsFactionValid
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AINSPlayerState::IsFactionValid()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerState.IsFactionValid");
		
		AINSPlayerState_IsFactionValid_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056B2060
	 * 		Name   -> Function Insurgency.INSPlayerState.IsDedicatedSpectator
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AINSPlayerState::IsDedicatedSpectator()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerState.IsDedicatedSpectator");
		
		AINSPlayerState_IsDedicatedSpectator_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056B1F60
	 * 		Name   -> Function Insurgency.INSPlayerState.IncrementScore
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		int32_t                                            Amount                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bIncrementTeam                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EScoreType                                         ScoreType                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSPlayerState::IncrementScore(int32_t Amount, bool bIncrementTeam, EScoreType ScoreType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerState.IncrementScore");
		
		AINSPlayerState_IncrementScore_Params params {};
		params.Amount = Amount;
		params.bIncrementTeam = bIncrementTeam;
		params.ScoreType = ScoreType;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056B1F30
	 * 		Name   -> Function Insurgency.INSPlayerState.HasSelectedSpecialClass
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AINSPlayerState::HasSelectedSpecialClass()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerState.HasSelectedSpecialClass");
		
		AINSPlayerState_HasSelectedSpecialClass_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056B1F00
	 * 		Name   -> Function Insurgency.INSPlayerState.HasSelectedOfficer
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AINSPlayerState::HasSelectedOfficer()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerState.HasSelectedOfficer");
		
		AINSPlayerState_HasSelectedOfficer_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056B1ED0
	 * 		Name   -> Function Insurgency.INSPlayerState.HasSelectedObserver
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AINSPlayerState::HasSelectedObserver()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerState.HasSelectedObserver");
		
		AINSPlayerState_HasSelectedObserver_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056B1DB0
	 * 		Name   -> Function Insurgency.INSPlayerState.GetUniqueNetId
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	struct FUniqueNetIdRepl AINSPlayerState::GetUniqueNetId()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerState.GetUniqueNetId");
		
		AINSPlayerState_GetUniqueNetId_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056B1D00
	 * 		Name   -> Function Insurgency.INSPlayerState.GetUniqueIdStringWithPlatform
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		class FString                                      OutUniqueId                                                (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSPlayerState::GetUniqueIdStringWithPlatform(class FString* OutUniqueId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerState.GetUniqueIdStringWithPlatform");
		
		AINSPlayerState_GetUniqueIdStringWithPlatform_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutUniqueId != nullptr)
			*OutUniqueId = params.OutUniqueId;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056B1C50
	 * 		Name   -> Function Insurgency.INSPlayerState.GetUniqueIdString
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		class FString                                      OutUniqueId                                                (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSPlayerState::GetUniqueIdString(class FString* OutUniqueId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerState.GetUniqueIdString");
		
		AINSPlayerState_GetUniqueIdString_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutUniqueId != nullptr)
			*OutUniqueId = params.OutUniqueId;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056B1C10
	 * 		Name   -> Function Insurgency.INSPlayerState.GetUniqueIdPlatform
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	class FName AINSPlayerState::GetUniqueIdPlatform()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerState.GetUniqueIdPlatform");
		
		AINSPlayerState_GetUniqueIdPlatform_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056B1BE0
	 * 		Name   -> Function Insurgency.INSPlayerState.GetTeamInfo
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	class ATeamInfo* AINSPlayerState::GetTeamInfo()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerState.GetTeamInfo");
		
		AINSPlayerState_GetTeamInfo_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056B1BA0
	 * 		Name   -> Function Insurgency.INSPlayerState.GetTeamId
	 * 		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	unsigned char AINSPlayerState::GetTeamId()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerState.GetTeamId");
		
		AINSPlayerState_GetTeamId_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056B1B70
	 * 		Name   -> Function Insurgency.INSPlayerState.GetSharedCosmeticState
	 * 		Flags  -> (Final, Native, Public)
	 */
	class USharedCosmeticState* AINSPlayerState::GetSharedCosmeticState()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerState.GetSharedCosmeticState");
		
		AINSPlayerState_GetSharedCosmeticState_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056B1B40
	 * 		Name   -> Function Insurgency.INSPlayerState.GetPreviousTeamInfo
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	class ATeamInfo* AINSPlayerState::GetPreviousTeamInfo()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerState.GetPreviousTeamInfo");
		
		AINSPlayerState_GetPreviousTeamInfo_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056B1A70
	 * 		Name   -> Function Insurgency.INSPlayerState.GetNemesisStatsForCopy
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		class AINSPlayerState*                             PlayerState                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FNemesisStats                               OutStats                                                   (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	bool AINSPlayerState::GetNemesisStatsForCopy(class AINSPlayerState* PlayerState, struct FNemesisStats* OutStats)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerState.GetNemesisStatsForCopy");
		
		AINSPlayerState_GetNemesisStatsForCopy_Params params {};
		params.PlayerState = PlayerState;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutStats != nullptr)
			*OutStats = params.OutStats;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056B1A40
	 * 		Name   -> Function Insurgency.INSPlayerState.GetIsPlaying
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AINSPlayerState::GetIsPlaying()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerState.GetIsPlaying");
		
		AINSPlayerState_GetIsPlaying_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056B19A0
	 * 		Name   -> Function Insurgency.INSPlayerState.GetColor
	 * 		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		class AINSPlayerState*                             RelativePlayer                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FLinearColor AINSPlayerState::GetColor(class AINSPlayerState* RelativePlayer)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerState.GetColor");
		
		AINSPlayerState_GetColor_Params params {};
		params.RelativePlayer = RelativePlayer;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056B1970
	 * 		Name   -> Function Insurgency.INSPlayerState.FindSoldier
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	class AINSSoldier* AINSPlayerState::FindSoldier()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerState.FindSoldier");
		
		AINSPlayerState_FindSoldier_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056B18A0
	 * 		Name   -> Function Insurgency.INSPlayerState.ClientUpdateSoldierPosition
	 * 		Flags  -> (Net, Native, Event, Public, NetClient)
	 * Parameters:
	 * 		class AINSSoldier*                                 Soldier                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bCanLean                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSPlayerState::ClientUpdateSoldierPosition(class AINSSoldier* Soldier, bool bCanLean)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerState.ClientUpdateSoldierPosition");
		
		AINSPlayerState_ClientUpdateSoldierPosition_Params params {};
		params.Soldier = Soldier;
		params.bCanLean = bCanLean;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056B1760
	 * 		Name   -> Function Insurgency.INSPlayerState.ClientUpdateLastRoundMostUsed
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetClient)
	 * Parameters:
	 * 		struct FPlayerRoundSummary                         RoundSummary                                               (ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void AINSPlayerState::ClientUpdateLastRoundMostUsed(const struct FPlayerRoundSummary& RoundSummary)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerState.ClientUpdateLastRoundMostUsed");
		
		AINSPlayerState_ClientUpdateLastRoundMostUsed_Params params {};
		params.RoundSummary = RoundSummary;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056B1680
	 * 		Name   -> Function Insurgency.INSPlayerState.ClientUpdateLastRoundExperience
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetClient)
	 * Parameters:
	 * 		struct FPlayerRoundExpSummary                      ExpResult                                                  (ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void AINSPlayerState::ClientUpdateLastRoundExperience(const struct FPlayerRoundExpSummary& ExpResult)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerState.ClientUpdateLastRoundExperience");
		
		AINSPlayerState_ClientUpdateLastRoundExperience_Params params {};
		params.ExpResult = ExpResult;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056B15F0
	 * 		Name   -> Function Insurgency.INSPlayerState.ClientScoreObjectiveReset
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetClient)
	 * Parameters:
	 * 		class AObjectiveCapturable*                        Objective                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSPlayerState::ClientScoreObjectiveReset(class AObjectiveCapturable* Objective)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerState.ClientScoreObjectiveReset");
		
		AINSPlayerState_ClientScoreObjectiveReset_Params params {};
		params.Objective = Objective;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056B14F0
	 * 		Name   -> Function Insurgency.INSPlayerState.ClientScoreObjectiveCaptured
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetClient)
	 * Parameters:
	 * 		class AObjectiveCapturable*                        Objective                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		unsigned char                                      OldOwners                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		unsigned char                                      NewOwners                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSPlayerState::ClientScoreObjectiveCaptured(class AObjectiveCapturable* Objective, unsigned char OldOwners, unsigned char NewOwners)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerState.ClientScoreObjectiveCaptured");
		
		AINSPlayerState_ClientScoreObjectiveCaptured_Params params {};
		params.Objective = Objective;
		params.OldOwners = OldOwners;
		params.NewOwners = NewOwners;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056B1460
	 * 		Name   -> Function Insurgency.INSPlayerState.ClientOnSight
	 * 		Flags  -> (Net, Native, Event, Public, NetClient)
	 * Parameters:
	 * 		class AItemWeapon*                                 Weapon                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSPlayerState::ClientOnSight(class AItemWeapon* Weapon)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerState.ClientOnSight");
		
		AINSPlayerState_ClientOnSight_Params params {};
		params.Weapon = Weapon;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x04E4EC00
	 * 		Name   -> Function Insurgency.INSPlayerState.ClientOnSeatTakenOver
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetClient)
	 * Parameters:
	 * 		class AINSCharacter*                               OldCharacter                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AController*                                 Controller                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSPlayerState::ClientOnSeatTakenOver(class AINSCharacter* OldCharacter, class AController* Controller)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerState.ClientOnSeatTakenOver");
		
		AINSPlayerState_ClientOnSeatTakenOver_Params params {};
		params.OldCharacter = OldCharacter;
		params.Controller = Controller;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056B1390
	 * 		Name   -> Function Insurgency.INSPlayerState.ClientOnReload
	 * 		Flags  -> (Net, Native, Event, Public, NetClient)
	 * Parameters:
	 * 		class AItemWeapon*                                 Weapon                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bSpeedReload                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSPlayerState::ClientOnReload(class AItemWeapon* Weapon, bool bSpeedReload)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerState.ClientOnReload");
		
		AINSPlayerState_ClientOnReload_Params params {};
		params.Weapon = Weapon;
		params.bSpeedReload = bSpeedReload;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056B1300
	 * 		Name   -> Function Insurgency.INSPlayerState.ClientOnPlayerSpawned
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetClient)
	 * Parameters:
	 * 		class AINSSoldier*                                 Player                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSPlayerState::ClientOnPlayerSpawned(class AINSSoldier* Player)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerState.ClientOnPlayerSpawned");
		
		AINSPlayerState_ClientOnPlayerSpawned_Params params {};
		params.Player = Player;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056B1230
	 * 		Name   -> Function Insurgency.INSPlayerState.ClientOnOpenDoor
	 * 		Flags  -> (Net, Native, Event, Public, NetClient)
	 * Parameters:
	 * 		class ADoor*                                       Door                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bKicked                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSPlayerState::ClientOnOpenDoor(class ADoor* Door, bool bKicked)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerState.ClientOnOpenDoor");
		
		AINSPlayerState_ClientOnOpenDoor_Params params {};
		params.Door = Door;
		params.bKicked = bKicked;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x04DB40E0
	 * 		Name   -> Function Insurgency.INSPlayerState.ClientOnObserverCalledFireSupport
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetClient)
	 */
	void AINSPlayerState::ClientOnObserverCalledFireSupport()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerState.ClientOnObserverCalledFireSupport");
		
		AINSPlayerState_ClientOnObserverCalledFireSupport_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056B11A0
	 * 		Name   -> Function Insurgency.INSPlayerState.ClientOnMeleeAttack
	 * 		Flags  -> (Net, Native, Event, Public, NetClient)
	 * Parameters:
	 * 		class AItemWeapon*                                 Weapon                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSPlayerState::ClientOnMeleeAttack(class AItemWeapon* Weapon)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerState.ClientOnMeleeAttack");
		
		AINSPlayerState_ClientOnMeleeAttack_Params params {};
		params.Weapon = Weapon;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056B10C0
	 * 		Name   -> Function Insurgency.INSPlayerState.ClientOnKilledOtherInVehicle
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetClient)
	 * Parameters:
	 * 		struct FSoldierKillInfo                            SoldierKillInfo                                            (Parm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void AINSPlayerState::ClientOnKilledOtherInVehicle(const struct FSoldierKillInfo& SoldierKillInfo)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerState.ClientOnKilledOtherInVehicle");
		
		AINSPlayerState_ClientOnKilledOtherInVehicle_Params params {};
		params.SoldierKillInfo = SoldierKillInfo;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x04DB3CA0
	 * 		Name   -> Function Insurgency.INSPlayerState.ClientOnFirstBlood
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetClient)
	 */
	void AINSPlayerState::ClientOnFirstBlood()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerState.ClientOnFirstBlood");
		
		AINSPlayerState_ClientOnFirstBlood_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056B1030
	 * 		Name   -> Function Insurgency.INSPlayerState.ClientOnFire
	 * 		Flags  -> (Net, Native, Event, Public, NetClient)
	 * Parameters:
	 * 		class AItemWeapon*                                 Weapon                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSPlayerState::ClientOnFire(class AItemWeapon* Weapon)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerState.ClientOnFire");
		
		AINSPlayerState_ClientOnFire_Params params {};
		params.Weapon = Weapon;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056B0F60
	 * 		Name   -> Function Insurgency.INSPlayerState.ClientOnEquip
	 * 		Flags  -> (Net, Native, Event, Public, NetClient)
	 * Parameters:
	 * 		class AINSSoldier*                                 Soldier                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AItemEquipable*                              Item                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSPlayerState::ClientOnEquip(class AINSSoldier* Soldier, class AItemEquipable* Item)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerState.ClientOnEquip");
		
		AINSPlayerState_ClientOnEquip_Params params {};
		params.Soldier = Soldier;
		params.Item = Item;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056B0ED0
	 * 		Name   -> Function Insurgency.INSPlayerState.ClientOnDryFire
	 * 		Flags  -> (Net, Native, Event, Public, NetClient)
	 * Parameters:
	 * 		class AItemWeapon*                                 Weapon                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSPlayerState::ClientOnDryFire(class AItemWeapon* Weapon)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerState.ClientOnDryFire");
		
		AINSPlayerState_ClientOnDryFire_Params params {};
		params.Weapon = Weapon;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x04DB4320
	 * 		Name   -> Function Insurgency.INSPlayerState.ClientOnDownedFireSupport
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetClient)
	 */
	void AINSPlayerState::ClientOnDownedFireSupport()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerState.ClientOnDownedFireSupport");
		
		AINSPlayerState_ClientOnDownedFireSupport_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056B0E40
	 * 		Name   -> Function Insurgency.INSPlayerState.ClientOnBeginOverlapObjective
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetClient)
	 * Parameters:
	 * 		class AObjectiveBase*                              Objective                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSPlayerState::ClientOnBeginOverlapObjective(class AObjectiveBase* Objective)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerState.ClientOnBeginOverlapObjective");
		
		AINSPlayerState_ClientOnBeginOverlapObjective_Params params {};
		params.Objective = Objective;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056B0DB0
	 * 		Name   -> Function Insurgency.INSPlayerState.ClientOnAmmoCheck
	 * 		Flags  -> (Net, Native, Event, Public, NetClient)
	 * Parameters:
	 * 		class AItemWeapon*                                 Weapon                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSPlayerState::ClientOnAmmoCheck(class AItemWeapon* Weapon)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerState.ClientOnAmmoCheck");
		
		AINSPlayerState_ClientOnAmmoCheck_Params params {};
		params.Weapon = Weapon;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056B0CE0
	 * 		Name   -> Function Insurgency.INSPlayerState.ClientObjectiveDestroyed
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetClient)
	 * Parameters:
	 * 		class AObjectiveDestructible*                      Objective                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bFromRig                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSPlayerState::ClientObjectiveDestroyed(class AObjectiveDestructible* Objective, bool bFromRig)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerState.ClientObjectiveDestroyed");
		
		AINSPlayerState_ClientObjectiveDestroyed_Params params {};
		params.Objective = Objective;
		params.bFromRig = bFromRig;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056B0CC0
	 * 		Name   -> Function Insurgency.INSPlayerState.ClearSharedCosmeticState
	 * 		Flags  -> (Final, Native, Public)
	 */
	void AINSPlayerState::ClearSharedCosmeticState()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerState.ClearSharedCosmeticState");
		
		AINSPlayerState_ClearSharedCosmeticState_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056B0C40
	 * 		Name   -> Function Insurgency.INSPlayerState.ChangePlayerClass
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UPlayerClass*                                NewPlayerClass                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSPlayerState::ChangePlayerClass(class UPlayerClass* NewPlayerClass)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerState.ChangePlayerClass");
		
		AINSPlayerState_ChangePlayerClass_Params params {};
		params.NewPlayerClass = NewPlayerClass;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056B0B30
	 * 		Name   -> Function Insurgency.INSPlayerState.AwardTaglineWithFloatContext
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UClass*                                      TaglineClass                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              ContextValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bAsPercentage                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSPlayerState::AwardTaglineWithFloatContext(class UClass* TaglineClass, float ContextValue, bool bAsPercentage)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerState.AwardTaglineWithFloatContext");
		
		AINSPlayerState_AwardTaglineWithFloatContext_Params params {};
		params.TaglineClass = TaglineClass;
		params.ContextValue = ContextValue;
		params.bAsPercentage = bAsPercentage;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056B0A70
	 * 		Name   -> Function Insurgency.INSPlayerState.AwardTaglineWithContext
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UClass*                                      TaglineClass                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            ContextValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSPlayerState::AwardTaglineWithContext(class UClass* TaglineClass, int32_t ContextValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerState.AwardTaglineWithContext");
		
		AINSPlayerState_AwardTaglineWithContext_Params params {};
		params.TaglineClass = TaglineClass;
		params.ContextValue = ContextValue;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056B09F0
	 * 		Name   -> Function Insurgency.INSPlayerState.AwardTagline
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UClass*                                      TaglineClass                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSPlayerState::AwardTagline(class UClass* TaglineClass)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerState.AwardTagline");
		
		AINSPlayerState_AwardTagline_Params params {};
		params.TaglineClass = TaglineClass;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056B0940
	 * 		Name   -> Function Insurgency.INSPlayerState.AddTagline
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		struct FPlayerAwardedTagline                       TaglineAward                                               (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void AINSPlayerState::AddTagline(const struct FPlayerAwardedTagline& TaglineAward)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPlayerState.AddTagline");
		
		AINSPlayerState_AddTagline_Params params {};
		params.TaglineAward = TaglineAward;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AINSPlayerState.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AINSPlayerState::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.INSPlayerState");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UINSProjectileMovementComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UINSProjectileMovementComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.INSProjectileMovementComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056B3480
	 * 		Name   -> Function Insurgency.INSPushGameMode.RespawnAttackingTeamPostObjective
	 * 		Flags  -> (Final, Native, Private)
	 */
	void AINSPushGameMode::RespawnAttackingTeamPostObjective()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPushGameMode.RespawnAttackingTeamPostObjective");
		
		AINSPushGameMode_RespawnAttackingTeamPostObjective_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056B3400
	 * 		Name   -> Function Insurgency.INSPushGameMode.OnWavesDepleted_DisableAutoBalance
	 * 		Flags  -> (Final, Native, Private)
	 * Parameters:
	 * 		class UReinforcementSystemComponent*               Component                                                  (ConstParm, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSPushGameMode::OnWavesDepleted_DisableAutoBalance(class UReinforcementSystemComponent* Component)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPushGameMode.OnWavesDepleted_DisableAutoBalance");
		
		AINSPushGameMode_OnWavesDepleted_DisableAutoBalance_Params params {};
		params.Component = Component;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056B3340
	 * 		Name   -> Function Insurgency.INSPushGameMode.OnWaveGained_ReenableAutoBalance
	 * 		Flags  -> (Final, Native, Private)
	 * Parameters:
	 * 		class UReinforcementSystemComponent*               Component                                                  (ConstParm, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            OldWaveCount                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSPushGameMode::OnWaveGained_ReenableAutoBalance(class UReinforcementSystemComponent* Component, int32_t OldWaveCount)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPushGameMode.OnWaveGained_ReenableAutoBalance");
		
		AINSPushGameMode_OnWaveGained_ReenableAutoBalance_Params params {};
		params.Component = Component;
		params.OldWaveCount = OldWaveCount;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> DelegateFunction Insurgency.INSPushGameMode.OnLastStandDelegate__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 */
	void AINSPushGameMode::OnLastStandDelegate__DelegateSignature()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction Insurgency.INSPushGameMode.OnLastStandDelegate__DelegateSignature");
		
		AINSPushGameMode_OnLastStandDelegate__DelegateSignature_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056B3320
	 * 		Name   -> Function Insurgency.INSPushGameMode.LastStandDeferredSetup
	 * 		Flags  -> (Final, Native, Public)
	 */
	void AINSPushGameMode::LastStandDeferredSetup()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPushGameMode.LastStandDeferredSetup");
		
		AINSPushGameMode_LastStandDeferredSetup_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056B3300
	 * 		Name   -> Function Insurgency.INSPushGameMode.DisableInitialSpawnZones
	 * 		Flags  -> (Final, Native, Public)
	 */
	void AINSPushGameMode::DisableInitialSpawnZones()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPushGameMode.DisableInitialSpawnZones");
		
		AINSPushGameMode_DisableInitialSpawnZones_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056B32E0
	 * 		Name   -> Function Insurgency.INSPushGameMode.AdvanceAttackerSpawns
	 * 		Flags  -> (Final, Native, Public)
	 */
	void AINSPushGameMode::AdvanceAttackerSpawns()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSPushGameMode.AdvanceAttackerSpawns");
		
		AINSPushGameMode_AdvanceAttackerSpawns_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AINSPushGameMode.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AINSPushGameMode::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.INSPushGameMode");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056B36D0
	 * 		Name   -> Function Insurgency.INSRangeMode.SetPlayerAndBotTeam
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		unsigned char                                      NewPlayerTeam                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		unsigned char                                      NewBotTeam                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSRangeMode::SetPlayerAndBotTeam(unsigned char NewPlayerTeam, unsigned char NewBotTeam)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSRangeMode.SetPlayerAndBotTeam");
		
		AINSRangeMode_SetPlayerAndBotTeam_Params params {};
		params.NewPlayerTeam = NewPlayerTeam;
		params.NewBotTeam = NewBotTeam;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056B36B0
	 * 		Name   -> Function Insurgency.INSRangeMode.ResetRange
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void AINSRangeMode::ResetRange()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSRangeMode.ResetRange");
		
		AINSRangeMode_ResetRange_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AINSRangeMode.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AINSRangeMode::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.INSRangeMode");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URichPresenceManager.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URichPresenceManager::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.RichPresenceManager");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AINSSandboxGameMode.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AINSSandboxGameMode::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.INSSandboxGameMode");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056B3F40
	 * 		Name   -> Function Insurgency.INSSingleRequestQueryQueue.OnComplete
	 * 		Flags  -> (Final, Native, Private)
	 * Parameters:
	 * 		bool                                               bSuccess                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UINSSingleRequestQueryQueue::OnComplete(bool bSuccess)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSingleRequestQueryQueue.OnComplete");
		
		UINSSingleRequestQueryQueue_OnComplete_Params params {};
		params.bSuccess = bSuccess;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056B3EB0
	 * 		Name   -> Function Insurgency.INSSingleRequestQueryQueue.OnCancelFindComplete
	 * 		Flags  -> (Final, Native, Private)
	 * Parameters:
	 * 		bool                                               bSuccess                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UINSSingleRequestQueryQueue::OnCancelFindComplete(bool bSuccess)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSingleRequestQueryQueue.OnCancelFindComplete");
		
		UINSSingleRequestQueryQueue_OnCancelFindComplete_Params params {};
		params.bSuccess = bSuccess;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UINSSingleRequestQueryQueue.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UINSSingleRequestQueryQueue::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.INSSingleRequestQueryQueue");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056B7080
	 * 		Name   -> Function Insurgency.INSFindSessionCallbackProxy.SortServerListEntries
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		TArray<class UServerListEntry*>                    ServerList                                                 (Parm, OutParm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EServerListSortType                                SortType                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bInverse                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UINSFindSessionCallbackProxy::STATIC_SortServerListEntries(TArray<class UServerListEntry*>* ServerList, EServerListSortType SortType, bool bInverse)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSFindSessionCallbackProxy.SortServerListEntries");
		
		UINSFindSessionCallbackProxy_SortServerListEntries_Params params {};
		params.SortType = SortType;
		params.bInverse = bInverse;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (ServerList != nullptr)
			*ServerList = params.ServerList;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056B6FF0
	 * 		Name   -> Function Insurgency.INSFindSessionCallbackProxy.OnCompleted
	 * 		Flags  -> (Final, Native, Private)
	 * Parameters:
	 * 		bool                                               bSuccess                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UINSFindSessionCallbackProxy::OnCompleted(bool bSuccess)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSFindSessionCallbackProxy.OnCompleted");
		
		UINSFindSessionCallbackProxy_OnCompleted_Params params {};
		params.bSuccess = bSuccess;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056B6E20
	 * 		Name   -> Function Insurgency.INSFindSessionCallbackProxy.MakeServerListEntry
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FBlueprintFindSessionResult                 Result                                                     (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	class UServerListEntry* UINSFindSessionCallbackProxy::STATIC_MakeServerListEntry(const struct FBlueprintFindSessionResult& Result)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSFindSessionCallbackProxy.MakeServerListEntry");
		
		UINSFindSessionCallbackProxy_MakeServerListEntry_Params params {};
		params.Result = Result;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056B67A0
	 * 		Name   -> Function Insurgency.INSFindSessionCallbackProxy.MakeDummyServerListEntry
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class FText                                        Name                                                       (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		class FText                                        Map                                                        (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		class FText                                        Mode                                                       (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		int32_t                                            Players                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            MaxPlayers                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            Ping                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bPassworded                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bOfficialRuleset                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bRanked                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bModded                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FBlueprintFindSessionResult                 ServerToJoin                                               (Parm, NativeAccessSpecifierPublic)
	 */
	class UServerListEntry* UINSFindSessionCallbackProxy::STATIC_MakeDummyServerListEntry(const class FText& Name, const class FText& Map, const class FText& Mode, int32_t Players, int32_t MaxPlayers, int32_t Ping, bool bPassworded, bool bOfficialRuleset, bool bRanked, bool bModded, const struct FBlueprintFindSessionResult& ServerToJoin)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSFindSessionCallbackProxy.MakeDummyServerListEntry");
		
		UINSFindSessionCallbackProxy_MakeDummyServerListEntry_Params params {};
		params.Name = Name;
		params.Map = Map;
		params.Mode = Mode;
		params.Players = Players;
		params.MaxPlayers = MaxPlayers;
		params.Ping = Ping;
		params.bPassworded = bPassworded;
		params.bOfficialRuleset = bOfficialRuleset;
		params.bRanked = bRanked;
		params.bModded = bModded;
		params.ServerToJoin = ServerToJoin;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056B61A0
	 * 		Name   -> Function Insurgency.INSFindSessionCallbackProxy.JoinSession
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            LocalUserNum                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FBlueprintFindSessionResult                 Result                                                     (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		class FString                                      ServerPassword                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UINSFindSessionCallbackProxy::STATIC_JoinSession(class UObject* WorldContextObject, int32_t LocalUserNum, const struct FBlueprintFindSessionResult& Result, const class FString& ServerPassword)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSFindSessionCallbackProxy.JoinSession");
		
		UINSFindSessionCallbackProxy_JoinSession_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.LocalUserNum = LocalUserNum;
		params.Result = Result;
		params.ServerPassword = ServerPassword;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056B5FD0
	 * 		Name   -> Function Insurgency.INSFindSessionCallbackProxy.IsVersusServer
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FBlueprintFindSessionResult                 Result                                                     (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	bool UINSFindSessionCallbackProxy::STATIC_IsVersusServer(const struct FBlueprintFindSessionResult& Result)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSFindSessionCallbackProxy.IsVersusServer");
		
		UINSFindSessionCallbackProxy_IsVersusServer_Params params {};
		params.Result = Result;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056B5E00
	 * 		Name   -> Function Insurgency.INSFindSessionCallbackProxy.IsUsingOfficialRuleset
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FBlueprintFindSessionResult                 Result                                                     (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	bool UINSFindSessionCallbackProxy::STATIC_IsUsingOfficialRuleset(const struct FBlueprintFindSessionResult& Result)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSFindSessionCallbackProxy.IsUsingOfficialRuleset");
		
		UINSFindSessionCallbackProxy_IsUsingOfficialRuleset_Params params {};
		params.Result = Result;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056B5C30
	 * 		Name   -> Function Insurgency.INSFindSessionCallbackProxy.IsRunningMutators
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FBlueprintFindSessionResult                 Result                                                     (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	bool UINSFindSessionCallbackProxy::STATIC_IsRunningMutators(const struct FBlueprintFindSessionResult& Result)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSFindSessionCallbackProxy.IsRunningMutators");
		
		UINSFindSessionCallbackProxy_IsRunningMutators_Params params {};
		params.Result = Result;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056B5A60
	 * 		Name   -> Function Insurgency.INSFindSessionCallbackProxy.IsRunningMods
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FBlueprintFindSessionResult                 Result                                                     (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	bool UINSFindSessionCallbackProxy::STATIC_IsRunningMods(const struct FBlueprintFindSessionResult& Result)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSFindSessionCallbackProxy.IsRunningMods");
		
		UINSFindSessionCallbackProxy_IsRunningMods_Params params {};
		params.Result = Result;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056B5890
	 * 		Name   -> Function Insurgency.INSFindSessionCallbackProxy.IsRankedServer
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FBlueprintFindSessionResult                 Result                                                     (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	bool UINSFindSessionCallbackProxy::STATIC_IsRankedServer(const struct FBlueprintFindSessionResult& Result)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSFindSessionCallbackProxy.IsRankedServer");
		
		UINSFindSessionCallbackProxy_IsRankedServer_Params params {};
		params.Result = Result;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056B56C0
	 * 		Name   -> Function Insurgency.INSFindSessionCallbackProxy.IsPasswordProtected
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FBlueprintFindSessionResult                 Result                                                     (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	bool UINSFindSessionCallbackProxy::STATIC_IsPasswordProtected(const struct FBlueprintFindSessionResult& Result)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSFindSessionCallbackProxy.IsPasswordProtected");
		
		UINSFindSessionCallbackProxy_IsPasswordProtected_Params params {};
		params.Result = Result;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056B54F0
	 * 		Name   -> Function Insurgency.INSFindSessionCallbackProxy.IsCoopServer
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FBlueprintFindSessionResult                 Result                                                     (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	bool UINSFindSessionCallbackProxy::STATIC_IsCoopServer(const struct FBlueprintFindSessionResult& Result)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSFindSessionCallbackProxy.IsCoopServer");
		
		UINSFindSessionCallbackProxy_IsCoopServer_Params params {};
		params.Result = Result;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x009D6F00
	 * 		Name   -> Function Insurgency.INSFindSessionCallbackProxy.GetServerName
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FBlueprintFindSessionResult                 Result                                                     (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	class FString UINSFindSessionCallbackProxy::STATIC_GetServerName(const struct FBlueprintFindSessionResult& Result)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSFindSessionCallbackProxy.GetServerName");
		
		UINSFindSessionCallbackProxy_GetServerName_Params params {};
		params.Result = Result;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056B5320
	 * 		Name   -> Function Insurgency.INSFindSessionCallbackProxy.GetServerEntryType
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FBlueprintFindSessionResult                 Result                                                     (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	EServerEntryType UINSFindSessionCallbackProxy::STATIC_GetServerEntryType(const struct FBlueprintFindSessionResult& Result)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSFindSessionCallbackProxy.GetServerEntryType");
		
		UINSFindSessionCallbackProxy_GetServerEntryType_Params params {};
		params.Result = Result;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x009D6D30
	 * 		Name   -> Function Insurgency.INSFindSessionCallbackProxy.GetPingInMs
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FBlueprintFindSessionResult                 Result                                                     (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	int32_t UINSFindSessionCallbackProxy::STATIC_GetPingInMs(const struct FBlueprintFindSessionResult& Result)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSFindSessionCallbackProxy.GetPingInMs");
		
		UINSFindSessionCallbackProxy_GetPingInMs_Params params {};
		params.Result = Result;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056B5150
	 * 		Name   -> Function Insurgency.INSFindSessionCallbackProxy.GetMaxPlayers
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FBlueprintFindSessionResult                 Result                                                     (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	int32_t UINSFindSessionCallbackProxy::STATIC_GetMaxPlayers(const struct FBlueprintFindSessionResult& Result)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSFindSessionCallbackProxy.GetMaxPlayers");
		
		UINSFindSessionCallbackProxy_GetMaxPlayers_Params params {};
		params.Result = Result;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056B4F40
	 * 		Name   -> Function Insurgency.INSFindSessionCallbackProxy.GetLevel
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FBlueprintFindSessionResult                 Result                                                     (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	class FString UINSFindSessionCallbackProxy::STATIC_GetLevel(const struct FBlueprintFindSessionResult& Result)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSFindSessionCallbackProxy.GetLevel");
		
		UINSFindSessionCallbackProxy_GetLevel_Params params {};
		params.Result = Result;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056B4D30
	 * 		Name   -> Function Insurgency.INSFindSessionCallbackProxy.GetGamemode
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FBlueprintFindSessionResult                 Result                                                     (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	class FString UINSFindSessionCallbackProxy::STATIC_GetGamemode(const struct FBlueprintFindSessionResult& Result)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSFindSessionCallbackProxy.GetGamemode");
		
		UINSFindSessionCallbackProxy_GetGamemode_Params params {};
		params.Result = Result;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056B4B60
	 * 		Name   -> Function Insurgency.INSFindSessionCallbackProxy.GetCurrentPlayers
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FBlueprintFindSessionResult                 Result                                                     (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	int32_t UINSFindSessionCallbackProxy::STATIC_GetCurrentPlayers(const struct FBlueprintFindSessionResult& Result)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSFindSessionCallbackProxy.GetCurrentPlayers");
		
		UINSFindSessionCallbackProxy_GetCurrentPlayers_Params params {};
		params.Result = Result;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056B48F0
	 * 		Name   -> Function Insurgency.INSFindSessionCallbackProxy.FindServerSessionsFiltered
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class APlayerController*                           PlayerController                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            MaxResults                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bUseLAN                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bUseFavorite                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FServerBrowserPreferences                   Filters                                                    (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		class UINSSingleRequestQueryQueue*                 Queue                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UINSFindSessionCallbackProxy* UINSFindSessionCallbackProxy::STATIC_FindServerSessionsFiltered(class UObject* WorldContextObject, class APlayerController* PlayerController, int32_t MaxResults, bool bUseLAN, bool bUseFavorite, const struct FServerBrowserPreferences& Filters, class UINSSingleRequestQueryQueue* Queue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSFindSessionCallbackProxy.FindServerSessionsFiltered");
		
		UINSFindSessionCallbackProxy_FindServerSessionsFiltered_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.PlayerController = PlayerController;
		params.MaxResults = MaxResults;
		params.bUseLAN = bUseLAN;
		params.bUseFavorite = bUseFavorite;
		params.Filters = Filters;
		params.Queue = Queue;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056B46F0
	 * 		Name   -> Function Insurgency.INSFindSessionCallbackProxy.FindServerSessions
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class APlayerController*                           PlayerController                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            MaxResults                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bUseLAN                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bCoopSearch                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bVersusSearch                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UINSSingleRequestQueryQueue*                 Queue                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UINSFindSessionCallbackProxy* UINSFindSessionCallbackProxy::STATIC_FindServerSessions(class UObject* WorldContextObject, class APlayerController* PlayerController, int32_t MaxResults, bool bUseLAN, bool bCoopSearch, bool bVersusSearch, class UINSSingleRequestQueryQueue* Queue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSFindSessionCallbackProxy.FindServerSessions");
		
		UINSFindSessionCallbackProxy_FindServerSessions_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.PlayerController = PlayerController;
		params.MaxResults = MaxResults;
		params.bUseLAN = bUseLAN;
		params.bCoopSearch = bCoopSearch;
		params.bVersusSearch = bVersusSearch;
		params.Queue = Queue;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UINSFindSessionCallbackProxy.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UINSFindSessionCallbackProxy::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.INSFindSessionCallbackProxy");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056B64A0
	 * 		Name   -> Function Insurgency.INSJoinSessionCallbackProxy.JoinSession
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class APlayerController*                           PlayerController                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FBlueprintFindSessionResult                 SearchResult                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		class FString                                      ServerPassword                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UINSJoinSessionCallbackProxy* UINSJoinSessionCallbackProxy::STATIC_JoinSession(class UObject* WorldContextObject, class APlayerController* PlayerController, const struct FBlueprintFindSessionResult& SearchResult, const class FString& ServerPassword)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSJoinSessionCallbackProxy.JoinSession");
		
		UINSJoinSessionCallbackProxy_JoinSession_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.PlayerController = PlayerController;
		params.SearchResult = SearchResult;
		params.ServerPassword = ServerPassword;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UINSJoinSessionCallbackProxy.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UINSJoinSessionCallbackProxy::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.INSJoinSessionCallbackProxy");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UINSSessionHelper.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UINSSessionHelper::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.INSSessionHelper");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UINSSignificanceManager.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UINSSignificanceManager::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.INSSignificanceManager");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056B7A70
	 * 		Name   -> Function Insurgency.INSSkeletalMeshComponent.UsesCustomFOV
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool UINSSkeletalMeshComponent::UsesCustomFOV()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSkeletalMeshComponent.UsesCustomFOV");
		
		UINSSkeletalMeshComponent_UsesCustomFOV_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056B7990
	 * 		Name   -> Function Insurgency.INSSkeletalMeshComponent.ReprojectTransform
	 * 		Flags  -> (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		struct FTransform                                  InOutTransform                                             (Parm, OutParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UINSSkeletalMeshComponent::ReprojectTransform(struct FTransform* InOutTransform)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSkeletalMeshComponent.ReprojectTransform");
		
		UINSSkeletalMeshComponent_ReprojectTransform_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (InOutTransform != nullptr)
			*InOutTransform = params.InOutTransform;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056B7900
	 * 		Name   -> Function Insurgency.INSSkeletalMeshComponent.ReprojectMatrix
	 * 		Flags  -> (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		struct FMatrix                                     InMatrix                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UINSSkeletalMeshComponent::ReprojectMatrix(struct FMatrix* InMatrix)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSkeletalMeshComponent.ReprojectMatrix");
		
		UINSSkeletalMeshComponent_ReprojectMatrix_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (InMatrix != nullptr)
			*InMatrix = params.InMatrix;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056B7800
	 * 		Name   -> Function Insurgency.INSSkeletalMeshComponent.OnSkeletalMeshLoaded
	 * 		Flags  -> (Final, Native, Public)
	 */
	void UINSSkeletalMeshComponent::OnSkeletalMeshLoaded()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSkeletalMeshComponent.OnSkeletalMeshLoaded");
		
		UINSSkeletalMeshComponent_OnSkeletalMeshLoaded_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056B77D0
	 * 		Name   -> Function Insurgency.INSSkeletalMeshComponent.GetCustomFOV
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	float UINSSkeletalMeshComponent::GetCustomFOV()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSkeletalMeshComponent.GetCustomFOV");
		
		UINSSkeletalMeshComponent_GetCustomFOV_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UINSSkeletalMeshComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UINSSkeletalMeshComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.INSSkeletalMeshComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056B7C00
	 * 		Name   -> Function Insurgency.INSSkeletalMeshMerge.Tick
	 * 		Flags  -> (Final, Native, Protected)
	 */
	void UINSSkeletalMeshMerge::Tick()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSkeletalMeshMerge.Tick");
		
		UINSSkeletalMeshMerge_Tick_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UINSSkeletalMeshMerge.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UINSSkeletalMeshMerge::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.INSSkeletalMeshMerge");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056B7F80
	 * 		Name   -> Function Insurgency.INSSkirmishGameMode.GetTotalActiveObjectives
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	int32_t AINSSkirmishGameMode::GetTotalActiveObjectives()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSkirmishGameMode.GetTotalActiveObjectives");
		
		AINSSkirmishGameMode_GetTotalActiveObjectives_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056B7EB0
	 * 		Name   -> Function Insurgency.INSSkirmishGameMode.GetNumActiveObjectivesOwnedForTeam
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		unsigned char                                      TeamId                                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bIncludeContested                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	int32_t AINSSkirmishGameMode::GetNumActiveObjectivesOwnedForTeam(unsigned char TeamId, bool bIncludeContested)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSkirmishGameMode.GetNumActiveObjectivesOwnedForTeam");
		
		AINSSkirmishGameMode_GetNumActiveObjectivesOwnedForTeam_Params params {};
		params.TeamId = TeamId;
		params.bIncludeContested = bIncludeContested;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056B7E80
	 * 		Name   -> Function Insurgency.INSSkirmishGameMode.CheckWinConditions
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	bool AINSSkirmishGameMode::CheckWinConditions()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSkirmishGameMode.CheckWinConditions");
		
		AINSSkirmishGameMode_CheckWinConditions_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05676050
	 * 		Name   -> Function Insurgency.INSSkirmishGameMode.CheckCustomEliminationRules
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void AINSSkirmishGameMode::CheckCustomEliminationRules()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSkirmishGameMode.CheckCustomEliminationRules");
		
		AINSSkirmishGameMode_CheckCustomEliminationRules_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056B7E60
	 * 		Name   -> Function Insurgency.INSSkirmishGameMode.CheckAllPointsSecure
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void AINSSkirmishGameMode::CheckAllPointsSecure()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSkirmishGameMode.CheckAllPointsSecure");
		
		AINSSkirmishGameMode_CheckAllPointsSecure_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AINSSkirmishGameMode.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AINSSkirmishGameMode::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.INSSkirmishGameMode");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056C5780
	 * 		Name   -> Function Insurgency.INSSoldier.UpdateWeightMovementParameters
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void AINSSoldier::UpdateWeightMovementParameters()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.UpdateWeightMovementParameters");
		
		AINSSoldier_UpdateWeightMovementParameters_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056C5760
	 * 		Name   -> Function Insurgency.INSSoldier.UpdateLocalRTPC
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void AINSSoldier::UpdateLocalRTPC()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.UpdateLocalRTPC");
		
		AINSSoldier_UpdateLocalRTPC_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056C5740
	 * 		Name   -> Function Insurgency.INSSoldier.UpdateFirstPersonVisibility
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void AINSSoldier::UpdateFirstPersonVisibility()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.UpdateFirstPersonVisibility");
		
		AINSSoldier_UpdateFirstPersonVisibility_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056C5670
	 * 		Name   -> Function Insurgency.INSSoldier.UnequipAllItems
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class AItemEquipable*                              IgnoreItem                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bInstant                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSSoldier::UnequipAllItems(class AItemEquipable* IgnoreItem, bool bInstant)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.UnequipAllItems");
		
		AINSSoldier_UnequipAllItems_Params params {};
		params.IgnoreItem = IgnoreItem;
		params.bInstant = bInstant;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056C5650
	 * 		Name   -> Function Insurgency.INSSoldier.SpawnRandomInventoryFromAvailableItems
	 * 		Flags  -> (Final, Exec, Native, Protected)
	 */
	void AINSSoldier::SpawnRandomInventoryFromAvailableItems()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.SpawnRandomInventoryFromAvailableItems");
		
		AINSSoldier_SpawnRandomInventoryFromAvailableItems_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056C5590
	 * 		Name   -> Function Insurgency.INSSoldier.SoldierPreDoorKick
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               KickWillSucceed                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class ADoor*                                       Door                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSSoldier::SoldierPreDoorKick(bool KickWillSucceed, class ADoor* Door)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.SoldierPreDoorKick");
		
		AINSSoldier_SoldierPreDoorKick_Params params {};
		params.KickWillSucceed = KickWillSucceed;
		params.Door = Door;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056C5560
	 * 		Name   -> Function Insurgency.INSSoldier.ShouldDealDamageInSpawnZone
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AINSSoldier::ShouldDealDamageInSpawnZone()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.ShouldDealDamageInSpawnZone");
		
		AINSSoldier_ShouldDealDamageInSpawnZone_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056C54E0
	 * 		Name   -> Function Insurgency.INSSoldier.SetWeight
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		float                                              NewWeight                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSSoldier::SetWeight(float NewWeight)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.SetWeight");
		
		AINSSoldier_SetWeight_Params params {};
		params.NewWeight = NewWeight;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056C5410
	 * 		Name   -> Function Insurgency.INSSoldier.SetStance
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		ESoldierStance                                     NewStance                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bClientSimulation                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool AINSSoldier::SetStance(ESoldierStance NewStance, bool bClientSimulation)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.SetStance");
		
		AINSSoldier_SetStance_Params params {};
		params.NewStance = NewStance;
		params.bClientSimulation = bClientSimulation;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056C5390
	 * 		Name   -> Function Insurgency.INSSoldier.SetStamina
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		float                                              NewStaminaValue                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSSoldier::SetStamina(float NewStaminaValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.SetStamina");
		
		AINSSoldier_SetStamina_Params params {};
		params.NewStaminaValue = NewStaminaValue;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056C5310
	 * 		Name   -> Function Insurgency.INSSoldier.SetMaxWaterDepthForProne
	 * 		Flags  -> (Final, Exec, Native, Protected)
	 * Parameters:
	 * 		float                                              InMaxWaterDepth                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSSoldier::SetMaxWaterDepthForProne(float InMaxWaterDepth)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.SetMaxWaterDepthForProne");
		
		AINSSoldier_SetMaxWaterDepthForProne_Params params {};
		params.InMaxWaterDepth = InMaxWaterDepth;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05630E50
	 * 		Name   -> Function Insurgency.INSSoldier.SetInSpawnZone
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bSpawnZone                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSSoldier::SetInSpawnZone(bool bSpawnZone)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.SetInSpawnZone");
		
		AINSSoldier_SetInSpawnZone_Params params {};
		params.bSpawnZone = bSpawnZone;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056C5240
	 * 		Name   -> Function Insurgency.INSSoldier.SetFocusMode
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bNewState                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bFromReplication                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSSoldier::SetFocusMode(bool bNewState, bool bFromReplication)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.SetFocusMode");
		
		AINSSoldier_SetFocusMode_Params params {};
		params.bNewState = bNewState;
		params.bFromReplication = bFromReplication;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056C4FB0
	 * 		Name   -> Function Insurgency.INSSoldier.ServerUse
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetServer, BlueprintCallable, NetValidate)
	 * Parameters:
	 * 		class AActor*                                      UseActor                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FHitResult                                  HitResult                                                  (ConstParm, Parm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	void AINSSoldier::ServerUse(class AActor* UseActor, const struct FHitResult& HitResult)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.ServerUse");
		
		AINSSoldier_ServerUse_Params params {};
		params.UseActor = UseActor;
		params.HitResult = HitResult;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056C4F00
	 * 		Name   -> Function Insurgency.INSSoldier.ServerUpdateInputLeanDirection
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
	 * Parameters:
	 * 		ELeanDirection                                     NewInputLeanDirection                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSSoldier::ServerUpdateInputLeanDirection(ELeanDirection NewInputLeanDirection)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.ServerUpdateInputLeanDirection");
		
		AINSSoldier_ServerUpdateInputLeanDirection_Params params {};
		params.NewInputLeanDirection = NewInputLeanDirection;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056C4E40
	 * 		Name   -> Function Insurgency.INSSoldier.ServerUpdateFreeaim
	 * 		Flags  -> (Net, Native, Event, Public, NetServer, NetValidate)
	 * Parameters:
	 * 		int32_t                                            CompressedAngle                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSSoldier::ServerUpdateFreeaim(int32_t CompressedAngle)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.ServerUpdateFreeaim");
		
		AINSSoldier_ServerUpdateFreeaim_Params params {};
		params.CompressedAngle = CompressedAngle;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056C4DF0
	 * 		Name   -> Function Insurgency.INSSoldier.ServerStopSlide
	 * 		Flags  -> (Net, NetReliable, Native, Event, Protected, NetServer, NetValidate)
	 */
	void AINSSoldier::ServerStopSlide()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.ServerStopSlide");
		
		AINSSoldier_ServerStopSlide_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056C4D00
	 * 		Name   -> Function Insurgency.INSSoldier.ServerSoldierPreDoorKick
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
	 * Parameters:
	 * 		bool                                               KickWillSucceed                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class ADoor*                                       Door                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSSoldier::ServerSoldierPreDoorKick(bool KickWillSucceed, class ADoor* Door)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.ServerSoldierPreDoorKick");
		
		AINSSoldier_ServerSoldierPreDoorKick_Params params {};
		params.KickWillSucceed = KickWillSucceed;
		params.Door = Door;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056C4C50
	 * 		Name   -> Function Insurgency.INSSoldier.ServerSoldierDoorKick
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
	 * Parameters:
	 * 		class ADoor*                                       Door                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSSoldier::ServerSoldierDoorKick(class ADoor* Door)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.ServerSoldierDoorKick");
		
		AINSSoldier_ServerSoldierDoorKick_Params params {};
		params.Door = Door;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056C4BA0
	 * 		Name   -> Function Insurgency.INSSoldier.ServerSetFocusMode
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
	 * Parameters:
	 * 		bool                                               bNewState                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSSoldier::ServerSetFocusMode(bool bNewState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.ServerSetFocusMode");
		
		AINSSoldier_ServerSetFocusMode_Params params {};
		params.bNewState = bNewState;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056C4AE0
	 * 		Name   -> Function Insurgency.INSSoldier.ServerSetCameraIsTargetingKillLocation
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
	 * Parameters:
	 * 		bool                                               bActive                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSSoldier::ServerSetCameraIsTargetingKillLocation(bool bActive)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.ServerSetCameraIsTargetingKillLocation");
		
		AINSSoldier_ServerSetCameraIsTargetingKillLocation_Params params {};
		params.bActive = bActive;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056C4A90
	 * 		Name   -> Function Insurgency.INSSoldier.ServerOnUseReleased
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
	 */
	void AINSSoldier::ServerOnUseReleased()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.ServerOnUseReleased");
		
		AINSSoldier_ServerOnUseReleased_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056C4A40
	 * 		Name   -> Function Insurgency.INSSoldier.ServerMelee
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetServer, BlueprintCallable, NetValidate)
	 */
	void AINSSoldier::ServerMelee()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.ServerMelee");
		
		AINSSoldier_ServerMelee_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056C49A0
	 * 		Name   -> Function Insurgency.INSSoldier.ServerInteractGearInSlot
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
	 * Parameters:
	 * 		EItemSlot                                          GearSlot                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSSoldier::ServerInteractGearInSlot(EItemSlot GearSlot)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.ServerInteractGearInSlot");
		
		AINSSoldier_ServerInteractGearInSlot_Params params {};
		params.GearSlot = GearSlot;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056C48B0
	 * 		Name   -> Function Insurgency.INSSoldier.ServerInformBulletHit
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
	 * Parameters:
	 * 		struct FClientBulletHit                            BulletHit                                                  (ConstParm, Parm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	void AINSSoldier::ServerInformBulletHit(const struct FClientBulletHit& BulletHit)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.ServerInformBulletHit");
		
		AINSSoldier_ServerInformBulletHit_Params params {};
		params.BulletHit = BulletHit;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056C4860
	 * 		Name   -> Function Insurgency.INSSoldier.ServerHandleVehicleUse
	 * 		Flags  -> (Net, NetReliable, Native, Event, Protected, NetServer, NetValidate)
	 */
	void AINSSoldier::ServerHandleVehicleUse()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.ServerHandleVehicleUse");
		
		AINSSoldier_ServerHandleVehicleUse_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056C47A0
	 * 		Name   -> Function Insurgency.INSSoldier.ServerEquipInventoryItem
	 * 		Flags  -> (Net, NetReliable, Native, Event, Protected, NetServer, NetValidate)
	 * Parameters:
	 * 		class AItemEquipable*                              Item                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSSoldier::ServerEquipInventoryItem(class AItemEquipable* Item)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.ServerEquipInventoryItem");
		
		AINSSoldier_ServerEquipInventoryItem_Params params {};
		params.Item = Item;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056C4700
	 * 		Name   -> Function Insurgency.INSSoldier.ServerDoSelectInventorySlot
	 * 		Flags  -> (Final, Net, NetReliable, Native, Event, Private, NetServer, NetValidate)
	 * Parameters:
	 * 		EItemSlot                                          Slot                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSSoldier::ServerDoSelectInventorySlot(EItemSlot Slot)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.ServerDoSelectInventorySlot");
		
		AINSSoldier_ServerDoSelectInventorySlot_Params params {};
		params.Slot = Slot;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056C4650
	 * 		Name   -> Function Insurgency.INSSoldier.ServerBreachDoor
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
	 * Parameters:
	 * 		class ADoor*                                       Door                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSSoldier::ServerBreachDoor(class ADoor* Door)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.ServerBreachDoor");
		
		AINSSoldier_ServerBreachDoor_Params params {};
		params.Door = Door;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056C4600
	 * 		Name   -> Function Insurgency.INSSoldier.ServerAttemptToSlide
	 * 		Flags  -> (Net, NetReliable, Native, Event, Protected, NetServer, NetValidate)
	 */
	void AINSSoldier::ServerAttemptToSlide()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.ServerAttemptToSlide");
		
		AINSSoldier_ServerAttemptToSlide_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056C5190
	 * 		Name   -> Function Insurgency.INSSoldier.Server_SetVehicleStance
	 * 		Flags  -> (Net, NetReliable, Native, Event, Protected, NetServer, NetValidate)
	 * Parameters:
	 * 		EVehicleStance                                     NewStance                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSSoldier::Server_SetVehicleStance(EVehicleStance NewStance)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.Server_SetVehicleStance");
		
		AINSSoldier_Server_SetVehicleStance_Params params {};
		params.NewStance = NewStance;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056C5140
	 * 		Name   -> Function Insurgency.INSSoldier.Server_FindWeaponForDriver
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
	 */
	void AINSSoldier::Server_FindWeaponForDriver()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.Server_FindWeaponForDriver");
		
		AINSSoldier_Server_FindWeaponForDriver_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056C50F0
	 * 		Name   -> Function Insurgency.INSSoldier.Server_DriverPutAwayWeapon
	 * 		Flags  -> (Net, NetReliable, Native, Event, Protected, NetServer, NetValidate)
	 */
	void AINSSoldier::Server_DriverPutAwayWeapon()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.Server_DriverPutAwayWeapon");
		
		AINSSoldier_Server_DriverPutAwayWeapon_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056C4570
	 * 		Name   -> Function Insurgency.INSSoldier.SelectInventorySlot
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		EItemSlot                                          Slot                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool AINSSoldier::SelectInventorySlot(EItemSlot Slot)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.SelectInventorySlot");
		
		AINSSoldier_SelectInventorySlot_Params params {};
		params.Slot = Slot;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056C4540
	 * 		Name   -> Function Insurgency.INSSoldier.SelectFirstAvailableInventoryItem
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	bool AINSSoldier::SelectFirstAvailableInventoryItem()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.SelectFirstAvailableInventoryItem");
		
		AINSSoldier_SelectFirstAvailableInventoryItem_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x04DB38C0
	 * 		Name   -> Function Insurgency.INSSoldier.Revive
	 * 		Flags  -> (Exec, Native, Public)
	 */
	void AINSSoldier::Revive()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.Revive");
		
		AINSSoldier_Revive_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056C4510
	 * 		Name   -> Function Insurgency.INSSoldier.Resupply
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	bool AINSSoldier::Resupply()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.Resupply");
		
		AINSSoldier_Resupply_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056C44F0
	 * 		Name   -> Function Insurgency.INSSoldier.ResetResupplyCooldown
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void AINSSoldier::ResetResupplyCooldown()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.ResetResupplyCooldown");
		
		AINSSoldier_ResetResupplyCooldown_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056C4430
	 * 		Name   -> Function Insurgency.INSSoldier.RemoveMagazine
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UClass*                                      AmmoType                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            NumToRemove                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool AINSSoldier::RemoveMagazine(class UClass* AmmoType, int32_t NumToRemove)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.RemoveMagazine");
		
		AINSSoldier_RemoveMagazine_Params params {};
		params.AmmoType = AmmoType;
		params.NumToRemove = NumToRemove;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056C43A0
	 * 		Name   -> Function Insurgency.INSSoldier.RemoveInventoryItems
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bForce                                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSSoldier::RemoveInventoryItems(bool bForce)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.RemoveInventoryItems");
		
		AINSSoldier_RemoveInventoryItems_Params params {};
		params.bForce = bForce;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056C4310
	 * 		Name   -> Function Insurgency.INSSoldier.RemoveFromInventory
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class AItemBase*                                   Item                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool AINSSoldier::RemoveFromInventory(class AItemBase* Item)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.RemoveFromInventory");
		
		AINSSoldier_RemoveFromInventory_Params params {};
		params.Item = Item;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056C42F0
	 * 		Name   -> Function Insurgency.INSSoldier.RemoveCosmetics
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void AINSSoldier::RemoveCosmetics()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.RemoveCosmetics");
		
		AINSSoldier_RemoveCosmetics_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056C42D0
	 * 		Name   -> Function Insurgency.INSSoldier.RefreshFirstPersonCosmeticVisibility
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void AINSSoldier::RefreshFirstPersonCosmeticVisibility()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.RefreshFirstPersonCosmeticVisibility");
		
		AINSSoldier_RefreshFirstPersonCosmeticVisibility_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056C4240
	 * 		Name   -> Function Insurgency.INSSoldier.ReequipWeapon
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bFallbackSelectFirst                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool AINSSoldier::ReequipWeapon(bool bFallbackSelectFirst)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.ReequipWeapon");
		
		AINSSoldier_ReequipWeapon_Params params {};
		params.bFallbackSelectFirst = bFallbackSelectFirst;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056C41C0
	 * 		Name   -> Function Insurgency.INSSoldier.RecoverStamina
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		float                                              Amount                                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSSoldier::RecoverStamina(float Amount)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.RecoverStamina");
		
		AINSSoldier_RecoverStamina_Params params {};
		params.Amount = Amount;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056C41A0
	 * 		Name   -> Function Insurgency.INSSoldier.RecalculateWeight
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void AINSSoldier::RecalculateWeight()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.RecalculateWeight");
		
		AINSSoldier_RecalculateWeight_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056C4060
	 * 		Name   -> Function Insurgency.INSSoldier.PlaySurfaceReactionPair
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		struct FSurfaceReactionPair                        Pair                                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		struct FHitResult                                  Trace                                                      (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	void AINSSoldier::PlaySurfaceReactionPair(const struct FSurfaceReactionPair& Pair, const struct FHitResult& Trace)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.PlaySurfaceReactionPair");
		
		AINSSoldier_PlaySurfaceReactionPair_Params params {};
		params.Pair = Pair;
		params.Trace = Trace;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056C3FD0
	 * 		Name   -> Function Insurgency.INSSoldier.PlaySurfaceReactionGround
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		struct FSurfaceReactionPair                        Pair                                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void AINSSoldier::PlaySurfaceReactionGround(const struct FSurfaceReactionPair& Pair)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.PlaySurfaceReactionGround");
		
		AINSSoldier_PlaySurfaceReactionGround_Params params {};
		params.Pair = Pair;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056C3D60
	 * 		Name   -> Function Insurgency.INSSoldier.PlaySurfaceReaction
	 * 		Flags  -> (Final, Native, Private, HasOutParms)
	 * Parameters:
	 * 		struct FSurfaceReactionPair                        Pair                                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		struct FHitResult                                  Trace                                                      (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 * 		struct FWWiseData                                  CustomAudioData                                            (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void AINSSoldier::PlaySurfaceReaction(const struct FSurfaceReactionPair& Pair, const struct FHitResult& Trace, const struct FWWiseData& CustomAudioData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.PlaySurfaceReaction");
		
		AINSSoldier_PlaySurfaceReaction_Params params {};
		params.Pair = Pair;
		params.Trace = Trace;
		params.CustomAudioData = CustomAudioData;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056C3D40
	 * 		Name   -> Function Insurgency.INSSoldier.PlayQueuedResponse
	 * 		Flags  -> (Final, Native, Private)
	 */
	void AINSSoldier::PlayQueuedResponse()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.PlayQueuedResponse");
		
		AINSSoldier_PlayQueuedResponse_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056C3BF0
	 * 		Name   -> Function Insurgency.INSSoldier.PlayPainSound
	 * 		Flags  -> (Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UINSDamageType*                              DamageType                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Damage                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bWasFriendlyFire                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bHeadshot                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSSoldier::PlayPainSound(class UINSDamageType* DamageType, float Damage, bool bWasFriendlyFire, bool bHeadshot)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.PlayPainSound");
		
		AINSSoldier_PlayPainSound_Params params {};
		params.DamageType = DamageType;
		params.Damage = Damage;
		params.bWasFriendlyFire = bWasFriendlyFire;
		params.bHeadshot = bHeadshot;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056C3BD0
	 * 		Name   -> Function Insurgency.INSSoldier.PlayObserverThank
	 * 		Flags  -> (Final, Native, Private)
	 */
	void AINSSoldier::PlayObserverThank()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.PlayObserverThank");
		
		AINSSoldier_PlayObserverThank_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056C3B40
	 * 		Name   -> Function Insurgency.INSSoldier.PlayGenericSoundEventMulticast
	 * 		Flags  -> (Net, NetReliable, Native, Event, NetMulticast, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UAkAudioEvent*                               Event                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSSoldier::PlayGenericSoundEventMulticast(class UAkAudioEvent* Event)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.PlayGenericSoundEventMulticast");
		
		AINSSoldier_PlayGenericSoundEventMulticast_Params params {};
		params.Event = Event;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056C3A60
	 * 		Name   -> Function Insurgency.INSSoldier.PlayGenericParticleEffectMulticast
	 * 		Flags  -> (Net, NetReliable, Native, Event, NetMulticast, Public, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		class UParticleSystem*                             Event                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     Location                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSSoldier::PlayGenericParticleEffectMulticast(class UParticleSystem* Event, const struct FVector& Location)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.PlayGenericParticleEffectMulticast");
		
		AINSSoldier_PlayGenericParticleEffectMulticast_Params params {};
		params.Event = Event;
		params.Location = Location;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x04DB4F40
	 * 		Name   -> Function Insurgency.INSSoldier.PlayFallDamageMulticast
	 * 		Flags  -> (Net, Native, Event, NetMulticast, Public, BlueprintCallable)
	 */
	void AINSSoldier::PlayFallDamageMulticast()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.PlayFallDamageMulticast");
		
		AINSSoldier_PlayFallDamageMulticast_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056C38C0
	 * 		Name   -> Function Insurgency.INSSoldier.PlayDialogue
	 * 		Flags  -> (Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		struct FCharacterResponseRequest                   SpeakRequest                                               (Parm, NativeAccessSpecifierPublic)
	 */
	bool AINSSoldier::PlayDialogue(const struct FCharacterResponseRequest& SpeakRequest)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.PlayDialogue");
		
		AINSSoldier_PlayDialogue_Params params {};
		params.SpeakRequest = SpeakRequest;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056C3800
	 * 		Name   -> Function Insurgency.INSSoldier.PlayCharacterSoundEvent
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UAkAudioEvent*                               FirstPersonEvent                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UAkAudioEvent*                               ThirdPersonEvent                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSSoldier::PlayCharacterSoundEvent(class UAkAudioEvent* FirstPersonEvent, class UAkAudioEvent* ThirdPersonEvent)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.PlayCharacterSoundEvent");
		
		AINSSoldier_PlayCharacterSoundEvent_Params params {};
		params.FirstPersonEvent = FirstPersonEvent;
		params.ThirdPersonEvent = ThirdPersonEvent;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056C37E0
	 * 		Name   -> Function Insurgency.INSSoldier.PerformResupply
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void AINSSoldier::PerformResupply()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.PerformResupply");
		
		AINSSoldier_PerformResupply_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056C3640
	 * 		Name   -> Function Insurgency.INSSoldier.OnSoundscapeUpdate
	 * 		Flags  -> (Final, Native, Public, HasOutParms)
	 * Parameters:
	 * 		struct FSoundscapeStateRepl                        State                                                      (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void AINSSoldier::OnSoundscapeUpdate(const struct FSoundscapeStateRepl& State)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.OnSoundscapeUpdate");
		
		AINSSoldier_OnSoundscapeUpdate_Params params {};
		params.State = State;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> Function Insurgency.INSSoldier.OnSlideStopped
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 * Parameters:
	 * 		float                                              SlideTransitionDuration                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSSoldier::OnSlideStopped(float SlideTransitionDuration)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.OnSlideStopped");
		
		AINSSoldier_OnSlideStopped_Params params {};
		params.SlideTransitionDuration = SlideTransitionDuration;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> Function Insurgency.INSSoldier.OnResponseSpoken
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		ECharacterResponse                                 Response                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSSoldier::OnResponseSpoken(ECharacterResponse Response)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.OnResponseSpoken");
		
		AINSSoldier_OnResponseSpoken_Params params {};
		params.Response = Response;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056C35C0
	 * 		Name   -> Function Insurgency.INSSoldier.OnResponseInterrupted
	 * 		Flags  -> (Final, Native, Private)
	 * Parameters:
	 * 		ECharacterResponse                                 Response                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSSoldier::OnResponseInterrupted(ECharacterResponse Response)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.OnResponseInterrupted");
		
		AINSSoldier_OnResponseInterrupted_Params params {};
		params.Response = Response;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056C33C0
	 * 		Name   -> Function Insurgency.INSSoldier.OnReserveAmmoUpdated
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void AINSSoldier::OnReserveAmmoUpdated()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.OnReserveAmmoUpdated");
		
		AINSSoldier_OnReserveAmmoUpdated_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056C35A0
	 * 		Name   -> Function Insurgency.INSSoldier.OnRep_Weight
	 * 		Flags  -> (Final, Native, Private)
	 */
	void AINSSoldier::OnRep_Weight()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.OnRep_Weight");
		
		AINSSoldier_OnRep_Weight_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056C3580
	 * 		Name   -> Function Insurgency.INSSoldier.OnRep_VehicleStance
	 * 		Flags  -> (Final, Native, Public)
	 */
	void AINSSoldier::OnRep_VehicleStance()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.OnRep_VehicleStance");
		
		AINSSoldier_OnRep_VehicleStance_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056C3560
	 * 		Name   -> Function Insurgency.INSSoldier.OnRep_Vaulting
	 * 		Flags  -> (Final, Native, Public)
	 */
	void AINSSoldier::OnRep_Vaulting()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.OnRep_Vaulting");
		
		AINSSoldier_OnRep_Vaulting_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056C3540
	 * 		Name   -> Function Insurgency.INSSoldier.OnRep_TeamId
	 * 		Flags  -> (Final, Native, Public)
	 */
	void AINSSoldier::OnRep_TeamId()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.OnRep_TeamId");
		
		AINSSoldier_OnRep_TeamId_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056C3520
	 * 		Name   -> Function Insurgency.INSSoldier.OnRep_Stamina
	 * 		Flags  -> (Final, Native, Private)
	 */
	void AINSSoldier::OnRep_Stamina()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.OnRep_Stamina");
		
		AINSSoldier_OnRep_Stamina_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x04DB39E0
	 * 		Name   -> Function Insurgency.INSSoldier.OnRep_ReplicatedStance
	 * 		Flags  -> (Native, Public)
	 */
	void AINSSoldier::OnRep_ReplicatedStance()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.OnRep_ReplicatedStance");
		
		AINSSoldier_OnRep_ReplicatedStance_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056C3500
	 * 		Name   -> Function Insurgency.INSSoldier.OnRep_ReplicatedFreeaim
	 * 		Flags  -> (Final, Native, Public)
	 */
	void AINSSoldier::OnRep_ReplicatedFreeaim()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.OnRep_ReplicatedFreeaim");
		
		AINSSoldier_OnRep_ReplicatedFreeaim_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x04DB3980
	 * 		Name   -> Function Insurgency.INSSoldier.OnRep_ReplicatedDesiredStance
	 * 		Flags  -> (Native, Public)
	 */
	void AINSSoldier::OnRep_ReplicatedDesiredStance()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.OnRep_ReplicatedDesiredStance");
		
		AINSSoldier_OnRep_ReplicatedDesiredStance_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056C34E0
	 * 		Name   -> Function Insurgency.INSSoldier.OnRep_PlayerClass
	 * 		Flags  -> (Final, Native, Public)
	 */
	void AINSSoldier::OnRep_PlayerClass()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.OnRep_PlayerClass");
		
		AINSSoldier_OnRep_PlayerClass_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056C34C0
	 * 		Name   -> Function Insurgency.INSSoldier.OnRep_PendingWeapon
	 * 		Flags  -> (Final, Native, Protected)
	 */
	void AINSSoldier::OnRep_PendingWeapon()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.OnRep_PendingWeapon");
		
		AINSSoldier_OnRep_PendingWeapon_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00C76AB0
	 * 		Name   -> Function Insurgency.INSSoldier.OnRep_KilledBy
	 * 		Flags  -> (Final, Native, Public)
	 */
	void AINSSoldier::OnRep_KilledBy()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.OnRep_KilledBy");
		
		AINSSoldier_OnRep_KilledBy_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056C34A0
	 * 		Name   -> Function Insurgency.INSSoldier.OnRep_KickInProgress
	 * 		Flags  -> (Final, Native, Public)
	 */
	void AINSSoldier::OnRep_KickInProgress()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.OnRep_KickInProgress");
		
		AINSSoldier_OnRep_KickInProgress_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00C76AB0
	 * 		Name   -> Function Insurgency.INSSoldier.OnRep_IsAI
	 * 		Flags  -> (Final, Native, Public)
	 */
	void AINSSoldier::OnRep_IsAI()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.OnRep_IsAI");
		
		AINSSoldier_OnRep_IsAI_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056C3480
	 * 		Name   -> Function Insurgency.INSSoldier.OnRep_Inventory
	 * 		Flags  -> (Final, Native, Protected)
	 */
	void AINSSoldier::OnRep_Inventory()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.OnRep_Inventory");
		
		AINSSoldier_OnRep_Inventory_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056C3460
	 * 		Name   -> Function Insurgency.INSSoldier.OnRep_Incapacitated
	 * 		Flags  -> (Final, Native, Public)
	 */
	void AINSSoldier::OnRep_Incapacitated()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.OnRep_Incapacitated");
		
		AINSSoldier_OnRep_Incapacitated_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056C3440
	 * 		Name   -> Function Insurgency.INSSoldier.OnRep_FocusMode
	 * 		Flags  -> (Final, Native, Public)
	 */
	void AINSSoldier::OnRep_FocusMode()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.OnRep_FocusMode");
		
		AINSSoldier_OnRep_FocusMode_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056C3420
	 * 		Name   -> Function Insurgency.INSSoldier.OnRep_DialogueDictionary
	 * 		Flags  -> (Final, Native, Public)
	 */
	void AINSSoldier::OnRep_DialogueDictionary()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.OnRep_DialogueDictionary");
		
		AINSSoldier_OnRep_DialogueDictionary_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056C3400
	 * 		Name   -> Function Insurgency.INSSoldier.OnRep_CurrentWeapon
	 * 		Flags  -> (Final, Native, Protected)
	 */
	void AINSSoldier::OnRep_CurrentWeapon()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.OnRep_CurrentWeapon");
		
		AINSSoldier_OnRep_CurrentWeapon_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056C33E0
	 * 		Name   -> Function Insurgency.INSSoldier.OnRep_CurrentHeldUsableActor
	 * 		Flags  -> (Final, Native, Private)
	 */
	void AINSSoldier::OnRep_CurrentHeldUsableActor()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.OnRep_CurrentHeldUsableActor");
		
		AINSSoldier_OnRep_CurrentHeldUsableActor_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056C33C0
	 * 		Name   -> Function Insurgency.INSSoldier.OnRep_Ammo
	 * 		Flags  -> (Final, Native, Public)
	 */
	void AINSSoldier::OnRep_Ammo()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.OnRep_Ammo");
		
		AINSSoldier_OnRep_Ammo_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056C3340
	 * 		Name   -> Function Insurgency.INSSoldier.OnFireSupportFinishedSuccesfully
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		class AFireSupportBase*                            FireSupport                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSSoldier::OnFireSupportFinishedSuccesfully(class AFireSupportBase* FireSupport)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.OnFireSupportFinishedSuccesfully");
		
		AINSSoldier_OnFireSupportFinishedSuccesfully_Params params {};
		params.FireSupport = FireSupport;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056C3220
	 * 		Name   -> Function Insurgency.INSSoldier.OnCharacterMovementChanged
	 * 		Flags  -> (Final, Native, Public, HasDefaults)
	 * Parameters:
	 * 		float                                              DeltaSeconds                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     OldLocation                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     OldVelocity                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSSoldier::OnCharacterMovementChanged(float DeltaSeconds, const struct FVector& OldLocation, const struct FVector& OldVelocity)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.OnCharacterMovementChanged");
		
		AINSSoldier_OnCharacterMovementChanged_Params params {};
		params.DeltaSeconds = DeltaSeconds;
		params.OldLocation = OldLocation;
		params.OldVelocity = OldVelocity;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x04DB3F20
	 * 		Name   -> Function Insurgency.INSSoldier.MulticastStopActiveDialogue
	 * 		Flags  -> (Final, Net, NetReliable, Native, Event, NetMulticast, Private)
	 */
	void AINSSoldier::MulticastStopActiveDialogue()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.MulticastStopActiveDialogue");
		
		AINSSoldier_MulticastStopActiveDialogue_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056C2F60
	 * 		Name   -> Function Insurgency.INSSoldier.MulticastSpeakPlayDialogue
	 * 		Flags  -> (Final, Net, NetReliable, Native, Event, NetMulticast, Private)
	 * Parameters:
	 * 		struct FCharacterResponseRequest                   SpeakRequest                                               (Parm, NativeAccessSpecifierPublic)
	 * 		uint32_t                                           Seed                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSSoldier::MulticastSpeakPlayDialogue(const struct FCharacterResponseRequest& SpeakRequest, uint32_t Seed)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.MulticastSpeakPlayDialogue");
		
		AINSSoldier_MulticastSpeakPlayDialogue_Params params {};
		params.SpeakRequest = SpeakRequest;
		params.Seed = Seed;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056C2EA0
	 * 		Name   -> Function Insurgency.INSSoldier.MulticastSoldierPreDoorKick
	 * 		Flags  -> (Net, NetReliable, Native, Event, NetMulticast, Public)
	 * Parameters:
	 * 		bool                                               KickWillSucceed                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class ADoor*                                       Door                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSSoldier::MulticastSoldierPreDoorKick(bool KickWillSucceed, class ADoor* Door)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.MulticastSoldierPreDoorKick");
		
		AINSSoldier_MulticastSoldierPreDoorKick_Params params {};
		params.KickWillSucceed = KickWillSucceed;
		params.Door = Door;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056C2E20
	 * 		Name   -> Function Insurgency.INSSoldier.MulticastScavenge
	 * 		Flags  -> (Net, NetReliable, Native, Event, NetMulticast, Public)
	 * Parameters:
	 * 		class AItemWeapon*                                 Weapon                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSSoldier::MulticastScavenge(class AItemWeapon* Weapon)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.MulticastScavenge");
		
		AINSSoldier_MulticastScavenge_Params params {};
		params.Weapon = Weapon;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056C2D60
	 * 		Name   -> Function Insurgency.INSSoldier.MulticastOnUseActorInteracted
	 * 		Flags  -> (Net, Native, Event, NetMulticast, Public, BlueprintCallable)
	 * Parameters:
	 * 		class AActor*                                      UsingActor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EUseItem                                           Item                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSSoldier::MulticastOnUseActorInteracted(class AActor* UsingActor, EUseItem Item)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.MulticastOnUseActorInteracted");
		
		AINSSoldier_MulticastOnUseActorInteracted_Params params {};
		params.UsingActor = UsingActor;
		params.Item = Item;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056C2D10
	 * 		Name   -> Function Insurgency.INSSoldier.MulticastMelee
	 * 		Flags  -> (Net, NetReliable, Native, Event, NetMulticast, Public, BlueprintCallable, NetValidate)
	 */
	void AINSSoldier::MulticastMelee()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.MulticastMelee");
		
		AINSSoldier_MulticastMelee_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056C2B10
	 * 		Name   -> Function Insurgency.INSSoldier.MulticastLanded
	 * 		Flags  -> (Net, NetReliable, Native, Event, NetMulticast, Public)
	 * Parameters:
	 * 		struct FWWiseData                                  AudioData                                                  (ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		struct FHitResult                                  GroundTrace                                                (ConstParm, Parm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	void AINSSoldier::MulticastLanded(const struct FWWiseData& AudioData, const struct FHitResult& GroundTrace)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.MulticastLanded");
		
		AINSSoldier_MulticastLanded_Params params {};
		params.AudioData = AudioData;
		params.GroundTrace = GroundTrace;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056C29C0
	 * 		Name   -> Function Insurgency.INSSoldier.MulticastIncrementSuppression
	 * 		Flags  -> (Net, NetReliable, Native, Event, NetMulticast, Public, BlueprintCallable)
	 * Parameters:
	 * 		float                                              Increment                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              HoldTime                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		ESuppressionContext                                InSuppressionContext                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              DistToSrc                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSSoldier::MulticastIncrementSuppression(float Increment, float HoldTime, ESuppressionContext InSuppressionContext, float DistToSrc)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.MulticastIncrementSuppression");
		
		AINSSoldier_MulticastIncrementSuppression_Params params {};
		params.Increment = Increment;
		params.HoldTime = HoldTime;
		params.InSuppressionContext = InSuppressionContext;
		params.DistToSrc = DistToSrc;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056C2820
	 * 		Name   -> Function Insurgency.INSSoldier.MulticastIncrementRecoil
	 * 		Flags  -> (Net, Native, Event, NetMulticast, Public, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FRotator                                    RecoilIncrement                                            (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     RecoilViewIncrement                                        (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              AimPunchFrac                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              RecoilPunchAdditiveFactor                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bIncludeOwner                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSSoldier::MulticastIncrementRecoil(const struct FRotator& RecoilIncrement, const struct FVector& RecoilViewIncrement, float AimPunchFrac, float RecoilPunchAdditiveFactor, bool bIncludeOwner)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.MulticastIncrementRecoil");
		
		AINSSoldier_MulticastIncrementRecoil_Params params {};
		params.RecoilIncrement = RecoilIncrement;
		params.RecoilViewIncrement = RecoilViewIncrement;
		params.AimPunchFrac = AimPunchFrac;
		params.RecoilPunchAdditiveFactor = RecoilPunchAdditiveFactor;
		params.bIncludeOwner = bIncludeOwner;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056C2680
	 * 		Name   -> Function Insurgency.INSSoldier.MulticastBlind
	 * 		Flags  -> (Net, NetReliable, Native, Event, NetMulticast, Public, BlueprintCallable)
	 * Parameters:
	 * 		float                                              BlindHoldTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              BlindFadeTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              BlindAlpha                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              SuppressionIncrement                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              FlashSuppressionHoldTime                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSSoldier::MulticastBlind(float BlindHoldTime, float BlindFadeTime, float BlindAlpha, float SuppressionIncrement, float FlashSuppressionHoldTime)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.MulticastBlind");
		
		AINSSoldier_MulticastBlind_Params params {};
		params.BlindHoldTime = BlindHoldTime;
		params.BlindFadeTime = BlindFadeTime;
		params.BlindAlpha = BlindAlpha;
		params.SuppressionIncrement = SuppressionIncrement;
		params.FlashSuppressionHoldTime = FlashSuppressionHoldTime;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056C2600
	 * 		Name   -> Function Insurgency.INSSoldier.MulticastApplyStun
	 * 		Flags  -> (Net, NetReliable, Native, Event, NetMulticast, Public, BlueprintCallable)
	 * Parameters:
	 * 		float                                              InStunDuration                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSSoldier::MulticastApplyStun(float InStunDuration)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.MulticastApplyStun");
		
		AINSSoldier_MulticastApplyStun_Params params {};
		params.InStunDuration = InStunDuration;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056C3120
	 * 		Name   -> Function Insurgency.INSSoldier.Multicast_ShowLagCompensationDebug
	 * 		Flags  -> (Net, NetReliable, Native, Event, NetMulticast, Public, HasDefaults)
	 * Parameters:
	 * 		struct FVector                                     ServerPosition                                             (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     CompensatedPosition                                        (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              DistanceFromReportedHit                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSSoldier::Multicast_ShowLagCompensationDebug(const struct FVector& ServerPosition, const struct FVector& CompensatedPosition, float DistanceFromReportedHit)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.Multicast_ShowLagCompensationDebug");
		
		AINSSoldier_Multicast_ShowLagCompensationDebug_Params params {};
		params.ServerPosition = ServerPosition;
		params.CompensatedPosition = CompensatedPosition;
		params.DistanceFromReportedHit = DistanceFromReportedHit;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056C25E0
	 * 		Name   -> Function Insurgency.INSSoldier.LoadSelectedCosmetics
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void AINSSoldier::LoadSelectedCosmetics()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.LoadSelectedCosmetics");
		
		AINSSoldier_LoadSelectedCosmetics_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056C2550
	 * 		Name   -> Function Insurgency.INSSoldier.ItemCapacityForSlot
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		EItemSlot                                          Slot                                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	int32_t AINSSoldier::ItemCapacityForSlot(EItemSlot Slot)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.ItemCapacityForSlot");
		
		AINSSoldier_ItemCapacityForSlot_Params params {};
		params.Slot = Slot;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056C2520
	 * 		Name   -> Function Insurgency.INSSoldier.IsWeaponRestricted
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AINSSoldier::IsWeaponRestricted()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.IsWeaponRestricted");
		
		AINSSoldier_IsWeaponRestricted_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056C24F0
	 * 		Name   -> Function Insurgency.INSSoldier.IsViewTarget
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AINSSoldier::IsViewTarget()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.IsViewTarget");
		
		AINSSoldier_IsViewTarget_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056C24C0
	 * 		Name   -> Function Insurgency.INSSoldier.IsVehicle
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AINSSoldier::IsVehicle()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.IsVehicle");
		
		AINSSoldier_IsVehicle_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056C2490
	 * 		Name   -> Function Insurgency.INSSoldier.IsUsingGamepad
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AINSSoldier::IsUsingGamepad()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.IsUsingGamepad");
		
		AINSSoldier_IsUsingGamepad_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056C2460
	 * 		Name   -> Function Insurgency.INSSoldier.IsUseProgressInTapTime
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AINSSoldier::IsUseProgressInTapTime()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.IsUseProgressInTapTime");
		
		AINSSoldier_IsUseProgressInTapTime_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056C2430
	 * 		Name   -> Function Insurgency.INSSoldier.IsUseInProgress
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AINSSoldier::IsUseInProgress()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.IsUseInProgress");
		
		AINSSoldier_IsUseInProgress_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056C2400
	 * 		Name   -> Function Insurgency.INSSoldier.IsStunned
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AINSSoldier::IsStunned()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.IsStunned");
		
		AINSSoldier_IsStunned_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056C23D0
	 * 		Name   -> Function Insurgency.INSSoldier.IsStanding
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AINSSoldier::IsStanding()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.IsStanding");
		
		AINSSoldier_IsStanding_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056C23A0
	 * 		Name   -> Function Insurgency.INSSoldier.IsSprinting
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AINSSoldier::IsSprinting()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.IsSprinting");
		
		AINSSoldier_IsSprinting_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056C2370
	 * 		Name   -> Function Insurgency.INSSoldier.IsSpecialPlayerClass
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AINSSoldier::IsSpecialPlayerClass()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.IsSpecialPlayerClass");
		
		AINSSoldier_IsSpecialPlayerClass_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056C2340
	 * 		Name   -> Function Insurgency.INSSoldier.IsRestricted
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AINSSoldier::IsRestricted()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.IsRestricted");
		
		AINSSoldier_IsRestricted_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056C2310
	 * 		Name   -> Function Insurgency.INSSoldier.IsReloading
	 * 		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure)
	 */
	bool AINSSoldier::IsReloading()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.IsReloading");
		
		AINSSoldier_IsReloading_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056C22E0
	 * 		Name   -> Function Insurgency.INSSoldier.IsProne
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AINSSoldier::IsProne()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.IsProne");
		
		AINSSoldier_IsProne_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056C22B0
	 * 		Name   -> Function Insurgency.INSSoldier.IsPressingWeaponInteractionKey
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AINSSoldier::IsPressingWeaponInteractionKey()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.IsPressingWeaponInteractionKey");
		
		AINSSoldier_IsPressingWeaponInteractionKey_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056C2280
	 * 		Name   -> Function Insurgency.INSSoldier.IsOutsidePlayableArea
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AINSSoldier::IsOutsidePlayableArea()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.IsOutsidePlayableArea");
		
		AINSSoldier_IsOutsidePlayableArea_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056C2250
	 * 		Name   -> Function Insurgency.INSSoldier.IsOfficer
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AINSSoldier::IsOfficer()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.IsOfficer");
		
		AINSSoldier_IsOfficer_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056C2220
	 * 		Name   -> Function Insurgency.INSSoldier.IsObserver
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AINSSoldier::IsObserver()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.IsObserver");
		
		AINSSoldier_IsObserver_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056C2190
	 * 		Name   -> Function Insurgency.INSSoldier.IsNearSupplyCrate
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		float                                              Tolerance                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool AINSSoldier::IsNearSupplyCrate(float Tolerance)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.IsNearSupplyCrate");
		
		AINSSoldier_IsNearSupplyCrate_Params params {};
		params.Tolerance = Tolerance;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056C2160
	 * 		Name   -> Function Insurgency.INSSoldier.IsMoving
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AINSSoldier::IsMoving()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.IsMoving");
		
		AINSSoldier_IsMoving_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056C2130
	 * 		Name   -> Function Insurgency.INSSoldier.IsLeaning
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AINSSoldier::IsLeaning()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.IsLeaning");
		
		AINSSoldier_IsLeaning_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056C2100
	 * 		Name   -> Function Insurgency.INSSoldier.IsInProneTransition
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AINSSoldier::IsInProneTransition()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.IsInProneTransition");
		
		AINSSoldier_IsInProneTransition_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056C20D0
	 * 		Name   -> Function Insurgency.INSSoldier.IsFullyCrawling
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AINSSoldier::IsFullyCrawling()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.IsFullyCrawling");
		
		AINSSoldier_IsFullyCrawling_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056C20A0
	 * 		Name   -> Function Insurgency.INSSoldier.IsFocusing
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AINSSoldier::IsFocusing()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.IsFocusing");
		
		AINSSoldier_IsFocusing_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056C2070
	 * 		Name   -> Function Insurgency.INSSoldier.IsFirstPersonViewTarget
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AINSSoldier::IsFirstPersonViewTarget()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.IsFirstPersonViewTarget");
		
		AINSSoldier_IsFirstPersonViewTarget_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056C2040
	 * 		Name   -> Function Insurgency.INSSoldier.IsDoorKickInProgress
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AINSSoldier::IsDoorKickInProgress()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.IsDoorKickInProgress");
		
		AINSSoldier_IsDoorKickInProgress_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056C2010
	 * 		Name   -> Function Insurgency.INSSoldier.IsCurrentlySliding
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AINSSoldier::IsCurrentlySliding()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.IsCurrentlySliding");
		
		AINSSoldier_IsCurrentlySliding_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056C1FE0
	 * 		Name   -> Function Insurgency.INSSoldier.IsCrouching
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AINSSoldier::IsCrouching()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.IsCrouching");
		
		AINSSoldier_IsCrouching_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056C1FB0
	 * 		Name   -> Function Insurgency.INSSoldier.IsCrawling
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AINSSoldier::IsCrawling()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.IsCrawling");
		
		AINSSoldier_IsCrawling_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056C1F80
	 * 		Name   -> Function Insurgency.INSSoldier.IsCompletelyBlind
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AINSSoldier::IsCompletelyBlind()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.IsCompletelyBlind");
		
		AINSSoldier_IsCompletelyBlind_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056C1F50
	 * 		Name   -> Function Insurgency.INSSoldier.IsClimbing
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AINSSoldier::IsClimbing()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.IsClimbing");
		
		AINSSoldier_IsClimbing_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056C1F20
	 * 		Name   -> Function Insurgency.INSSoldier.IsClientUpdating
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AINSSoldier::IsClientUpdating()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.IsClientUpdating");
		
		AINSSoldier_IsClientUpdating_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056C1EF0
	 * 		Name   -> Function Insurgency.INSSoldier.IsBusy
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AINSSoldier::IsBusy()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.IsBusy");
		
		AINSSoldier_IsBusy_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056C1EC0
	 * 		Name   -> Function Insurgency.INSSoldier.IsBlind
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AINSSoldier::IsBlind()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.IsBlind");
		
		AINSSoldier_IsBlind_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056C1E90
	 * 		Name   -> Function Insurgency.INSSoldier.IsAtSprintingSpeed
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AINSSoldier::IsAtSprintingSpeed()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.IsAtSprintingSpeed");
		
		AINSSoldier_IsAtSprintingSpeed_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056C1E60
	 * 		Name   -> Function Insurgency.INSSoldier.IsAimingDownSights
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AINSSoldier::IsAimingDownSights()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.IsAimingDownSights");
		
		AINSSoldier_IsAimingDownSights_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056C1DD0
	 * 		Name   -> Function Insurgency.INSSoldier.InvalidatePlayerAppearance
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bClearCosmeticCache                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSSoldier::InvalidatePlayerAppearance(bool bClearCosmeticCache)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.InvalidatePlayerAppearance");
		
		AINSSoldier_InvalidatePlayerAppearance_Params params {};
		params.bClearCosmeticCache = bClearCosmeticCache;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056C1D50
	 * 		Name   -> Function Insurgency.INSSoldier.InteractWeaponUpgrade
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		EWeaponUpgradeSlot                                 InSlot                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSSoldier::InteractWeaponUpgrade(EWeaponUpgradeSlot InSlot)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.InteractWeaponUpgrade");
		
		AINSSoldier_InteractWeaponUpgrade_Params params {};
		params.InSlot = InSlot;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056C1D30
	 * 		Name   -> Function Insurgency.INSSoldier.InteractWeaponUnderbarrelUpgrade
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void AINSSoldier::InteractWeaponUnderbarrelUpgrade()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.InteractWeaponUnderbarrelUpgrade");
		
		AINSSoldier_InteractWeaponUnderbarrelUpgrade_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056C1D10
	 * 		Name   -> Function Insurgency.INSSoldier.InteractWeaponStockUpgrade
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void AINSSoldier::InteractWeaponStockUpgrade()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.InteractWeaponStockUpgrade");
		
		AINSSoldier_InteractWeaponStockUpgrade_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056C1CF0
	 * 		Name   -> Function Insurgency.INSSoldier.InteractWeaponSiderailUpgrade
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void AINSSoldier::InteractWeaponSiderailUpgrade()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.InteractWeaponSiderailUpgrade");
		
		AINSSoldier_InteractWeaponSiderailUpgrade_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056C1CD0
	 * 		Name   -> Function Insurgency.INSSoldier.InteractWeaponOpticUpgrade
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void AINSSoldier::InteractWeaponOpticUpgrade()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.InteractWeaponOpticUpgrade");
		
		AINSSoldier_InteractWeaponOpticUpgrade_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056C1C00
	 * 		Name   -> Function Insurgency.INSSoldier.InteractGearInSlot
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		EItemSlot                                          GearSlot                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bFallbackEquipable                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSSoldier::InteractGearInSlot(EItemSlot GearSlot, bool bFallbackEquipable)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.InteractGearInSlot");
		
		AINSSoldier_InteractGearInSlot_Params params {};
		params.GearSlot = GearSlot;
		params.bFallbackEquipable = bFallbackEquipable;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056C1BE0
	 * 		Name   -> Function Insurgency.INSSoldier.InteractGearAccessoryCycleOptic
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void AINSSoldier::InteractGearAccessoryCycleOptic()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.InteractGearAccessoryCycleOptic");
		
		AINSSoldier_InteractGearAccessoryCycleOptic_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056C1BC0
	 * 		Name   -> Function Insurgency.INSSoldier.InteractGearAccessory
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void AINSSoldier::InteractGearAccessory()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.InteractGearAccessory");
		
		AINSSoldier_InteractGearAccessory_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056C17B0
	 * 		Name   -> Function Insurgency.INSSoldier.InStanceTransition
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AINSSoldier::InStanceTransition()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.InStanceTransition");
		
		AINSSoldier_InStanceTransition_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056A21A0
	 * 		Name   -> Function Insurgency.INSSoldier.InSpawnZone
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AINSSoldier::InSpawnZone()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.InSpawnZone");
		
		AINSSoldier_InSpawnZone_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056C1A70
	 * 		Name   -> Function Insurgency.INSSoldier.IncrementSuppression
	 * 		Flags  -> (Final, Exec, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		float                                              Increment                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              HoldTime                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		ESuppressionContext                                InSuppressionContext                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              DistToSrc                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSSoldier::IncrementSuppression(float Increment, float HoldTime, ESuppressionContext InSuppressionContext, float DistToSrc)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.IncrementSuppression");
		
		AINSSoldier_IncrementSuppression_Params params {};
		params.Increment = Increment;
		params.HoldTime = HoldTime;
		params.InSuppressionContext = InSuppressionContext;
		params.DistToSrc = DistToSrc;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056C19F0
	 * 		Name   -> Function Insurgency.INSSoldier.IncrementScore
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		int32_t                                            Amount                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSSoldier::IncrementScore(int32_t Amount)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.IncrementScore");
		
		AINSSoldier_IncrementScore_Params params {};
		params.Amount = Amount;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056C1870
	 * 		Name   -> Function Insurgency.INSSoldier.IncrementRecoil
	 * 		Flags  -> (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FRotator                                    RecoilIncrement                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     RecoilViewIncrement                                        (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              AimPunchFrac                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              RecoilPunchAdditiveFactor                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSSoldier::IncrementRecoil(const struct FRotator& RecoilIncrement, const struct FVector& RecoilViewIncrement, float AimPunchFrac, float RecoilPunchAdditiveFactor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.IncrementRecoil");
		
		AINSSoldier_IncrementRecoil_Params params {};
		params.RecoilIncrement = RecoilIncrement;
		params.RecoilViewIncrement = RecoilViewIncrement;
		params.AimPunchFrac = AimPunchFrac;
		params.RecoilPunchAdditiveFactor = RecoilPunchAdditiveFactor;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056C17E0
	 * 		Name   -> Function Insurgency.INSSoldier.IncrementFreeaim
	 * 		Flags  -> (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FRotator                                    Amount                                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void AINSSoldier::IncrementFreeaim(const struct FRotator& Amount)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.IncrementFreeaim");
		
		AINSSoldier_IncrementFreeaim_Params params {};
		params.Amount = Amount;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x04DB3780
	 * 		Name   -> Function Insurgency.INSSoldier.Incapacitate
	 * 		Flags  -> (Exec, Native, Public)
	 */
	void AINSSoldier::Incapacitate()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.Incapacitate");
		
		AINSSoldier_Incapacitate_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056C1780
	 * 		Name   -> Function Insurgency.INSSoldier.HasTeamInfoReplicated
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	bool AINSSoldier::HasTeamInfoReplicated()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.HasTeamInfoReplicated");
		
		AINSSoldier_HasTeamInfoReplicated_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056C1750
	 * 		Name   -> Function Insurgency.INSSoldier.HasRadio
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AINSSoldier::HasRadio()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.HasRadio");
		
		AINSSoldier_HasRadio_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056C1720
	 * 		Name   -> Function Insurgency.INSSoldier.HasNearbyRadio
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AINSSoldier::HasNearbyRadio()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.HasNearbyRadio");
		
		AINSSoldier_HasNearbyRadio_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056C16F0
	 * 		Name   -> Function Insurgency.INSSoldier.HasJustLandedJump
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AINSSoldier::HasJustLandedJump()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.HasJustLandedJump");
		
		AINSSoldier_HasJustLandedJump_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056C16C0
	 * 		Name   -> Function Insurgency.INSSoldier.HasJumped
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AINSSoldier::HasJumped()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.HasJumped");
		
		AINSSoldier_HasJumped_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056C1630
	 * 		Name   -> Function Insurgency.INSSoldier.HasInventoryItem
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		class UClass*                                      ItemClass                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool AINSSoldier::HasInventoryItem(class UClass* ItemClass)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.HasInventoryItem");
		
		AINSSoldier_HasInventoryItem_Params params {};
		params.ItemClass = ItemClass;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056C15A0
	 * 		Name   -> Function Insurgency.INSSoldier.GiveInventoryItems
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bSelectFirstItem                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSSoldier::GiveInventoryItems(bool bSelectFirstItem)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.GiveInventoryItems");
		
		AINSSoldier_GiveInventoryItems_Params params {};
		params.bSelectFirstItem = bSelectFirstItem;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056C14D0
	 * 		Name   -> Function Insurgency.INSSoldier.GiveAmmoFromStoredAmmo
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		TArray<struct FStoredAmmo>                         StoredAmmo                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSSoldier::GiveAmmoFromStoredAmmo(TArray<struct FStoredAmmo> StoredAmmo)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.GiveAmmoFromStoredAmmo");
		
		AINSSoldier_GiveAmmoFromStoredAmmo_Params params {};
		params.StoredAmmo = StoredAmmo;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056C1410
	 * 		Name   -> Function Insurgency.INSSoldier.GiveAmmoForWeapon
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class AItemWeapon*                                 Weapon                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            Amount                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSSoldier::GiveAmmoForWeapon(class AItemWeapon* Weapon, int32_t Amount)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.GiveAmmoForWeapon");
		
		AINSSoldier_GiveAmmoForWeapon_Params params {};
		params.Weapon = Weapon;
		params.Amount = Amount;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056C12D0
	 * 		Name   -> Function Insurgency.INSSoldier.GiveAmmo
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UClass*                                      AmmoType                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            Amount                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UClass*                                      AmmoTypeOverride                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            MaxCarryOverride                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSSoldier::GiveAmmo(class UClass* AmmoType, int32_t Amount, class UClass* AmmoTypeOverride, int32_t MaxCarryOverride)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.GiveAmmo");
		
		AINSSoldier_GiveAmmo_Params params {};
		params.AmmoType = AmmoType;
		params.Amount = Amount;
		params.AmmoTypeOverride = AmmoTypeOverride;
		params.MaxCarryOverride = MaxCarryOverride;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056C12A0
	 * 		Name   -> Function Insurgency.INSSoldier.GetWeight
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	float AINSSoldier::GetWeight()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.GetWeight");
		
		AINSSoldier_GetWeight_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056C1270
	 * 		Name   -> Function Insurgency.INSSoldier.GetWeaponMesh1P
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	class UINSSkeletalMeshComponent* AINSSoldier::GetWeaponMesh1P()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.GetWeaponMesh1P");
		
		AINSSoldier_GetWeaponMesh1P_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056C1240
	 * 		Name   -> Function Insurgency.INSSoldier.GetWalkingFrac
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	float AINSSoldier::GetWalkingFrac()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.GetWalkingFrac");
		
		AINSSoldier_GetWalkingFrac_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056C1210
	 * 		Name   -> Function Insurgency.INSSoldier.GetUseProgress
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	float AINSSoldier::GetUseProgress()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.GetUseProgress");
		
		AINSSoldier_GetUseProgress_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056C11E0
	 * 		Name   -> Function Insurgency.INSSoldier.GetUseElapsedTime
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	float AINSSoldier::GetUseElapsedTime()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.GetUseElapsedTime");
		
		AINSSoldier_GetUseElapsedTime_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056C11B0
	 * 		Name   -> Function Insurgency.INSSoldier.GetTopSpeedFraction
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	float AINSSoldier::GetTopSpeedFraction()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.GetTopSpeedFraction");
		
		AINSSoldier_GetTopSpeedFraction_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056C1180
	 * 		Name   -> Function Insurgency.INSSoldier.GetTopSpeed
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	float AINSSoldier::GetTopSpeed()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.GetTopSpeed");
		
		AINSSoldier_GetTopSpeed_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056C1150
	 * 		Name   -> Function Insurgency.INSSoldier.GetToleranceForNonSprintingFire
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	float AINSSoldier::GetToleranceForNonSprintingFire()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.GetToleranceForNonSprintingFire");
		
		AINSSoldier_GetToleranceForNonSprintingFire_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056C1120
	 * 		Name   -> Function Insurgency.INSSoldier.GetTimeSinceLastRenderTime
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
	 */
	float AINSSoldier::GetTimeSinceLastRenderTime()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.GetTimeSinceLastRenderTime");
		
		AINSSoldier_GetTimeSinceLastRenderTime_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056C10F0
	 * 		Name   -> Function Insurgency.INSSoldier.GetTimeOutsidePlayableArea
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	float AINSSoldier::GetTimeOutsidePlayableArea()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.GetTimeOutsidePlayableArea");
		
		AINSSoldier_GetTimeOutsidePlayableArea_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056C10B0
	 * 		Name   -> Function Insurgency.INSSoldier.GetTeamId
	 * 		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	unsigned char AINSSoldier::GetTeamId()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.GetTeamId");
		
		AINSSoldier_GetTeamId_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056C1080
	 * 		Name   -> Function Insurgency.INSSoldier.GetTeam
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	class ATeamInfo* AINSSoldier::GetTeam()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.GetTeam");
		
		AINSSoldier_GetTeam_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056C1050
	 * 		Name   -> Function Insurgency.INSSoldier.GetStaminaFrac
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	float AINSSoldier::GetStaminaFrac()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.GetStaminaFrac");
		
		AINSSoldier_GetStaminaFrac_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056C1020
	 * 		Name   -> Function Insurgency.INSSoldier.GetStamina
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	float AINSSoldier::GetStamina()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.GetStamina");
		
		AINSSoldier_GetStamina_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056C0FF0
	 * 		Name   -> Function Insurgency.INSSoldier.GetSprintAlpha
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	float AINSSoldier::GetSprintAlpha()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.GetSprintAlpha");
		
		AINSSoldier_GetSprintAlpha_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056C0F40
	 * 		Name   -> Function Insurgency.INSSoldier.GetSortedEquipableItems
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		TArray<class AItemEquipable*>                      OutEquipables                                              (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSSoldier::GetSortedEquipableItems(TArray<class AItemEquipable*>* OutEquipables)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.GetSortedEquipableItems");
		
		AINSSoldier_GetSortedEquipableItems_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutEquipables != nullptr)
			*OutEquipables = params.OutEquipables;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056C0F00
	 * 		Name   -> Function Insurgency.INSSoldier.GetShootAngles
	 * 		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable)
	 */
	struct FRotator AINSSoldier::GetShootAngles()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.GetShootAngles");
		
		AINSSoldier_GetShootAngles_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056C0ED0
	 * 		Name   -> Function Insurgency.INSSoldier.GetSharedCosmeticState
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	class USharedCosmeticState* AINSSoldier::GetSharedCosmeticState()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.GetSharedCosmeticState");
		
		AINSSoldier_GetSharedCosmeticState_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056C0EA0
	 * 		Name   -> Function Insurgency.INSSoldier.GetSensingComponent
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	class UINSPawnSensingComponent* AINSSoldier::GetSensingComponent()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.GetSensingComponent");
		
		AINSSoldier_GetSensingComponent_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056C0E10
	 * 		Name   -> Function Insurgency.INSSoldier.GetReserveAmmoForWeapon
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		class AItemWeapon*                                 Weapon                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	int32_t AINSSoldier::GetReserveAmmoForWeapon(class AItemWeapon* Weapon)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.GetReserveAmmoForWeapon");
		
		AINSSoldier_GetReserveAmmoForWeapon_Params params {};
		params.Weapon = Weapon;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056C0D80
	 * 		Name   -> Function Insurgency.INSSoldier.GetReserveAmmo
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UClass*                                      AmmoType                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	int32_t AINSSoldier::GetReserveAmmo(class UClass* AmmoType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.GetReserveAmmo");
		
		AINSSoldier_GetReserveAmmo_Params params {};
		params.AmmoType = AmmoType;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056C0D50
	 * 		Name   -> Function Insurgency.INSSoldier.GetRemoteViewPitch
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
	 */
	float AINSSoldier::GetRemoteViewPitch()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.GetRemoteViewPitch");
		
		AINSSoldier_GetRemoteViewPitch_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056C0CC0
	 * 		Name   -> Function Insurgency.INSSoldier.GetRelativeMeshZForStance
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		ESoldierStance                                     NewStance                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	float AINSSoldier::GetRelativeMeshZForStance(ESoldierStance NewStance)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.GetRelativeMeshZForStance");
		
		AINSSoldier_GetRelativeMeshZForStance_Params params {};
		params.NewStance = NewStance;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056C0C90
	 * 		Name   -> Function Insurgency.INSSoldier.GetRelativeMeshZForCurrentStance
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	float AINSSoldier::GetRelativeMeshZForCurrentStance()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.GetRelativeMeshZForCurrentStance");
		
		AINSSoldier_GetRelativeMeshZForCurrentStance_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056C0C00
	 * 		Name   -> Function Insurgency.INSSoldier.GetRecentMaxVelocity
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		float                                              Time                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	float AINSSoldier::GetRecentMaxVelocity(float Time)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.GetRecentMaxVelocity");
		
		AINSSoldier_GetRecentMaxVelocity_Params params {};
		params.Time = Time;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056C0B60
	 * 		Name   -> Function Insurgency.INSSoldier.GetRecentLocalVelocity
	 * 		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		float                                              Time                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FVector AINSSoldier::GetRecentLocalVelocity(float Time)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.GetRecentLocalVelocity");
		
		AINSSoldier_GetRecentLocalVelocity_Params params {};
		params.Time = Time;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056C0AD0
	 * 		Name   -> Function Insurgency.INSSoldier.GetRadioSignalQuality
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		float                                              Distance                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	float AINSSoldier::GetRadioSignalQuality(float Distance)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.GetRadioSignalQuality");
		
		AINSSoldier_GetRadioSignalQuality_Params params {};
		params.Distance = Distance;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056C0970
	 * 		Name   -> Function Insurgency.INSSoldier.GetPreviousItemInSlot
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		EItemSlot                                          Slot                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AItemEquipable*                              CurrentItem                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bFallbackToLast                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bIgnoreCanEquip                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class AItemEquipable* AINSSoldier::GetPreviousItemInSlot(EItemSlot Slot, class AItemEquipable* CurrentItem, bool bFallbackToLast, bool bIgnoreCanEquip)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.GetPreviousItemInSlot");
		
		AINSSoldier_GetPreviousItemInSlot_Params params {};
		params.Slot = Slot;
		params.CurrentItem = CurrentItem;
		params.bFallbackToLast = bFallbackToLast;
		params.bIgnoreCanEquip = bIgnoreCanEquip;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056C0940
	 * 		Name   -> Function Insurgency.INSSoldier.GetPlayerSpeedClassification
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	EPlayerSpeedClassification AINSSoldier::GetPlayerSpeedClassification()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.GetPlayerSpeedClassification");
		
		AINSSoldier_GetPlayerSpeedClassification_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056C0910
	 * 		Name   -> Function Insurgency.INSSoldier.GetPlayerController
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	class AINSPlayerController* AINSSoldier::GetPlayerController()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.GetPlayerController");
		
		AINSSoldier_GetPlayerController_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056C08E0
	 * 		Name   -> Function Insurgency.INSSoldier.GetPendingOrActiveItem
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
	 */
	class AItemEquipable* AINSSoldier::GetPendingOrActiveItem()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.GetPendingOrActiveItem");
		
		AINSSoldier_GetPendingOrActiveItem_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056C08B0
	 * 		Name   -> Function Insurgency.INSSoldier.GetPendingItem
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
	 */
	class AItemEquipable* AINSSoldier::GetPendingItem()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.GetPendingItem");
		
		AINSSoldier_GetPendingItem_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056C0820
	 * 		Name   -> Function Insurgency.INSSoldier.GetNumNearbyTeammates
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		float                                              Radius                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	int32_t AINSSoldier::GetNumNearbyTeammates(float Radius)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.GetNumNearbyTeammates");
		
		AINSSoldier_GetNumNearbyTeammates_Params params {};
		params.Radius = Radius;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056C0730
	 * 		Name   -> Function Insurgency.INSSoldier.GetNextMagazine
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		class UClass*                                      AmmoType                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FStoredMagazine                             OutMagazine                                                (Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	bool AINSSoldier::GetNextMagazine(class UClass* AmmoType, struct FStoredMagazine* OutMagazine)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.GetNextMagazine");
		
		AINSSoldier_GetNextMagazine_Params params {};
		params.AmmoType = AmmoType;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutMagazine != nullptr)
			*OutMagazine = params.OutMagazine;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056C05D0
	 * 		Name   -> Function Insurgency.INSSoldier.GetNextItemInSlot
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		EItemSlot                                          Slot                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AItemEquipable*                              CurrentItem                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bFallbackToFirst                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bIgnoreCanEquip                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class AItemEquipable* AINSSoldier::GetNextItemInSlot(EItemSlot Slot, class AItemEquipable* CurrentItem, bool bFallbackToFirst, bool bIgnoreCanEquip)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.GetNextItemInSlot");
		
		AINSSoldier_GetNextItemInSlot_Params params {};
		params.Slot = Slot;
		params.CurrentItem = CurrentItem;
		params.bFallbackToFirst = bFallbackToFirst;
		params.bIgnoreCanEquip = bIgnoreCanEquip;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056C05A0
	 * 		Name   -> Function Insurgency.INSSoldier.GetNextBulletId
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
	 */
	int32_t AINSSoldier::GetNextBulletId()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.GetNextBulletId");
		
		AINSSoldier_GetNextBulletId_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056C0510
	 * 		Name   -> Function Insurgency.INSSoldier.GetNearbySupplyCrate
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		float                                              Tolerance                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class ASupplyCrate* AINSSoldier::GetNearbySupplyCrate(float Tolerance)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.GetNearbySupplyCrate");
		
		AINSSoldier_GetNearbySupplyCrate_Params params {};
		params.Tolerance = Tolerance;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056C0490
	 * 		Name   -> Function Insurgency.INSSoldier.GetNearbyRadios
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	TArray<class AItemRadio*> AINSSoldier::GetNearbyRadios()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.GetNearbyRadios");
		
		AINSSoldier_GetNearbyRadios_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056C0460
	 * 		Name   -> Function Insurgency.INSSoldier.GetMovingFrac
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	float AINSSoldier::GetMovingFrac()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.GetMovingFrac");
		
		AINSSoldier_GetMovingFrac_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056C0430
	 * 		Name   -> Function Insurgency.INSSoldier.GetMergedMesh
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	class UCosmeticItem* AINSSoldier::GetMergedMesh()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.GetMergedMesh");
		
		AINSSoldier_GetMergedMesh_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056C0400
	 * 		Name   -> Function Insurgency.INSSoldier.GetMeleeStaminaFrac
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	float AINSSoldier::GetMeleeStaminaFrac()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.GetMeleeStaminaFrac");
		
		AINSSoldier_GetMeleeStaminaFrac_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056C0330
	 * 		Name   -> Function Insurgency.INSSoldier.GetMaxLeaningViewXOffset
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		ELeanDirection                                     NewInputLeanDirection                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bMoving                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	float AINSSoldier::GetMaxLeaningViewXOffset(ELeanDirection NewInputLeanDirection, bool bMoving)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.GetMaxLeaningViewXOffset");
		
		AINSSoldier_GetMaxLeaningViewXOffset_Params params {};
		params.NewInputLeanDirection = NewInputLeanDirection;
		params.bMoving = bMoving;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056C02A0
	 * 		Name   -> Function Insurgency.INSSoldier.GetMaxAmmoForWeapon
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		class AItemWeapon*                                 Weapon                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	int32_t AINSSoldier::GetMaxAmmoForWeapon(class AItemWeapon* Weapon)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.GetMaxAmmoForWeapon");
		
		AINSSoldier_GetMaxAmmoForWeapon_Params params {};
		params.Weapon = Weapon;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056C0210
	 * 		Name   -> Function Insurgency.INSSoldier.GetMaxAmmo
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		class UClass*                                      AmmoContainer                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	int32_t AINSSoldier::GetMaxAmmo(class UClass* AmmoContainer)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.GetMaxAmmo");
		
		AINSSoldier_GetMaxAmmo_Params params {};
		params.AmmoContainer = AmmoContainer;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056C0180
	 * 		Name   -> Function Insurgency.INSSoldier.GetLeaningViewYOffset
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		float                                              DesiredLeanAmount                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	float AINSSoldier::GetLeaningViewYOffset(float DesiredLeanAmount)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.GetLeaningViewYOffset");
		
		AINSSoldier_GetLeaningViewYOffset_Params params {};
		params.DesiredLeanAmount = DesiredLeanAmount;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056C00F0
	 * 		Name   -> Function Insurgency.INSSoldier.GetLeaningViewXOffset
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		float                                              DesiredLeanAmount                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	float AINSSoldier::GetLeaningViewXOffset(float DesiredLeanAmount)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.GetLeaningViewXOffset");
		
		AINSSoldier_GetLeaningViewXOffset_Params params {};
		params.DesiredLeanAmount = DesiredLeanAmount;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056C00C0
	 * 		Name   -> Function Insurgency.INSSoldier.GetLastMovementTimeServer
	 * 		Flags  -> (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	float AINSSoldier::GetLastMovementTimeServer()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.GetLastMovementTimeServer");
		
		AINSSoldier_GetLastMovementTimeServer_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056C0030
	 * 		Name   -> Function Insurgency.INSSoldier.GetItemInSlot
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		EItemSlot                                          Slot                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class AItemBase* AINSSoldier::GetItemInSlot(EItemSlot Slot)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.GetItemInSlot");
		
		AINSSoldier_GetItemInSlot_Params params {};
		params.Slot = Slot;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056BFFA0
	 * 		Name   -> Function Insurgency.INSSoldier.GetItemInInventory
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class UClass*                                      ItemClass                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class AItemBase* AINSSoldier::GetItemInInventory(class UClass* ItemClass)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.GetItemInInventory");
		
		AINSSoldier_GetItemInInventory_Params params {};
		params.ItemClass = ItemClass;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056BFF10
	 * 		Name   -> Function Insurgency.INSSoldier.GetItemEquippedCountByClass
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		class UClass*                                      ItemClass                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	int32_t AINSSoldier::GetItemEquippedCountByClass(class UClass* ItemClass)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.GetItemEquippedCountByClass");
		
		AINSSoldier_GetItemEquippedCountByClass_Params params {};
		params.ItemClass = ItemClass;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056BFE80
	 * 		Name   -> Function Insurgency.INSSoldier.GetItemEquippedCount
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		class AItemBase*                                   ItemClass                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	int32_t AINSSoldier::GetItemEquippedCount(class AItemBase* ItemClass)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.GetItemEquippedCount");
		
		AINSSoldier_GetItemEquippedCount_Params params {};
		params.ItemClass = ItemClass;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056BFE40
	 * 		Name   -> Function Insurgency.INSSoldier.GetGroundLocation
	 * 		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
	 */
	struct FVector AINSSoldier::GetGroundLocation()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.GetGroundLocation");
		
		AINSSoldier_GetGroundLocation_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056BFDA0
	 * 		Name   -> Function Insurgency.INSSoldier.GetGrenadeInInventory
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		bool                                               bLethal                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class AItemGrenade* AINSSoldier::GetGrenadeInInventory(bool bLethal)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.GetGrenadeInInventory");
		
		AINSSoldier_GetGrenadeInInventory_Params params {};
		params.bLethal = bLethal;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056BFD10
	 * 		Name   -> Function Insurgency.INSSoldier.GetGearInSlot
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		EItemSlot                                          GearSlot                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class AItemGear* AINSSoldier::GetGearInSlot(EItemSlot GearSlot)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.GetGearInSlot");
		
		AINSSoldier_GetGearInSlot_Params params {};
		params.GearSlot = GearSlot;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056BFC40
	 * 		Name   -> Function Insurgency.INSSoldier.GetFirearmInCategory
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		EFirearmCategory                                   Category                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bIncludingNonConsumingItems                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class AItemFirearm* AINSSoldier::GetFirearmInCategory(EFirearmCategory Category, bool bIncludingNonConsumingItems)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.GetFirearmInCategory");
		
		AINSSoldier_GetFirearmInCategory_Params params {};
		params.Category = Category;
		params.bIncludingNonConsumingItems = bIncludingNonConsumingItems;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056BFBB0
	 * 		Name   -> Function Insurgency.INSSoldier.GetFirearmCategoryEquipLimit
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		EFirearmCategory                                   Category                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	int32_t AINSSoldier::GetFirearmCategoryEquipLimit(EFirearmCategory Category)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.GetFirearmCategoryEquipLimit");
		
		AINSSoldier_GetFirearmCategoryEquipLimit_Params params {};
		params.Category = Category;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056BFB80
	 * 		Name   -> Function Insurgency.INSSoldier.GetFactionDefinition
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	class UFactionDefinition* AINSSoldier::GetFactionDefinition()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.GetFactionDefinition");
		
		AINSSoldier_GetFactionDefinition_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056BFB50
	 * 		Name   -> Function Insurgency.INSSoldier.GetEquippedItemSlotsMask
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	int32_t AINSSoldier::GetEquippedItemSlotsMask()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.GetEquippedItemSlotsMask");
		
		AINSSoldier_GetEquippedItemSlotsMask_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056BFA80
	 * 		Name   -> Function Insurgency.INSSoldier.GetEquippedCountInFirearmCategory
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		EFirearmCategory                                   Category                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bIncludingNonConsumingItems                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	int32_t AINSSoldier::GetEquippedCountInFirearmCategory(EFirearmCategory Category, bool bIncludingNonConsumingItems)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.GetEquippedCountInFirearmCategory");
		
		AINSSoldier_GetEquippedCountInFirearmCategory_Params params {};
		params.Category = Category;
		params.bIncludingNonConsumingItems = bIncludingNonConsumingItems;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056BF9D0
	 * 		Name   -> Function Insurgency.INSSoldier.GetEquipableItems
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		TArray<class AItemEquipable*>                      OutEquipables                                              (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSSoldier::GetEquipableItems(TArray<class AItemEquipable*>* OutEquipables)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.GetEquipableItems");
		
		AINSSoldier_GetEquipableItems_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutEquipables != nullptr)
			*OutEquipables = params.OutEquipables;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056BF940
	 * 		Name   -> Function Insurgency.INSSoldier.GetEquipableInSlot
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		EItemSlot                                          Slot                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class AItemEquipable* AINSSoldier::GetEquipableInSlot(EItemSlot Slot)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.GetEquipableInSlot");
		
		AINSSoldier_GetEquipableInSlot_Params params {};
		params.Slot = Slot;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056BF910
	 * 		Name   -> Function Insurgency.INSSoldier.GetDesiredStance
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	ESoldierStance AINSSoldier::GetDesiredStance()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.GetDesiredStance");
		
		AINSSoldier_GetDesiredStance_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056BF8D0
	 * 		Name   -> Function Insurgency.INSSoldier.GetCurrentWeaponSwitch
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
	 */
	class FName AINSSoldier::GetCurrentWeaponSwitch()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.GetCurrentWeaponSwitch");
		
		AINSSoldier_GetCurrentWeaponSwitch_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056BF8A0
	 * 		Name   -> Function Insurgency.INSSoldier.GetCurrentWeapon
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	class AItemEquipable* AINSSoldier::GetCurrentWeapon()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.GetCurrentWeapon");
		
		AINSSoldier_GetCurrentWeapon_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056BF870
	 * 		Name   -> Function Insurgency.INSSoldier.GetCurrentUseActor
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	class AActor* AINSSoldier::GetCurrentUseActor()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.GetCurrentUseActor");
		
		AINSSoldier_GetCurrentUseActor_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056BF840
	 * 		Name   -> Function Insurgency.INSSoldier.GetCrawlingAlpha
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	float AINSSoldier::GetCrawlingAlpha()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.GetCrawlingAlpha");
		
		AINSSoldier_GetCrawlingAlpha_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056BF7B0
	 * 		Name   -> Function Insurgency.INSSoldier.GetComplexGroundTrace
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	struct FHitResult AINSSoldier::GetComplexGroundTrace()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.GetComplexGroundTrace");
		
		AINSSoldier_GetComplexGroundTrace_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056BF780
	 * 		Name   -> Function Insurgency.INSSoldier.GetClosestRadioSupportPawn
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
	 */
	class APawn* AINSSoldier::GetClosestRadioSupportPawn()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.GetClosestRadioSupportPawn");
		
		AINSSoldier_GetClosestRadioSupportPawn_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056BF750
	 * 		Name   -> Function Insurgency.INSSoldier.GetClosestOfficerPawn
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
	 */
	class APawn* AINSSoldier::GetClosestOfficerPawn()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.GetClosestOfficerPawn");
		
		AINSSoldier_GetClosestOfficerPawn_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056BF720
	 * 		Name   -> Function Insurgency.INSSoldier.GetBodyMesh1P
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	class UINSSkeletalMeshComponent* AINSSoldier::GetBodyMesh1P()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.GetBodyMesh1P");
		
		AINSSoldier_GetBodyMesh1P_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056BF6E0
	 * 		Name   -> Function Insurgency.INSSoldier.GetBlindFrac
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
	 */
	float AINSSoldier::GetBlindFrac()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.GetBlindFrac");
		
		AINSSoldier_GetBlindFrac_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056BF6B0
	 * 		Name   -> Function Insurgency.INSSoldier.GetArmMesh1P
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	class UINSSkeletalMeshComponent* AINSSoldier::GetArmMesh1P()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.GetArmMesh1P");
		
		AINSSoldier_GetArmMesh1P_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056BF5D0
	 * 		Name   -> Function Insurgency.INSSoldier.GetAmmo
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UClass*                                      AmmoType                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FStoredAmmo AINSSoldier::GetAmmo(class UClass* AmmoType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.GetAmmo");
		
		AINSSoldier_GetAmmo_Params params {};
		params.AmmoType = AmmoType;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056BF4C0
	 * 		Name   -> Function Insurgency.INSSoldier.GetAISquad
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	class UINSAISquad* AINSSoldier::GetAISquad()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.GetAISquad");
		
		AINSSoldier_GetAISquad_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056BF490
	 * 		Name   -> Function Insurgency.INSSoldier.GetAIController
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	class AINSAISoldierController* AINSSoldier::GetAIController()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.GetAIController");
		
		AINSSoldier_GetAIController_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056BF540
	 * 		Name   -> Function Insurgency.INSSoldier.GetAdditionalAmmoForWeapon
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		class AItemWeapon*                                 Weapon                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	int32_t AINSSoldier::GetAdditionalAmmoForWeapon(class AItemWeapon* Weapon)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.GetAdditionalAmmoForWeapon");
		
		AINSSoldier_GetAdditionalAmmoForWeapon_Params params {};
		params.Weapon = Weapon;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056BF510
	 * 		Name   -> Function Insurgency.INSSoldier.GetActiveObjectiveId
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	unsigned char AINSSoldier::GetActiveObjectiveId()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.GetActiveObjectiveId");
		
		AINSSoldier_GetActiveObjectiveId_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056BF4E0
	 * 		Name   -> Function Insurgency.INSSoldier.GetActiveObjective
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
	 */
	class AObjectiveBase* AINSSoldier::GetActiveObjective()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.GetActiveObjective");
		
		AINSSoldier_GetActiveObjective_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056BF470
	 * 		Name   -> Function Insurgency.INSSoldier.FinishObserverResponse
	 * 		Flags  -> (Final, Native, Private)
	 */
	void AINSSoldier::FinishObserverResponse()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.FinishObserverResponse");
		
		AINSSoldier_FinishObserverResponse_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056BF340
	 * 		Name   -> Function Insurgency.INSSoldier.FindUseActors
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		TArray<struct FUsableActor>                        OutUsableActors                                            (Parm, OutParm, ZeroConstructor, ReferenceParm, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              DistanceOverride                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              RadiusOverride                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool AINSSoldier::FindUseActors(TArray<struct FUsableActor>* OutUsableActors, float DistanceOverride, float RadiusOverride)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.FindUseActors");
		
		AINSSoldier_FindUseActors_Params params {};
		params.DistanceOverride = DistanceOverride;
		params.RadiusOverride = RadiusOverride;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutUsableActors != nullptr)
			*OutUsableActors = params.OutUsableActors;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056BF260
	 * 		Name   -> Function Insurgency.INSSoldier.FindUseActor
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		struct FHitResult                                  OutHitResult                                               (Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	class AActor* AINSSoldier::FindUseActor(struct FHitResult* OutHitResult)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.FindUseActor");
		
		AINSSoldier_FindUseActor_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutHitResult != nullptr)
			*OutHitResult = params.OutHitResult;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056BF230
	 * 		Name   -> Function Insurgency.INSSoldier.FindDoor
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	class ADoor* AINSSoldier::FindDoor()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.FindDoor");
		
		AINSSoldier_FindDoor_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056BF170
	 * 		Name   -> Function Insurgency.INSSoldier.EquipInventoryItem
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class AItemEquipable*                              Item                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bFromServer                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool AINSSoldier::EquipInventoryItem(class AItemEquipable* Item, bool bFromServer)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.EquipInventoryItem");
		
		AINSSoldier_EquipInventoryItem_Params params {};
		params.Item = Item;
		params.bFromServer = bFromServer;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056BF150
	 * 		Name   -> Function Insurgency.INSSoldier.DropWeapons
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void AINSSoldier::DropWeapons()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.DropWeapons");
		
		AINSSoldier_DropWeapons_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056BF0D0
	 * 		Name   -> Function Insurgency.INSSoldier.DrainStamina
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		float                                              Amount                                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSSoldier::DrainStamina(float Amount)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.DrainStamina");
		
		AINSSoldier_DrainStamina_Params params {};
		params.Amount = Amount;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056BF000
	 * 		Name   -> Function Insurgency.INSSoldier.CountItemsInSlot
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		EItemSlot                                          Slot                                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bIncludingNonConsumingItems                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	int32_t AINSSoldier::CountItemsInSlot(EItemSlot Slot, bool bIncludingNonConsumingItems)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.CountItemsInSlot");
		
		AINSSoldier_CountItemsInSlot_Params params {};
		params.Slot = Slot;
		params.bIncludingNonConsumingItems = bIncludingNonConsumingItems;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056BEF50
	 * 		Name   -> Function Insurgency.INSSoldier.ClientSetHeldUsableActor
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetClient)
	 * Parameters:
	 * 		struct FTimedUsableActor                           UsableActorInfo                                            (ConstParm, Parm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void AINSSoldier::ClientSetHeldUsableActor(const struct FTimedUsableActor& UsableActorInfo)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.ClientSetHeldUsableActor");
		
		AINSSoldier_ClientSetHeldUsableActor_Params params {};
		params.UsableActorInfo = UsableActorInfo;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056BEEC0
	 * 		Name   -> Function Insurgency.INSSoldier.ClientOnResupplyStartEndSoundFeedback
	 * 		Flags  -> (Net, Native, Event, Public, NetClient)
	 * Parameters:
	 * 		bool                                               bStartResupply                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSSoldier::ClientOnResupplyStartEndSoundFeedback(bool bStartResupply)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.ClientOnResupplyStartEndSoundFeedback");
		
		AINSSoldier_ClientOnResupplyStartEndSoundFeedback_Params params {};
		params.bStartResupply = bStartResupply;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056BEEA0
	 * 		Name   -> Function Insurgency.INSSoldier.ClientOnResupplyAmmo
	 * 		Flags  -> (Net, Native, Event, Public, NetClient)
	 */
	void AINSSoldier::ClientOnResupplyAmmo()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.ClientOnResupplyAmmo");
		
		AINSSoldier_ClientOnResupplyAmmo_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056BEDD0
	 * 		Name   -> Function Insurgency.INSSoldier.ClientOnGatheredAmmo
	 * 		Flags  -> (Net, Native, Event, Public, NetClient)
	 * Parameters:
	 * 		class AItemWeapon*                                 FromWeapon                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bPlaySound                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSSoldier::ClientOnGatheredAmmo(class AItemWeapon* FromWeapon, bool bPlaySound)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.ClientOnGatheredAmmo");
		
		AINSSoldier_ClientOnGatheredAmmo_Params params {};
		params.FromWeapon = FromWeapon;
		params.bPlaySound = bPlaySound;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056BEC20
	 * 		Name   -> Function Insurgency.INSSoldier.ClientIncrementSuppression
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, HasDefaults, NetClient)
	 * Parameters:
	 * 		float                                              Increment                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              HoldTime                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		ESuppressionContext                                InSuppressionContext                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              DistToSrc                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     Origin                                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSSoldier::ClientIncrementSuppression(float Increment, float HoldTime, ESuppressionContext InSuppressionContext, float DistToSrc, const struct FVector& Origin)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.ClientIncrementSuppression");
		
		AINSSoldier_ClientIncrementSuppression_Params params {};
		params.Increment = Increment;
		params.HoldTime = HoldTime;
		params.InSuppressionContext = InSuppressionContext;
		params.DistToSrc = DistToSrc;
		params.Origin = Origin;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056BEB50
	 * 		Name   -> Function Insurgency.INSSoldier.ClientEquipInventoryItem
	 * 		Flags  -> (Net, NetReliable, Native, Event, Protected, NetClient)
	 * Parameters:
	 * 		class AItemEquipable*                              Item                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AItemEquipable*                              Previous                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSSoldier::ClientEquipInventoryItem(class AItemEquipable* Item, class AItemEquipable* Previous)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.ClientEquipInventoryItem");
		
		AINSSoldier_ClientEquipInventoryItem_Params params {};
		params.Item = Item;
		params.Previous = Previous;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056BEAD0
	 * 		Name   -> Function Insurgency.INSSoldier.CenterFreeaim
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		float                                              Fraction                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSSoldier::CenterFreeaim(float Fraction)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.CenterFreeaim");
		
		AINSSoldier_CenterFreeaim_Params params {};
		params.Fraction = Fraction;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056BEA60
	 * 		Name   -> Function Insurgency.INSSoldier.CanShowCosmeticEffects
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AINSSoldier::CanShowCosmeticEffects()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.CanShowCosmeticEffects");
		
		AINSSoldier_CanShowCosmeticEffects_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056BEA30
	 * 		Name   -> Function Insurgency.INSSoldier.CanScore
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AINSSoldier::CanScore()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.CanScore");
		
		AINSSoldier_CanScore_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056BEA00
	 * 		Name   -> Function Insurgency.INSSoldier.CanChangeStance
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AINSSoldier::CanChangeStance()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.CanChangeStance");
		
		AINSSoldier_CanChangeStance_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056BEAB0
	 * 		Name   -> Function Insurgency.INSSoldier.CancelUse
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void AINSSoldier::CancelUse()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.CancelUse");
		
		AINSSoldier_CancelUse_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056BEA90
	 * 		Name   -> Function Insurgency.INSSoldier.CancelSprint
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void AINSSoldier::CancelSprint()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.CancelSprint");
		
		AINSSoldier_CancelSprint_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056BE910
	 * 		Name   -> Function Insurgency.INSSoldier.CalcViewLocation
	 * 		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bApplyLeanOffset                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bApplyViewBob                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FVector AINSSoldier::CalcViewLocation(bool bApplyLeanOffset, bool bApplyViewBob)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.CalcViewLocation");
		
		AINSSoldier_CalcViewLocation_Params params {};
		params.bApplyLeanOffset = bApplyLeanOffset;
		params.bApplyViewBob = bApplyViewBob;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056BE7D0
	 * 		Name   -> Function Insurgency.INSSoldier.CalcRecoilOffset
	 * 		Flags  -> (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FVector                                     Position                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FRotator                                    Angles                                                     (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		struct FRotator                                    OriginalAngles                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void AINSSoldier::CalcRecoilOffset(struct FVector* Position, struct FRotator* Angles, const struct FRotator& OriginalAngles)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.CalcRecoilOffset");
		
		AINSSoldier_CalcRecoilOffset_Params params {};
		params.OriginalAngles = OriginalAngles;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (Position != nullptr)
			*Position = params.Position;
		if (Angles != nullptr)
			*Angles = params.Angles;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056BE7A0
	 * 		Name   -> Function Insurgency.INSSoldier.CalcFocusFraction
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
	 */
	float AINSSoldier::CalcFocusFraction()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.CalcFocusFraction");
		
		AINSSoldier_CalcFocusFraction_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> Function Insurgency.INSSoldier.BlueprintUpdateFirstPersonVisibility
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 * Parameters:
	 * 		bool                                               bIsFirstPersonVisible                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSSoldier::BlueprintUpdateFirstPersonVisibility(bool bIsFirstPersonVisible)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.BlueprintUpdateFirstPersonVisibility");
		
		AINSSoldier_BlueprintUpdateFirstPersonVisibility_Params params {};
		params.bIsFirstPersonVisible = bIsFirstPersonVisible;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> Function Insurgency.INSSoldier.BlueprintOnStanceChanged
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		ESoldierStance                                     OldStance                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSSoldier::BlueprintOnStanceChanged(ESoldierStance OldStance)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.BlueprintOnStanceChanged");
		
		AINSSoldier_BlueprintOnStanceChanged_Params params {};
		params.OldStance = OldStance;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> Function Insurgency.INSSoldier.BlueprintCalcCamera
	 * 		Flags  -> (Event, Public, HasOutParms, HasDefaults, BlueprintEvent)
	 * Parameters:
	 * 		float                                              DeltaTime                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     InLocation                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FRotator                                    InRotation                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		float                                              InFOV                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     OutLocation                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FRotator                                    OutRotation                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		float                                              OutFOV                                                     (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSSoldier::BlueprintCalcCamera(float DeltaTime, const struct FVector& InLocation, const struct FRotator& InRotation, float InFOV, struct FVector* OutLocation, struct FRotator* OutRotation, float* OutFOV)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.BlueprintCalcCamera");
		
		AINSSoldier_BlueprintCalcCamera_Params params {};
		params.DeltaTime = DeltaTime;
		params.InLocation = InLocation;
		params.InRotation = InRotation;
		params.InFOV = InFOV;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutLocation != nullptr)
			*OutLocation = params.OutLocation;
		if (OutRotation != nullptr)
			*OutRotation = params.OutRotation;
		if (OutFOV != nullptr)
			*OutFOV = params.OutFOV;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056BE600
	 * 		Name   -> Function Insurgency.INSSoldier.Blind
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		float                                              BlindHoldTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              BlindFadeTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              BlindAlpha                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              SuppressionIncrement                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              FlashSuppressionHoldTime                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSSoldier::Blind(float BlindHoldTime, float BlindFadeTime, float BlindAlpha, float SuppressionIncrement, float FlashSuppressionHoldTime)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.Blind");
		
		AINSSoldier_Blind_Params params {};
		params.BlindHoldTime = BlindHoldTime;
		params.BlindFadeTime = BlindFadeTime;
		params.BlindAlpha = BlindAlpha;
		params.SuppressionIncrement = SuppressionIncrement;
		params.FlashSuppressionHoldTime = FlashSuppressionHoldTime;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056BE5E0
	 * 		Name   -> Function Insurgency.INSSoldier.BeginObserverResponse
	 * 		Flags  -> (Final, Native, Private)
	 */
	void AINSSoldier::BeginObserverResponse()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.BeginObserverResponse");
		
		AINSSoldier_BeginObserverResponse_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056BE560
	 * 		Name   -> Function Insurgency.INSSoldier.ApplyStun
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		float                                              InStunDuration                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSSoldier::ApplyStun(float InStunDuration)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.ApplyStun");
		
		AINSSoldier_ApplyStun_Params params {};
		params.InStunDuration = InStunDuration;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056BE470
	 * 		Name   -> Function Insurgency.INSSoldier.ApplyAttributes
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		struct FPlayerClassAttributes                      Attributes                                                 (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void AINSSoldier::ApplyAttributes(const struct FPlayerClassAttributes& Attributes)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.ApplyAttributes");
		
		AINSSoldier_ApplyAttributes_Params params {};
		params.Attributes = Attributes;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> DelegateFunction Insurgency.INSSoldier.AmmoGatheredDelegate__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 */
	void AINSSoldier::AmmoGatheredDelegate__DelegateSignature()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction Insurgency.INSSoldier.AmmoGatheredDelegate__DelegateSignature");
		
		AINSSoldier_AmmoGatheredDelegate__DelegateSignature_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056BE440
	 * 		Name   -> Function Insurgency.INSSoldier.AllowWeaponReload
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AINSSoldier::AllowWeaponReload()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.AllowWeaponReload");
		
		AINSSoldier_AllowWeaponReload_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056BE410
	 * 		Name   -> Function Insurgency.INSSoldier.AllowWeaponFocus
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AINSSoldier::AllowWeaponFocus()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.AllowWeaponFocus");
		
		AINSSoldier_AllowWeaponFocus_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056BE3E0
	 * 		Name   -> Function Insurgency.INSSoldier.AllowWeaponFire
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AINSSoldier::AllowWeaponFire()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.AllowWeaponFire");
		
		AINSSoldier_AllowWeaponFire_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056BE3B0
	 * 		Name   -> Function Insurgency.INSSoldier.AllowUseInVehicle
	 * 		Flags  -> (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AINSSoldier::AllowUseInVehicle()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.AllowUseInVehicle");
		
		AINSSoldier_AllowUseInVehicle_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056BE380
	 * 		Name   -> Function Insurgency.INSSoldier.AllowSprint
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AINSSoldier::AllowSprint()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.AllowSprint");
		
		AINSSoldier_AllowSprint_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056BE350
	 * 		Name   -> Function Insurgency.INSSoldier.AllowRun
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AINSSoldier::AllowRun()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.AllowRun");
		
		AINSSoldier_AllowRun_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056BE320
	 * 		Name   -> Function Insurgency.INSSoldier.AllowResupply
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AINSSoldier::AllowResupply()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.AllowResupply");
		
		AINSSoldier_AllowResupply_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056BE2F0
	 * 		Name   -> Function Insurgency.INSSoldier.AllowMove
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AINSSoldier::AllowMove()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.AllowMove");
		
		AINSSoldier_AllowMove_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056BE2C0
	 * 		Name   -> Function Insurgency.INSSoldier.AllowJumpShoot
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AINSSoldier::AllowJumpShoot()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.AllowJumpShoot");
		
		AINSSoldier_AllowJumpShoot_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056BE290
	 * 		Name   -> Function Insurgency.INSSoldier.AllowFreeaim
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AINSSoldier::AllowFreeaim()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.AllowFreeaim");
		
		AINSSoldier_AllowFreeaim_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056BE260
	 * 		Name   -> Function Insurgency.INSSoldier.AllowFiremodeToggle
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AINSSoldier::AllowFiremodeToggle()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.AllowFiremodeToggle");
		
		AINSSoldier_AllowFiremodeToggle_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056BE230
	 * 		Name   -> Function Insurgency.INSSoldier.AllowEquipmentPhysics
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AINSSoldier::AllowEquipmentPhysics()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.AllowEquipmentPhysics");
		
		AINSSoldier_AllowEquipmentPhysics_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056BE200
	 * 		Name   -> Function Insurgency.INSSoldier.AllowAimDownSights
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AINSSoldier::AllowAimDownSights()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.AllowAimDownSights");
		
		AINSSoldier_AllowAimDownSights_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056BE180
	 * 		Name   -> Function Insurgency.INSSoldier.AddWeight
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		float                                              Delta                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSSoldier::AddWeight(float Delta)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.AddWeight");
		
		AINSSoldier_AddWeight_Params params {};
		params.Delta = Delta;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056BE0F0
	 * 		Name   -> Function Insurgency.INSSoldier.AddViewPunchRotator
	 * 		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FRotator                                    ViewPunchIncrement                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void AINSSoldier::AddViewPunchRotator(const struct FRotator& ViewPunchIncrement)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.AddViewPunchRotator");
		
		AINSSoldier_AddViewPunchRotator_Params params {};
		params.ViewPunchIncrement = ViewPunchIncrement;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056BDFE0
	 * 		Name   -> Function Insurgency.INSSoldier.AddViewPunch
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		float                                              Pitch                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Yaw                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Roll                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSSoldier::AddViewPunch(float Pitch, float Yaw, float Roll)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.AddViewPunch");
		
		AINSSoldier_AddViewPunch_Params params {};
		params.Pitch = Pitch;
		params.Yaw = Yaw;
		params.Roll = Roll;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056BDF20
	 * 		Name   -> Function Insurgency.INSSoldier.AddToInventory
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class AItemBase*                                   Item                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bFromReplication                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool AINSSoldier::AddToInventory(class AItemBase* Item, bool bFromReplication)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.AddToInventory");
		
		AINSSoldier_AddToInventory_Params params {};
		params.Item = Item;
		params.bFromReplication = bFromReplication;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056BDDF0
	 * 		Name   -> Function Insurgency.INSSoldier.AddCosmetic
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		struct FSelectedCosmetic                           Cosmetic                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		bool                                               bDeferInit                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSSoldier::AddCosmetic(const struct FSelectedCosmetic& Cosmetic, bool bDeferInit)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSoldier.AddCosmetic");
		
		AINSSoldier_AddCosmetic_Params params {};
		params.Cosmetic = Cosmetic;
		params.bDeferInit = bDeferInit;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AINSSoldier.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AINSSoldier::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.INSSoldier");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056C5EE0
	 * 		Name   -> Function Insurgency.INSSpectatorPawn.ToggleAdminMenu
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void AINSSpectatorPawn::ToggleAdminMenu()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSpectatorPawn.ToggleAdminMenu");
		
		AINSSpectatorPawn_ToggleAdminMenu_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056C5EC0
	 * 		Name   -> Function Insurgency.INSSpectatorPawn.SpectatePreviousPlayer
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void AINSSpectatorPawn::SpectatePreviousPlayer()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSpectatorPawn.SpectatePreviousPlayer");
		
		AINSSpectatorPawn_SpectatePreviousPlayer_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056C5DB0
	 * 		Name   -> Function Insurgency.INSSpectatorPawn.SpectatePlayerOnTeam
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		unsigned char                                      TeamIndex                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            Offset                                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bIgnoreDead                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSSpectatorPawn::SpectatePlayerOnTeam(unsigned char TeamIndex, int32_t Offset, bool bIgnoreDead)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSpectatorPawn.SpectatePlayerOnTeam");
		
		AINSSpectatorPawn_SpectatePlayerOnTeam_Params params {};
		params.TeamIndex = TeamIndex;
		params.Offset = Offset;
		params.bIgnoreDead = bIgnoreDead;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056C5D90
	 * 		Name   -> Function Insurgency.INSSpectatorPawn.SpectateNextPlayer
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void AINSSpectatorPawn::SpectateNextPlayer()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSpectatorPawn.SpectateNextPlayer");
		
		AINSSpectatorPawn_SpectateNextPlayer_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056C5D10
	 * 		Name   -> Function Insurgency.INSSpectatorPawn.SetViewTargetPlayerState
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class APlayerState*                                InPlayerState                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSSpectatorPawn::SetViewTargetPlayerState(class APlayerState* InPlayerState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSpectatorPawn.SetViewTargetPlayerState");
		
		AINSSpectatorPawn_SetViewTargetPlayerState_Params params {};
		params.InPlayerState = InPlayerState;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056C5C20
	 * 		Name   -> Function Insurgency.INSSpectatorPawn.SetViewTarget
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		class AActor*                                      Target                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FViewTargetTransitionParams                 TransitionParams                                           (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void AINSSpectatorPawn::SetViewTarget(class AActor* Target, const struct FViewTargetTransitionParams& TransitionParams)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSpectatorPawn.SetViewTarget");
		
		AINSSpectatorPawn_SetViewTarget_Params params {};
		params.Target = Target;
		params.TransitionParams = TransitionParams;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056C5B60
	 * 		Name   -> Function Insurgency.INSSpectatorPawn.Server_AdminCheat
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetServer, BlueprintCallable, NetValidate)
	 * Parameters:
	 * 		class FString                                      Command                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSSpectatorPawn::Server_AdminCheat(const class FString& Command)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSpectatorPawn.Server_AdminCheat");
		
		AINSSpectatorPawn_Server_AdminCheat_Params params {};
		params.Command = Command;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00C76AB0
	 * 		Name   -> Function Insurgency.INSSpectatorPawn.ResetCameraPosition
	 * 		Flags  -> (Final, Exec, Native, Public)
	 */
	void AINSSpectatorPawn::ResetCameraPosition()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSpectatorPawn.ResetCameraPosition");
		
		AINSSpectatorPawn_ResetCameraPosition_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056C5AC0
	 * 		Name   -> Function Insurgency.INSSpectatorPawn.AdminCheat
	 * 		Flags  -> (Final, Exec, Native, Public)
	 * Parameters:
	 * 		class FString                                      Command                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSSpectatorPawn::AdminCheat(const class FString& Command)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSpectatorPawn.AdminCheat");
		
		AINSSpectatorPawn_AdminCheat_Params params {};
		params.Command = Command;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AINSSpectatorPawn.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AINSSpectatorPawn::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.INSSpectatorPawn");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction USurvivalWaveConfig.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* USurvivalWaveConfig::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.SurvivalWaveConfig");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056C6AB0
	 * 		Name   -> Function Insurgency.INSSurvivalGameMode.SkipToExtraction
	 * 		Flags  -> (Final, Exec, Native, Public)
	 */
	void AINSSurvivalGameMode::SkipToExtraction()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSurvivalGameMode.SkipToExtraction");
		
		AINSSurvivalGameMode_SkipToExtraction_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056C6A90
	 * 		Name   -> Function Insurgency.INSSurvivalGameMode.SetupObjectives
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void AINSSurvivalGameMode::SetupObjectives()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSurvivalGameMode.SetupObjectives");
		
		AINSSurvivalGameMode_SetupObjectives_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056C6A10
	 * 		Name   -> Function Insurgency.INSSurvivalGameMode.SetOverrideWaveConfig
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class USurvivalWaveConfig*                         InWaveConfig                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSSurvivalGameMode::SetOverrideWaveConfig(class USurvivalWaveConfig* InWaveConfig)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSurvivalGameMode.SetOverrideWaveConfig");
		
		AINSSurvivalGameMode_SetOverrideWaveConfig_Params params {};
		params.InWaveConfig = InWaveConfig;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056C69F0
	 * 		Name   -> Function Insurgency.INSSurvivalGameMode.PopulateHelicopterWithPlayers
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void AINSSurvivalGameMode::PopulateHelicopterWithPlayers()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSurvivalGameMode.PopulateHelicopterWithPlayers");
		
		AINSSurvivalGameMode_PopulateHelicopterWithPlayers_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056C69C0
	 * 		Name   -> Function Insurgency.INSSurvivalGameMode.IsFinalWave
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AINSSurvivalGameMode::IsFinalWave()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSurvivalGameMode.IsFinalWave");
		
		AINSSurvivalGameMode_IsFinalWave_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056C6990
	 * 		Name   -> Function Insurgency.INSSurvivalGameMode.GetWaveConfig
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	class USurvivalWaveConfig* AINSSurvivalGameMode::GetWaveConfig()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSurvivalGameMode.GetWaveConfig");
		
		AINSSurvivalGameMode_GetWaveConfig_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056C6960
	 * 		Name   -> Function Insurgency.INSSurvivalGameMode.GetSurvivalScenarioData
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	class USurvivalScenarioData* AINSSurvivalGameMode::GetSurvivalScenarioData()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSurvivalGameMode.GetSurvivalScenarioData");
		
		AINSSurvivalGameMode_GetSurvivalScenarioData_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056C6930
	 * 		Name   -> Function Insurgency.INSSurvivalGameMode.FindExtractionHelicopter
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	class AVehicleHoveringBase* AINSSurvivalGameMode::FindExtractionHelicopter()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSurvivalGameMode.FindExtractionHelicopter");
		
		AINSSurvivalGameMode_FindExtractionHelicopter_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056C6910
	 * 		Name   -> Function Insurgency.INSSurvivalGameMode.ActivateNextObjective
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void AINSSurvivalGameMode::ActivateNextObjective()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSurvivalGameMode.ActivateNextObjective");
		
		AINSSurvivalGameMode_ActivateNextObjective_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AINSSurvivalGameMode.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AINSSurvivalGameMode::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.INSSurvivalGameMode");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056C71D0
	 * 		Name   -> Function Insurgency.INSSurvivalGameState.SetCurrentWave
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		int32_t                                            NewCurrentWave                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSSurvivalGameState::SetCurrentWave(int32_t NewCurrentWave)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSurvivalGameState.SetCurrentWave");
		
		AINSSurvivalGameState_SetCurrentWave_Params params {};
		params.NewCurrentWave = NewCurrentWave;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> DelegateFunction Insurgency.INSSurvivalGameState.OnSurvivalWaveChangedDelegate__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 * Parameters:
	 * 		int32_t                                            NewWave                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSSurvivalGameState::OnSurvivalWaveChangedDelegate__DelegateSignature(int32_t NewWave)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction Insurgency.INSSurvivalGameState.OnSurvivalWaveChangedDelegate__DelegateSignature");
		
		AINSSurvivalGameState_OnSurvivalWaveChangedDelegate__DelegateSignature_Params params {};
		params.NewWave = NewWave;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> DelegateFunction Insurgency.INSSurvivalGameState.OnSurvivalPrepareNextWaveDelegate__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 */
	void AINSSurvivalGameState::OnSurvivalPrepareNextWaveDelegate__DelegateSignature()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction Insurgency.INSSurvivalGameState.OnSurvivalPrepareNextWaveDelegate__DelegateSignature");
		
		AINSSurvivalGameState_OnSurvivalPrepareNextWaveDelegate__DelegateSignature_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> DelegateFunction Insurgency.INSSurvivalGameState.OnSurvivalIncomingWaveDelegate__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 * Parameters:
	 * 		ESurvivalWaveType                                  WaveType                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSSurvivalGameState::OnSurvivalIncomingWaveDelegate__DelegateSignature(ESurvivalWaveType WaveType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction Insurgency.INSSurvivalGameState.OnSurvivalIncomingWaveDelegate__DelegateSignature");
		
		AINSSurvivalGameState_OnSurvivalIncomingWaveDelegate__DelegateSignature_Params params {};
		params.WaveType = WaveType;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> DelegateFunction Insurgency.INSSurvivalGameState.OnSurvivalDefendExtractionPointDelegate__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 * Parameters:
	 * 		bool                                               bIsDefending                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSSurvivalGameState::OnSurvivalDefendExtractionPointDelegate__DelegateSignature(bool bIsDefending)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction Insurgency.INSSurvivalGameState.OnSurvivalDefendExtractionPointDelegate__DelegateSignature");
		
		AINSSurvivalGameState_OnSurvivalDefendExtractionPointDelegate__DelegateSignature_Params params {};
		params.bIsDefending = bIsDefending;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056C71B0
	 * 		Name   -> Function Insurgency.INSSurvivalGameState.OnRep_TotalWaves
	 * 		Flags  -> (Final, Native, Private)
	 */
	void AINSSurvivalGameState::OnRep_TotalWaves()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSurvivalGameState.OnRep_TotalWaves");
		
		AINSSurvivalGameState_OnRep_TotalWaves_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056C7190
	 * 		Name   -> Function Insurgency.INSSurvivalGameState.OnRep_IsDefending
	 * 		Flags  -> (Final, Native, Private)
	 */
	void AINSSurvivalGameState::OnRep_IsDefending()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSurvivalGameState.OnRep_IsDefending");
		
		AINSSurvivalGameState_OnRep_IsDefending_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056C7170
	 * 		Name   -> Function Insurgency.INSSurvivalGameState.OnRep_CurrentWave
	 * 		Flags  -> (Final, Native, Private)
	 */
	void AINSSurvivalGameState::OnRep_CurrentWave()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSurvivalGameState.OnRep_CurrentWave");
		
		AINSSurvivalGameState_OnRep_CurrentWave_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x04DB3AE0
	 * 		Name   -> Function Insurgency.INSSurvivalGameState.Multicast_SurvivalPrepareNextWaveEvent
	 * 		Flags  -> (Net, NetReliable, Native, Event, NetMulticast, Public)
	 */
	void AINSSurvivalGameState::Multicast_SurvivalPrepareNextWaveEvent()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSurvivalGameState.Multicast_SurvivalPrepareNextWaveEvent");
		
		AINSSurvivalGameState_Multicast_SurvivalPrepareNextWaveEvent_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056995A0
	 * 		Name   -> Function Insurgency.INSSurvivalGameState.Multicast_SurvivalIncomingWaveEvent
	 * 		Flags  -> (Net, NetReliable, Native, Event, NetMulticast, Public)
	 * Parameters:
	 * 		ESurvivalWaveType                                  NewCurrentWaveType                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSSurvivalGameState::Multicast_SurvivalIncomingWaveEvent(ESurvivalWaveType NewCurrentWaveType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSurvivalGameState.Multicast_SurvivalIncomingWaveEvent");
		
		AINSSurvivalGameState_Multicast_SurvivalIncomingWaveEvent_Params params {};
		params.NewCurrentWaveType = NewCurrentWaveType;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056C70B0
	 * 		Name   -> Function Insurgency.INSSurvivalGameState.Multicast_StartHelicopterSequence
	 * 		Flags  -> (Net, NetReliable, Native, Event, NetMulticast, Public)
	 * Parameters:
	 * 		class ALevelSequenceActor*                         Sequence                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AVehicleHoveringBase*                        Helicopter                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSSurvivalGameState::Multicast_StartHelicopterSequence(class ALevelSequenceActor* Sequence, class AVehicleHoveringBase* Helicopter)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSSurvivalGameState.Multicast_StartHelicopterSequence");
		
		AINSSurvivalGameState_Multicast_StartHelicopterSequence_Params params {};
		params.Sequence = Sequence;
		params.Helicopter = Helicopter;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AINSSurvivalGameState.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AINSSurvivalGameState::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.INSSurvivalGameState");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UInsurgencyGlobals.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UInsurgencyGlobals::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.InsurgencyGlobals");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056C7C00
	 * 		Name   -> Function Insurgency.INSWorldSettings.OnRep_LoadedLightingScenario
	 * 		Flags  -> (Final, Native, Public)
	 */
	void AINSWorldSettings::OnRep_LoadedLightingScenario()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSWorldSettings.OnRep_LoadedLightingScenario");
		
		AINSWorldSettings_OnRep_LoadedLightingScenario_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056C7B70
	 * 		Name   -> Function Insurgency.INSWorldSettings.LoadAndPlayBenchmarkSequence
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bAutomated                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AINSWorldSettings::LoadAndPlayBenchmarkSequence(bool bAutomated)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSWorldSettings.LoadAndPlayBenchmarkSequence");
		
		AINSWorldSettings_LoadAndPlayBenchmarkSequence_Params params {};
		params.bAutomated = bAutomated;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056C7B50
	 * 		Name   -> Function Insurgency.INSWorldSettings.BenchmarkOnStop
	 * 		Flags  -> (Final, Native, Public)
	 */
	void AINSWorldSettings::BenchmarkOnStop()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.INSWorldSettings.BenchmarkOnStop");
		
		AINSWorldSettings_BenchmarkOnStop_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AINSWorldSettings.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AINSWorldSettings::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.INSWorldSettings");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AIntroCameraActor.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AIntroCameraActor::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.IntroCameraActor");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056C9170
	 * 		Name   -> Function Insurgency.InventoryComponent.SortItems
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void UInventoryComponent::SortItems()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.InventoryComponent.SortItems");
		
		UInventoryComponent_SortItems_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056C90F0
	 * 		Name   -> Function Insurgency.InventoryComponent.RemoveItem
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		int32_t                                            ItemIdx                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UInventoryComponent::RemoveItem(int32_t ItemIdx)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.InventoryComponent.RemoveItem");
		
		UInventoryComponent_RemoveItem_Params params {};
		params.ItemIdx = ItemIdx;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056C90D0
	 * 		Name   -> Function Insurgency.InventoryComponent.PurgeItems
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void UInventoryComponent::PurgeItems()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.InventoryComponent.PurgeItems");
		
		UInventoryComponent_PurgeItems_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056C90B0
	 * 		Name   -> Function Insurgency.InventoryComponent.OnRep_InventoryItems
	 * 		Flags  -> (Final, Native, Public)
	 */
	void UInventoryComponent::OnRep_InventoryItems()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.InventoryComponent.OnRep_InventoryItems");
		
		UInventoryComponent_OnRep_InventoryItems_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> DelegateFunction Insurgency.InventoryComponent.InventoryChangedDelegate__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 */
	void UInventoryComponent::InventoryChangedDelegate__DelegateSignature()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction Insurgency.InventoryComponent.InventoryChangedDelegate__DelegateSignature");
		
		UInventoryComponent_InventoryChangedDelegate__DelegateSignature_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056C9020
	 * 		Name   -> Function Insurgency.InventoryComponent.HasItemInSlot
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		EItemSlot                                          Slot                                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UInventoryComponent::HasItemInSlot(EItemSlot Slot)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.InventoryComponent.HasItemInSlot");
		
		UInventoryComponent_HasItemInSlot_Params params {};
		params.Slot = Slot;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056C8F50
	 * 		Name   -> Function Insurgency.InventoryComponent.GiveItemsReverse
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class AINSSoldier*                                 Consumer                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bConsumeItems                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UInventoryComponent::GiveItemsReverse(class AINSSoldier* Consumer, bool bConsumeItems)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.InventoryComponent.GiveItemsReverse");
		
		UInventoryComponent_GiveItemsReverse_Params params {};
		params.Consumer = Consumer;
		params.bConsumeItems = bConsumeItems;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056C8E80
	 * 		Name   -> Function Insurgency.InventoryComponent.GiveItems
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class AINSSoldier*                                 Consumer                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bConsumeItems                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UInventoryComponent::GiveItems(class AINSSoldier* Consumer, bool bConsumeItems)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.InventoryComponent.GiveItems");
		
		UInventoryComponent_GiveItems_Params params {};
		params.Consumer = Consumer;
		params.bConsumeItems = bConsumeItems;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056C8D20
	 * 		Name   -> Function Insurgency.InventoryComponent.GiveItemAt
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		int32_t                                            ItemIdx                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AINSSoldier*                                 Consumer                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bDeferSpawn                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bConsumeItem                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class AItemBase* UInventoryComponent::GiveItemAt(int32_t ItemIdx, class AINSSoldier* Consumer, bool bDeferSpawn, bool bConsumeItem)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.InventoryComponent.GiveItemAt");
		
		UInventoryComponent_GiveItemAt_Params params {};
		params.ItemIdx = ItemIdx;
		params.Consumer = Consumer;
		params.bDeferSpawn = bDeferSpawn;
		params.bConsumeItem = bConsumeItem;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056C8CA0
	 * 		Name   -> Function Insurgency.InventoryComponent.GiveFallbackItems
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class AINSSoldier*                                 Consumer                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UInventoryComponent::GiveFallbackItems(class AINSSoldier* Consumer)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.InventoryComponent.GiveFallbackItems");
		
		UInventoryComponent_GiveFallbackItems_Params params {};
		params.Consumer = Consumer;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056C8B70
	 * 		Name   -> Function Insurgency.InventoryComponent.GetInventoryItemsFilteredByItemSlot
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		TArray<struct FInventorySlot>                      OutItems                                                   (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EItemSlot                                          Slot                                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UInventoryComponent::GetInventoryItemsFilteredByItemSlot(TArray<struct FInventorySlot>* OutItems, EItemSlot Slot)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.InventoryComponent.GetInventoryItemsFilteredByItemSlot");
		
		UInventoryComponent_GetInventoryItemsFilteredByItemSlot_Params params {};
		params.Slot = Slot;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutItems != nullptr)
			*OutItems = params.OutItems;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056C8AE0
	 * 		Name   -> Function Insurgency.InventoryComponent.EmptyItems
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bIgnoreLockedSlots                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UInventoryComponent::EmptyItems(bool bIgnoreLockedSlots)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.InventoryComponent.EmptyItems");
		
		UInventoryComponent_EmptyItems_Params params {};
		params.bIgnoreLockedSlots = bIgnoreLockedSlots;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056C8980
	 * 		Name   -> Function Insurgency.InventoryComponent.ContainsItem
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		bool                                               bIncludeChildren                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UInventoryComponent::ContainsItem(bool bIncludeChildren)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.InventoryComponent.ContainsItem");
		
		UInventoryComponent_ContainsItem_Params params {};
		params.bIncludeChildren = bIncludeChildren;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056C8810
	 * 		Name   -> Function Insurgency.InventoryComponent.CollectFallbackItemsFor
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		TArray<class UClass*>                              OutFallbackItems                                           (Parm, OutParm, ZeroConstructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UInventoryComponent::CollectFallbackItemsFor(TArray<class UClass*>* OutFallbackItems)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.InventoryComponent.CollectFallbackItemsFor");
		
		UInventoryComponent_CollectFallbackItemsFor_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutFallbackItems != nullptr)
			*OutFallbackItems = params.OutFallbackItems;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056C8760
	 * 		Name   -> Function Insurgency.InventoryComponent.CollectFallbackItems
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		TArray<class UClass*>                              OutFallbackItems                                           (Parm, OutParm, ZeroConstructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UInventoryComponent::CollectFallbackItems(TArray<class UClass*>* OutFallbackItems)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.InventoryComponent.CollectFallbackItems");
		
		UInventoryComponent_CollectFallbackItems_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutFallbackItems != nullptr)
			*OutFallbackItems = params.OutFallbackItems;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056C8610
	 * 		Name   -> Function Insurgency.InventoryComponent.CheckFallbackFor
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		class AINSSoldier*                                 Consumer                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UInventoryComponent::CheckFallbackFor(class AINSSoldier* Consumer)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.InventoryComponent.CheckFallbackFor");
		
		UInventoryComponent_CheckFallbackFor_Params params {};
		params.Consumer = Consumer;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> Function Insurgency.InventoryComponent.BlueprintOnGiveItem
	 * 		Flags  -> (Event, Public, HasOutParms, BlueprintEvent)
	 * Parameters:
	 * 		struct FInventorySlot                              Slot                                                       (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		class AItemBase*                                   SpawnedItem                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UInventoryComponent::BlueprintOnGiveItem(const struct FInventorySlot& Slot, class AItemBase* SpawnedItem)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.InventoryComponent.BlueprintOnGiveItem");
		
		UInventoryComponent_BlueprintOnGiveItem_Params params {};
		params.Slot = Slot;
		params.SpawnedItem = SpawnedItem;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056C84C0
	 * 		Name   -> Function Insurgency.InventoryComponent.AddItem
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		struct FInventorySlot                              Slot                                                       (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		bool                                               bSortNow                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UInventoryComponent::AddItem(const struct FInventorySlot& Slot, bool bSortNow)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.InventoryComponent.AddItem");
		
		UInventoryComponent_AddItem_Params params {};
		params.Slot = Slot;
		params.bSortNow = bSortNow;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UInventoryComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UInventoryComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.InventoryComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056CC430
	 * 		Name   -> Function Insurgency.ItemBase.SetThirdPersonMeshesVisibility
	 * 		Flags  -> (Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bVisible                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bPropagateToChildren                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AItemBase::SetThirdPersonMeshesVisibility(bool bVisible, bool bPropagateToChildren)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemBase.SetThirdPersonMeshesVisibility");
		
		AItemBase_SetThirdPersonMeshesVisibility_Params params {};
		params.bVisible = bVisible;
		params.bPropagateToChildren = bPropagateToChildren;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056CC3B0
	 * 		Name   -> Function Insurgency.ItemBase.ReattachMasterPosedChildMeshes
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class USkinnedMeshComponent*                       NewParent                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AItemBase::ReattachMasterPosedChildMeshes(class USkinnedMeshComponent* NewParent)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemBase.ReattachMasterPosedChildMeshes");
		
		AItemBase_ReattachMasterPosedChildMeshes_Params params {};
		params.NewParent = NewParent;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056CC310
	 * 		Name   -> Function Insurgency.ItemBase.PlaySoundEventPairOnOwner
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		struct FAkComponentCameraPair                      AudioEvent                                                 (Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void AItemBase::PlaySoundEventPairOnOwner(struct FAkComponentCameraPair* AudioEvent)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemBase.PlaySoundEventPairOnOwner");
		
		AItemBase_PlaySoundEventPairOnOwner_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (AudioEvent != nullptr)
			*AudioEvent = params.AudioEvent;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056CC250
	 * 		Name   -> Function Insurgency.ItemBase.PlaySoundEventOnOwnerFromView
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UAkAudioEvent*                               FirstPersonEvent                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UAkAudioEvent*                               ThirdPersonEvent                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AItemBase::PlaySoundEventOnOwnerFromView(class UAkAudioEvent* FirstPersonEvent, class UAkAudioEvent* ThirdPersonEvent)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemBase.PlaySoundEventOnOwnerFromView");
		
		AItemBase_PlaySoundEventOnOwnerFromView_Params params {};
		params.FirstPersonEvent = FirstPersonEvent;
		params.ThirdPersonEvent = ThirdPersonEvent;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056CC180
	 * 		Name   -> Function Insurgency.ItemBase.PlaySoundEventOnOwner
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UAkAudioEvent*                               Event                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bThirdPerson                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AItemBase::PlaySoundEventOnOwner(class UAkAudioEvent* Event, bool bThirdPerson)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemBase.PlaySoundEventOnOwner");
		
		AItemBase_PlaySoundEventOnOwner_Params params {};
		params.Event = Event;
		params.bThirdPerson = bThirdPerson;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> Function Insurgency.ItemBase.OnThirdPersonMeshesVisibilityChanged
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 * Parameters:
	 * 		bool                                               bVisible                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bPropagateToChildren                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AItemBase::OnThirdPersonMeshesVisibilityChanged(bool bVisible, bool bPropagateToChildren)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemBase.OnThirdPersonMeshesVisibilityChanged");
		
		AItemBase_OnThirdPersonMeshesVisibilityChanged_Params params {};
		params.bVisible = bVisible;
		params.bPropagateToChildren = bPropagateToChildren;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056CC0B0
	 * 		Name   -> Function Insurgency.ItemBase.OnSpawnedPreviewActor
	 * 		Flags  -> (Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bFirstPerson                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UPlayerInventoryComponent*                   PlayerInventory                                            (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AItemBase::OnSpawnedPreviewActor(bool bFirstPerson, class UPlayerInventoryComponent* PlayerInventory)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemBase.OnSpawnedPreviewActor");
		
		AItemBase_OnSpawnedPreviewActor_Params params {};
		params.bFirstPerson = bFirstPerson;
		params.PlayerInventory = PlayerInventory;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056CC090
	 * 		Name   -> Function Insurgency.ItemBase.OnRep_PawnOwner
	 * 		Flags  -> (Final, Native, Public)
	 */
	void AItemBase::OnRep_PawnOwner()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemBase.OnRep_PawnOwner");
		
		AItemBase_OnRep_PawnOwner_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> Function Insurgency.ItemBase.MigrateStructsToNative
	 * 		Flags  -> (Event, Public, BlueprintCallable, BlueprintEvent)
	 */
	void AItemBase::MigrateStructsToNative()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemBase.MigrateStructsToNative");
		
		AItemBase_MigrateStructsToNative_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056CC060
	 * 		Name   -> Function Insurgency.ItemBase.IsOwnerLocallyControlled
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AItemBase::IsOwnerLocallyControlled()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemBase.IsOwnerLocallyControlled");
		
		AItemBase_IsOwnerLocallyControlled_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056CC020
	 * 		Name   -> Function Insurgency.ItemBase.GetWeight
	 * 		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	float AItemBase::GetWeight()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemBase.GetWeight");
		
		AItemBase_GetWeight_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056CBFF0
	 * 		Name   -> Function Insurgency.ItemBase.GetRepresentativeItemSlot
	 * 		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	EItemSlot AItemBase::GetRepresentativeItemSlot()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemBase.GetRepresentativeItemSlot");
		
		AItemBase_GetRepresentativeItemSlot_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056CBFC0
	 * 		Name   -> Function Insurgency.ItemBase.GetOwnerMesh3P
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	class USkeletalMeshComponent* AItemBase::GetOwnerMesh3P()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemBase.GetOwnerMesh3P");
		
		AItemBase_GetOwnerMesh3P_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056CBF90
	 * 		Name   -> Function Insurgency.ItemBase.GetMesh3P
	 * 		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	class UINSSkeletalMeshComponent* AItemBase::GetMesh3P()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemBase.GetMesh3P");
		
		AItemBase_GetMesh3P_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056CBF50
	 * 		Name   -> Function Insurgency.ItemBase.GetDroppedLifeSpan
	 * 		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	float AItemBase::GetDroppedLifeSpan()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemBase.GetDroppedLifeSpan");
		
		AItemBase_GetDroppedLifeSpan_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056CBF20
	 * 		Name   -> Function Insurgency.ItemBase.DropItem
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	bool AItemBase::DropItem()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemBase.DropItem");
		
		AItemBase_DropItem_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x04DB3A00
	 * 		Name   -> Function Insurgency.ItemBase.DetachMeshFromPawn
	 * 		Flags  -> (Native, Public, BlueprintCallable)
	 */
	void AItemBase::DetachMeshFromPawn()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemBase.DetachMeshFromPawn");
		
		AItemBase_DetachMeshFromPawn_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056CBEF0
	 * 		Name   -> Function Insurgency.ItemBase.ConsumesSlotCapacity
	 * 		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AItemBase::ConsumesSlotCapacity()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemBase.ConsumesSlotCapacity");
		
		AItemBase_ConsumesSlotCapacity_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056CBED0
	 * 		Name   -> Function Insurgency.ItemBase.CheckPhysicsSleep
	 * 		Flags  -> (Final, Native, Public)
	 */
	void AItemBase::CheckPhysicsSleep()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemBase.CheckPhysicsSleep");
		
		AItemBase_CheckPhysicsSleep_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056BEA60
	 * 		Name   -> Function Insurgency.ItemBase.CanShowCosmeticEffects
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AItemBase::CanShowCosmeticEffects()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemBase.CanShowCosmeticEffects");
		
		AItemBase_CanShowCosmeticEffects_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056CBEA0
	 * 		Name   -> Function Insurgency.ItemBase.CanBeDropped
	 * 		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure)
	 */
	bool AItemBase::CanBeDropped()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemBase.CanBeDropped");
		
		AItemBase_CanBeDropped_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> Function Insurgency.ItemBase.BlueprintSpawnedPreviewActor
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		bool                                               bFirstPerson                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UPlayerInventoryComponent*                   PlayerInventory                                            (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AItemBase::BlueprintSpawnedPreviewActor(bool bFirstPerson, class UPlayerInventoryComponent* PlayerInventory)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemBase.BlueprintSpawnedPreviewActor");
		
		AItemBase_BlueprintSpawnedPreviewActor_Params params {};
		params.bFirstPerson = bFirstPerson;
		params.PlayerInventory = PlayerInventory;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> Function Insurgency.ItemBase.BlueprintPreItemRemovedFromInventory
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 */
	void AItemBase::BlueprintPreItemRemovedFromInventory()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemBase.BlueprintPreItemRemovedFromInventory");
		
		AItemBase_BlueprintPreItemRemovedFromInventory_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> Function Insurgency.ItemBase.BlueprintPostItemRemovedFromInventory
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		class AINSSoldier*                                 PreviousOwnerPawn                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AItemBase::BlueprintPostItemRemovedFromInventory(class AINSSoldier* PreviousOwnerPawn)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemBase.BlueprintPostItemRemovedFromInventory");
		
		AItemBase_BlueprintPostItemRemovedFromInventory_Params params {};
		params.PreviousOwnerPawn = PreviousOwnerPawn;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> Function Insurgency.ItemBase.BlueprintOnPickedUp
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 */
	void AItemBase::BlueprintOnPickedUp()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemBase.BlueprintOnPickedUp");
		
		AItemBase_BlueprintOnPickedUp_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> Function Insurgency.ItemBase.BlueprintOnDropped
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 */
	void AItemBase::BlueprintOnDropped()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemBase.BlueprintOnDropped");
		
		AItemBase_BlueprintOnDropped_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> Function Insurgency.ItemBase.BlueprintOnDetachMeshFromPawn
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		class UINSSkeletalMeshComponent*                   Mesh                                                       (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AItemBase::BlueprintOnDetachMeshFromPawn(class UINSSkeletalMeshComponent* Mesh)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemBase.BlueprintOnDetachMeshFromPawn");
		
		AItemBase_BlueprintOnDetachMeshFromPawn_Params params {};
		params.Mesh = Mesh;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> Function Insurgency.ItemBase.BlueprintOnDeath
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 */
	void AItemBase::BlueprintOnDeath()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemBase.BlueprintOnDeath");
		
		AItemBase_BlueprintOnDeath_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> Function Insurgency.ItemBase.BlueprintOnAttachMeshToPawn
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		class UINSSkeletalMeshComponent*                   Mesh                                                       (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AItemBase::BlueprintOnAttachMeshToPawn(class UINSSkeletalMeshComponent* Mesh)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemBase.BlueprintOnAttachMeshToPawn");
		
		AItemBase_BlueprintOnAttachMeshToPawn_Params params {};
		params.Mesh = Mesh;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> Function Insurgency.ItemBase.BlueprintCalcOwnerCamera
	 * 		Flags  -> (Event, Public, HasOutParms, BlueprintCallable, BlueprintEvent)
	 * Parameters:
	 * 		float                                              DeltaTime                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FMinimalViewInfo                            OutResult                                                  (Parm, OutParm, NativeAccessSpecifierPublic)
	 */
	void AItemBase::BlueprintCalcOwnerCamera(float DeltaTime, struct FMinimalViewInfo* OutResult)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemBase.BlueprintCalcOwnerCamera");
		
		AItemBase_BlueprintCalcOwnerCamera_Params params {};
		params.DeltaTime = DeltaTime;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutResult != nullptr)
			*OutResult = params.OutResult;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x04DB44A0
	 * 		Name   -> Function Insurgency.ItemBase.AttachMeshToPawn
	 * 		Flags  -> (Native, Public, BlueprintCallable)
	 */
	void AItemBase::AttachMeshToPawn()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemBase.AttachMeshToPawn");
		
		AItemBase_AttachMeshToPawn_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AItemBase.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AItemBase::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.ItemBase");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056CE070
	 * 		Name   -> Function Insurgency.ItemEquipable.UpdateLocalRTPC
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void AItemEquipable::UpdateLocalRTPC()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemEquipable.UpdateLocalRTPC");
		
		AItemEquipable_UpdateLocalRTPC_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056CE040
	 * 		Name   -> Function Insurgency.ItemEquipable.ShouldShowItemsOnBack
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AItemEquipable::ShouldShowItemsOnBack()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemEquipable.ShouldShowItemsOnBack");
		
		AItemEquipable_ShouldShowItemsOnBack_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056CE010
	 * 		Name   -> Function Insurgency.ItemEquipable.ShouldPlayFirstEquip
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AItemEquipable::ShouldPlayFirstEquip()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemEquipable.ShouldPlayFirstEquip");
		
		AItemEquipable_ShouldPlayFirstEquip_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056CDF30
	 * 		Name   -> Function Insurgency.ItemEquipable.SetWeaponRTPC
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class FString                                      RTPCName                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Value                                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AItemEquipable::SetWeaponRTPC(const class FString& RTPCName, float Value)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemEquipable.SetWeaponRTPC");
		
		AItemEquipable_SetWeaponRTPC_Params params {};
		params.RTPCName = RTPCName;
		params.Value = Value;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056CDEB0
	 * 		Name   -> Function Insurgency.ItemEquipable.SetEquipableState
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		EEquipableState                                    NewState                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AItemEquipable::SetEquipableState(EEquipableState NewState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemEquipable.SetEquipableState");
		
		AItemEquipable_SetEquipableState_Params params {};
		params.NewState = NewState;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056CDE00
	 * 		Name   -> Function Insurgency.ItemEquipable.PlaySoundEventPair
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		struct FAkComponentCameraPair                      AudioEvent                                                 (Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	int32_t AItemEquipable::PlaySoundEventPair(struct FAkComponentCameraPair* AudioEvent)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemEquipable.PlaySoundEventPair");
		
		AItemEquipable_PlaySoundEventPair_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (AudioEvent != nullptr)
			*AudioEvent = params.AudioEvent;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056CDD40
	 * 		Name   -> Function Insurgency.ItemEquipable.PlaySoundEventFromView
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UAkAudioEvent*                               FirstPersonEvent                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UAkAudioEvent*                               ThirdPersonEvent                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	int32_t AItemEquipable::PlaySoundEventFromView(class UAkAudioEvent* FirstPersonEvent, class UAkAudioEvent* ThirdPersonEvent)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemEquipable.PlaySoundEventFromView");
		
		AItemEquipable_PlaySoundEventFromView_Params params {};
		params.FirstPersonEvent = FirstPersonEvent;
		params.ThirdPersonEvent = ThirdPersonEvent;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056CDC80
	 * 		Name   -> Function Insurgency.ItemEquipable.PlaySoundEvent
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UAkAudioEvent*                               Event                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bApplySpeedOfSound                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	int32_t AItemEquipable::PlaySoundEvent(class UAkAudioEvent* Event, bool bApplySpeedOfSound)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemEquipable.PlaySoundEvent");
		
		AItemEquipable_PlaySoundEvent_Params params {};
		params.Event = Event;
		params.bApplySpeedOfSound = bApplySpeedOfSound;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056CDC60
	 * 		Name   -> Function Insurgency.ItemEquipable.OnRep_EquipableState
	 * 		Flags  -> (Final, Native, Private)
	 */
	void AItemEquipable::OnRep_EquipableState()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemEquipable.OnRep_EquipableState");
		
		AItemEquipable_OnRep_EquipableState_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> DelegateFunction Insurgency.ItemEquipable.ItemUnequipDelegate__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 * Parameters:
	 * 		bool                                               bInstant                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AItemEquipable*                              SwitchingTo                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AItemEquipable::ItemUnequipDelegate__DelegateSignature(bool bInstant, class AItemEquipable* SwitchingTo)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction Insurgency.ItemEquipable.ItemUnequipDelegate__DelegateSignature");
		
		AItemEquipable_ItemUnequipDelegate__DelegateSignature_Params params {};
		params.bInstant = bInstant;
		params.SwitchingTo = SwitchingTo;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> DelegateFunction Insurgency.ItemEquipable.ItemEquipDelegate__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 * Parameters:
	 * 		bool                                               bInstant                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AItemEquipable*                              SwitchingFrom                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bWantsFirstEquip                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AItemEquipable::ItemEquipDelegate__DelegateSignature(bool bInstant, class AItemEquipable* SwitchingFrom, bool bWantsFirstEquip)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction Insurgency.ItemEquipable.ItemEquipDelegate__DelegateSignature");
		
		AItemEquipable_ItemEquipDelegate__DelegateSignature_Params params {};
		params.bInstant = bInstant;
		params.SwitchingFrom = SwitchingFrom;
		params.bWantsFirstEquip = bWantsFirstEquip;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056CDC30
	 * 		Name   -> Function Insurgency.ItemEquipable.IsViewTarget
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AItemEquipable::IsViewTarget()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemEquipable.IsViewTarget");
		
		AItemEquipable_IsViewTarget_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056CDC00
	 * 		Name   -> Function Insurgency.ItemEquipable.IsUnequippingOrUnequipped
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AItemEquipable::IsUnequippingOrUnequipped()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemEquipable.IsUnequippingOrUnequipped");
		
		AItemEquipable_IsUnequippingOrUnequipped_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056CDBD0
	 * 		Name   -> Function Insurgency.ItemEquipable.IsUnequipping
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AItemEquipable::IsUnequipping()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemEquipable.IsUnequipping");
		
		AItemEquipable_IsUnequipping_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056CDBA0
	 * 		Name   -> Function Insurgency.ItemEquipable.IsUnequipped
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AItemEquipable::IsUnequipped()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemEquipable.IsUnequipped");
		
		AItemEquipable_IsUnequipped_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056CDB70
	 * 		Name   -> Function Insurgency.ItemEquipable.IsOwnerUsingGamepad
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AItemEquipable::IsOwnerUsingGamepad()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemEquipable.IsOwnerUsingGamepad");
		
		AItemEquipable_IsOwnerUsingGamepad_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056CDB40
	 * 		Name   -> Function Insurgency.ItemEquipable.IsMeshVisibleWhenUnequipped
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AItemEquipable::IsMeshVisibleWhenUnequipped()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemEquipable.IsMeshVisibleWhenUnequipped");
		
		AItemEquipable_IsMeshVisibleWhenUnequipped_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056CDB10
	 * 		Name   -> Function Insurgency.ItemEquipable.IsFreeaimEnabled
	 * 		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AItemEquipable::IsFreeaimEnabled()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemEquipable.IsFreeaimEnabled");
		
		AItemEquipable_IsFreeaimEnabled_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056CDAE0
	 * 		Name   -> Function Insurgency.ItemEquipable.IsFirstPersonViewTarget
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AItemEquipable::IsFirstPersonViewTarget()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemEquipable.IsFirstPersonViewTarget");
		
		AItemEquipable_IsFirstPersonViewTarget_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056CDAB0
	 * 		Name   -> Function Insurgency.ItemEquipable.IsEquippingOrEquipped
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AItemEquipable::IsEquippingOrEquipped()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemEquipable.IsEquippingOrEquipped");
		
		AItemEquipable_IsEquippingOrEquipped_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056CDA80
	 * 		Name   -> Function Insurgency.ItemEquipable.IsEquipping
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AItemEquipable::IsEquipping()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemEquipable.IsEquipping");
		
		AItemEquipable_IsEquipping_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056CD9F0
	 * 		Name   -> Function Insurgency.ItemEquipable.IsEquippedOrNearlyEquipped
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		float                                              Tolerance                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool AItemEquipable::IsEquippedOrNearlyEquipped(float Tolerance)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemEquipable.IsEquippedOrNearlyEquipped");
		
		AItemEquipable_IsEquippedOrNearlyEquipped_Params params {};
		params.Tolerance = Tolerance;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056CD9C0
	 * 		Name   -> Function Insurgency.ItemEquipable.IsEquipped
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AItemEquipable::IsEquipped()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemEquipable.IsEquipped");
		
		AItemEquipable_IsEquipped_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056CD990
	 * 		Name   -> Function Insurgency.ItemEquipable.IsAIControlled
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AItemEquipable::IsAIControlled()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemEquipable.IsAIControlled");
		
		AItemEquipable_IsAIControlled_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056CD8F0
	 * 		Name   -> Function Insurgency.ItemEquipable.GetUnequipDurationModifier
	 * 		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		bool                                               bSwitchingFrom                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	float AItemEquipable::GetUnequipDurationModifier(bool bSwitchingFrom)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemEquipable.GetUnequipDurationModifier");
		
		AItemEquipable_GetUnequipDurationModifier_Params params {};
		params.bSwitchingFrom = bSwitchingFrom;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056CD8C0
	 * 		Name   -> Function Insurgency.ItemEquipable.GetOwningPawn
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	class AINSSoldier* AItemEquipable::GetOwningPawn()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemEquipable.GetOwningPawn");
		
		AItemEquipable_GetOwningPawn_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056CD890
	 * 		Name   -> Function Insurgency.ItemEquipable.GetMesh1P
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	class UINSSkeletalMeshComponent* AItemEquipable::GetMesh1P()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemEquipable.GetMesh1P");
		
		AItemEquipable_GetMesh1P_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056CD850
	 * 		Name   -> Function Insurgency.ItemEquipable.GetFreeaimFraction
	 * 		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	float AItemEquipable::GetFreeaimFraction()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemEquipable.GetFreeaimFraction");
		
		AItemEquipable_GetFreeaimFraction_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056CD780
	 * 		Name   -> Function Insurgency.ItemEquipable.GetEquipDurationModifier
	 * 		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		bool                                               bSwitchingFrom                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	float AItemEquipable::GetEquipDurationModifier(bool bSwitchingFrom)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemEquipable.GetEquipDurationModifier");
		
		AItemEquipable_GetEquipDurationModifier_Params params {};
		params.bSwitchingFrom = bSwitchingFrom;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056CD820
	 * 		Name   -> Function Insurgency.ItemEquipable.GetEquipableState
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	EEquipableState AItemEquipable::GetEquipableState()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemEquipable.GetEquipableState");
		
		AItemEquipable_GetEquipableState_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056CD750
	 * 		Name   -> Function Insurgency.ItemEquipable.GetController
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	class AController* AItemEquipable::GetController()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemEquipable.GetController");
		
		AItemEquipable_GetController_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x04DB4E40
	 * 		Name   -> Function Insurgency.ItemEquipable.ClientCancelUnequip
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetClient)
	 */
	void AItemEquipable::ClientCancelUnequip()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemEquipable.ClientCancelUnequip");
		
		AItemEquipable_ClientCancelUnequip_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x04DCFF00
	 * 		Name   -> Function Insurgency.ItemEquipable.ClientCancelEquip
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetClient)
	 */
	void AItemEquipable::ClientCancelEquip()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemEquipable.ClientCancelEquip");
		
		AItemEquipable_ClientCancelEquip_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056CD720
	 * 		Name   -> Function Insurgency.ItemEquipable.CanEquipBlueprint
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AItemEquipable::CanEquipBlueprint()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemEquipable.CanEquipBlueprint");
		
		AItemEquipable_CanEquipBlueprint_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> Function Insurgency.ItemEquipable.BlueprintOnUpdateFirstPersonVisibility
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 * Parameters:
	 * 		bool                                               bFirstPersonVisibile                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AItemEquipable::BlueprintOnUpdateFirstPersonVisibility(bool bFirstPersonVisibile)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemEquipable.BlueprintOnUpdateFirstPersonVisibility");
		
		AItemEquipable_BlueprintOnUpdateFirstPersonVisibility_Params params {};
		params.bFirstPersonVisibile = bFirstPersonVisibile;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> Function Insurgency.ItemEquipable.BlueprintOnUnequipped
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 */
	void AItemEquipable::BlueprintOnUnequipped()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemEquipable.BlueprintOnUnequipped");
		
		AItemEquipable_BlueprintOnUnequipped_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> Function Insurgency.ItemEquipable.BlueprintOnUnequip
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 */
	void AItemEquipable::BlueprintOnUnequip()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemEquipable.BlueprintOnUnequip");
		
		AItemEquipable_BlueprintOnUnequip_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> Function Insurgency.ItemEquipable.BlueprintOnEquipped
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 */
	void AItemEquipable::BlueprintOnEquipped()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemEquipable.BlueprintOnEquipped");
		
		AItemEquipable_BlueprintOnEquipped_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> Function Insurgency.ItemEquipable.BlueprintOnEquip
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 */
	void AItemEquipable::BlueprintOnEquip()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemEquipable.BlueprintOnEquip");
		
		AItemEquipable_BlueprintOnEquip_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> Function Insurgency.ItemEquipable.BlueprintOnAttachToBack
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		class UINSSkeletalMeshComponent*                   Mesh                                                       (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AItemEquipable::BlueprintOnAttachToBack(class UINSSkeletalMeshComponent* Mesh)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemEquipable.BlueprintOnAttachToBack");
		
		AItemEquipable_BlueprintOnAttachToBack_Params params {};
		params.Mesh = Mesh;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056CD700
	 * 		Name   -> Function Insurgency.ItemEquipable.AttachMeshToBack
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void AItemEquipable::AttachMeshToBack()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemEquipable.AttachMeshToBack");
		
		AItemEquipable_AttachMeshToBack_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AItemEquipable.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AItemEquipable::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.ItemEquipable");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> DelegateFunction Insurgency.ItemWeapon.WeaponUpgradeRemovedDelegate__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 * Parameters:
	 * 		class UWeaponUpgradeComponent*                     Upgrade                                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AItemWeapon::WeaponUpgradeRemovedDelegate__DelegateSignature(class UWeaponUpgradeComponent* Upgrade)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction Insurgency.ItemWeapon.WeaponUpgradeRemovedDelegate__DelegateSignature");
		
		AItemWeapon_WeaponUpgradeRemovedDelegate__DelegateSignature_Params params {};
		params.Upgrade = Upgrade;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> DelegateFunction Insurgency.ItemWeapon.WeaponUpgradeInstalledDelegate__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 * Parameters:
	 * 		class UWeaponUpgradeComponent*                     Upgrade                                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AItemWeapon::WeaponUpgradeInstalledDelegate__DelegateSignature(class UWeaponUpgradeComponent* Upgrade)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction Insurgency.ItemWeapon.WeaponUpgradeInstalledDelegate__DelegateSignature");
		
		AItemWeapon_WeaponUpgradeInstalledDelegate__DelegateSignature_Params params {};
		params.Upgrade = Upgrade;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056DE1E0
	 * 		Name   -> Function Insurgency.ItemWeapon.UsesReloadSequences
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AItemWeapon::UsesReloadSequences()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemWeapon.UsesReloadSequences");
		
		AItemWeapon_UsesReloadSequences_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056DE1B0
	 * 		Name   -> Function Insurgency.ItemWeapon.UsesMagazineReloads
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AItemWeapon::UsesMagazineReloads()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemWeapon.UsesMagazineReloads");
		
		AItemWeapon_UsesMagazineReloads_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056DE120
	 * 		Name   -> Function Insurgency.ItemWeapon.UpdateVisibleAmmoContainerToDefault
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bForceFirstPerson                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AItemWeapon::UpdateVisibleAmmoContainerToDefault(bool bForceFirstPerson)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemWeapon.UpdateVisibleAmmoContainerToDefault");
		
		AItemWeapon_UpdateVisibleAmmoContainerToDefault_Params params {};
		params.bForceFirstPerson = bForceFirstPerson;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056DDF80
	 * 		Name   -> Function Insurgency.ItemWeapon.UpdateVisibleAmmoContainerForMeshes
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UClass*                                      NewContainer                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class USkeletalMeshComponent*                      ParentMesh1P                                               (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bForce1P                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class USkeletalMeshComponent*                      ParentMesh3P                                               (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bForce3P                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AItemWeapon::UpdateVisibleAmmoContainerForMeshes(class UClass* NewContainer, class USkeletalMeshComponent* ParentMesh1P, bool bForce1P, class USkeletalMeshComponent* ParentMesh3P, bool bForce3P)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemWeapon.UpdateVisibleAmmoContainerForMeshes");
		
		AItemWeapon_UpdateVisibleAmmoContainerForMeshes_Params params {};
		params.NewContainer = NewContainer;
		params.ParentMesh1P = ParentMesh1P;
		params.bForce1P = bForce1P;
		params.ParentMesh3P = ParentMesh3P;
		params.bForce3P = bForce3P;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056DDE30
	 * 		Name   -> Function Insurgency.ItemWeapon.UpdateVisibleAmmoContainerForMesh
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UClass*                                      NewContainer                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class USkeletalMeshComponent*                      ParentMesh                                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bFirstPerson                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bForce                                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AItemWeapon::UpdateVisibleAmmoContainerForMesh(class UClass* NewContainer, class USkeletalMeshComponent* ParentMesh, bool bFirstPerson, bool bForce)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemWeapon.UpdateVisibleAmmoContainerForMesh");
		
		AItemWeapon_UpdateVisibleAmmoContainerForMesh_Params params {};
		params.NewContainer = NewContainer;
		params.ParentMesh = ParentMesh;
		params.bFirstPerson = bFirstPerson;
		params.bForce = bForce;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056DDD20
	 * 		Name   -> Function Insurgency.ItemWeapon.UpdateVisibleAmmoContainer
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UClass*                                      NewContainer                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bForceFirstPerson                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bForceThirdPerson                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AItemWeapon::UpdateVisibleAmmoContainer(class UClass* NewContainer, bool bForceFirstPerson, bool bForceThirdPerson)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemWeapon.UpdateVisibleAmmoContainer");
		
		AItemWeapon_UpdateVisibleAmmoContainer_Params params {};
		params.NewContainer = NewContainer;
		params.bForceFirstPerson = bForceFirstPerson;
		params.bForceThirdPerson = bForceThirdPerson;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056DDD00
	 * 		Name   -> Function Insurgency.ItemWeapon.UpdateUpgradeFallbackThirdPersonMeshes
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void AItemWeapon::UpdateUpgradeFallbackThirdPersonMeshes()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemWeapon.UpdateUpgradeFallbackThirdPersonMeshes");
		
		AItemWeapon_UpdateUpgradeFallbackThirdPersonMeshes_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056DDC80
	 * 		Name   -> Function Insurgency.ItemWeapon.UpdateUpgradeFallbackFirstPersonMeshes
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class USkeletalMeshComponent*                      ParentSkeletalMesh                                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AItemWeapon::UpdateUpgradeFallbackFirstPersonMeshes(class USkeletalMeshComponent* ParentSkeletalMesh)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemWeapon.UpdateUpgradeFallbackFirstPersonMeshes");
		
		AItemWeapon_UpdateUpgradeFallbackFirstPersonMeshes_Params params {};
		params.ParentSkeletalMesh = ParentSkeletalMesh;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> Function Insurgency.ItemWeapon.UpdateSocketName
	 * 		Flags  -> (Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure)
	 * Parameters:
	 * 		class FName                                        ParentSocket                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class FName AItemWeapon::UpdateSocketName(const class FName& ParentSocket)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemWeapon.UpdateSocketName");
		
		AItemWeapon_UpdateSocketName_Params params {};
		params.ParentSocket = ParentSocket;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056DDBF0
	 * 		Name   -> Function Insurgency.ItemWeapon.UpdateLoadedAmmo
	 * 		Flags  -> (Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		int32_t                                            NewLoadedAmmo                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AItemWeapon::UpdateLoadedAmmo(int32_t NewLoadedAmmo)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemWeapon.UpdateLoadedAmmo");
		
		AItemWeapon_UpdateLoadedAmmo_Params params {};
		params.NewLoadedAmmo = NewLoadedAmmo;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056DDB60
	 * 		Name   -> Function Insurgency.ItemWeapon.SpawnWeaponUpgrade
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UClass*                                      UpgradeClass                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UWeaponUpgradeComponent* AItemWeapon::SpawnWeaponUpgrade(class UClass* UpgradeClass)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemWeapon.SpawnWeaponUpgrade");
		
		AItemWeapon_SpawnWeaponUpgrade_Params params {};
		params.UpgradeClass = UpgradeClass;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056DDB30
	 * 		Name   -> Function Insurgency.ItemWeapon.ShouldRemoveOnUnequip
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AItemWeapon::ShouldRemoveOnUnequip()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemWeapon.ShouldRemoveOnUnequip");
		
		AItemWeapon_ShouldRemoveOnUnequip_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056DDAA0
	 * 		Name   -> Function Insurgency.ItemWeapon.SetChamberedRound
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bNewChamberedRound                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AItemWeapon::SetChamberedRound(bool bNewChamberedRound)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemWeapon.SetChamberedRound");
		
		AItemWeapon_SetChamberedRound_Params params {};
		params.bNewChamberedRound = bNewChamberedRound;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056DD910
	 * 		Name   -> Function Insurgency.ItemWeapon.ServerInformGenericMeleeHit
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
	 * Parameters:
	 * 		struct FHitResult                                  Hit                                                        (ConstParm, Parm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	void AItemWeapon::ServerInformGenericMeleeHit(const struct FHitResult& Hit)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemWeapon.ServerInformGenericMeleeHit");
		
		AItemWeapon_ServerInformGenericMeleeHit_Params params {};
		params.Hit = Hit;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056DD8C0
	 * 		Name   -> Function Insurgency.ItemWeapon.ServerDoGenericMeleeAttack
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
	 */
	void AItemWeapon::ServerDoGenericMeleeAttack()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemWeapon.ServerDoGenericMeleeAttack");
		
		AItemWeapon_ServerDoGenericMeleeAttack_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056DD870
	 * 		Name   -> Function Insurgency.ItemWeapon.ServerCheckEmpty
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
	 */
	void AItemWeapon::ServerCheckEmpty()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemWeapon.ServerCheckEmpty");
		
		AItemWeapon_ServerCheckEmpty_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056DDA50
	 * 		Name   -> Function Insurgency.ItemWeapon.Server_OnMeleeChargeEnd
	 * 		Flags  -> (Net, NetReliable, Native, Event, Protected, NetServer, NetValidate)
	 */
	void AItemWeapon::Server_OnMeleeChargeEnd()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemWeapon.Server_OnMeleeChargeEnd");
		
		AItemWeapon_Server_OnMeleeChargeEnd_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056DDA00
	 * 		Name   -> Function Insurgency.ItemWeapon.Server_OnMeleeChargeBegin
	 * 		Flags  -> (Net, NetReliable, Native, Event, Protected, NetServer, NetValidate)
	 */
	void AItemWeapon::Server_OnMeleeChargeBegin()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemWeapon.Server_OnMeleeChargeBegin");
		
		AItemWeapon_Server_OnMeleeChargeBegin_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056DD850
	 * 		Name   -> Function Insurgency.ItemWeapon.RemoveFirstPersonUpgradeMeshes
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void AItemWeapon::RemoveFirstPersonUpgradeMeshes()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemWeapon.RemoveFirstPersonUpgradeMeshes");
		
		AItemWeapon_RemoveFirstPersonUpgradeMeshes_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056DD830
	 * 		Name   -> Function Insurgency.ItemWeapon.RemoveFirstPersonAttachedMeshes
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void AItemWeapon::RemoveFirstPersonAttachedMeshes()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemWeapon.RemoveFirstPersonAttachedMeshes");
		
		AItemWeapon_RemoveFirstPersonAttachedMeshes_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x04DB4EE0
	 * 		Name   -> Function Insurgency.ItemWeapon.ReloadLoadAmmo
	 * 		Flags  -> (Native, Public, BlueprintCallable)
	 */
	void AItemWeapon::ReloadLoadAmmo()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemWeapon.ReloadLoadAmmo");
		
		AItemWeapon_ReloadLoadAmmo_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x04DB4160
	 * 		Name   -> Function Insurgency.ItemWeapon.PullBolt
	 * 		Flags  -> (Native, Public, BlueprintCallable)
	 */
	void AItemWeapon::PullBolt()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemWeapon.PullBolt");
		
		AItemWeapon_PullBolt_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056DD7F0
	 * 		Name   -> Function Insurgency.ItemWeapon.PeekPendingAmmoContainer
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	class UClass* AItemWeapon::PeekPendingAmmoContainer()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemWeapon.PeekPendingAmmoContainer");
		
		AItemWeapon_PeekPendingAmmoContainer_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056DD7D0
	 * 		Name   -> Function Insurgency.ItemWeapon.OnRep_PendingAmmoContainer
	 * 		Flags  -> (Final, Native, Public)
	 */
	void AItemWeapon::OnRep_PendingAmmoContainer()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemWeapon.OnRep_PendingAmmoContainer");
		
		AItemWeapon_OnRep_PendingAmmoContainer_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056DD7B0
	 * 		Name   -> Function Insurgency.ItemWeapon.OnRep_MountedComponent
	 * 		Flags  -> (Final, Native, Private)
	 */
	void AItemWeapon::OnRep_MountedComponent()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemWeapon.OnRep_MountedComponent");
		
		AItemWeapon_OnRep_MountedComponent_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00C76AB0
	 * 		Name   -> Function Insurgency.ItemWeapon.OnRep_MeleeCharging
	 * 		Flags  -> (Final, Native, Public)
	 */
	void AItemWeapon::OnRep_MeleeCharging()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemWeapon.OnRep_MeleeCharging");
		
		AItemWeapon_OnRep_MeleeCharging_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056DD790
	 * 		Name   -> Function Insurgency.ItemWeapon.OnRep_LoadedAmmoContainer
	 * 		Flags  -> (Final, Native, Public)
	 */
	void AItemWeapon::OnRep_LoadedAmmoContainer()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemWeapon.OnRep_LoadedAmmoContainer");
		
		AItemWeapon_OnRep_LoadedAmmoContainer_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x04DB3560
	 * 		Name   -> Function Insurgency.ItemWeapon.OnRep_LoadedAmmo
	 * 		Flags  -> (Native, Protected)
	 */
	void AItemWeapon::OnRep_LoadedAmmo()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemWeapon.OnRep_LoadedAmmo");
		
		AItemWeapon_OnRep_LoadedAmmo_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x04DB47C0
	 * 		Name   -> Function Insurgency.ItemWeapon.OnRep_ChamberedRound
	 * 		Flags  -> (Native, Protected)
	 */
	void AItemWeapon::OnRep_ChamberedRound()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemWeapon.OnRep_ChamberedRound");
		
		AItemWeapon_OnRep_ChamberedRound_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056DD770
	 * 		Name   -> Function Insurgency.ItemWeapon.OnRep_AttachedParent
	 * 		Flags  -> (Final, Native, Private)
	 */
	void AItemWeapon::OnRep_AttachedParent()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemWeapon.OnRep_AttachedParent");
		
		AItemWeapon_OnRep_AttachedParent_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> DelegateFunction Insurgency.ItemWeapon.OnGenericMeleeAttackDelegate__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 * Parameters:
	 * 		bool                                               bBash                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AItemWeapon::OnGenericMeleeAttackDelegate__DelegateSignature(bool bBash)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction Insurgency.ItemWeapon.OnGenericMeleeAttackDelegate__DelegateSignature");
		
		AItemWeapon_OnGenericMeleeAttackDelegate__DelegateSignature_Params params {};
		params.bBash = bBash;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056DD750
	 * 		Name   -> Function Insurgency.ItemWeapon.OnAmmoUpdated
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void AItemWeapon::OnAmmoUpdated()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemWeapon.OnAmmoUpdated");
		
		AItemWeapon_OnAmmoUpdated_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056DD720
	 * 		Name   -> Function Insurgency.ItemWeapon.NeedsBoltPull
	 * 		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AItemWeapon::NeedsBoltPull()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemWeapon.NeedsBoltPull");
		
		AItemWeapon_NeedsBoltPull_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056DD650
	 * 		Name   -> Function Insurgency.ItemWeapon.MountWeaponOnComponent
	 * 		Flags  -> (Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class USceneComponent*                             Component                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FName                                        SocketName                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AItemWeapon::MountWeaponOnComponent(class USceneComponent* Component, const class FName& SocketName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemWeapon.MountWeaponOnComponent");
		
		AItemWeapon_MountWeaponOnComponent_Params params {};
		params.Component = Component;
		params.SocketName = SocketName;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056DD620
	 * 		Name   -> Function Insurgency.ItemWeapon.MagazineCapacity
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	int32_t AItemWeapon::MagazineCapacity()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemWeapon.MagazineCapacity");
		
		AItemWeapon_MagazineCapacity_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056DD600
	 * 		Name   -> Function Insurgency.ItemWeapon.LoadAmmo
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void AItemWeapon::LoadAmmo()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemWeapon.LoadAmmo");
		
		AItemWeapon_LoadAmmo_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056DD5D0
	 * 		Name   -> Function Insurgency.ItemWeapon.IsWeaponHasMutualInclusionsUpgrades
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AItemWeapon::IsWeaponHasMutualInclusionsUpgrades()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemWeapon.IsWeaponHasMutualInclusionsUpgrades");
		
		AItemWeapon_IsWeaponHasMutualInclusionsUpgrades_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056DD5A0
	 * 		Name   -> Function Insurgency.ItemWeapon.IsWeaponFull
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AItemWeapon::IsWeaponFull()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemWeapon.IsWeaponFull");
		
		AItemWeapon_IsWeaponFull_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056DD510
	 * 		Name   -> Function Insurgency.ItemWeapon.IsWeaponAttachedTo
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		class AItemWeapon*                                 Other                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool AItemWeapon::IsWeaponAttachedTo(class AItemWeapon* Other)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemWeapon.IsWeaponAttachedTo");
		
		AItemWeapon_IsWeaponAttachedTo_Params params {};
		params.Other = Other;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056DD4E0
	 * 		Name   -> Function Insurgency.ItemWeapon.IsValidLoadedAmmo
	 * 		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AItemWeapon::IsValidLoadedAmmo()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemWeapon.IsValidLoadedAmmo");
		
		AItemWeapon_IsValidLoadedAmmo_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056DD4B0
	 * 		Name   -> Function Insurgency.ItemWeapon.IsSingleReload
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AItemWeapon::IsSingleReload()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemWeapon.IsSingleReload");
		
		AItemWeapon_IsSingleReload_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056DD480
	 * 		Name   -> Function Insurgency.ItemWeapon.IsOpenBolt
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AItemWeapon::IsOpenBolt()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemWeapon.IsOpenBolt");
		
		AItemWeapon_IsOpenBolt_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056DD450
	 * 		Name   -> Function Insurgency.ItemWeapon.IsMounted
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AItemWeapon::IsMounted()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemWeapon.IsMounted");
		
		AItemWeapon_IsMounted_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056DD420
	 * 		Name   -> Function Insurgency.ItemWeapon.IsAttackRestricted
	 * 		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AItemWeapon::IsAttackRestricted()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemWeapon.IsAttackRestricted");
		
		AItemWeapon_IsAttackRestricted_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056DD3F0
	 * 		Name   -> Function Insurgency.ItemWeapon.IsAttached
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AItemWeapon::IsAttached()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemWeapon.IsAttached");
		
		AItemWeapon_IsAttached_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056DD3C0
	 * 		Name   -> Function Insurgency.ItemWeapon.IsAtLargestMagazine
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AItemWeapon::IsAtLargestMagazine()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemWeapon.IsAtLargestMagazine");
		
		AItemWeapon_IsAtLargestMagazine_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056DD330
	 * 		Name   -> Function Insurgency.ItemWeapon.IsAmmoContainerSupported
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		class UClass*                                      AmmoType                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool AItemWeapon::IsAmmoContainerSupported(class UClass* AmmoType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemWeapon.IsAmmoContainerSupported");
		
		AItemWeapon_IsAmmoContainerSupported_Params params {};
		params.AmmoType = AmmoType;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056DD2B0
	 * 		Name   -> Function Insurgency.ItemWeapon.InteractUpgradeSlot
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		EWeaponUpgradeSlot                                 Slot                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AItemWeapon::InteractUpgradeSlot(EWeaponUpgradeSlot Slot)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemWeapon.InteractUpgradeSlot");
		
		AItemWeapon_InteractUpgradeSlot_Params params {};
		params.Slot = Slot;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056DD1F0
	 * 		Name   -> Function Insurgency.ItemWeapon.InGenericMeleeAttack
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AItemWeapon::InGenericMeleeAttack()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemWeapon.InGenericMeleeAttack");
		
		AItemWeapon_InGenericMeleeAttack_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056DD220
	 * 		Name   -> Function Insurgency.ItemWeapon.IncrementLoadedAmmo
	 * 		Flags  -> (Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		int32_t                                            AddedAmmo                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AItemWeapon::IncrementLoadedAmmo(int32_t AddedAmmo)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemWeapon.IncrementLoadedAmmo");
		
		AItemWeapon_IncrementLoadedAmmo_Params params {};
		params.AddedAmmo = AddedAmmo;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056DD1C0
	 * 		Name   -> Function Insurgency.ItemWeapon.HasVisibleMagazine
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AItemWeapon::HasVisibleMagazine()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemWeapon.HasVisibleMagazine");
		
		AItemWeapon_HasVisibleMagazine_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056DD130
	 * 		Name   -> Function Insurgency.ItemWeapon.HasUpgradeWithTag
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		class FName                                        Tag                                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool AItemWeapon::HasUpgradeWithTag(const class FName& Tag)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemWeapon.HasUpgradeWithTag");
		
		AItemWeapon_HasUpgradeWithTag_Params params {};
		params.Tag = Tag;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056DD0A0
	 * 		Name   -> Function Insurgency.ItemWeapon.HasUpgradeInSlot
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		EWeaponUpgradeSlot                                 Slot                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool AItemWeapon::HasUpgradeInSlot(EWeaponUpgradeSlot Slot)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemWeapon.HasUpgradeInSlot");
		
		AItemWeapon_HasUpgradeInSlot_Params params {};
		params.Slot = Slot;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056DD070
	 * 		Name   -> Function Insurgency.ItemWeapon.HasRoundInChamber
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AItemWeapon::HasRoundInChamber()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemWeapon.HasRoundInChamber");
		
		AItemWeapon_HasRoundInChamber_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> Function Insurgency.ItemWeapon.HasMovableUpgrade
	 * 		Flags  -> (Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure)
	 */
	bool AItemWeapon::HasMovableUpgrade()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemWeapon.HasMovableUpgrade");
		
		AItemWeapon_HasMovableUpgrade_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056DD040
	 * 		Name   -> Function Insurgency.ItemWeapon.HasLoadedAmmo
	 * 		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AItemWeapon::HasLoadedAmmo()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemWeapon.HasLoadedAmmo");
		
		AItemWeapon_HasLoadedAmmo_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056DD010
	 * 		Name   -> Function Insurgency.ItemWeapon.HasAttachedMagazine
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AItemWeapon::HasAttachedMagazine()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemWeapon.HasAttachedMagazine");
		
		AItemWeapon_HasAttachedMagazine_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x04DB5C90
	 * 		Name   -> Function Insurgency.ItemWeapon.GiveDefaultAmmo
	 * 		Flags  -> (Native, Public, BlueprintCallable)
	 */
	void AItemWeapon::GiveDefaultAmmo()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemWeapon.GiveDefaultAmmo");
		
		AItemWeapon_GiveDefaultAmmo_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056DCF80
	 * 		Name   -> Function Insurgency.ItemWeapon.GetUpgradeInSlot
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		EWeaponUpgradeSlot                                 Slot                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UWeaponUpgradeComponent* AItemWeapon::GetUpgradeInSlot(EWeaponUpgradeSlot Slot)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemWeapon.GetUpgradeInSlot");
		
		AItemWeapon_GetUpgradeInSlot_Params params {};
		params.Slot = Slot;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056DCF50
	 * 		Name   -> Function Insurgency.ItemWeapon.GetReserveAmmo
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	int32_t AItemWeapon::GetReserveAmmo()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemWeapon.GetReserveAmmo");
		
		AItemWeapon_GetReserveAmmo_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056DCF20
	 * 		Name   -> Function Insurgency.ItemWeapon.GetPendingAmmoContainer
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	class UAmmoContainer* AItemWeapon::GetPendingAmmoContainer()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemWeapon.GetPendingAmmoContainer");
		
		AItemWeapon_GetPendingAmmoContainer_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056DCEF0
	 * 		Name   -> Function Insurgency.ItemWeapon.GetNextMagazineSize
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	int32_t AItemWeapon::GetNextMagazineSize()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemWeapon.GetNextMagazineSize");
		
		AItemWeapon_GetNextMagazineSize_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056DCDA0
	 * 		Name   -> Function Insurgency.ItemWeapon.GetMutualInclusionsUpgrades
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		class UClass*                                      Upgrade                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AItemWeapon::GetMutualInclusionsUpgrades(class UClass* Upgrade)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemWeapon.GetMutualInclusionsUpgrades");
		
		AItemWeapon_GetMutualInclusionsUpgrades_Params params {};
		params.Upgrade = Upgrade;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> Function Insurgency.ItemWeapon.GetMovableUpgrade
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 */
	class UWeaponUpgradeComponent* AItemWeapon::GetMovableUpgrade()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemWeapon.GetMovableUpgrade");
		
		AItemWeapon_GetMovableUpgrade_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056DCD80
	 * 		Name   -> Function Insurgency.ItemWeapon.GetMountedComponent
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	class USceneComponent* AItemWeapon::GetMountedComponent()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemWeapon.GetMountedComponent");
		
		AItemWeapon_GetMountedComponent_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056DCD50
	 * 		Name   -> Function Insurgency.ItemWeapon.GetLoadedAmmoType
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	class UAmmoType* AItemWeapon::GetLoadedAmmoType()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemWeapon.GetLoadedAmmoType");
		
		AItemWeapon_GetLoadedAmmoType_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056DCD20
	 * 		Name   -> Function Insurgency.ItemWeapon.GetLoadedAmmoFrac
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	float AItemWeapon::GetLoadedAmmoFrac()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemWeapon.GetLoadedAmmoFrac");
		
		AItemWeapon_GetLoadedAmmoFrac_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056DCCF0
	 * 		Name   -> Function Insurgency.ItemWeapon.GetLoadedAmmoContainer
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	class UAmmoContainer* AItemWeapon::GetLoadedAmmoContainer()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemWeapon.GetLoadedAmmoContainer");
		
		AItemWeapon_GetLoadedAmmoContainer_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056DCCC0
	 * 		Name   -> Function Insurgency.ItemWeapon.GetLoadedAmmo
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	int32_t AItemWeapon::GetLoadedAmmo()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemWeapon.GetLoadedAmmo");
		
		AItemWeapon_GetLoadedAmmo_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056DCC90
	 * 		Name   -> Function Insurgency.ItemWeapon.GetLargestMagazine
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	int32_t AItemWeapon::GetLargestMagazine()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemWeapon.GetLargestMagazine");
		
		AItemWeapon_GetLargestMagazine_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056DCC60
	 * 		Name   -> Function Insurgency.ItemWeapon.GetEquippedUpgradeSlotsMask
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	int32_t AItemWeapon::GetEquippedUpgradeSlotsMask()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemWeapon.GetEquippedUpgradeSlotsMask");
		
		AItemWeapon_GetEquippedUpgradeSlotsMask_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056DCC20
	 * 		Name   -> Function Insurgency.ItemWeapon.GetDefaultAmmoType
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	class UClass* AItemWeapon::GetDefaultAmmoType()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemWeapon.GetDefaultAmmoType");
		
		AItemWeapon_GetDefaultAmmoType_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056DCBE0
	 * 		Name   -> Function Insurgency.ItemWeapon.GetDefaultAmmoContainerType
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	class UClass* AItemWeapon::GetDefaultAmmoContainerType()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemWeapon.GetDefaultAmmoContainerType");
		
		AItemWeapon_GetDefaultAmmoContainerType_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056DCB00
	 * 		Name   -> Function Insurgency.ItemWeapon.GetCompatibleAmmo
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		TArray<struct FStoredAmmo>                         Ammo                                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	int32_t AItemWeapon::GetCompatibleAmmo(TArray<struct FStoredAmmo> Ammo)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemWeapon.GetCompatibleAmmo");
		
		AItemWeapon_GetCompatibleAmmo_Params params {};
		params.Ammo = Ammo;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056DCAE0
	 * 		Name   -> Function Insurgency.ItemWeapon.GenericMeleeAttack
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void AItemWeapon::GenericMeleeAttack()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemWeapon.GenericMeleeAttack");
		
		AItemWeapon_GenericMeleeAttack_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056DCA50
	 * 		Name   -> Function Insurgency.ItemWeapon.EquipMountedWeapon
	 * 		Flags  -> (Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class AINSCharacter*                               Character                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AItemWeapon::EquipMountedWeapon(class AINSCharacter* Character)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemWeapon.EquipMountedWeapon");
		
		AItemWeapon_EquipMountedWeapon_Params params {};
		params.Character = Character;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056DCA30
	 * 		Name   -> Function Insurgency.ItemWeapon.DoGenericMeleeAttack
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void AItemWeapon::DoGenericMeleeAttack()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemWeapon.DoGenericMeleeAttack");
		
		AItemWeapon_DoGenericMeleeAttack_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056DC9A0
	 * 		Name   -> Function Insurgency.ItemWeapon.DestroyVisibleAmmoContainerMesh
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bFirstPerson                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AItemWeapon::DestroyVisibleAmmoContainerMesh(bool bFirstPerson)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemWeapon.DestroyVisibleAmmoContainerMesh");
		
		AItemWeapon_DestroyVisibleAmmoContainerMesh_Params params {};
		params.bFirstPerson = bFirstPerson;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056DC910
	 * 		Name   -> Function Insurgency.ItemWeapon.DecrementAmmo
	 * 		Flags  -> (Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		int32_t                                            Amount                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AItemWeapon::DecrementAmmo(int32_t Amount)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemWeapon.DecrementAmmo");
		
		AItemWeapon_DecrementAmmo_Params params {};
		params.Amount = Amount;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056DC8E0
	 * 		Name   -> Function Insurgency.ItemWeapon.ConsumesAmmo
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AItemWeapon::ConsumesAmmo()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemWeapon.ConsumesAmmo");
		
		AItemWeapon_ConsumesAmmo_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x04DB4B20
	 * 		Name   -> Function Insurgency.ItemWeapon.CheckEmpty
	 * 		Flags  -> (Native, Public, BlueprintCallable)
	 */
	void AItemWeapon::CheckEmpty()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemWeapon.CheckEmpty");
		
		AItemWeapon_CheckEmpty_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x04DB4A80
	 * 		Name   -> Function Insurgency.ItemWeapon.ChamberRound
	 * 		Flags  -> (Native, Public, BlueprintCallable)
	 */
	void AItemWeapon::ChamberRound()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemWeapon.ChamberRound");
		
		AItemWeapon_ChamberRound_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05684440
	 * 		Name   -> Function Insurgency.ItemWeapon.CanGenericMeleeAttack
	 * 		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AItemWeapon::CanGenericMeleeAttack()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemWeapon.CanGenericMeleeAttack");
		
		AItemWeapon_CanGenericMeleeAttack_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> DelegateFunction Insurgency.ItemWeapon.CalcShotOriginDelegate__DelegateSignature
	 * 		Flags  -> (Public, Delegate, HasOutParms, HasDefaults)
	 * Parameters:
	 * 		struct FVector                                     OutShotOrigin                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AItemWeapon::CalcShotOriginDelegate__DelegateSignature(struct FVector* OutShotOrigin)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction Insurgency.ItemWeapon.CalcShotOriginDelegate__DelegateSignature");
		
		AItemWeapon_CalcShotOriginDelegate__DelegateSignature_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutShotOrigin != nullptr)
			*OutShotOrigin = params.OutShotOrigin;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> DelegateFunction Insurgency.ItemWeapon.CalcShotDirectionDelegate__DelegateSignature
	 * 		Flags  -> (Public, Delegate, HasOutParms, HasDefaults)
	 * Parameters:
	 * 		struct FVector                                     OutShotDirection                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AItemWeapon::CalcShotDirectionDelegate__DelegateSignature(struct FVector* OutShotDirection)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction Insurgency.ItemWeapon.CalcShotDirectionDelegate__DelegateSignature");
		
		AItemWeapon_CalcShotDirectionDelegate__DelegateSignature_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutShotDirection != nullptr)
			*OutShotDirection = params.OutShotDirection;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056DC7F0
	 * 		Name   -> Function Insurgency.ItemWeapon.CalcShootVectors
	 * 		Flags  -> (Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FVector                                     OutShootPosition                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     OutShootDirection                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AItemWeapon::CalcShootVectors(struct FVector* OutShootPosition, struct FVector* OutShootDirection)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemWeapon.CalcShootVectors");
		
		AItemWeapon_CalcShootVectors_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutShootPosition != nullptr)
			*OutShootPosition = params.OutShootPosition;
		if (OutShootDirection != nullptr)
			*OutShootDirection = params.OutShootDirection;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056DC700
	 * 		Name   -> Function Insurgency.ItemWeapon.CalcShootOffset
	 * 		Flags  -> (Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FVector                                     Location                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FRotator                                    Rotation                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void AItemWeapon::CalcShootOffset(struct FVector* Location, struct FRotator* Rotation)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemWeapon.CalcShootOffset");
		
		AItemWeapon_CalcShootOffset_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (Location != nullptr)
			*Location = params.Location;
		if (Rotation != nullptr)
			*Rotation = params.Rotation;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056DC640
	 * 		Name   -> Function Insurgency.ItemWeapon.BroadcastGenericMeleeHit
	 * 		Flags  -> (Net, Native, Event, NetMulticast, Public)
	 * Parameters:
	 * 		struct FHitResult                                  Hit                                                        (ConstParm, Parm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	void AItemWeapon::BroadcastGenericMeleeHit(const struct FHitResult& Hit)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemWeapon.BroadcastGenericMeleeHit");
		
		AItemWeapon_BroadcastGenericMeleeHit_Params params {};
		params.Hit = Hit;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056DC620
	 * 		Name   -> Function Insurgency.ItemWeapon.BroadcastDoGenericMeleeAttack
	 * 		Flags  -> (Net, Native, Event, NetMulticast, Public)
	 */
	void AItemWeapon::BroadcastDoGenericMeleeAttack()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemWeapon.BroadcastDoGenericMeleeAttack");
		
		AItemWeapon_BroadcastDoGenericMeleeAttack_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> Function Insurgency.ItemWeapon.BlueprintOnUpdateVisibleAmmoContainer
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		bool                                               bVisible                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AItemWeapon::BlueprintOnUpdateVisibleAmmoContainer(bool bVisible)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemWeapon.BlueprintOnUpdateVisibleAmmoContainer");
		
		AItemWeapon_BlueprintOnUpdateVisibleAmmoContainer_Params params {};
		params.bVisible = bVisible;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056DC600
	 * 		Name   -> Function Insurgency.ItemWeapon.BeginGenericMeleeAttack
	 * 		Flags  -> (Final, Native, Public)
	 */
	void AItemWeapon::BeginGenericMeleeAttack()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemWeapon.BeginGenericMeleeAttack");
		
		AItemWeapon_BeginGenericMeleeAttack_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056DC4A0
	 * 		Name   -> Function Insurgency.ItemWeapon.AddChildMesh
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		struct FWeaponAttachedModel                        AttachedModel                                              (Parm, OutParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 * 		class USkeletalMeshComponent*                      ParentMeshComponent                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bIsFirstPerson                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AItemWeapon::AddChildMesh(struct FWeaponAttachedModel* AttachedModel, class USkeletalMeshComponent* ParentMeshComponent, bool bIsFirstPerson)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemWeapon.AddChildMesh");
		
		AItemWeapon_AddChildMesh_Params params {};
		params.ParentMeshComponent = ParentMeshComponent;
		params.bIsFirstPerson = bIsFirstPerson;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (AttachedModel != nullptr)
			*AttachedModel = params.AttachedModel;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AItemWeapon.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AItemWeapon::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.ItemWeapon");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056CA270
	 * 		Name   -> Function Insurgency.ItemAimableWeapon.ToggleSights
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void AItemAimableWeapon::ToggleSights()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemAimableWeapon.ToggleSights");
		
		AItemAimableWeapon_ToggleSights_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056CA240
	 * 		Name   -> Function Insurgency.ItemAimableWeapon.ShouldEnterPointShootMode
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AItemAimableWeapon::ShouldEnterPointShootMode()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemAimableWeapon.ShouldEnterPointShootMode");
		
		AItemAimableWeapon_ShouldEnterPointShootMode_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056CA170
	 * 		Name   -> Function Insurgency.ItemAimableWeapon.SetSights
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bNewAimingDownSights                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bFromReplication                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AItemAimableWeapon::SetSights(bool bNewAimingDownSights, bool bFromReplication)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemAimableWeapon.SetSights");
		
		AItemAimableWeapon_SetSights_Params params {};
		params.bNewAimingDownSights = bNewAimingDownSights;
		params.bFromReplication = bFromReplication;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056CA0C0
	 * 		Name   -> Function Insurgency.ItemAimableWeapon.ServerSetSights
	 * 		Flags  -> (Net, NetReliable, Native, Event, Protected, NetServer, NetValidate)
	 * Parameters:
	 * 		bool                                               bNewAimingDownSights                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AItemAimableWeapon::ServerSetSights(bool bNewAimingDownSights)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemAimableWeapon.ServerSetSights");
		
		AItemAimableWeapon_ServerSetSights_Params params {};
		params.bNewAimingDownSights = bNewAimingDownSights;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056CA0A0
	 * 		Name   -> Function Insurgency.ItemAimableWeapon.OnRep_AimingDownSights
	 * 		Flags  -> (Final, Native, Protected)
	 */
	void AItemAimableWeapon::OnRep_AimingDownSights()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemAimableWeapon.OnRep_AimingDownSights");
		
		AItemAimableWeapon_OnRep_AimingDownSights_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056CA070
	 * 		Name   -> Function Insurgency.ItemAimableWeapon.IsRaisingOrLoweringSights
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AItemAimableWeapon::IsRaisingOrLoweringSights()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemAimableWeapon.IsRaisingOrLoweringSights");
		
		AItemAimableWeapon_IsRaisingOrLoweringSights_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056CA040
	 * 		Name   -> Function Insurgency.ItemAimableWeapon.IsFullySighted
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AItemAimableWeapon::IsFullySighted()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemAimableWeapon.IsFullySighted");
		
		AItemAimableWeapon_IsFullySighted_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056CA010
	 * 		Name   -> Function Insurgency.ItemAimableWeapon.IsAimingDownSights
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AItemAimableWeapon::IsAimingDownSights()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemAimableWeapon.IsAimingDownSights");
		
		AItemAimableWeapon_IsAimingDownSights_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056C9FE0
	 * 		Name   -> Function Insurgency.ItemAimableWeapon.IsAimingDownScope
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AItemAimableWeapon::IsAimingDownScope()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemAimableWeapon.IsAimingDownScope");
		
		AItemAimableWeapon_IsAimingDownScope_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056C9FB0
	 * 		Name   -> Function Insurgency.ItemAimableWeapon.GetZoomProgress
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	float AItemAimableWeapon::GetZoomProgress()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemAimableWeapon.GetZoomProgress");
		
		AItemAimableWeapon_GetZoomProgress_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056C9FB0
	 * 		Name   -> Function Insurgency.ItemAimableWeapon.GetCachedSightsFraction
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	float AItemAimableWeapon::GetCachedSightsFraction()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemAimableWeapon.GetCachedSightsFraction");
		
		AItemAimableWeapon_GetCachedSightsFraction_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056C9F90
	 * 		Name   -> Function Insurgency.ItemAimableWeapon.ExitSights
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void AItemAimableWeapon::ExitSights()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemAimableWeapon.ExitSights");
		
		AItemAimableWeapon_ExitSights_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056C9F70
	 * 		Name   -> Function Insurgency.ItemAimableWeapon.EnterSights
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void AItemAimableWeapon::EnterSights()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemAimableWeapon.EnterSights");
		
		AItemAimableWeapon_EnterSights_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056C9F40
	 * 		Name   -> Function Insurgency.ItemAimableWeapon.CanAimDownSights
	 * 		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AItemAimableWeapon::CanAimDownSights()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemAimableWeapon.CanAimDownSights");
		
		AItemAimableWeapon_CanAimDownSights_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056C9F10
	 * 		Name   -> Function Insurgency.ItemAimableWeapon.CalcSightsFraction
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
	 */
	float AItemAimableWeapon::CalcSightsFraction()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemAimableWeapon.CalcSightsFraction");
		
		AItemAimableWeapon_CalcSightsFraction_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> Function Insurgency.ItemAimableWeapon.BlueprintOnToggleSights
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		bool                                               bNewAimingDownSights                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bFromReplication                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AItemAimableWeapon::BlueprintOnToggleSights(bool bNewAimingDownSights, bool bFromReplication)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemAimableWeapon.BlueprintOnToggleSights");
		
		AItemAimableWeapon_BlueprintOnToggleSights_Params params {};
		params.bNewAimingDownSights = bNewAimingDownSights;
		params.bFromReplication = bFromReplication;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056C9EE0
	 * 		Name   -> Function Insurgency.ItemAimableWeapon.AllowSightsChange
	 * 		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AItemAimableWeapon::AllowSightsChange()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemAimableWeapon.AllowSightsChange");
		
		AItemAimableWeapon_AllowSightsChange_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AItemAimableWeapon.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AItemAimableWeapon::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.ItemAimableWeapon");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056D88D0
	 * 		Name   -> Function Insurgency.ItemPickup.ResetPickup
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void AItemPickup::ResetPickup()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemPickup.ResetPickup");
		
		AItemPickup_ResetPickup_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056D88B0
	 * 		Name   -> Function Insurgency.ItemPickup.OnSetItemClass
	 * 		Flags  -> (Final, Native, Protected)
	 */
	void AItemPickup::OnSetItemClass()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemPickup.OnSetItemClass");
		
		AItemPickup_OnSetItemClass_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056D8890
	 * 		Name   -> Function Insurgency.ItemPickup.OnRep_Upgrades
	 * 		Flags  -> (Final, Native, Protected)
	 */
	void AItemPickup::OnRep_Upgrades()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemPickup.OnRep_Upgrades");
		
		AItemPickup_OnRep_Upgrades_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056D8890
	 * 		Name   -> Function Insurgency.ItemPickup.OnRep_ItemClass
	 * 		Flags  -> (Final, Native, Protected)
	 */
	void AItemPickup::OnRep_ItemClass()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemPickup.OnRep_ItemClass");
		
		AItemPickup_OnRep_ItemClass_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056D8870
	 * 		Name   -> Function Insurgency.ItemPickup.OnRep_Disabled
	 * 		Flags  -> (Final, Native, Private)
	 */
	void AItemPickup::OnRep_Disabled()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemPickup.OnRep_Disabled");
		
		AItemPickup_OnRep_Disabled_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x04EC2B30
	 * 		Name   -> Function Insurgency.ItemPickup.OnPickupEnabledOrDisabled
	 * 		Flags  -> (Native, Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		bool                                               bNewIsDisabled                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AItemPickup::OnPickupEnabledOrDisabled(bool bNewIsDisabled)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemPickup.OnPickupEnabledOrDisabled");
		
		AItemPickup_OnPickupEnabledOrDisabled_Params params {};
		params.bNewIsDisabled = bNewIsDisabled;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056D87B0
	 * 		Name   -> Function Insurgency.ItemPickup.OnLinkedObjectiveActivated
	 * 		Flags  -> (Final, Native, Private)
	 * Parameters:
	 * 		bool                                               bNewState                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AObjectiveBase*                              Objective                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AItemPickup::OnLinkedObjectiveActivated(bool bNewState, class AObjectiveBase* Objective)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemPickup.OnLinkedObjectiveActivated");
		
		AItemPickup_OnLinkedObjectiveActivated_Params params {};
		params.bNewState = bNewState;
		params.Objective = Objective;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056D8790
	 * 		Name   -> Function Insurgency.ItemPickup.OnItemClassChanged
	 * 		Flags  -> (Final, Native, Protected)
	 */
	void AItemPickup::OnItemClassChanged()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemPickup.OnItemClassChanged");
		
		AItemPickup_OnItemClassChanged_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056D8700
	 * 		Name   -> Function Insurgency.ItemPickup.Multicast_SetDisabled
	 * 		Flags  -> (Final, Net, NetReliable, Native, Event, NetMulticast, Private)
	 * Parameters:
	 * 		bool                                               IsDisabled                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AItemPickup::Multicast_SetDisabled(bool IsDisabled)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemPickup.Multicast_SetDisabled");
		
		AItemPickup_Multicast_SetDisabled_Params params {};
		params.IsDisabled = IsDisabled;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00CBA850
	 * 		Name   -> Function Insurgency.ItemPickup.Multicast_PlayPickupEvent
	 * 		Flags  -> (Net, NetReliable, Native, Event, NetMulticast, Public)
	 */
	void AItemPickup::Multicast_PlayPickupEvent()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemPickup.Multicast_PlayPickupEvent");
		
		AItemPickup_Multicast_PlayPickupEvent_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> DelegateFunction Insurgency.ItemPickup.ItemPickupDelegate__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 * Parameters:
	 * 		class AItemEquipable*                              PickedUpItem                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AINSSoldier*                                 Soldier                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AItemPickup::ItemPickupDelegate__DelegateSignature(class AItemEquipable* PickedUpItem, class AINSSoldier* Soldier)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction Insurgency.ItemPickup.ItemPickupDelegate__DelegateSignature");
		
		AItemPickup_ItemPickupDelegate__DelegateSignature_Params params {};
		params.PickedUpItem = PickedUpItem;
		params.Soldier = Soldier;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056D86D0
	 * 		Name   -> Function Insurgency.ItemPickup.IsPickupDisabled
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AItemPickup::IsPickupDisabled()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemPickup.IsPickupDisabled");
		
		AItemPickup_IsPickupDisabled_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056D86B0
	 * 		Name   -> Function Insurgency.ItemPickup.EnablePickup
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void AItemPickup::EnablePickup()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemPickup.EnablePickup");
		
		AItemPickup_EnablePickup_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056D8630
	 * 		Name   -> Function Insurgency.ItemPickup.DisablePickup
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		float                                              PickupTimer                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AItemPickup::DisablePickup(float PickupTimer)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemPickup.DisablePickup");
		
		AItemPickup_DisablePickup_Params params {};
		params.PickupTimer = PickupTimer;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> DelegateFunction Insurgency.ItemPickup.ClearAmmoDelegate__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 * Parameters:
	 * 		class AItemEquipable*                              PickedUpItem                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AINSSoldier*                                 Soldier                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AItemPickup::ClearAmmoDelegate__DelegateSignature(class AItemEquipable* PickedUpItem, class AINSSoldier* Soldier)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction Insurgency.ItemPickup.ClearAmmoDelegate__DelegateSignature");
		
		AItemPickup_ClearAmmoDelegate__DelegateSignature_Params params {};
		params.PickedUpItem = PickedUpItem;
		params.Soldier = Soldier;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AItemPickup.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AItemPickup::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.ItemPickup");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AItemAmmoPickup.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AItemAmmoPickup::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.ItemAmmoPickup");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056D4B40
	 * 		Name   -> Function Insurgency.ItemGear.ShouldSpawnAttachmentMesh
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		class FName                                        AttachmentSocket                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool AItemGear::ShouldSpawnAttachmentMesh(const class FName& AttachmentSocket)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemGear.ShouldSpawnAttachmentMesh");
		
		AItemGear_ShouldSpawnAttachmentMesh_Params params {};
		params.AttachmentSocket = AttachmentSocket;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056D4B20
	 * 		Name   -> Function Insurgency.ItemGear.Interact
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void AItemGear::Interact()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemGear.Interact");
		
		AItemGear_Interact_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> Function Insurgency.ItemGear.BlueprintOnTransferToRagdoll
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		class ARagdoll*                                    Ragdoll                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AItemGear::BlueprintOnTransferToRagdoll(class ARagdoll* Ragdoll)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemGear.BlueprintOnTransferToRagdoll");
		
		AItemGear_BlueprintOnTransferToRagdoll_Params params {};
		params.Ragdoll = Ragdoll;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AItemGear.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AItemGear::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.ItemGear");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056CB160
	 * 		Name   -> Function Insurgency.ItemAmmoVest.UpdatePreviewVisuals
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bPreviewFemale                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EItemGearLevel                                     PreviewArmorLevel                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AItemAmmoVest::UpdatePreviewVisuals(bool bPreviewFemale, EItemGearLevel PreviewArmorLevel)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemAmmoVest.UpdatePreviewVisuals");
		
		AItemAmmoVest_UpdatePreviewVisuals_Params params {};
		params.bPreviewFemale = bPreviewFemale;
		params.PreviewArmorLevel = PreviewArmorLevel;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056CB000
	 * 		Name   -> Function Insurgency.ItemAmmoVest.UpdateEquipmentVisualsInternal
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bForce                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bProfile                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UInventoryComponent*                         Inventory                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bDontRunOnProfile                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AItemAmmoVest::UpdateEquipmentVisualsInternal(bool bForce, bool bProfile, class UInventoryComponent* Inventory, bool bDontRunOnProfile)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemAmmoVest.UpdateEquipmentVisualsInternal");
		
		AItemAmmoVest_UpdateEquipmentVisualsInternal_Params params {};
		params.bForce = bForce;
		params.bProfile = bProfile;
		params.Inventory = Inventory;
		params.bDontRunOnProfile = bDontRunOnProfile;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> Function Insurgency.ItemAmmoVest.UpdateEquipmentVisuals
	 * 		Flags  -> (Event, Public, BlueprintCallable, BlueprintEvent)
	 * Parameters:
	 * 		bool                                               bForce                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bProfile                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UInventoryComponent*                         Inventory                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AItemAmmoVest::UpdateEquipmentVisuals(bool bForce, bool bProfile, class UInventoryComponent* Inventory)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemAmmoVest.UpdateEquipmentVisuals");
		
		AItemAmmoVest_UpdateEquipmentVisuals_Params params {};
		params.bForce = bForce;
		params.bProfile = bProfile;
		params.Inventory = Inventory;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x04DB41A0
	 * 		Name   -> Function Insurgency.ItemAmmoVest.UpdateEquipmentChangeInterface
	 * 		Flags  -> (Native, Event, Public, BlueprintEvent)
	 */
	void AItemAmmoVest::UpdateEquipmentChangeInterface()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemAmmoVest.UpdateEquipmentChangeInterface");
		
		AItemAmmoVest_UpdateEquipmentChangeInterface_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056CAF80
	 * 		Name   -> Function Insurgency.ItemAmmoVest.SetCarrierCosmetic
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UCosmeticItem*                               NewCarrierCosmetic                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AItemAmmoVest::SetCarrierCosmetic(class UCosmeticItem* NewCarrierCosmetic)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemAmmoVest.SetCarrierCosmetic");
		
		AItemAmmoVest_SetCarrierCosmetic_Params params {};
		params.NewCarrierCosmetic = NewCarrierCosmetic;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> Function Insurgency.ItemAmmoVest.SetCarrierArmourCombination
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		EItemGearLevel                                     Item                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AItemAmmoVest::SetCarrierArmourCombination(EItemGearLevel Item)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemAmmoVest.SetCarrierArmourCombination");
		
		AItemAmmoVest_SetCarrierArmourCombination_Params params {};
		params.Item = Item;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056CAF00
	 * 		Name   -> Function Insurgency.ItemAmmoVest.SetBackpackCosmetic
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UCosmeticItem*                               NewBackPackCosmetic                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AItemAmmoVest::SetBackpackCosmetic(class UCosmeticItem* NewBackPackCosmetic)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemAmmoVest.SetBackpackCosmetic");
		
		AItemAmmoVest_SetBackpackCosmetic_Params params {};
		params.NewBackPackCosmetic = NewBackPackCosmetic;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> Function Insurgency.ItemAmmoVest.OnUpdateCosmeticMeshesMorphs
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		bool                                               bProfile                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AItemAmmoVest::OnUpdateCosmeticMeshesMorphs(bool bProfile)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemAmmoVest.OnUpdateCosmeticMeshesMorphs");
		
		AItemAmmoVest_OnUpdateCosmeticMeshesMorphs_Params params {};
		params.bProfile = bProfile;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> Function Insurgency.ItemAmmoVest.OnUpdateCharacterAnimInstance
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		bool                                               bProfile                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AItemAmmoVest::OnUpdateCharacterAnimInstance(bool bProfile)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemAmmoVest.OnUpdateCharacterAnimInstance");
		
		AItemAmmoVest_OnUpdateCharacterAnimInstance_Params params {};
		params.bProfile = bProfile;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056CAEE0
	 * 		Name   -> Function Insurgency.ItemAmmoVest.OnSettingsChanged
	 * 		Flags  -> (Final, Native, Private)
	 */
	void AItemAmmoVest::OnSettingsChanged()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemAmmoVest.OnSettingsChanged");
		
		AItemAmmoVest_OnSettingsChanged_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056CAE60
	 * 		Name   -> Function Insurgency.ItemAmmoVest.OnMeshLoaded
	 * 		Flags  -> (Final, Native, Private)
	 * Parameters:
	 * 		class UINSSkeletalMeshComponent*                   INSSkeletalMeshComponent                                   (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AItemAmmoVest::OnMeshLoaded(class UINSSkeletalMeshComponent* INSSkeletalMeshComponent)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemAmmoVest.OnMeshLoaded");
		
		AItemAmmoVest_OnMeshLoaded_Params params {};
		params.INSSkeletalMeshComponent = INSSkeletalMeshComponent;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056CAE40
	 * 		Name   -> Function Insurgency.ItemAmmoVest.OnMergedMesh
	 * 		Flags  -> (Final, Native, Private)
	 */
	void AItemAmmoVest::OnMergedMesh()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemAmmoVest.OnMergedMesh");
		
		AItemAmmoVest_OnMergedMesh_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056CADC0
	 * 		Name   -> Function Insurgency.ItemAmmoVest.OnExitVehicle
	 * 		Flags  -> (Final, Native, Private)
	 * Parameters:
	 * 		class UVehicleSeatComponent*                       VehicleSeat                                                (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AItemAmmoVest::OnExitVehicle(class UVehicleSeatComponent* VehicleSeat)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemAmmoVest.OnExitVehicle");
		
		AItemAmmoVest_OnExitVehicle_Params params {};
		params.VehicleSeat = VehicleSeat;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056CAD40
	 * 		Name   -> Function Insurgency.ItemAmmoVest.OnEnteredVehicle
	 * 		Flags  -> (Final, Native, Private)
	 * Parameters:
	 * 		class UVehicleSeatComponent*                       VehicleSeat                                                (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AItemAmmoVest::OnEnteredVehicle(class UVehicleSeatComponent* VehicleSeat)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemAmmoVest.OnEnteredVehicle");
		
		AItemAmmoVest_OnEnteredVehicle_Params params {};
		params.VehicleSeat = VehicleSeat;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056CACC0
	 * 		Name   -> Function Insurgency.ItemAmmoVest.OnAttachMeshToPawn
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UINSSkeletalMeshComponent*                   Mesh                                                       (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AItemAmmoVest::OnAttachMeshToPawn(class UINSSkeletalMeshComponent* Mesh)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemAmmoVest.OnAttachMeshToPawn");
		
		AItemAmmoVest_OnAttachMeshToPawn_Params params {};
		params.Mesh = Mesh;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> Function Insurgency.ItemAmmoVest.GetSkeletalMesh3P
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		EItemGearLevel                                     Item                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AItemAmmoVest::GetSkeletalMesh3P(EItemGearLevel Item)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemAmmoVest.GetSkeletalMesh3P");
		
		AItemAmmoVest_GetSkeletalMesh3P_Params params {};
		params.Item = Item;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> Function Insurgency.ItemAmmoVest.GetCurrentArmourLevel
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 */
	EItemGearLevel AItemAmmoVest::GetCurrentArmourLevel()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemAmmoVest.GetCurrentArmourLevel");
		
		AItemAmmoVest_GetCurrentArmourLevel_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056CAC30
	 * 		Name   -> Function Insurgency.ItemAmmoVest.GetAdditionalAmmoForWeapon
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		class AItemWeapon*                                 Weapon                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	int32_t AItemAmmoVest::GetAdditionalAmmoForWeapon(class AItemWeapon* Weapon)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemAmmoVest.GetAdditionalAmmoForWeapon");
		
		AItemAmmoVest_GetAdditionalAmmoForWeapon_Params params {};
		params.Weapon = Weapon;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AItemAmmoVest.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AItemAmmoVest::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.ItemAmmoVest");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AItemArmor.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AItemArmor::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.ItemArmor");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056CC670
	 * 		Name   -> Function Insurgency.ItemBinocular.GetAimRotationOffset
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	float AItemBinocular::GetAimRotationOffset()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemBinocular.GetAimRotationOffset");
		
		AItemBinocular_GetAimRotationOffset_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AItemBinocular.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AItemBinocular::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.ItemBinocular");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056CCAA0
	 * 		Name   -> Function Insurgency.ItemDetonator.ServerDetonate
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
	 */
	void AItemDetonator::ServerDetonate()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemDetonator.ServerDetonate");
		
		AItemDetonator_ServerDetonate_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> DelegateFunction Insurgency.ItemDetonator.OnDetonatorUsedDelegate__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 */
	void AItemDetonator::OnDetonatorUsedDelegate__DelegateSignature()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction Insurgency.ItemDetonator.OnDetonatorUsedDelegate__DelegateSignature");
		
		AItemDetonator_OnDetonatorUsedDelegate__DelegateSignature_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x04DB52E0
	 * 		Name   -> Function Insurgency.ItemDetonator.MulticastDetonate
	 * 		Flags  -> (Net, Native, Event, NetMulticast, Public)
	 */
	void AItemDetonator::MulticastDetonate()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemDetonator.MulticastDetonate");
		
		AItemDetonator_MulticastDetonate_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056CCA80
	 * 		Name   -> Function Insurgency.ItemDetonator.CheckDetonated
	 * 		Flags  -> (Final, Native, Public)
	 */
	void AItemDetonator::CheckDetonated()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemDetonator.CheckDetonated");
		
		AItemDetonator_CheckDetonated_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> Function Insurgency.ItemDetonator.BlueprintOnDetonated
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 */
	void AItemDetonator::BlueprintOnDetonated()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemDetonator.BlueprintOnDetonated");
		
		AItemDetonator_BlueprintOnDetonated_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056CCA00
	 * 		Name   -> Function Insurgency.ItemDetonator.AddGrenade
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class AProjectileBase*                             Projectile                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AItemDetonator::AddGrenade(class AProjectileBase* Projectile)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemDetonator.AddGrenade");
		
		AItemDetonator_AddGrenade_Params params {};
		params.Projectile = Projectile;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AItemDetonator.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AItemDetonator::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.ItemDetonator");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056D48D0
	 * 		Name   -> Function Insurgency.ItemFirearm.SupportsSpeedReload
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AItemFirearm::SupportsSpeedReload()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemFirearm.SupportsSpeedReload");
		
		AItemFirearm_SupportsSpeedReload_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056D4800
	 * 		Name   -> Function Insurgency.ItemFirearm.StartReload
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bReloadIfFull                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bFromClientReplication                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AItemFirearm::StartReload(bool bReloadIfFull, bool bFromClientReplication)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemFirearm.StartReload");
		
		AItemFirearm_StartReload_Params params {};
		params.bReloadIfFull = bReloadIfFull;
		params.bFromClientReplication = bFromClientReplication;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056D4770
	 * 		Name   -> Function Insurgency.ItemFirearm.StartAmmoCheck
	 * 		Flags  -> (Final, Native, Protected, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bFromClientReplication                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AItemFirearm::StartAmmoCheck(bool bFromClientReplication)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemFirearm.StartAmmoCheck");
		
		AItemFirearm_StartAmmoCheck_Params params {};
		params.bFromClientReplication = bFromClientReplication;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056D4740
	 * 		Name   -> Function Insurgency.ItemFirearm.ShouldSingleReload
	 * 		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AItemFirearm::ShouldSingleReload()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemFirearm.ShouldSingleReload");
		
		AItemFirearm_ShouldSingleReload_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056D4710
	 * 		Name   -> Function Insurgency.ItemFirearm.ShouldFireTracerRound
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AItemFirearm::ShouldFireTracerRound()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemFirearm.ShouldFireTracerRound");
		
		AItemFirearm_ShouldFireTracerRound_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056D46E0
	 * 		Name   -> Function Insurgency.ItemFirearm.ShouldDryReload
	 * 		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AItemFirearm::ShouldDryReload()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemFirearm.ShouldDryReload");
		
		AItemFirearm_ShouldDryReload_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056D4660
	 * 		Name   -> Function Insurgency.ItemFirearm.SetFiremode
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		EFirearmFiremode                                   NewFiremode                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AItemFirearm::SetFiremode(EFirearmFiremode NewFiremode)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemFirearm.SetFiremode");
		
		AItemFirearm_SetFiremode_Params params {};
		params.NewFiremode = NewFiremode;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056D45D0
	 * 		Name   -> Function Insurgency.ItemFirearm.SetFireEnabled
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bNewFireEnabled                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AItemFirearm::SetFireEnabled(bool bNewFireEnabled)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemFirearm.SetFireEnabled");
		
		AItemFirearm_SetFireEnabled_Params params {};
		params.bNewFireEnabled = bNewFireEnabled;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056D4550
	 * 		Name   -> Function Insurgency.ItemFirearm.SetBoltState
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		EFirearmBoltState                                  NewBoltState                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AItemFirearm::SetBoltState(EFirearmBoltState NewBoltState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemFirearm.SetBoltState");
		
		AItemFirearm_SetBoltState_Params params {};
		params.NewBoltState = NewBoltState;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056D44B0
	 * 		Name   -> Function Insurgency.ItemFirearm.ServerStartSwitchMagazine
	 * 		Flags  -> (Net, NetReliable, Native, Event, Protected, NetServer, NetValidate)
	 * Parameters:
	 * 		ESwitchingMagazineState                            SwitchMagazineStateForSave                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AItemFirearm::ServerStartSwitchMagazine(ESwitchingMagazineState SwitchMagazineStateForSave)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemFirearm.ServerStartSwitchMagazine");
		
		AItemFirearm_ServerStartSwitchMagazine_Params params {};
		params.SwitchMagazineStateForSave = SwitchMagazineStateForSave;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056D4460
	 * 		Name   -> Function Insurgency.ItemFirearm.ServerStartSpeedReload
	 * 		Flags  -> (Net, NetReliable, Native, Event, Protected, NetServer, NetValidate)
	 */
	void AItemFirearm::ServerStartSpeedReload()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemFirearm.ServerStartSpeedReload");
		
		AItemFirearm_ServerStartSpeedReload_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056D4410
	 * 		Name   -> Function Insurgency.ItemFirearm.ServerStartReload
	 * 		Flags  -> (Net, NetReliable, Native, Event, Protected, NetServer, NetValidate)
	 */
	void AItemFirearm::ServerStartReload()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemFirearm.ServerStartReload");
		
		AItemFirearm_ServerStartReload_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056D43C0
	 * 		Name   -> Function Insurgency.ItemFirearm.ServerStartAmmoCheck
	 * 		Flags  -> (Net, NetReliable, Native, Event, Protected, NetServer, NetValidate)
	 */
	void AItemFirearm::ServerStartAmmoCheck()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemFirearm.ServerStartAmmoCheck");
		
		AItemFirearm_ServerStartAmmoCheck_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056D4300
	 * 		Name   -> Function Insurgency.ItemFirearm.ServerSetFiringState
	 * 		Flags  -> (Final, Net, NetReliable, Native, Event, Private, NetServer, NetValidate)
	 * Parameters:
	 * 		bool                                               bNewIsFiring                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AItemFirearm::ServerSetFiringState(bool bNewIsFiring)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemFirearm.ServerSetFiringState");
		
		AItemFirearm_ServerSetFiringState_Params params {};
		params.bNewIsFiring = bNewIsFiring;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056D42B0
	 * 		Name   -> Function Insurgency.ItemFirearm.ServerInterruptSwitchMagazine
	 * 		Flags  -> (Net, NetReliable, Native, Event, Protected, NetServer, NetValidate)
	 */
	void AItemFirearm::ServerInterruptSwitchMagazine()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemFirearm.ServerInterruptSwitchMagazine");
		
		AItemFirearm_ServerInterruptSwitchMagazine_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056D4260
	 * 		Name   -> Function Insurgency.ItemFirearm.ServerInterruptReload
	 * 		Flags  -> (Net, NetReliable, Native, Event, Protected, NetServer, NetValidate)
	 */
	void AItemFirearm::ServerInterruptReload()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemFirearm.ServerInterruptReload");
		
		AItemFirearm_ServerInterruptReload_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056D4080
	 * 		Name   -> Function Insurgency.ItemFirearm.ServerFireWeapon
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetServer, HasDefaults, NetValidate)
	 * Parameters:
	 * 		struct FVector                                     Origin                                                     (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector_NetQuantizeNormal                   Direction                                                  (ConstParm, Parm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            RandomSeed                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Timestamp                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            ClientBulletId                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AItemFirearm::ServerFireWeapon(const struct FVector& Origin, const struct FVector_NetQuantizeNormal& Direction, int32_t RandomSeed, float Timestamp, int32_t ClientBulletId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemFirearm.ServerFireWeapon");
		
		AItemFirearm_ServerFireWeapon_Params params {};
		params.Origin = Origin;
		params.Direction = Direction;
		params.RandomSeed = RandomSeed;
		params.Timestamp = Timestamp;
		params.ClientBulletId = ClientBulletId;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056D3FE0
	 * 		Name   -> Function Insurgency.ItemFirearm.ServerFinishSwitchMagazine
	 * 		Flags  -> (Net, NetReliable, Native, Event, Protected, NetServer, NetValidate)
	 * Parameters:
	 * 		ESwitchingMagazineState                            SwitchMagazineStateForSave                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AItemFirearm::ServerFinishSwitchMagazine(ESwitchingMagazineState SwitchMagazineStateForSave)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemFirearm.ServerFinishSwitchMagazine");
		
		AItemFirearm_ServerFinishSwitchMagazine_Params params {};
		params.SwitchMagazineStateForSave = SwitchMagazineStateForSave;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056D3F90
	 * 		Name   -> Function Insurgency.ItemFirearm.ServerDryFire
	 * 		Flags  -> (Net, Native, Event, Public, NetServer, NetValidate)
	 */
	void AItemFirearm::ServerDryFire()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemFirearm.ServerDryFire");
		
		AItemFirearm_ServerDryFire_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056D3DB0
	 * 		Name   -> Function Insurgency.ItemFirearm.ServerDelayedFireProjectile
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetServer, HasDefaults, NetValidate)
	 * Parameters:
	 * 		struct FVector                                     Origin                                                     (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector_NetQuantizeNormal                   ShootDir                                                   (ConstParm, Parm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            RandomSeed                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              ClientTimestamp                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            ClientBulletId                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AItemFirearm::ServerDelayedFireProjectile(const struct FVector& Origin, const struct FVector_NetQuantizeNormal& ShootDir, int32_t RandomSeed, float ClientTimestamp, int32_t ClientBulletId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemFirearm.ServerDelayedFireProjectile");
		
		AItemFirearm_ServerDelayedFireProjectile_Params params {};
		params.Origin = Origin;
		params.ShootDir = ShootDir;
		params.RandomSeed = RandomSeed;
		params.ClientTimestamp = ClientTimestamp;
		params.ClientBulletId = ClientBulletId;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056D3D00
	 * 		Name   -> Function Insurgency.ItemFirearm.ServerCycleFiremode
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
	 * Parameters:
	 * 		EFirearmFiremode                                   Firemode                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AItemFirearm::ServerCycleFiremode(EFirearmFiremode Firemode)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemFirearm.ServerCycleFiremode");
		
		AItemFirearm_ServerCycleFiremode_Params params {};
		params.Firemode = Firemode;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056D3CB0
	 * 		Name   -> Function Insurgency.ItemFirearm.ServerBeginBoltCycle
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
	 */
	void AItemFirearm::ServerBeginBoltCycle()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemFirearm.ServerBeginBoltCycle");
		
		AItemFirearm_ServerBeginBoltCycle_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056D3C80
	 * 		Name   -> Function Insurgency.ItemFirearm.ReleaseTrigger
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	bool AItemFirearm::ReleaseTrigger()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemFirearm.ReleaseTrigger");
		
		AItemFirearm_ReleaseTrigger_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056D3C50
	 * 		Name   -> Function Insurgency.ItemFirearm.PullTrigger
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	bool AItemFirearm::PullTrigger()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemFirearm.PullTrigger");
		
		AItemFirearm_PullTrigger_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056D3C30
	 * 		Name   -> Function Insurgency.ItemFirearm.PlayEjectAfterFiringLast
	 * 		Flags  -> (Final, Native, Public)
	 */
	void AItemFirearm::PlayEjectAfterFiringLast()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemFirearm.PlayEjectAfterFiringLast");
		
		AItemFirearm_PlayEjectAfterFiringLast_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> DelegateFunction Insurgency.ItemFirearm.OnSwitchMagazineInterruptDelegate__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 * Parameters:
	 * 		float                                              AnimationInterruptTime                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AItemFirearm::OnSwitchMagazineInterruptDelegate__DelegateSignature(float AnimationInterruptTime)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction Insurgency.ItemFirearm.OnSwitchMagazineInterruptDelegate__DelegateSignature");
		
		AItemFirearm_OnSwitchMagazineInterruptDelegate__DelegateSignature_Params params {};
		params.AnimationInterruptTime = AnimationInterruptTime;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> DelegateFunction Insurgency.ItemFirearm.OnSwitchMagazineDelegate__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 * Parameters:
	 * 		float                                              RateMultiplier                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bDryReload                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AItemFirearm::OnSwitchMagazineDelegate__DelegateSignature(float RateMultiplier, bool bDryReload)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction Insurgency.ItemFirearm.OnSwitchMagazineDelegate__DelegateSignature");
		
		AItemFirearm_OnSwitchMagazineDelegate__DelegateSignature_Params params {};
		params.RateMultiplier = RateMultiplier;
		params.bDryReload = bDryReload;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> DelegateFunction Insurgency.ItemFirearm.OnSpeedReloadDelegate__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 * Parameters:
	 * 		bool                                               bDryReload                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              RateMultiplier                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AItemFirearm::OnSpeedReloadDelegate__DelegateSignature(bool bDryReload, float RateMultiplier)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction Insurgency.ItemFirearm.OnSpeedReloadDelegate__DelegateSignature");
		
		AItemFirearm_OnSpeedReloadDelegate__DelegateSignature_Params params {};
		params.bDryReload = bDryReload;
		params.RateMultiplier = RateMultiplier;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056D3C10
	 * 		Name   -> Function Insurgency.ItemFirearm.OnRep_FirearmState
	 * 		Flags  -> (Final, Native, Protected)
	 */
	void AItemFirearm::OnRep_FirearmState()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemFirearm.OnRep_FirearmState");
		
		AItemFirearm_OnRep_FirearmState_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056D3BF0
	 * 		Name   -> Function Insurgency.ItemFirearm.OnRep_BoltState
	 * 		Flags  -> (Final, Native, Private)
	 */
	void AItemFirearm::OnRep_BoltState()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemFirearm.OnRep_BoltState");
		
		AItemFirearm_OnRep_BoltState_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> DelegateFunction Insurgency.ItemFirearm.OnReloadInterruptDelegate__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 */
	void AItemFirearm::OnReloadInterruptDelegate__DelegateSignature()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction Insurgency.ItemFirearm.OnReloadInterruptDelegate__DelegateSignature");
		
		AItemFirearm_OnReloadInterruptDelegate__DelegateSignature_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> DelegateFunction Insurgency.ItemFirearm.OnReloadDelegate__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 * Parameters:
	 * 		bool                                               bDryReload                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bSingleReload                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              RateMultiplier                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AItemFirearm::OnReloadDelegate__DelegateSignature(bool bDryReload, bool bSingleReload, float RateMultiplier)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction Insurgency.ItemFirearm.OnReloadDelegate__DelegateSignature");
		
		AItemFirearm_OnReloadDelegate__DelegateSignature_Params params {};
		params.bDryReload = bDryReload;
		params.bSingleReload = bSingleReload;
		params.RateMultiplier = RateMultiplier;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> DelegateFunction Insurgency.ItemFirearm.OnReloadAfterSwitchMagazineDelegate__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 * Parameters:
	 * 		bool                                               bDryReload                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bSingleReload                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              RateMultiplier                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AItemFirearm::OnReloadAfterSwitchMagazineDelegate__DelegateSignature(bool bDryReload, bool bSingleReload, float RateMultiplier)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction Insurgency.ItemFirearm.OnReloadAfterSwitchMagazineDelegate__DelegateSignature");
		
		AItemFirearm_OnReloadAfterSwitchMagazineDelegate__DelegateSignature_Params params {};
		params.bDryReload = bDryReload;
		params.bSingleReload = bSingleReload;
		params.RateMultiplier = RateMultiplier;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> DelegateFunction Insurgency.ItemFirearm.OnMagOutDelegate__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 */
	void AItemFirearm::OnMagOutDelegate__DelegateSignature()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction Insurgency.ItemFirearm.OnMagOutDelegate__DelegateSignature");
		
		AItemFirearm_OnMagOutDelegate__DelegateSignature_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> DelegateFunction Insurgency.ItemFirearm.OnMagInDelegate__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 */
	void AItemFirearm::OnMagInDelegate__DelegateSignature()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction Insurgency.ItemFirearm.OnMagInDelegate__DelegateSignature");
		
		AItemFirearm_OnMagInDelegate__DelegateSignature_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> DelegateFunction Insurgency.ItemFirearm.OnFireStopDelegate__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 */
	void AItemFirearm::OnFireStopDelegate__DelegateSignature()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction Insurgency.ItemFirearm.OnFireStopDelegate__DelegateSignature");
		
		AItemFirearm_OnFireStopDelegate__DelegateSignature_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x04DB53A0
	 * 		Name   -> Function Insurgency.ItemFirearm.OnFireStop
	 * 		Flags  -> (Native, Public)
	 */
	void AItemFirearm::OnFireStop()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemFirearm.OnFireStop");
		
		AItemFirearm_OnFireStop_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> DelegateFunction Insurgency.ItemFirearm.OnFireStartDelegate__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 */
	void AItemFirearm::OnFireStartDelegate__DelegateSignature()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction Insurgency.ItemFirearm.OnFireStartDelegate__DelegateSignature");
		
		AItemFirearm_OnFireStartDelegate__DelegateSignature_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x04DB3F60
	 * 		Name   -> Function Insurgency.ItemFirearm.OnFireStart
	 * 		Flags  -> (Native, Public)
	 */
	void AItemFirearm::OnFireStart()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemFirearm.OnFireStart");
		
		AItemFirearm_OnFireStart_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> DelegateFunction Insurgency.ItemFirearm.OnFireDelegate__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate, HasOutParms, HasDefaults)
	 * Parameters:
	 * 		struct FVector                                     FireOrigin                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     FireDirection                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AItemFirearm::OnFireDelegate__DelegateSignature(const struct FVector& FireOrigin, const struct FVector& FireDirection)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction Insurgency.ItemFirearm.OnFireDelegate__DelegateSignature");
		
		AItemFirearm_OnFireDelegate__DelegateSignature_Params params {};
		params.FireOrigin = FireOrigin;
		params.FireDirection = FireDirection;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056D3AC0
	 * 		Name   -> Function Insurgency.ItemFirearm.OnFire
	 * 		Flags  -> (Native, Public, HasOutParms, HasDefaults)
	 * Parameters:
	 * 		struct FVector                                     Origin                                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     ShootDir                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bFromReplication                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AItemFirearm::OnFire(const struct FVector& Origin, const struct FVector& ShootDir, bool bFromReplication)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemFirearm.OnFire");
		
		AItemFirearm_OnFire_Params params {};
		params.Origin = Origin;
		params.ShootDir = ShootDir;
		params.bFromReplication = bFromReplication;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056D3A30
	 * 		Name   -> Function Insurgency.ItemFirearm.OnFindParticleSystemForAmmoTypeStaticMesh
	 * 		Flags  -> (Final, Native, Private)
	 * Parameters:
	 * 		bool                                               bIsAmmoContainer                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AItemFirearm::OnFindParticleSystemForAmmoTypeStaticMesh(bool bIsAmmoContainer)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemFirearm.OnFindParticleSystemForAmmoTypeStaticMesh");
		
		AItemFirearm_OnFindParticleSystemForAmmoTypeStaticMesh_Params params {};
		params.bIsAmmoContainer = bIsAmmoContainer;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> DelegateFunction Insurgency.ItemFirearm.OnDryFireDelegate__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 */
	void AItemFirearm::OnDryFireDelegate__DelegateSignature()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction Insurgency.ItemFirearm.OnDryFireDelegate__DelegateSignature");
		
		AItemFirearm_OnDryFireDelegate__DelegateSignature_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> DelegateFunction Insurgency.ItemFirearm.OnCycleFiremodeDelegate__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 * Parameters:
	 * 		EFirearmFiremode                                   OldFiremode                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EFirearmFiremode                                   NewFiremode                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AItemFirearm::OnCycleFiremodeDelegate__DelegateSignature(EFirearmFiremode OldFiremode, EFirearmFiremode NewFiremode)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction Insurgency.ItemFirearm.OnCycleFiremodeDelegate__DelegateSignature");
		
		AItemFirearm_OnCycleFiremodeDelegate__DelegateSignature_Params params {};
		params.OldFiremode = OldFiremode;
		params.NewFiremode = NewFiremode;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> DelegateFunction Insurgency.ItemFirearm.OnBoltCycleDelegate__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 */
	void AItemFirearm::OnBoltCycleDelegate__DelegateSignature()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction Insurgency.ItemFirearm.OnBoltCycleDelegate__DelegateSignature");
		
		AItemFirearm_OnBoltCycleDelegate__DelegateSignature_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> DelegateFunction Insurgency.ItemFirearm.OnBeginFinishReloadDelegate__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 * Parameters:
	 * 		bool                                               bFromSinglyLoaded                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AItemFirearm::OnBeginFinishReloadDelegate__DelegateSignature(bool bFromSinglyLoaded)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction Insurgency.ItemFirearm.OnBeginFinishReloadDelegate__DelegateSignature");
		
		AItemFirearm_OnBeginFinishReloadDelegate__DelegateSignature_Params params {};
		params.bFromSinglyLoaded = bFromSinglyLoaded;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> DelegateFunction Insurgency.ItemFirearm.OnAmmoCheckDelegate__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 */
	void AItemFirearm::OnAmmoCheckDelegate__DelegateSignature()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction Insurgency.ItemFirearm.OnAmmoCheckDelegate__DelegateSignature");
		
		AItemFirearm_OnAmmoCheckDelegate__DelegateSignature_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056D3A10
	 * 		Name   -> Function Insurgency.ItemFirearm.NetMulticastStartAmmoCheck
	 * 		Flags  -> (Net, NetReliable, Native, Event, NetMulticast, Protected)
	 */
	void AItemFirearm::NetMulticastStartAmmoCheck()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemFirearm.NetMulticastStartAmmoCheck");
		
		AItemFirearm_NetMulticastStartAmmoCheck_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056D38F0
	 * 		Name   -> Function Insurgency.ItemFirearm.MulticastFireWeapon
	 * 		Flags  -> (Net, NetReliable, Native, Event, NetMulticast, Public, HasDefaults)
	 * Parameters:
	 * 		struct FVector                                     Origin                                                     (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     Direction                                                  (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            RandomSeed                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AItemFirearm::MulticastFireWeapon(const struct FVector& Origin, const struct FVector& Direction, int32_t RandomSeed)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemFirearm.MulticastFireWeapon");
		
		AItemFirearm_MulticastFireWeapon_Params params {};
		params.Origin = Origin;
		params.Direction = Direction;
		params.RandomSeed = RandomSeed;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056D37F0
	 * 		Name   -> Function Insurgency.ItemFirearm.MulticastFireProjectile
	 * 		Flags  -> (Net, NetReliable, Native, Event, NetMulticast, Public, HasDefaults)
	 * Parameters:
	 * 		struct FVector                                     Origin                                                     (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector_NetQuantizeNormal                   ShootDir                                                   (ConstParm, Parm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            RandomSeed                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AItemFirearm::MulticastFireProjectile(const struct FVector& Origin, const struct FVector_NetQuantizeNormal& ShootDir, int32_t RandomSeed)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemFirearm.MulticastFireProjectile");
		
		AItemFirearm_MulticastFireProjectile_Params params {};
		params.Origin = Origin;
		params.ShootDir = ShootDir;
		params.RandomSeed = RandomSeed;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056D37D0
	 * 		Name   -> Function Insurgency.ItemFirearm.MulticastDryFire
	 * 		Flags  -> (Net, Native, Event, NetMulticast, Public)
	 */
	void AItemFirearm::MulticastDryFire()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemFirearm.MulticastDryFire");
		
		AItemFirearm_MulticastDryFire_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056D39F0
	 * 		Name   -> Function Insurgency.ItemFirearm.Multicast_PlayEjectAfterFiringLast
	 * 		Flags  -> (Net, NetReliable, Native, Event, NetMulticast, Public)
	 */
	void AItemFirearm::Multicast_PlayEjectAfterFiringLast()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemFirearm.Multicast_PlayEjectAfterFiringLast");
		
		AItemFirearm_Multicast_PlayEjectAfterFiringLast_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056D37A0
	 * 		Name   -> Function Insurgency.ItemFirearm.IsWaitingToFire
	 * 		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AItemFirearm::IsWaitingToFire()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemFirearm.IsWaitingToFire");
		
		AItemFirearm_IsWaitingToFire_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056D3770
	 * 		Name   -> Function Insurgency.ItemFirearm.IsTacticalReload
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AItemFirearm::IsTacticalReload()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemFirearm.IsTacticalReload");
		
		AItemFirearm_IsTacticalReload_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056D3740
	 * 		Name   -> Function Insurgency.ItemFirearm.IsSwitchingMagazineGenus
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AItemFirearm::IsSwitchingMagazineGenus()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemFirearm.IsSwitchingMagazineGenus");
		
		AItemFirearm_IsSwitchingMagazineGenus_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056D3710
	 * 		Name   -> Function Insurgency.ItemFirearm.IsSwitchingMagazine
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AItemFirearm::IsSwitchingMagazine()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemFirearm.IsSwitchingMagazine");
		
		AItemFirearm_IsSwitchingMagazine_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056D36E0
	 * 		Name   -> Function Insurgency.ItemFirearm.IsSuspendedSwitchingMagazine
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AItemFirearm::IsSuspendedSwitchingMagazine()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemFirearm.IsSuspendedSwitchingMagazine");
		
		AItemFirearm_IsSuspendedSwitchingMagazine_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056D36B0
	 * 		Name   -> Function Insurgency.ItemFirearm.IsSuspendedReloadSwitchingMagazine
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AItemFirearm::IsSuspendedReloadSwitchingMagazine()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemFirearm.IsSuspendedReloadSwitchingMagazine");
		
		AItemFirearm_IsSuspendedReloadSwitchingMagazine_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056D3680
	 * 		Name   -> Function Insurgency.ItemFirearm.IsSuspendedManualSwitchingMagazine
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AItemFirearm::IsSuspendedManualSwitchingMagazine()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemFirearm.IsSuspendedManualSwitchingMagazine");
		
		AItemFirearm_IsSuspendedManualSwitchingMagazine_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056D3650
	 * 		Name   -> Function Insurgency.ItemFirearm.IsSuspendedInvalidSwitchingMagazine
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AItemFirearm::IsSuspendedInvalidSwitchingMagazine()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemFirearm.IsSuspendedInvalidSwitchingMagazine");
		
		AItemFirearm_IsSuspendedInvalidSwitchingMagazine_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056D3620
	 * 		Name   -> Function Insurgency.ItemFirearm.IsSuspendedFireSwitchingMagazine
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AItemFirearm::IsSuspendedFireSwitchingMagazine()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemFirearm.IsSuspendedFireSwitchingMagazine");
		
		AItemFirearm_IsSuspendedFireSwitchingMagazine_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056D35F0
	 * 		Name   -> Function Insurgency.ItemFirearm.IsSpeedReloading
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AItemFirearm::IsSpeedReloading()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemFirearm.IsSpeedReloading");
		
		AItemFirearm_IsSpeedReloading_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056D35C0
	 * 		Name   -> Function Insurgency.ItemFirearm.IsReloadingOrFinishingReload
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AItemFirearm::IsReloadingOrFinishingReload()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemFirearm.IsReloadingOrFinishingReload");
		
		AItemFirearm_IsReloadingOrFinishingReload_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056D3590
	 * 		Name   -> Function Insurgency.ItemFirearm.IsReloadingInsertLoop
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AItemFirearm::IsReloadingInsertLoop()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemFirearm.IsReloadingInsertLoop");
		
		AItemFirearm_IsReloadingInsertLoop_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056D3560
	 * 		Name   -> Function Insurgency.ItemFirearm.IsReloading
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AItemFirearm::IsReloading()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemFirearm.IsReloading");
		
		AItemFirearm_IsReloading_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056D3530
	 * 		Name   -> Function Insurgency.ItemFirearm.IsPullingTrigger
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AItemFirearm::IsPullingTrigger()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemFirearm.IsPullingTrigger");
		
		AItemFirearm_IsPullingTrigger_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056D3500
	 * 		Name   -> Function Insurgency.ItemFirearm.IsPlayerControlled
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AItemFirearm::IsPlayerControlled()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemFirearm.IsPlayerControlled");
		
		AItemFirearm_IsPlayerControlled_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056D34D0
	 * 		Name   -> Function Insurgency.ItemFirearm.IsNeedSwitchMagazineState
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AItemFirearm::IsNeedSwitchMagazineState()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemFirearm.IsNeedSwitchMagazineState");
		
		AItemFirearm_IsNeedSwitchMagazineState_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056D34A0
	 * 		Name   -> Function Insurgency.ItemFirearm.IsManualAction
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AItemFirearm::IsManualAction()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemFirearm.IsManualAction");
		
		AItemFirearm_IsManualAction_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056D3470
	 * 		Name   -> Function Insurgency.ItemFirearm.IsLocallyControlled
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AItemFirearm::IsLocallyControlled()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemFirearm.IsLocallyControlled");
		
		AItemFirearm_IsLocallyControlled_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056D3440
	 * 		Name   -> Function Insurgency.ItemFirearm.IsInStandardReload
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AItemFirearm::IsInStandardReload()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemFirearm.IsInStandardReload");
		
		AItemFirearm_IsInStandardReload_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056D3410
	 * 		Name   -> Function Insurgency.ItemFirearm.IsInSingleReload
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AItemFirearm::IsInSingleReload()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemFirearm.IsInSingleReload");
		
		AItemFirearm_IsInSingleReload_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056D33E0
	 * 		Name   -> Function Insurgency.ItemFirearm.IsInMagazineStyleReload
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AItemFirearm::IsInMagazineStyleReload()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemFirearm.IsInMagazineStyleReload");
		
		AItemFirearm_IsInMagazineStyleReload_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056D33B0
	 * 		Name   -> Function Insurgency.ItemFirearm.IsInInterruptableState
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AItemFirearm::IsInInterruptableState()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemFirearm.IsInInterruptableState");
		
		AItemFirearm_IsInInterruptableState_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056D3380
	 * 		Name   -> Function Insurgency.ItemFirearm.IsInFiringAnimation
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	bool AItemFirearm::IsInFiringAnimation()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemFirearm.IsInFiringAnimation");
		
		AItemFirearm_IsInFiringAnimation_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056D3350
	 * 		Name   -> Function Insurgency.ItemFirearm.IsIdle
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AItemFirearm::IsIdle()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemFirearm.IsIdle");
		
		AItemFirearm_IsIdle_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056D3320
	 * 		Name   -> Function Insurgency.ItemFirearm.IsFocusing
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AItemFirearm::IsFocusing()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemFirearm.IsFocusing");
		
		AItemFirearm_IsFocusing_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056D32F0
	 * 		Name   -> Function Insurgency.ItemFirearm.IsFiring
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AItemFirearm::IsFiring()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemFirearm.IsFiring");
		
		AItemFirearm_IsFiring_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056D32C0
	 * 		Name   -> Function Insurgency.ItemFirearm.IsFireEnabled
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AItemFirearm::IsFireEnabled()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemFirearm.IsFireEnabled");
		
		AItemFirearm_IsFireEnabled_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056D3290
	 * 		Name   -> Function Insurgency.ItemFirearm.IsFinishingReload
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AItemFirearm::IsFinishingReload()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemFirearm.IsFinishingReload");
		
		AItemFirearm_IsFinishingReload_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056D3260
	 * 		Name   -> Function Insurgency.ItemFirearm.IsDryReload
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AItemFirearm::IsDryReload()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemFirearm.IsDryReload");
		
		AItemFirearm_IsDryReload_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056D3230
	 * 		Name   -> Function Insurgency.ItemFirearm.IsCyclingBolt
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AItemFirearm::IsCyclingBolt()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemFirearm.IsCyclingBolt");
		
		AItemFirearm_IsCyclingBolt_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056D3200
	 * 		Name   -> Function Insurgency.ItemFirearm.IsCheckingAmmo
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AItemFirearm::IsCheckingAmmo()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemFirearm.IsCheckingAmmo");
		
		AItemFirearm_IsCheckingAmmo_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056D31D0
	 * 		Name   -> Function Insurgency.ItemFirearm.IsChangingFiremode
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AItemFirearm::IsChangingFiremode()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemFirearm.IsChangingFiremode");
		
		AItemFirearm_IsChangingFiremode_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056D31A0
	 * 		Name   -> Function Insurgency.ItemFirearm.IsBoltReady
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AItemFirearm::IsBoltReady()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemFirearm.IsBoltReady");
		
		AItemFirearm_IsBoltReady_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056D3170
	 * 		Name   -> Function Insurgency.ItemFirearm.IsBarrelObstructed
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AItemFirearm::IsBarrelObstructed()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemFirearm.IsBarrelObstructed");
		
		AItemFirearm_IsBarrelObstructed_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056D3140
	 * 		Name   -> Function Insurgency.ItemFirearm.IsBarrelAtLeastPartiallyObstructed
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AItemFirearm::IsBarrelAtLeastPartiallyObstructed()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemFirearm.IsBarrelAtLeastPartiallyObstructed");
		
		AItemFirearm_IsBarrelAtLeastPartiallyObstructed_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056D3110
	 * 		Name   -> Function Insurgency.ItemFirearm.HasMultipleFiremodes
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AItemFirearm::HasMultipleFiremodes()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemFirearm.HasMultipleFiremodes");
		
		AItemFirearm_HasMultipleFiremodes_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056D3080
	 * 		Name   -> Function Insurgency.ItemFirearm.HasFiremode
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		EFirearmFiremode                                   Firemode                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool AItemFirearm::HasFiremode(EFirearmFiremode Firemode)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemFirearm.HasFiremode");
		
		AItemFirearm_HasFiremode_Params params {};
		params.Firemode = Firemode;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056D3050
	 * 		Name   -> Function Insurgency.ItemFirearm.HasBipodDeployed
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AItemFirearm::HasBipodDeployed()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemFirearm.HasBipodDeployed");
		
		AItemFirearm_HasBipodDeployed_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056D2FA0
	 * 		Name   -> Function Insurgency.ItemFirearm.GetReloadTimesForState
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		EFirearmState                                      ReloadState                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FReloadTimes AItemFirearm::GetReloadTimesForState(EFirearmState ReloadState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemFirearm.GetReloadTimesForState");
		
		AItemFirearm_GetReloadTimesForState_Params params {};
		params.ReloadState = ReloadState;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056D2E90
	 * 		Name   -> Function Insurgency.ItemFirearm.GetReloadTimesForContainer
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		class UClass*                                      ContainerType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FReloadTimesGroup AItemFirearm::GetReloadTimesForContainer(class UClass* ContainerType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemFirearm.GetReloadTimesForContainer");
		
		AItemFirearm_GetReloadTimesForContainer_Params params {};
		params.ContainerType = ContainerType;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056D2E00
	 * 		Name   -> Function Insurgency.ItemFirearm.GetRecoilRestRate
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		int32_t                                            ShotCount                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	float AItemFirearm::GetRecoilRestRate(int32_t ShotCount)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemFirearm.GetRecoilRestRate");
		
		AItemFirearm_GetRecoilRestRate_Params params {};
		params.ShotCount = ShotCount;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056D2DD0
	 * 		Name   -> Function Insurgency.ItemFirearm.GetProjectileSpread
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	float AItemFirearm::GetProjectileSpread()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemFirearm.GetProjectileSpread");
		
		AItemFirearm_GetProjectileSpread_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056D2CB0
	 * 		Name   -> Function Insurgency.ItemFirearm.GetMuzzleSocketFromMesh
	 * 		Flags  -> (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		class USkeletalMeshComponent*                      Component                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     OutShootPosition                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     OutShootDirection                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AItemFirearm::GetMuzzleSocketFromMesh(class USkeletalMeshComponent* Component, struct FVector* OutShootPosition, struct FVector* OutShootDirection)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemFirearm.GetMuzzleSocketFromMesh");
		
		AItemFirearm_GetMuzzleSocketFromMesh_Params params {};
		params.Component = Component;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutShootPosition != nullptr)
			*OutShootPosition = params.OutShootPosition;
		if (OutShootDirection != nullptr)
			*OutShootDirection = params.OutShootDirection;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056D2C10
	 * 		Name   -> Function Insurgency.ItemFirearm.GetMuzzleMesh
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		bool                                               bForceFirstPerson                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class USkeletalMeshComponent* AItemFirearm::GetMuzzleMesh(bool bForceFirstPerson)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemFirearm.GetMuzzleMesh");
		
		AItemFirearm_GetMuzzleMesh_Params params {};
		params.bForceFirstPerson = bForceFirstPerson;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056D2AE0
	 * 		Name   -> Function Insurgency.ItemFirearm.GetMuzzle
	 * 		Flags  -> (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		struct FVector                                     OutShootPosition                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     OutShootDirection                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bFirstPerson                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AItemFirearm::GetMuzzle(struct FVector* OutShootPosition, struct FVector* OutShootDirection, bool bFirstPerson)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemFirearm.GetMuzzle");
		
		AItemFirearm_GetMuzzle_Params params {};
		params.bFirstPerson = bFirstPerson;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutShootPosition != nullptr)
			*OutShootPosition = params.OutShootPosition;
		if (OutShootDirection != nullptr)
			*OutShootDirection = params.OutShootDirection;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056D2A60
	 * 		Name   -> Function Insurgency.ItemFirearm.GetLoadedAmmoSubContainers
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	TArray<int32_t> AItemFirearm::GetLoadedAmmoSubContainers()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemFirearm.GetLoadedAmmoSubContainers");
		
		AItemFirearm_GetLoadedAmmoSubContainers_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056D29D0
	 * 		Name   -> Function Insurgency.ItemFirearm.GetLoadedAmmoSubContainer
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		int32_t                                            ContainerIndex                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	int32_t AItemFirearm::GetLoadedAmmoSubContainer(int32_t ContainerIndex)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemFirearm.GetLoadedAmmoSubContainer");
		
		AItemFirearm_GetLoadedAmmoSubContainer_Params params {};
		params.ContainerIndex = ContainerIndex;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056D29A0
	 * 		Name   -> Function Insurgency.ItemFirearm.GetLastFireTime
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	float AItemFirearm::GetLastFireTime()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemFirearm.GetLastFireTime");
		
		AItemFirearm_GetLastFireTime_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056D28A0
	 * 		Name   -> Function Insurgency.ItemFirearm.GetFreeaimMuzzle
	 * 		Flags  -> (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		struct FVector                                     OutShootPosition                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     OutShootDirection                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool AItemFirearm::GetFreeaimMuzzle(struct FVector* OutShootPosition, struct FVector* OutShootDirection)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemFirearm.GetFreeaimMuzzle");
		
		AItemFirearm_GetFreeaimMuzzle_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutShootPosition != nullptr)
			*OutShootPosition = params.OutShootPosition;
		if (OutShootDirection != nullptr)
			*OutShootDirection = params.OutShootDirection;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056D27C0
	 * 		Name   -> Function Insurgency.ItemFirearm.GetFirstPersonMuzzle
	 * 		Flags  -> (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		struct FVector                                     OutShootPosition                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     OutShootDirection                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AItemFirearm::GetFirstPersonMuzzle(struct FVector* OutShootPosition, struct FVector* OutShootDirection)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemFirearm.GetFirstPersonMuzzle");
		
		AItemFirearm_GetFirstPersonMuzzle_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutShootPosition != nullptr)
			*OutShootPosition = params.OutShootPosition;
		if (OutShootDirection != nullptr)
			*OutShootDirection = params.OutShootDirection;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056D2790
	 * 		Name   -> Function Insurgency.ItemFirearm.GetFiremodeCount
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	int32_t AItemFirearm::GetFiremodeCount()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemFirearm.GetFiremodeCount");
		
		AItemFirearm_GetFiremodeCount_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056D2760
	 * 		Name   -> Function Insurgency.ItemFirearm.GetFiremode
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	EFirearmFiremode AItemFirearm::GetFiremode()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemFirearm.GetFiremode");
		
		AItemFirearm_GetFiremode_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056D2730
	 * 		Name   -> Function Insurgency.ItemFirearm.GetFirearmState
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	EFirearmState AItemFirearm::GetFirearmState()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemFirearm.GetFirearmState");
		
		AItemFirearm_GetFirearmState_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056D2690
	 * 		Name   -> Function Insurgency.ItemFirearm.GetEffectTargetMesh
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		bool                                               bForceFirstPerson                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class USkeletalMeshComponent* AItemFirearm::GetEffectTargetMesh(bool bForceFirstPerson)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemFirearm.GetEffectTargetMesh");
		
		AItemFirearm_GetEffectTargetMesh_Params params {};
		params.bForceFirstPerson = bForceFirstPerson;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056D25B0
	 * 		Name   -> Function Insurgency.ItemFirearm.GetContainerReloadTimesForState
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		class UClass*                                      ContainerType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EFirearmState                                      ReloadState                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FReloadTimes AItemFirearm::GetContainerReloadTimesForState(class UClass* ContainerType, EFirearmState ReloadState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemFirearm.GetContainerReloadTimesForState");
		
		AItemFirearm_GetContainerReloadTimesForState_Params params {};
		params.ContainerType = ContainerType;
		params.ReloadState = ReloadState;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056D2580
	 * 		Name   -> Function Insurgency.ItemFirearm.GetBoltState
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	EFirearmBoltState AItemFirearm::GetBoltState()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemFirearm.GetBoltState");
		
		AItemFirearm_GetBoltState_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056D2550
	 * 		Name   -> Function Insurgency.ItemFirearm.GetBipod
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	class UWeaponBipodComponent* AItemFirearm::GetBipod()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemFirearm.GetBipod");
		
		AItemFirearm_GetBipod_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056D2510
	 * 		Name   -> Function Insurgency.ItemFirearm.GetAmmoContainerForReloadStart
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	class UClass* AItemFirearm::GetAmmoContainerForReloadStart()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemFirearm.GetAmmoContainerForReloadStart");
		
		AItemFirearm_GetAmmoContainerForReloadStart_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056D24F0
	 * 		Name   -> Function Insurgency.ItemFirearm.ForceStopFire
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void AItemFirearm::ForceStopFire()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemFirearm.ForceStopFire");
		
		AItemFirearm_ForceStopFire_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056D2470
	 * 		Name   -> Function Insurgency.ItemFirearm.ForceChangeFiremode
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		EFirearmFiremode                                   Firemode                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AItemFirearm::ForceChangeFiremode(EFirearmFiremode Firemode)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemFirearm.ForceChangeFiremode");
		
		AItemFirearm_ForceChangeFiremode_Params params {};
		params.Firemode = Firemode;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056D2450
	 * 		Name   -> Function Insurgency.ItemFirearm.FireWeapon
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void AItemFirearm::FireWeapon()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemFirearm.FireWeapon");
		
		AItemFirearm_FireWeapon_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056D2240
	 * 		Name   -> Function Insurgency.ItemFirearm.FireProjectile
	 * 		Flags  -> (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FVector                                     Origin                                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     ShootDir                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            RandomSeed                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              ClientTimestamp                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            ClientBulletId                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bClientReplication                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AItemFirearm::FireProjectile(const struct FVector& Origin, const struct FVector& ShootDir, int32_t RandomSeed, float ClientTimestamp, int32_t ClientBulletId, bool bClientReplication)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemFirearm.FireProjectile");
		
		AItemFirearm_FireProjectile_Params params {};
		params.Origin = Origin;
		params.ShootDir = ShootDir;
		params.RandomSeed = RandomSeed;
		params.ClientTimestamp = ClientTimestamp;
		params.ClientBulletId = ClientBulletId;
		params.bClientReplication = bClientReplication;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056D2220
	 * 		Name   -> Function Insurgency.ItemFirearm.FinishBoltCycle
	 * 		Flags  -> (Final, Native, Public)
	 */
	void AItemFirearm::FinishBoltCycle()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemFirearm.FinishBoltCycle");
		
		AItemFirearm_FinishBoltCycle_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056D2200
	 * 		Name   -> Function Insurgency.ItemFirearm.ExecuteSwitchMagazine
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void AItemFirearm::ExecuteSwitchMagazine()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemFirearm.ExecuteSwitchMagazine");
		
		AItemFirearm_ExecuteSwitchMagazine_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056D21D0
	 * 		Name   -> Function Insurgency.ItemFirearm.DoesBoltNeedCycling
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AItemFirearm::DoesBoltNeedCycling()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemFirearm.DoesBoltNeedCycling");
		
		AItemFirearm_DoesBoltNeedCycling_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056D21B0
	 * 		Name   -> Function Insurgency.ItemFirearm.CreateRecoil
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void AItemFirearm::CreateRecoil()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemFirearm.CreateRecoil");
		
		AItemFirearm_CreateRecoil_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056D2130
	 * 		Name   -> Function Insurgency.ItemFirearm.ClientStartSwitchMagazine
	 * 		Flags  -> (Net, NetReliable, Native, Event, Protected, NetClient)
	 * Parameters:
	 * 		ESwitchingMagazineState                            SwitchMagazineStateForSave                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AItemFirearm::ClientStartSwitchMagazine(ESwitchingMagazineState SwitchMagazineStateForSave)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemFirearm.ClientStartSwitchMagazine");
		
		AItemFirearm_ClientStartSwitchMagazine_Params params {};
		params.SwitchMagazineStateForSave = SwitchMagazineStateForSave;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056D2110
	 * 		Name   -> Function Insurgency.ItemFirearm.ClientLoadMagAmmo
	 * 		Flags  -> (Net, NetReliable, Native, Event, Protected, NetClient)
	 */
	void AItemFirearm::ClientLoadMagAmmo()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemFirearm.ClientLoadMagAmmo");
		
		AItemFirearm_ClientLoadMagAmmo_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056D20F0
	 * 		Name   -> Function Insurgency.ItemFirearm.ClientInterruptSwitchMagazine
	 * 		Flags  -> (Net, NetReliable, Native, Event, Protected, NetClient)
	 */
	void AItemFirearm::ClientInterruptSwitchMagazine()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemFirearm.ClientInterruptSwitchMagazine");
		
		AItemFirearm_ClientInterruptSwitchMagazine_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056D20D0
	 * 		Name   -> Function Insurgency.ItemFirearm.ClientInterruptReload
	 * 		Flags  -> (Net, NetReliable, Native, Event, Protected, NetClient)
	 */
	void AItemFirearm::ClientInterruptReload()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemFirearm.ClientInterruptReload");
		
		AItemFirearm_ClientInterruptReload_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056D2050
	 * 		Name   -> Function Insurgency.ItemFirearm.ClientFinishSwitchMagazine
	 * 		Flags  -> (Net, NetReliable, Native, Event, Protected, NetClient)
	 * Parameters:
	 * 		ESwitchingMagazineState                            SwitchMagazineStateForSave                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AItemFirearm::ClientFinishSwitchMagazine(ESwitchingMagazineState SwitchMagazineStateForSave)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemFirearm.ClientFinishSwitchMagazine");
		
		AItemFirearm_ClientFinishSwitchMagazine_Params params {};
		params.SwitchMagazineStateForSave = SwitchMagazineStateForSave;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056D2030
	 * 		Name   -> Function Insurgency.ItemFirearm.ClientFinishReloading
	 * 		Flags  -> (Net, NetReliable, Native, Event, Protected, NetClient)
	 */
	void AItemFirearm::ClientFinishReloading()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemFirearm.ClientFinishReloading");
		
		AItemFirearm_ClientFinishReloading_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056D1FE0
	 * 		Name   -> Function Insurgency.ItemFirearm.CanSwitchMagazine
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AItemFirearm::CanSwitchMagazine()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemFirearm.CanSwitchMagazine");
		
		AItemFirearm_CanSwitchMagazine_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056D1FB0
	 * 		Name   -> Function Insurgency.ItemFirearm.CanStartFire
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AItemFirearm::CanStartFire()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemFirearm.CanStartFire");
		
		AItemFirearm_CanStartFire_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056D1F80
	 * 		Name   -> Function Insurgency.ItemFirearm.CanInterruptFire
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AItemFirearm::CanInterruptFire()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemFirearm.CanInterruptFire");
		
		AItemFirearm_CanInterruptFire_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056D1F50
	 * 		Name   -> Function Insurgency.ItemFirearm.CanFire
	 * 		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AItemFirearm::CanFire()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemFirearm.CanFire");
		
		AItemFirearm_CanFire_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056D1F20
	 * 		Name   -> Function Insurgency.ItemFirearm.CanContinueFiring
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AItemFirearm::CanContinueFiring()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemFirearm.CanContinueFiring");
		
		AItemFirearm_CanContinueFiring_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056D2010
	 * 		Name   -> Function Insurgency.ItemFirearm.CancelBoltCycle
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void AItemFirearm::CancelBoltCycle()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemFirearm.CancelBoltCycle");
		
		AItemFirearm_CancelBoltCycle_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056D1EF0
	 * 		Name   -> Function Insurgency.ItemFirearm.CalcRecoilModifier
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	float AItemFirearm::CalcRecoilModifier()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemFirearm.CalcRecoilModifier");
		
		AItemFirearm_CalcRecoilModifier_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056D1E30
	 * 		Name   -> Function Insurgency.ItemFirearm.BroadcastFiremodeChange
	 * 		Flags  -> (Net, Native, Event, NetMulticast, Public)
	 * Parameters:
	 * 		EFirearmFiremode                                   OldFiremode                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EFirearmFiremode                                   NewFiremode                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AItemFirearm::BroadcastFiremodeChange(EFirearmFiremode OldFiremode, EFirearmFiremode NewFiremode)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemFirearm.BroadcastFiremodeChange");
		
		AItemFirearm_BroadcastFiremodeChange_Params params {};
		params.OldFiremode = OldFiremode;
		params.NewFiremode = NewFiremode;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> Function Insurgency.ItemFirearm.BlueprintOnSwitchMagazineInterrupt
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 * Parameters:
	 * 		float                                              AnimationInterruptTime                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AItemFirearm::BlueprintOnSwitchMagazineInterrupt(float AnimationInterruptTime)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemFirearm.BlueprintOnSwitchMagazineInterrupt");
		
		AItemFirearm_BlueprintOnSwitchMagazineInterrupt_Params params {};
		params.AnimationInterruptTime = AnimationInterruptTime;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> Function Insurgency.ItemFirearm.BlueprintOnSwitchMagazine
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 */
	void AItemFirearm::BlueprintOnSwitchMagazine()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemFirearm.BlueprintOnSwitchMagazine");
		
		AItemFirearm_BlueprintOnSwitchMagazine_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> Function Insurgency.ItemFirearm.BlueprintOnSpeedReload
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 */
	void AItemFirearm::BlueprintOnSpeedReload()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemFirearm.BlueprintOnSpeedReload");
		
		AItemFirearm_BlueprintOnSpeedReload_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> Function Insurgency.ItemFirearm.BlueprintOnReloadInterrupted
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 */
	void AItemFirearm::BlueprintOnReloadInterrupted()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemFirearm.BlueprintOnReloadInterrupted");
		
		AItemFirearm_BlueprintOnReloadInterrupted_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> Function Insurgency.ItemFirearm.BlueprintOnReloaded
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 */
	void AItemFirearm::BlueprintOnReloaded()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemFirearm.BlueprintOnReloaded");
		
		AItemFirearm_BlueprintOnReloaded_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> Function Insurgency.ItemFirearm.BlueprintOnReloadAfterSwitchMagazine
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 */
	void AItemFirearm::BlueprintOnReloadAfterSwitchMagazine()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemFirearm.BlueprintOnReloadAfterSwitchMagazine");
		
		AItemFirearm_BlueprintOnReloadAfterSwitchMagazine_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> Function Insurgency.ItemFirearm.BlueprintOnReload
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 */
	void AItemFirearm::BlueprintOnReload()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemFirearm.BlueprintOnReload");
		
		AItemFirearm_BlueprintOnReload_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> Function Insurgency.ItemFirearm.BlueprintOnFireStopping
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 */
	void AItemFirearm::BlueprintOnFireStopping()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemFirearm.BlueprintOnFireStopping");
		
		AItemFirearm_BlueprintOnFireStopping_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> Function Insurgency.ItemFirearm.BlueprintOnFireStop
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 */
	void AItemFirearm::BlueprintOnFireStop()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemFirearm.BlueprintOnFireStop");
		
		AItemFirearm_BlueprintOnFireStop_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> Function Insurgency.ItemFirearm.BlueprintOnFireStart
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 */
	void AItemFirearm::BlueprintOnFireStart()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemFirearm.BlueprintOnFireStart");
		
		AItemFirearm_BlueprintOnFireStart_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> Function Insurgency.ItemFirearm.BlueprintOnFire
	 * 		Flags  -> (Event, Protected, HasDefaults, BlueprintEvent)
	 * Parameters:
	 * 		struct FVector                                     Origin                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     Direction                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AItemFirearm::BlueprintOnFire(const struct FVector& Origin, const struct FVector& Direction)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemFirearm.BlueprintOnFire");
		
		AItemFirearm_BlueprintOnFire_Params params {};
		params.Origin = Origin;
		params.Direction = Direction;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> Function Insurgency.ItemFirearm.BlueprintOnDryFire
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 */
	void AItemFirearm::BlueprintOnDryFire()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemFirearm.BlueprintOnDryFire");
		
		AItemFirearm_BlueprintOnDryFire_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> Function Insurgency.ItemFirearm.BlueprintOnCycleFiremode
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 * Parameters:
	 * 		EFirearmFiremode                                   OldFiremode                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EFirearmFiremode                                   NewFiremode                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AItemFirearm::BlueprintOnCycleFiremode(EFirearmFiremode OldFiremode, EFirearmFiremode NewFiremode)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemFirearm.BlueprintOnCycleFiremode");
		
		AItemFirearm_BlueprintOnCycleFiremode_Params params {};
		params.OldFiremode = OldFiremode;
		params.NewFiremode = NewFiremode;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> Function Insurgency.ItemFirearm.BlueprintOnBoltCycle
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 */
	void AItemFirearm::BlueprintOnBoltCycle()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemFirearm.BlueprintOnBoltCycle");
		
		AItemFirearm_BlueprintOnBoltCycle_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056D1DA0
	 * 		Name   -> Function Insurgency.ItemFirearm.BeginBoltCycle
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bFromReplication                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AItemFirearm::BeginBoltCycle(bool bFromReplication)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemFirearm.BeginBoltCycle");
		
		AItemFirearm_BeginBoltCycle_Params params {};
		params.bFromReplication = bFromReplication;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> DelegateFunction Insurgency.ItemFirearm.AllowNextShotDelegate__DelegateSignature
	 * 		Flags  -> (Public, Delegate)
	 */
	bool AItemFirearm::AllowNextShotDelegate__DelegateSignature()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction Insurgency.ItemFirearm.AllowNextShotDelegate__DelegateSignature");
		
		AItemFirearm_AllowNextShotDelegate__DelegateSignature_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056D1D70
	 * 		Name   -> Function Insurgency.ItemFirearm.AllowNextShot
	 * 		Flags  -> (Native, Public, Const)
	 */
	bool AItemFirearm::AllowNextShot()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemFirearm.AllowNextShot");
		
		AItemFirearm_AllowNextShot_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> DelegateFunction Insurgency.ItemFirearm.AllowFireDelegate__DelegateSignature
	 * 		Flags  -> (Public, Delegate)
	 */
	bool AItemFirearm::AllowFireDelegate__DelegateSignature()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction Insurgency.ItemFirearm.AllowFireDelegate__DelegateSignature");
		
		AItemFirearm_AllowFireDelegate__DelegateSignature_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056D1D40
	 * 		Name   -> Function Insurgency.ItemFirearm.AllowFire
	 * 		Flags  -> (Final, Native, Public, Const)
	 */
	bool AItemFirearm::AllowFire()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemFirearm.AllowFire");
		
		AItemFirearm_AllowFire_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AItemFirearm.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AItemFirearm::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.ItemFirearm");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056D6FB0
	 * 		Name   -> Function Insurgency.ItemInteractableGear.ToggleGear
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void AItemInteractableGear::ToggleGear()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemInteractableGear.ToggleGear");
		
		AItemInteractableGear_ToggleGear_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056D6F30
	 * 		Name   -> Function Insurgency.ItemInteractableGear.SetEquipableState
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		EEquipableState                                    NewState                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AItemInteractableGear::SetEquipableState(EEquipableState NewState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemInteractableGear.SetEquipableState");
		
		AItemInteractableGear_SetEquipableState_Params params {};
		params.NewState = NewState;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056D6F10
	 * 		Name   -> Function Insurgency.ItemInteractableGear.OnTransitionComplete
	 * 		Flags  -> (Final, Native, Public)
	 */
	void AItemInteractableGear::OnTransitionComplete()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemInteractableGear.OnTransitionComplete");
		
		AItemInteractableGear_OnTransitionComplete_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056D6EF0
	 * 		Name   -> Function Insurgency.ItemInteractableGear.OnRep_EquipableState
	 * 		Flags  -> (Final, Native, Private)
	 */
	void AItemInteractableGear::OnRep_EquipableState()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemInteractableGear.OnRep_EquipableState");
		
		AItemInteractableGear_OnRep_EquipableState_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056D6E70
	 * 		Name   -> Function Insurgency.ItemInteractableGear.OnPutAwayWeaponForToggle
	 * 		Flags  -> (Native, Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		float                                              WeaponUnequipDuration                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AItemInteractableGear::OnPutAwayWeaponForToggle(float WeaponUnequipDuration)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemInteractableGear.OnPutAwayWeaponForToggle");
		
		AItemInteractableGear_OnPutAwayWeaponForToggle_Params params {};
		params.WeaponUnequipDuration = WeaponUnequipDuration;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056D6E50
	 * 		Name   -> Function Insurgency.ItemInteractableGear.MulticastOnCanceled
	 * 		Flags  -> (Net, Native, Event, NetMulticast, Public)
	 */
	void AItemInteractableGear::MulticastOnCanceled()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemInteractableGear.MulticastOnCanceled");
		
		AItemInteractableGear_MulticastOnCanceled_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056D6E20
	 * 		Name   -> Function Insurgency.ItemInteractableGear.IsUnequippingOrUnequipped
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AItemInteractableGear::IsUnequippingOrUnequipped()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemInteractableGear.IsUnequippingOrUnequipped");
		
		AItemInteractableGear_IsUnequippingOrUnequipped_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056D6DF0
	 * 		Name   -> Function Insurgency.ItemInteractableGear.IsUnequipping
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AItemInteractableGear::IsUnequipping()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemInteractableGear.IsUnequipping");
		
		AItemInteractableGear_IsUnequipping_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056D6DC0
	 * 		Name   -> Function Insurgency.ItemInteractableGear.IsUnequipped
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AItemInteractableGear::IsUnequipped()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemInteractableGear.IsUnequipped");
		
		AItemInteractableGear_IsUnequipped_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056D6D90
	 * 		Name   -> Function Insurgency.ItemInteractableGear.IsTransitioningTo
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AItemInteractableGear::IsTransitioningTo()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemInteractableGear.IsTransitioningTo");
		
		AItemInteractableGear_IsTransitioningTo_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056D6D60
	 * 		Name   -> Function Insurgency.ItemInteractableGear.IsInWeaponTransitionDelay
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AItemInteractableGear::IsInWeaponTransitionDelay()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemInteractableGear.IsInWeaponTransitionDelay");
		
		AItemInteractableGear_IsInWeaponTransitionDelay_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056D6D30
	 * 		Name   -> Function Insurgency.ItemInteractableGear.IsEquippingOrEquipped
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AItemInteractableGear::IsEquippingOrEquipped()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemInteractableGear.IsEquippingOrEquipped");
		
		AItemInteractableGear_IsEquippingOrEquipped_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056D6D00
	 * 		Name   -> Function Insurgency.ItemInteractableGear.IsEquipping
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AItemInteractableGear::IsEquipping()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemInteractableGear.IsEquipping");
		
		AItemInteractableGear_IsEquipping_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056D6CD0
	 * 		Name   -> Function Insurgency.ItemInteractableGear.IsEquipped
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AItemInteractableGear::IsEquipped()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemInteractableGear.IsEquipped");
		
		AItemInteractableGear_IsEquipped_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> DelegateFunction Insurgency.ItemInteractableGear.InteractableStateChangedDelegate__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 * Parameters:
	 * 		class AItemInteractableGear*                       Gear                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EEquipableState                                    NewState                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AItemInteractableGear::InteractableStateChangedDelegate__DelegateSignature(class AItemInteractableGear* Gear, EEquipableState NewState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction Insurgency.ItemInteractableGear.InteractableStateChangedDelegate__DelegateSignature");
		
		AItemInteractableGear_InteractableStateChangedDelegate__DelegateSignature_Params params {};
		params.Gear = Gear;
		params.NewState = NewState;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056D6CA0
	 * 		Name   -> Function Insurgency.ItemInteractableGear.GetInteractableGearType
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	EInteractableGearType AItemInteractableGear::GetInteractableGearType()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemInteractableGear.GetInteractableGearType");
		
		AItemInteractableGear_GetInteractableGearType_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056D6C70
	 * 		Name   -> Function Insurgency.ItemInteractableGear.GetEquipableState
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	EEquipableState AItemInteractableGear::GetEquipableState()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemInteractableGear.GetEquipableState");
		
		AItemInteractableGear_GetEquipableState_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> Function Insurgency.ItemInteractableGear.BlueprintInteractableStateChanged
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		EEquipableState                                    NewState                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AItemInteractableGear::BlueprintInteractableStateChanged(EEquipableState NewState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemInteractableGear.BlueprintInteractableStateChanged");
		
		AItemInteractableGear_BlueprintInteractableStateChanged_Params params {};
		params.NewState = NewState;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AItemInteractableGear.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AItemInteractableGear::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.ItemInteractableGear");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00C76AB0
	 * 		Name   -> Function Insurgency.ItemGoggles.OnRep_Active
	 * 		Flags  -> (Final, Native, Public)
	 */
	void AItemGoggles::OnRep_Active()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemGoggles.OnRep_Active");
		
		AItemGoggles_OnRep_Active_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056D4FB0
	 * 		Name   -> Function Insurgency.ItemGoggles.MulticastPlayToggleAudioCue
	 * 		Flags  -> (Net, Native, Event, NetMulticast, Public)
	 * Parameters:
	 * 		bool                                               bEquip                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AItemGoggles::MulticastPlayToggleAudioCue(bool bEquip)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemGoggles.MulticastPlayToggleAudioCue");
		
		AItemGoggles_MulticastPlayToggleAudioCue_Params params {};
		params.bEquip = bEquip;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> Function Insurgency.ItemGoggles.AttachGogglesToComponent
	 * 		Flags  -> (Event, Public, BlueprintCallable, BlueprintEvent)
	 * Parameters:
	 * 		class UINSSkeletalMeshComponent*                   TargetComponent                                            (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AItemGoggles::AttachGogglesToComponent(class UINSSkeletalMeshComponent* TargetComponent)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemGoggles.AttachGogglesToComponent");
		
		AItemGoggles_AttachGogglesToComponent_Params params {};
		params.TargetComponent = TargetComponent;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AItemGoggles.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AItemGoggles::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.ItemGoggles");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056D62D0
	 * 		Name   -> Function Insurgency.ItemGrenade.SetThrowMode
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		EGrenadeThrowMode                                  NewThrowMode                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AItemGrenade::SetThrowMode(EGrenadeThrowMode NewThrowMode)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemGrenade.SetThrowMode");
		
		AItemGrenade_SetThrowMode_Params params {};
		params.NewThrowMode = NewThrowMode;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056D6250
	 * 		Name   -> Function Insurgency.ItemGrenade.SetGrenadeState
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		EGrenadeState                                      NewGrenadeState                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AItemGrenade::SetGrenadeState(EGrenadeState NewGrenadeState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemGrenade.SetGrenadeState");
		
		AItemGrenade_SetGrenadeState_Params params {};
		params.NewGrenadeState = NewGrenadeState;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056D6200
	 * 		Name   -> Function Insurgency.ItemGrenade.ServerStartCook
	 * 		Flags  -> (Net, NetReliable, Native, Event, Protected, NetServer, NetValidate)
	 */
	void AItemGrenade::ServerStartCook()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemGrenade.ServerStartCook");
		
		AItemGrenade_ServerStartCook_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056D6140
	 * 		Name   -> Function Insurgency.ItemGrenade.ServerSetHold
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
	 * Parameters:
	 * 		bool                                               Val                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AItemGrenade::ServerSetHold(bool Val)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemGrenade.ServerSetHold");
		
		AItemGrenade_ServerSetHold_Params params {};
		params.Val = Val;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056D60F0
	 * 		Name   -> Function Insurgency.ItemGrenade.ServerReleaseThrow
	 * 		Flags  -> (Net, NetReliable, Native, Event, Protected, NetServer, NetValidate)
	 */
	void AItemGrenade::ServerReleaseThrow()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemGrenade.ServerReleaseThrow");
		
		AItemGrenade_ServerReleaseThrow_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056D6050
	 * 		Name   -> Function Insurgency.ItemGrenade.ServerPullBack
	 * 		Flags  -> (Net, NetReliable, Native, Event, Protected, NetServer, NetValidate)
	 * Parameters:
	 * 		EGrenadeThrowMode                                  NewThrowMode                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AItemGrenade::ServerPullBack(EGrenadeThrowMode NewThrowMode)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemGrenade.ServerPullBack");
		
		AItemGrenade_ServerPullBack_Params params {};
		params.NewThrowMode = NewThrowMode;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056D6030
	 * 		Name   -> Function Insurgency.ItemGrenade.OnRep_ThrowMode
	 * 		Flags  -> (Final, Native, Protected)
	 */
	void AItemGrenade::OnRep_ThrowMode()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemGrenade.OnRep_ThrowMode");
		
		AItemGrenade_OnRep_ThrowMode_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056D6010
	 * 		Name   -> Function Insurgency.ItemGrenade.OnRep_ProjectileInHand
	 * 		Flags  -> (Final, Native, Public)
	 */
	void AItemGrenade::OnRep_ProjectileInHand()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemGrenade.OnRep_ProjectileInHand");
		
		AItemGrenade_OnRep_ProjectileInHand_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056D5FF0
	 * 		Name   -> Function Insurgency.ItemGrenade.OnRep_GrenadeState
	 * 		Flags  -> (Final, Native, Protected)
	 */
	void AItemGrenade::OnRep_GrenadeState()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemGrenade.OnRep_GrenadeState");
		
		AItemGrenade_OnRep_GrenadeState_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> DelegateFunction Insurgency.ItemGrenade.OnHotGrenadePickedUpDelegate__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 */
	void AItemGrenade::OnHotGrenadePickedUpDelegate__DelegateSignature()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction Insurgency.ItemGrenade.OnHotGrenadePickedUpDelegate__DelegateSignature");
		
		AItemGrenade_OnHotGrenadePickedUpDelegate__DelegateSignature_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> DelegateFunction Insurgency.ItemGrenade.OnGrenadeThrowModeChangedDelegate__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 * Parameters:
	 * 		EGrenadeThrowMode                                  OldThrowMode                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AItemGrenade::OnGrenadeThrowModeChangedDelegate__DelegateSignature(EGrenadeThrowMode OldThrowMode)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction Insurgency.ItemGrenade.OnGrenadeThrowModeChangedDelegate__DelegateSignature");
		
		AItemGrenade_OnGrenadeThrowModeChangedDelegate__DelegateSignature_Params params {};
		params.OldThrowMode = OldThrowMode;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> DelegateFunction Insurgency.ItemGrenade.OnGrenadeStateChangedDelegate__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 * Parameters:
	 * 		EGrenadeState                                      OldState                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AItemGrenade::OnGrenadeStateChangedDelegate__DelegateSignature(EGrenadeState OldState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction Insurgency.ItemGrenade.OnGrenadeStateChangedDelegate__DelegateSignature");
		
		AItemGrenade_OnGrenadeStateChangedDelegate__DelegateSignature_Params params {};
		params.OldState = OldState;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> DelegateFunction Insurgency.ItemGrenade.OnGrenadeSpawnedDelegate__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 * Parameters:
	 * 		class AProjectileBase*                             NewProjectile                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AItemGrenade::OnGrenadeSpawnedDelegate__DelegateSignature(class AProjectileBase* NewProjectile)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction Insurgency.ItemGrenade.OnGrenadeSpawnedDelegate__DelegateSignature");
		
		AItemGrenade_OnGrenadeSpawnedDelegate__DelegateSignature_Params params {};
		params.NewProjectile = NewProjectile;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> DelegateFunction Insurgency.ItemGrenade.OnGrenadeReloadDelegate__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 */
	void AItemGrenade::OnGrenadeReloadDelegate__DelegateSignature()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction Insurgency.ItemGrenade.OnGrenadeReloadDelegate__DelegateSignature");
		
		AItemGrenade_OnGrenadeReloadDelegate__DelegateSignature_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> DelegateFunction Insurgency.ItemGrenade.OnGrenadePullbackDelegate__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 * Parameters:
	 * 		EGrenadeThrowMode                                  ThrowMode                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AItemGrenade::OnGrenadePullbackDelegate__DelegateSignature(EGrenadeThrowMode ThrowMode)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction Insurgency.ItemGrenade.OnGrenadePullbackDelegate__DelegateSignature");
		
		AItemGrenade_OnGrenadePullbackDelegate__DelegateSignature_Params params {};
		params.ThrowMode = ThrowMode;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> DelegateFunction Insurgency.ItemGrenade.OnGrenadeBeginThrowDelegate__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 */
	void AItemGrenade::OnGrenadeBeginThrowDelegate__DelegateSignature()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction Insurgency.ItemGrenade.OnGrenadeBeginThrowDelegate__DelegateSignature");
		
		AItemGrenade_OnGrenadeBeginThrowDelegate__DelegateSignature_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> DelegateFunction Insurgency.ItemGrenade.OnGrenadeBeginCookDelegate__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 * Parameters:
	 * 		EGrenadeThrowMode                                  NewThrowMode                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AItemGrenade::OnGrenadeBeginCookDelegate__DelegateSignature(EGrenadeThrowMode NewThrowMode)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction Insurgency.ItemGrenade.OnGrenadeBeginCookDelegate__DelegateSignature");
		
		AItemGrenade_OnGrenadeBeginCookDelegate__DelegateSignature_Params params {};
		params.NewThrowMode = NewThrowMode;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056D5FC0
	 * 		Name   -> Function Insurgency.ItemGrenade.IsThrowingAndInHand
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AItemGrenade::IsThrowingAndInHand()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemGrenade.IsThrowingAndInHand");
		
		AItemGrenade_IsThrowingAndInHand_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056D5F90
	 * 		Name   -> Function Insurgency.ItemGrenade.IsThrowing
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AItemGrenade::IsThrowing()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemGrenade.IsThrowing");
		
		AItemGrenade_IsThrowing_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056D5F60
	 * 		Name   -> Function Insurgency.ItemGrenade.IsPullingBack
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AItemGrenade::IsPullingBack()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemGrenade.IsPullingBack");
		
		AItemGrenade_IsPullingBack_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056D5F30
	 * 		Name   -> Function Insurgency.ItemGrenade.IsPrimedForThrow
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AItemGrenade::IsPrimedForThrow()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemGrenade.IsPrimedForThrow");
		
		AItemGrenade_IsPrimedForThrow_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056D5F00
	 * 		Name   -> Function Insurgency.ItemGrenade.IsPinPulled
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AItemGrenade::IsPinPulled()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemGrenade.IsPinPulled");
		
		AItemGrenade_IsPinPulled_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056D5ED0
	 * 		Name   -> Function Insurgency.ItemGrenade.IsOverhandThrow
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AItemGrenade::IsOverhandThrow()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemGrenade.IsOverhandThrow");
		
		AItemGrenade_IsOverhandThrow_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056D5EA0
	 * 		Name   -> Function Insurgency.ItemGrenade.IsInCookingState
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AItemGrenade::IsInCookingState()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemGrenade.IsInCookingState");
		
		AItemGrenade_IsInCookingState_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056D5E70
	 * 		Name   -> Function Insurgency.ItemGrenade.IsGrenadeBusy
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AItemGrenade::IsGrenadeBusy()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemGrenade.IsGrenadeBusy");
		
		AItemGrenade_IsGrenadeBusy_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056D5E40
	 * 		Name   -> Function Insurgency.ItemGrenade.IsCooking
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AItemGrenade::IsCooking()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemGrenade.IsCooking");
		
		AItemGrenade_IsCooking_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056D5E10
	 * 		Name   -> Function Insurgency.ItemGrenade.GetUpwardsThrowSpeed
	 * 		Flags  -> (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
	 */
	float AItemGrenade::GetUpwardsThrowSpeed()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemGrenade.GetUpwardsThrowSpeed");
		
		AItemGrenade_GetUpwardsThrowSpeed_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056D5DE0
	 * 		Name   -> Function Insurgency.ItemGrenade.GetThrowSpeed
	 * 		Flags  -> (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
	 */
	float AItemGrenade::GetThrowSpeed()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemGrenade.GetThrowSpeed");
		
		AItemGrenade_GetThrowSpeed_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056D5DB0
	 * 		Name   -> Function Insurgency.ItemGrenade.GetThrowMode
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	EGrenadeThrowMode AItemGrenade::GetThrowMode()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemGrenade.GetThrowMode");
		
		AItemGrenade_GetThrowMode_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056D5D80
	 * 		Name   -> Function Insurgency.ItemGrenade.GetSpawnedGrenadeTimer
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	float AItemGrenade::GetSpawnedGrenadeTimer()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemGrenade.GetSpawnedGrenadeTimer");
		
		AItemGrenade_GetSpawnedGrenadeTimer_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056D5D50
	 * 		Name   -> Function Insurgency.ItemGrenade.GetGrenadeState
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	EGrenadeState AItemGrenade::GetGrenadeState()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemGrenade.GetGrenadeState");
		
		AItemGrenade_GetGrenadeState_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056D5CC0
	 * 		Name   -> Function Insurgency.ItemGrenade.DropGrenade
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bDeath                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AItemGrenade::DropGrenade(bool bDeath)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemGrenade.DropGrenade");
		
		AItemGrenade_DropGrenade_Params params {};
		params.bDeath = bDeath;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056D5C90
	 * 		Name   -> Function Insurgency.ItemGrenade.CanThrow
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AItemGrenade::CanThrow()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemGrenade.CanThrow");
		
		AItemGrenade_CanThrow_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056D5C60
	 * 		Name   -> Function Insurgency.ItemGrenade.CanPullback
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AItemGrenade::CanPullback()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemGrenade.CanPullback");
		
		AItemGrenade_CanPullback_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AItemGrenade.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AItemGrenade::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.ItemGrenade");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AItemHeavyMachineGun.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AItemHeavyMachineGun::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.ItemHeavyMachineGun");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056D7AB0
	 * 		Name   -> Function Insurgency.ItemMeleeWeapon.ServerStartSwing
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
	 * Parameters:
	 * 		int32_t                                            AttackIndex                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AItemMeleeWeapon::ServerStartSwing(int32_t AttackIndex)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemMeleeWeapon.ServerStartSwing");
		
		AItemMeleeWeapon_ServerStartSwing_Params params {};
		params.AttackIndex = AttackIndex;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056D7960
	 * 		Name   -> Function Insurgency.ItemMeleeWeapon.ServerNotifyHit
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
	 * Parameters:
	 * 		struct FHitResult                                  Hit                                                        (ConstParm, Parm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 * 		float                                              ClientTime                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AItemMeleeWeapon::ServerNotifyHit(const struct FHitResult& Hit, float ClientTime)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemMeleeWeapon.ServerNotifyHit");
		
		AItemMeleeWeapon_ServerNotifyHit_Params params {};
		params.Hit = Hit;
		params.ClientTime = ClientTime;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056D7930
	 * 		Name   -> Function Insurgency.ItemMeleeWeapon.IsSwinging
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AItemMeleeWeapon::IsSwinging()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemMeleeWeapon.IsSwinging");
		
		AItemMeleeWeapon_IsSwinging_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056D7900
	 * 		Name   -> Function Insurgency.ItemMeleeWeapon.InSwingDelay
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AItemMeleeWeapon::InSwingDelay()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemMeleeWeapon.InSwingDelay");
		
		AItemMeleeWeapon_InSwingDelay_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056D78D0
	 * 		Name   -> Function Insurgency.ItemMeleeWeapon.GetSwingRemainingTime
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	float AItemMeleeWeapon::GetSwingRemainingTime()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemMeleeWeapon.GetSwingRemainingTime");
		
		AItemMeleeWeapon_GetSwingRemainingTime_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056D78A0
	 * 		Name   -> Function Insurgency.ItemMeleeWeapon.GetSwingPercentage
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	float AItemMeleeWeapon::GetSwingPercentage()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemMeleeWeapon.GetSwingPercentage");
		
		AItemMeleeWeapon_GetSwingPercentage_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056D7870
	 * 		Name   -> Function Insurgency.ItemMeleeWeapon.GetNextSwingTime
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	float AItemMeleeWeapon::GetNextSwingTime()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemMeleeWeapon.GetNextSwingTime");
		
		AItemMeleeWeapon_GetNextSwingTime_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056D7840
	 * 		Name   -> Function Insurgency.ItemMeleeWeapon.CanSwing
	 * 		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AItemMeleeWeapon::CanSwing()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemMeleeWeapon.CanSwing");
		
		AItemMeleeWeapon_CanSwing_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056D77C0
	 * 		Name   -> Function Insurgency.ItemMeleeWeapon.BroadcastStartSwing
	 * 		Flags  -> (Net, NetReliable, Native, Event, NetMulticast, Public)
	 * Parameters:
	 * 		int32_t                                            AttackIndex                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AItemMeleeWeapon::BroadcastStartSwing(int32_t AttackIndex)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemMeleeWeapon.BroadcastStartSwing");
		
		AItemMeleeWeapon_BroadcastStartSwing_Params params {};
		params.AttackIndex = AttackIndex;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056D7700
	 * 		Name   -> Function Insurgency.ItemMeleeWeapon.BroadcastHit
	 * 		Flags  -> (Net, NetReliable, Native, Event, NetMulticast, Public)
	 * Parameters:
	 * 		struct FHitResult                                  Hit                                                        (ConstParm, Parm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	void AItemMeleeWeapon::BroadcastHit(const struct FHitResult& Hit)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemMeleeWeapon.BroadcastHit");
		
		AItemMeleeWeapon_BroadcastHit_Params params {};
		params.Hit = Hit;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> Function Insurgency.ItemMeleeWeapon.BlueprintOnSwing
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 */
	void AItemMeleeWeapon::BlueprintOnSwing()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemMeleeWeapon.BlueprintOnSwing");
		
		AItemMeleeWeapon_BlueprintOnSwing_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> Function Insurgency.ItemMeleeWeapon.BlueprintOnHit
	 * 		Flags  -> (Event, Public, HasOutParms, BlueprintEvent)
	 * Parameters:
	 * 		struct FHitResult                                  Hit                                                        (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	void AItemMeleeWeapon::BlueprintOnHit(const struct FHitResult& Hit)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemMeleeWeapon.BlueprintOnHit");
		
		AItemMeleeWeapon_BlueprintOnHit_Params params {};
		params.Hit = Hit;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056D7620
	 * 		Name   -> Function Insurgency.ItemMeleeWeapon.ApplyDamageForHit
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		struct FHitResult                                  Hit                                                        (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	void AItemMeleeWeapon::ApplyDamageForHit(const struct FHitResult& Hit)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemMeleeWeapon.ApplyDamageForHit");
		
		AItemMeleeWeapon_ApplyDamageForHit_Params params {};
		params.Hit = Hit;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AItemMeleeWeapon.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AItemMeleeWeapon::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.ItemMeleeWeapon");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056D7D60
	 * 		Name   -> Function Insurgency.ItemMinigun.IsUsingSpinUpTime
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AItemMinigun::IsUsingSpinUpTime()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemMinigun.IsUsingSpinUpTime");
		
		AItemMinigun_IsUsingSpinUpTime_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056D7D30
	 * 		Name   -> Function Insurgency.ItemMinigun.IsSpunUp
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AItemMinigun::IsSpunUp()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemMinigun.IsSpunUp");
		
		AItemMinigun_IsSpunUp_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AItemMinigun.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AItemMinigun::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.ItemMinigun");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056D7F00
	 * 		Name   -> Function Insurgency.ItemNightVision.SpawnGearUpgrade
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UClass*                                      UpgradeClass                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UGearUpgradeComponent* AItemNightVision::SpawnGearUpgrade(class UClass* UpgradeClass)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemNightVision.SpawnGearUpgrade");
		
		AItemNightVision_SpawnGearUpgrade_Params params {};
		params.UpgradeClass = UpgradeClass;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AItemNightVision.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AItemNightVision::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.ItemNightVision");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056D8D80
	 * 		Name   -> Function Insurgency.ItemPickupDynamic.SetPickupItemAndUpgrades
	 * 		Flags  -> (Final, BlueprintAuthorityOnly, Native, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		class UClass*                                      InItemClass                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		TArray<class UClass*>                              InUpgrades                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AItemPickupDynamic::SetPickupItemAndUpgrades(class UClass* InItemClass, TArray<class UClass*> InUpgrades)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemPickupDynamic.SetPickupItemAndUpgrades");
		
		AItemPickupDynamic_SetPickupItemAndUpgrades_Params params {};
		params.InItemClass = InItemClass;
		params.InUpgrades = InUpgrades;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056D8D00
	 * 		Name   -> Function Insurgency.ItemPickupDynamic.SetPickupItem
	 * 		Flags  -> (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UClass*                                      InItemClass                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AItemPickupDynamic::SetPickupItem(class UClass* InItemClass)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemPickupDynamic.SetPickupItem");
		
		AItemPickupDynamic_SetPickupItem_Params params {};
		params.InItemClass = InItemClass;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056D8C30
	 * 		Name   -> Function Insurgency.ItemPickupDynamic.SetLockedUser
	 * 		Flags  -> (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class AINSSoldier*                                 InLockedUser                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              OverrideLockoutTimer                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AItemPickupDynamic::SetLockedUser(class AINSSoldier* InLockedUser, float OverrideLockoutTimer)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemPickupDynamic.SetLockedUser");
		
		AItemPickupDynamic_SetLockedUser_Params params {};
		params.InLockedUser = InLockedUser;
		params.OverrideLockoutTimer = OverrideLockoutTimer;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056D8C10
	 * 		Name   -> Function Insurgency.ItemPickupDynamic.ClearLockedUser
	 * 		Flags  -> (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
	 */
	void AItemPickupDynamic::ClearLockedUser()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemPickupDynamic.ClearLockedUser");
		
		AItemPickupDynamic_ClearLockedUser_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AItemPickupDynamic.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AItemPickupDynamic::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.ItemPickupDynamic");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056D9FA0
	 * 		Name   -> Function Insurgency.ItemRemoteExplosive.SwitchToDetonator
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void AItemRemoteExplosive::SwitchToDetonator()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemRemoteExplosive.SwitchToDetonator");
		
		AItemRemoteExplosive_SwitchToDetonator_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056D9F20
	 * 		Name   -> Function Insurgency.ItemRemoteExplosive.OnGrenadeSpawned
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		class AProjectileBase*                             NewProjectile                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AItemRemoteExplosive::OnGrenadeSpawned(class AProjectileBase* NewProjectile)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemRemoteExplosive.OnGrenadeSpawned");
		
		AItemRemoteExplosive_OnGrenadeSpawned_Params params {};
		params.NewProjectile = NewProjectile;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AItemRemoteExplosive.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AItemRemoteExplosive::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.ItemRemoteExplosive");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056D9710
	 * 		Name   -> Function Insurgency.ItemPlantedExplosive.TracePlantTargetDest
	 * 		Flags  -> (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FHitResult                                  OutHitResult                                               (Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     FromLocation                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     DestLocation                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool AItemPlantedExplosive::TracePlantTargetDest(struct FHitResult* OutHitResult, const struct FVector& FromLocation, const struct FVector& DestLocation)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemPlantedExplosive.TracePlantTargetDest");
		
		AItemPlantedExplosive_TracePlantTargetDest_Params params {};
		params.FromLocation = FromLocation;
		params.DestLocation = DestLocation;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutHitResult != nullptr)
			*OutHitResult = params.OutHitResult;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056D9630
	 * 		Name   -> Function Insurgency.ItemPlantedExplosive.TracePlantTarget
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		struct FHitResult                                  OutHitResult                                               (Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	bool AItemPlantedExplosive::TracePlantTarget(struct FHitResult* OutHitResult)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemPlantedExplosive.TracePlantTarget");
		
		AItemPlantedExplosive_TracePlantTarget_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutHitResult != nullptr)
			*OutHitResult = params.OutHitResult;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056D9550
	 * 		Name   -> Function Insurgency.ItemPlantedExplosive.SetupPlant
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		struct FHitResult                                  PlantTrace                                                 (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	void AItemPlantedExplosive::SetupPlant(const struct FHitResult& PlantTrace)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemPlantedExplosive.SetupPlant");
		
		AItemPlantedExplosive_SetupPlant_Params params {};
		params.PlantTrace = PlantTrace;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056D9470
	 * 		Name   -> Function Insurgency.ItemPlantedExplosive.SetPlantLocationFromTrace
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		struct FHitResult                                  PlantTrace                                                 (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	void AItemPlantedExplosive::SetPlantLocationFromTrace(const struct FHitResult& PlantTrace)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemPlantedExplosive.SetPlantLocationFromTrace");
		
		AItemPlantedExplosive_SetPlantLocationFromTrace_Params params {};
		params.PlantTrace = PlantTrace;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056D9420
	 * 		Name   -> Function Insurgency.ItemPlantedExplosive.ServerStartPlant
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
	 */
	void AItemPlantedExplosive::ServerStartPlant()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemPlantedExplosive.ServerStartPlant");
		
		AItemPlantedExplosive_ServerStartPlant_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056D93D0
	 * 		Name   -> Function Insurgency.ItemPlantedExplosive.ServerPlantAbandoned
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
	 */
	void AItemPlantedExplosive::ServerPlantAbandoned()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemPlantedExplosive.ServerPlantAbandoned");
		
		AItemPlantedExplosive_ServerPlantAbandoned_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056D93B0
	 * 		Name   -> Function Insurgency.ItemPlantedExplosive.OnRep_Planting
	 * 		Flags  -> (Final, Native, Public)
	 */
	void AItemPlantedExplosive::OnRep_Planting()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemPlantedExplosive.OnRep_Planting");
		
		AItemPlantedExplosive_OnRep_Planting_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> DelegateFunction Insurgency.ItemPlantedExplosive.OnPlantStartDelegate__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 */
	void AItemPlantedExplosive::OnPlantStartDelegate__DelegateSignature()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction Insurgency.ItemPlantedExplosive.OnPlantStartDelegate__DelegateSignature");
		
		AItemPlantedExplosive_OnPlantStartDelegate__DelegateSignature_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> DelegateFunction Insurgency.ItemPlantedExplosive.OnPlantFinishedDelegate__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 */
	void AItemPlantedExplosive::OnPlantFinishedDelegate__DelegateSignature()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction Insurgency.ItemPlantedExplosive.OnPlantFinishedDelegate__DelegateSignature");
		
		AItemPlantedExplosive_OnPlantFinishedDelegate__DelegateSignature_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> DelegateFunction Insurgency.ItemPlantedExplosive.OnPlantAbandonedDelegate__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 */
	void AItemPlantedExplosive::OnPlantAbandonedDelegate__DelegateSignature()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction Insurgency.ItemPlantedExplosive.OnPlantAbandonedDelegate__DelegateSignature");
		
		AItemPlantedExplosive_OnPlantAbandonedDelegate__DelegateSignature_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056D9390
	 * 		Name   -> Function Insurgency.ItemPlantedExplosive.MulticastOnPlantComplete
	 * 		Flags  -> (Net, NetReliable, Native, Event, NetMulticast, Public)
	 */
	void AItemPlantedExplosive::MulticastOnPlantComplete()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemPlantedExplosive.MulticastOnPlantComplete");
		
		AItemPlantedExplosive_MulticastOnPlantComplete_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x04DB3920
	 * 		Name   -> Function Insurgency.ItemPlantedExplosive.ClientAbandonPlant
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetClient)
	 */
	void AItemPlantedExplosive::ClientAbandonPlant()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemPlantedExplosive.ClientAbandonPlant");
		
		AItemPlantedExplosive_ClientAbandonPlant_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AItemPlantedExplosive.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AItemPlantedExplosive::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.ItemPlantedExplosive");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056D9C40
	 * 		Name   -> Function Insurgency.ItemRadio.RadiusEndOverlap
	 * 		Flags  -> (Final, Native, Private)
	 * Parameters:
	 * 		class UPrimitiveComponent*                         OverlappedComponent                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      OtherActor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UPrimitiveComponent*                         OtherComp                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            OtherBodyIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AItemRadio::RadiusEndOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32_t OtherBodyIndex)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemRadio.RadiusEndOverlap");
		
		AItemRadio_RadiusEndOverlap_Params params {};
		params.OverlappedComponent = OverlappedComponent;
		params.OtherActor = OtherActor;
		params.OtherComp = OtherComp;
		params.OtherBodyIndex = OtherBodyIndex;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056D9A30
	 * 		Name   -> Function Insurgency.ItemRadio.RadiusBeginOverlap
	 * 		Flags  -> (Final, Native, Private, HasOutParms)
	 * Parameters:
	 * 		class UPrimitiveComponent*                         OverlappedComponent                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      OtherActor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UPrimitiveComponent*                         OtherComp                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            OtherBodyIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bFromSweep                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FHitResult                                  SweepResult                                                (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	void AItemRadio::RadiusBeginOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32_t OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemRadio.RadiusBeginOverlap");
		
		AItemRadio_RadiusBeginOverlap_Params params {};
		params.OverlappedComponent = OverlappedComponent;
		params.OtherActor = OtherActor;
		params.OtherComp = OtherComp;
		params.OtherBodyIndex = OtherBodyIndex;
		params.bFromSweep = bFromSweep;
		params.SweepResult = SweepResult;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AItemRadio.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AItemRadio::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.ItemRadio");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056DA5B0
	 * 		Name   -> Function Insurgency.ItemRevolver.OnRep_CurrentChamberIndex
	 * 		Flags  -> (Final, Native, Private)
	 */
	void AItemRevolver::OnRep_CurrentChamberIndex()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemRevolver.OnRep_CurrentChamberIndex");
		
		AItemRevolver_OnRep_CurrentChamberIndex_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056DA590
	 * 		Name   -> Function Insurgency.ItemRevolver.OnRep_ChamberStates
	 * 		Flags  -> (Final, Native, Private)
	 */
	void AItemRevolver::OnRep_ChamberStates()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemRevolver.OnRep_ChamberStates");
		
		AItemRevolver_OnRep_ChamberStates_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> DelegateFunction Insurgency.ItemRevolver.OnChamberStatesUpdateDelegate__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 */
	void AItemRevolver::OnChamberStatesUpdateDelegate__DelegateSignature()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction Insurgency.ItemRevolver.OnChamberStatesUpdateDelegate__DelegateSignature");
		
		AItemRevolver_OnChamberStatesUpdateDelegate__DelegateSignature_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> DelegateFunction Insurgency.ItemRevolver.OnActiveChamberUpdatedDelegate__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 */
	void AItemRevolver::OnActiveChamberUpdatedDelegate__DelegateSignature()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction Insurgency.ItemRevolver.OnActiveChamberUpdatedDelegate__DelegateSignature");
		
		AItemRevolver_OnActiveChamberUpdatedDelegate__DelegateSignature_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056DA500
	 * 		Name   -> Function Insurgency.ItemRevolver.HasAnyChamberInState
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		ERevolverChamberState                              ChamberState                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool AItemRevolver::HasAnyChamberInState(ERevolverChamberState ChamberState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemRevolver.HasAnyChamberInState");
		
		AItemRevolver_HasAnyChamberInState_Params params {};
		params.ChamberState = ChamberState;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056DA4D0
	 * 		Name   -> Function Insurgency.ItemRevolver.GetCurrentChamberState
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	ERevolverChamberState AItemRevolver::GetCurrentChamberState()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemRevolver.GetCurrentChamberState");
		
		AItemRevolver_GetCurrentChamberState_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056DA4A0
	 * 		Name   -> Function Insurgency.ItemRevolver.CountFiredChambers
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	int32_t AItemRevolver::CountFiredChambers()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemRevolver.CountFiredChambers");
		
		AItemRevolver_CountFiredChambers_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056DA410
	 * 		Name   -> Function Insurgency.ItemRevolver.CountChambersInState
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		ERevolverChamberState                              ChamberState                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	int32_t AItemRevolver::CountChambersInState(ERevolverChamberState ChamberState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemRevolver.CountChambersInState");
		
		AItemRevolver_CountChambersInState_Params params {};
		params.ChamberState = ChamberState;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056DA3E0
	 * 		Name   -> Function Insurgency.ItemRevolver.AreAllChambersEmpty
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AItemRevolver::AreAllChambersEmpty()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ItemRevolver.AreAllChambersEmpty");
		
		AItemRevolver_AreAllChambersEmpty_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AItemRevolver.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AItemRevolver::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.ItemRevolver");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AItemStripper.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AItemStripper::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.ItemStripper");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x057057B0
	 * 		Name   -> Function Insurgency.OptionsMenu.SavePlayerSettings
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void UOptionsMenu::SavePlayerSettings()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.OptionsMenu.SavePlayerSettings");
		
		UOptionsMenu_SavePlayerSettings_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x04DB5D40
	 * 		Name   -> Function Insurgency.OptionsMenu.ResetToDefaults
	 * 		Flags  -> (Native, Public, BlueprintCallable)
	 */
	void UOptionsMenu::ResetToDefaults()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.OptionsMenu.ResetToDefaults");
		
		UOptionsMenu_ResetToDefaults_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x04DB5D60
	 * 		Name   -> Function Insurgency.OptionsMenu.RefreshSettings
	 * 		Flags  -> (Native, Public, BlueprintCallable)
	 */
	void UOptionsMenu::RefreshSettings()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.OptionsMenu.RefreshSettings");
		
		UOptionsMenu_RefreshSettings_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05705790
	 * 		Name   -> Function Insurgency.OptionsMenu.MarkSettingsDirty
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void UOptionsMenu::MarkSettingsDirty()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.OptionsMenu.MarkSettingsDirty");
		
		UOptionsMenu_MarkSettingsDirty_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05705760
	 * 		Name   -> Function Insurgency.OptionsMenu.GetUserSettings
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	class UINSGameUserSettings* UOptionsMenu::GetUserSettings()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.OptionsMenu.GetUserSettings");
		
		UOptionsMenu_GetUserSettings_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05705730
	 * 		Name   -> Function Insurgency.OptionsMenu.GetLocalProfile
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	class UINSPlayerLocalProfile* UOptionsMenu::GetLocalProfile()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.OptionsMenu.GetLocalProfile");
		
		UOptionsMenu_GetLocalProfile_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> Function Insurgency.OptionsMenu.BlueprintResetToDefaults
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 */
	void UOptionsMenu::BlueprintResetToDefaults()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.OptionsMenu.BlueprintResetToDefaults");
		
		UOptionsMenu_BlueprintResetToDefaults_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> Function Insurgency.OptionsMenu.BlueprintRefreshSettings
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 */
	void UOptionsMenu::BlueprintRefreshSettings()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.OptionsMenu.BlueprintRefreshSettings");
		
		UOptionsMenu_BlueprintRefreshSettings_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> Function Insurgency.OptionsMenu.BlueprintApplyChanges
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 */
	void UOptionsMenu::BlueprintApplyChanges()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.OptionsMenu.BlueprintApplyChanges");
		
		UOptionsMenu_BlueprintApplyChanges_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x04DB5D80
	 * 		Name   -> Function Insurgency.OptionsMenu.ApplyChanges
	 * 		Flags  -> (Native, Public, BlueprintCallable)
	 */
	void UOptionsMenu::ApplyChanges()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.OptionsMenu.ApplyChanges");
		
		UOptionsMenu_ApplyChanges_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UOptionsMenu.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UOptionsMenu::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.OptionsMenu");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056E0190
	 * 		Name   -> Function Insurgency.KeyBindingsMenu.UpdateKeyBindings
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void UKeyBindingsMenu::UpdateKeyBindings()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.KeyBindingsMenu.UpdateKeyBindings");
		
		UKeyBindingsMenu_UpdateKeyBindings_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056E0020
	 * 		Name   -> Function Insurgency.KeyBindingsMenu.UpdateKeyBinding
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		struct FKeyBindingOption                           Binding                                                    (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		struct FInputChord                                 NewInput                                                   (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UKeyBindingsMenu::UpdateKeyBinding(const struct FKeyBindingOption& Binding, const struct FInputChord& NewInput)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.KeyBindingsMenu.UpdateKeyBinding");
		
		UKeyBindingsMenu_UpdateKeyBinding_Params params {};
		params.Binding = Binding;
		params.NewInput = NewInput;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056E0000
	 * 		Name   -> Function Insurgency.KeyBindingsMenu.SaveKeyMappings
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void UKeyBindingsMenu::SaveKeyMappings()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.KeyBindingsMenu.SaveKeyMappings");
		
		UKeyBindingsMenu_SaveKeyMappings_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056DFFE0
	 * 		Name   -> Function Insurgency.KeyBindingsMenu.ResetBindingsToDefaults
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void UKeyBindingsMenu::ResetBindingsToDefaults()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.KeyBindingsMenu.ResetBindingsToDefaults");
		
		UKeyBindingsMenu_ResetBindingsToDefaults_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056DFEA0
	 * 		Name   -> Function Insurgency.KeyBindingsMenu.RemoveAllMappingsFromKeyWithExemptions
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		struct FKey                                        Key                                                        (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		TArray<class FName>                                ExemptActions                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UKeyBindingsMenu::RemoveAllMappingsFromKeyWithExemptions(const struct FKey& Key, TArray<class FName> ExemptActions)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.KeyBindingsMenu.RemoveAllMappingsFromKeyWithExemptions");
		
		UKeyBindingsMenu_RemoveAllMappingsFromKeyWithExemptions_Params params {};
		params.Key = Key;
		params.ExemptActions = ExemptActions;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056DFDD0
	 * 		Name   -> Function Insurgency.KeyBindingsMenu.RemoveAllMappingsFromKey
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		struct FKey                                        Key                                                        (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UKeyBindingsMenu::RemoveAllMappingsFromKey(const struct FKey& Key)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.KeyBindingsMenu.RemoveAllMappingsFromKey");
		
		UKeyBindingsMenu_RemoveAllMappingsFromKey_Params params {};
		params.Key = Key;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056DFCA0
	 * 		Name   -> Function Insurgency.KeyBindingsMenu.RemoveActionMapping
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		struct FInputActionKeyMapping                      KeyMapping                                                 (Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UKeyBindingsMenu::RemoveActionMapping(struct FInputActionKeyMapping* KeyMapping)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.KeyBindingsMenu.RemoveActionMapping");
		
		UKeyBindingsMenu_RemoveActionMapping_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (KeyMapping != nullptr)
			*KeyMapping = params.KeyMapping;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> DelegateFunction Insurgency.KeyBindingsMenu.RefreshAllKeysDelegate__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 */
	void UKeyBindingsMenu::RefreshAllKeysDelegate__DelegateSignature()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction Insurgency.KeyBindingsMenu.RefreshAllKeysDelegate__DelegateSignature");
		
		UKeyBindingsMenu_RefreshAllKeysDelegate__DelegateSignature_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056DFC80
	 * 		Name   -> Function Insurgency.KeyBindingsMenu.RefreshAllKeys
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void UKeyBindingsMenu::RefreshAllKeys()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.KeyBindingsMenu.RefreshAllKeys");
		
		UKeyBindingsMenu_RefreshAllKeys_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056DFAD0
	 * 		Name   -> Function Insurgency.KeyBindingsMenu.HasKeyConflict
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		struct FKeyBindingOption                           Binding                                                    (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		struct FKey                                        TestKey                                                    (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FName                                        OutConflictingAction                                       (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UKeyBindingsMenu::HasKeyConflict(const struct FKeyBindingOption& Binding, const struct FKey& TestKey, class FName* OutConflictingAction)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.KeyBindingsMenu.HasKeyConflict");
		
		UKeyBindingsMenu_HasKeyConflict_Params params {};
		params.Binding = Binding;
		params.TestKey = TestKey;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutConflictingAction != nullptr)
			*OutConflictingAction = params.OutConflictingAction;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056DF9C0
	 * 		Name   -> Function Insurgency.KeyBindingsMenu.GetLocalizedActionName
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		class FName                                        Action                                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FText                                        OutLocalized                                               (Parm, OutParm, NativeAccessSpecifierPublic)
	 */
	void UKeyBindingsMenu::GetLocalizedActionName(const class FName& Action, class FText* OutLocalized)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.KeyBindingsMenu.GetLocalizedActionName");
		
		UKeyBindingsMenu_GetLocalizedActionName_Params params {};
		params.Action = Action;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutLocalized != nullptr)
			*OutLocalized = params.OutLocalized;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056DF8F0
	 * 		Name   -> Function Insurgency.KeyBindingsMenu.GetActionMappings
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	TMap<class FName, struct FActionMapList> UKeyBindingsMenu::GetActionMappings()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.KeyBindingsMenu.GetActionMappings");
		
		UKeyBindingsMenu_GetActionMappings_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056DF8D0
	 * 		Name   -> Function Insurgency.KeyBindingsMenu.ApplyDirtyKeyBindings
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void UKeyBindingsMenu::ApplyDirtyKeyBindings()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.KeyBindingsMenu.ApplyDirtyKeyBindings");
		
		UKeyBindingsMenu_ApplyDirtyKeyBindings_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056DF7A0
	 * 		Name   -> Function Insurgency.KeyBindingsMenu.AddActionMapping
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		struct FInputActionKeyMapping                      KeyMapping                                                 (Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UKeyBindingsMenu::AddActionMapping(struct FInputActionKeyMapping* KeyMapping)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.KeyBindingsMenu.AddActionMapping");
		
		UKeyBindingsMenu_AddActionMapping_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (KeyMapping != nullptr)
			*KeyMapping = params.KeyMapping;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UKeyBindingsMenu.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UKeyBindingsMenu::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.KeyBindingsMenu");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UKeyHintDecorator.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UKeyHintDecorator::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.KeyHintDecorator");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UKeyIconImageData.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UKeyIconImageData::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.KeyIconImageData");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UKeyIconSettings.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UKeyIconSettings::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.KeyIconSettings");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056E1BA0
	 * 		Name   -> Function Insurgency.KeyIconWidget.UpdateAction
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		struct FLessonInputAction                          NewAction                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UKeyIconWidget::UpdateAction(const struct FLessonInputAction& NewAction)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.KeyIconWidget.UpdateAction");
		
		UKeyIconWidget_UpdateAction_Params params {};
		params.NewAction = NewAction;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056E1AB0
	 * 		Name   -> Function Insurgency.KeyIconWidget.SetKey
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		struct FKey                                        InKey                                                      (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UKeyIconWidget::SetKey(const struct FKey& InKey)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.KeyIconWidget.SetKey");
		
		UKeyIconWidget_SetKey_Params params {};
		params.InKey = InKey;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056E19D0
	 * 		Name   -> Function Insurgency.KeyIconWidget.SetFallbackKey
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		struct FKey                                        InFallbackKey                                              (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UKeyIconWidget::SetFallbackKey(const struct FKey& InFallbackKey)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.KeyIconWidget.SetFallbackKey");
		
		UKeyIconWidget_SetFallbackKey_Params params {};
		params.InFallbackKey = InFallbackKey;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056E19B0
	 * 		Name   -> Function Insurgency.KeyIconWidget.RebuildKeyIcon
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void UKeyIconWidget::RebuildKeyIcon()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.KeyIconWidget.RebuildKeyIcon");
		
		UKeyIconWidget_RebuildKeyIcon_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056E18F0
	 * 		Name   -> Function Insurgency.KeyIconWidget.OnUsingControllerUpdated
	 * 		Flags  -> (Final, Native, Protected)
	 * Parameters:
	 * 		bool                                               bUsingController                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EeInputIconType                                    NewIconType                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UKeyIconWidget::OnUsingControllerUpdated(bool bUsingController, EeInputIconType NewIconType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.KeyIconWidget.OnUsingControllerUpdated");
		
		UKeyIconWidget_OnUsingControllerUpdated_Params params {};
		params.bUsingController = bUsingController;
		params.NewIconType = NewIconType;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056E18D0
	 * 		Name   -> Function Insurgency.KeyIconWidget.OnSettingsUpdated
	 * 		Flags  -> (Final, Native, Protected)
	 */
	void UKeyIconWidget::OnSettingsUpdated()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.KeyIconWidget.OnSettingsUpdated");
		
		UKeyIconWidget_OnSettingsUpdated_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056E18A0
	 * 		Name   -> Function Insurgency.KeyIconWidget.IsUsingGamepad
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool UKeyIconWidget::IsUsingGamepad()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.KeyIconWidget.IsUsingGamepad");
		
		UKeyIconWidget_IsUsingGamepad_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056E17B0
	 * 		Name   -> Function Insurgency.KeyIconWidget.GetTextureForKey
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		struct FKey                                        InKey                                                      (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UTexture2D* UKeyIconWidget::GetTextureForKey(const struct FKey& InKey)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.KeyIconWidget.GetTextureForKey");
		
		UKeyIconWidget_GetTextureForKey_Params params {};
		params.InKey = InKey;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056E1780
	 * 		Name   -> Function Insurgency.KeyIconWidget.GetTextureForInput
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	class UTexture2D* UKeyIconWidget::GetTextureForInput()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.KeyIconWidget.GetTextureForInput");
		
		UKeyIconWidget_GetTextureForInput_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056E1660
	 * 		Name   -> Function Insurgency.KeyIconWidget.GetKeyForInput
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		bool                                               bIsUsingGamepad                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FKey UKeyIconWidget::GetKeyForInput(bool bIsUsingGamepad)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.KeyIconWidget.GetKeyForInput");
		
		UKeyIconWidget_GetKeyForInput_Params params {};
		params.bIsUsingGamepad = bIsUsingGamepad;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056E1630
	 * 		Name   -> Function Insurgency.KeyIconWidget.GetInputIconType
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	EeInputIconType UKeyIconWidget::GetInputIconType()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.KeyIconWidget.GetInputIconType");
		
		UKeyIconWidget_GetInputIconType_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UKeyIconWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UKeyIconWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.KeyIconWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x057226F0
	 * 		Name   -> Function Insurgency.SandstormAchievement.OnLeaderboardReadComplete
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bWasSuccessful                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void USandstormAchievement::OnLeaderboardReadComplete(bool bWasSuccessful)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.SandstormAchievement.OnLeaderboardReadComplete");
		
		USandstormAchievement_OnLeaderboardReadComplete_Params params {};
		params.bWasSuccessful = bWasSuccessful;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05722490
	 * 		Name   -> Function Insurgency.SandstormAchievement.IncrementPlatformStat
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		class FName                                        InStatName                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void USandstormAchievement::IncrementPlatformStat(const class FName& InStatName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.SandstormAchievement.IncrementPlatformStat");
		
		USandstormAchievement_IncrementPlatformStat_Params params {};
		params.InStatName = InStatName;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> Function Insurgency.SandstormAchievement.BlueprintInit
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		class AINSPlayerState*                             PlayerState                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void USandstormAchievement::BlueprintInit(class AINSPlayerState* PlayerState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.SandstormAchievement.BlueprintInit");
		
		USandstormAchievement_BlueprintInit_Params params {};
		params.PlayerState = PlayerState;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction USandstormAchievement.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* USandstormAchievement::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.SandstormAchievement");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056E3F90
	 * 		Name   -> Function Insurgency.KillAchievement.OnRecievedKill
	 * 		Flags  -> (Final, Native, Public, HasOutParms)
	 * Parameters:
	 * 		struct FSoldierKillInfo                            SoldierKillInfo                                            (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UKillAchievement::OnRecievedKill(const struct FSoldierKillInfo& SoldierKillInfo)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.KillAchievement.OnRecievedKill");
		
		UKillAchievement_OnRecievedKill_Params params {};
		params.SoldierKillInfo = SoldierKillInfo;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UKillAchievement.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UKillAchievement::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.KillAchievement");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056E3F10
	 * 		Name   -> Function Insurgency.FirstBloodAchievement.OnRecievedFirstBlood
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		class AINSPlayerController*                        Killer                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UFirstBloodAchievement::OnRecievedFirstBlood(class AINSPlayerController* Killer)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.FirstBloodAchievement.OnRecievedFirstBlood");
		
		UFirstBloodAchievement_OnRecievedFirstBlood_Params params {};
		params.Killer = Killer;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UFirstBloodAchievement.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UFirstBloodAchievement::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.FirstBloodAchievement");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056E3EF0
	 * 		Name   -> Function Insurgency.FlaccidParalysisAchievement.OnOwningSoldierKilled
	 * 		Flags  -> (Final, Native, Public)
	 */
	void UFlaccidParalysisAchievement::OnOwningSoldierKilled()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.FlaccidParalysisAchievement.OnOwningSoldierKilled");
		
		UFlaccidParalysisAchievement_OnOwningSoldierKilled_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UFlaccidParalysisAchievement.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UFlaccidParalysisAchievement::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.FlaccidParalysisAchievement");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056E3E70
	 * 		Name   -> Function Insurgency.GroundedAchievement.OnDownedFireSupport
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		class AINSPlayerController*                        Killer                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGroundedAchievement::OnDownedFireSupport(class AINSPlayerController* Killer)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.GroundedAchievement.OnDownedFireSupport");
		
		UGroundedAchievement_OnDownedFireSupport_Params params {};
		params.Killer = Killer;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGroundedAchievement.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGroundedAchievement::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.GroundedAchievement");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UPersonalAchievement.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UPersonalAchievement::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.PersonalAchievement");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UHitAndRunAchievement.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UHitAndRunAchievement::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.HitAndRunAchievement");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UPointShootingAchievement.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UPointShootingAchievement::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.PointShootingAchievement");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMountAndGunAchievement.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMountAndGunAchievement::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.MountAndGunAchievement");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UKnockKnockAchievement.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UKnockKnockAchievement::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.KnockKnockAchievement");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UShotgunShotgunAchievement.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UShotgunShotgunAchievement::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.ShotgunShotgunAchievement");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UEfficientAchievement.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UEfficientAchievement::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.EfficientAchievement");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UItsAllInTheReflxesAchievement.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UItsAllInTheReflxesAchievement::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.ItsAllInTheReflxesAchievement");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UHSLDAchievement.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UHSLDAchievement::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.HSLDAchievement");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UWallbangerAchievement.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UWallbangerAchievement::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.WallbangerAchievement");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UThanksStationAchievement.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UThanksStationAchievement::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.ThanksStationAchievement");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056E4060
	 * 		Name   -> Function Insurgency.JR50Achievement.OnRecievedVehicleKill
	 * 		Flags  -> (Final, Native, Public, HasOutParms)
	 * Parameters:
	 * 		struct FSoldierKillInfo                            SoldierKillInfo                                            (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UJR50Achievement::OnRecievedVehicleKill(const struct FSoldierKillInfo& SoldierKillInfo)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.JR50Achievement.OnRecievedVehicleKill");
		
		UJR50Achievement_OnRecievedVehicleKill_Params params {};
		params.SoldierKillInfo = SoldierKillInfo;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UJR50Achievement.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UJR50Achievement::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.JR50Achievement");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056E4060
	 * 		Name   -> Function Insurgency.RoadHazardAchievement.OnRecievedVehicleKill
	 * 		Flags  -> (Final, Native, Public, HasOutParms)
	 * Parameters:
	 * 		struct FSoldierKillInfo                            SoldierKillInfo                                            (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void URoadHazardAchievement::OnRecievedVehicleKill(const struct FSoldierKillInfo& SoldierKillInfo)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.RoadHazardAchievement.OnRecievedVehicleKill");
		
		URoadHazardAchievement_OnRecievedVehicleKill_Params params {};
		params.SoldierKillInfo = SoldierKillInfo;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URoadHazardAchievement.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URoadHazardAchievement::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.RoadHazardAchievement");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URuthlessAchievement.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URuthlessAchievement::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.RuthlessAchievement");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UCinematicAchievement.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UCinematicAchievement::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.CinematicAchievement");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UExploitativeAchievement.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UExploitativeAchievement::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.ExploitativeAchievement");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ULuckyAchievement.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ULuckyAchievement::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.LuckyAchievement");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UBlindFireAchievement.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UBlindFireAchievement::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.BlindFireAchievement");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UBangedAchievement.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UBangedAchievement::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.BangedAchievement");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056E3DB0
	 * 		Name   -> Function Insurgency.TraumaAchievement.OnDismemberRagdoll
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		class ARagdoll*                                    Ragdoll                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AController*                                 Controller                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UTraumaAchievement::OnDismemberRagdoll(class ARagdoll* Ragdoll, class AController* Controller)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.TraumaAchievement.OnDismemberRagdoll");
		
		UTraumaAchievement_OnDismemberRagdoll_Params params {};
		params.Ragdoll = Ragdoll;
		params.Controller = Controller;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UTraumaAchievement.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UTraumaAchievement::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.TraumaAchievement");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UKillerInterface.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UKillerInterface::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.KillerInterface");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056E4750
	 * 		Name   -> Function Insurgency.KitPreviewActor.RegisterPlayer
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class AINSBasePlayerController*                    InPlayerController                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AKitPreviewActor::RegisterPlayer(class AINSBasePlayerController* InPlayerController)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.KitPreviewActor.RegisterPlayer");
		
		AKitPreviewActor_RegisterPlayer_Params params {};
		params.InPlayerController = InPlayerController;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056E4680
	 * 		Name   -> Function Insurgency.KitPreviewActor.OnUpdatePlayerClass
	 * 		Flags  -> (Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UFactionDefinition*                          FactionDefinition                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UPlayerClass*                                PlayerClass                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AKitPreviewActor::OnUpdatePlayerClass(class UFactionDefinition* FactionDefinition, class UPlayerClass* PlayerClass)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.KitPreviewActor.OnUpdatePlayerClass");
		
		AKitPreviewActor_OnUpdatePlayerClass_Params params {};
		params.FactionDefinition = FactionDefinition;
		params.PlayerClass = PlayerClass;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x04DB5CB0
	 * 		Name   -> Function Insurgency.KitPreviewActor.OnUpdateInventory
	 * 		Flags  -> (Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UPlayerInventoryComponent*                   InventoryComponent                                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AKitPreviewActor::OnUpdateInventory(class UPlayerInventoryComponent* InventoryComponent)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.KitPreviewActor.OnUpdateInventory");
		
		AKitPreviewActor_OnUpdateInventory_Params params {};
		params.InventoryComponent = InventoryComponent;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056E45C0
	 * 		Name   -> Function Insurgency.KitPreviewActor.OnTeamChanged
	 * 		Flags  -> (Final, Native, Private)
	 * Parameters:
	 * 		unsigned char                                      TeamId                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class ATeamInfo*                                   TeamInfo                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AKitPreviewActor::OnTeamChanged(unsigned char TeamId, class ATeamInfo* TeamInfo)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.KitPreviewActor.OnTeamChanged");
		
		AKitPreviewActor_OnTeamChanged_Params params {};
		params.TeamId = TeamId;
		params.TeamInfo = TeamInfo;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056E4540
	 * 		Name   -> Function Insurgency.KitPreviewActor.OnPlayerClassChanged
	 * 		Flags  -> (Final, Native, Private)
	 * Parameters:
	 * 		class UPlayerClass*                                PlayerClass                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AKitPreviewActor::OnPlayerClassChanged(class UPlayerClass* PlayerClass)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.KitPreviewActor.OnPlayerClassChanged");
		
		AKitPreviewActor_OnPlayerClassChanged_Params params {};
		params.PlayerClass = PlayerClass;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056E4520
	 * 		Name   -> Function Insurgency.KitPreviewActor.OnInventoryChanged
	 * 		Flags  -> (Final, Native, Private)
	 */
	void AKitPreviewActor::OnInventoryChanged()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.KitPreviewActor.OnInventoryChanged");
		
		AKitPreviewActor_OnInventoryChanged_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x04E7D6E0
	 * 		Name   -> Function Insurgency.KitPreviewActor.OnFirstPersonWeaponMeshSet
	 * 		Flags  -> (Native, Protected)
	 * Parameters:
	 * 		class UINSSkeletalMeshComponent*                   NewMesh                                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AKitPreviewActor::OnFirstPersonWeaponMeshSet(class UINSSkeletalMeshComponent* NewMesh)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.KitPreviewActor.OnFirstPersonWeaponMeshSet");
		
		AKitPreviewActor_OnFirstPersonWeaponMeshSet_Params params {};
		params.NewMesh = NewMesh;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056E44F0
	 * 		Name   -> Function Insurgency.KitPreviewActor.GetOwnerInventory
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	class UPlayerInventoryComponent* AKitPreviewActor::GetOwnerInventory()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.KitPreviewActor.GetOwnerInventory");
		
		AKitPreviewActor_GetOwnerInventory_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AKitPreviewActor.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AKitPreviewActor::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.KitPreviewActor");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AKitPreviewCharacter.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AKitPreviewCharacter::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.KitPreviewCharacter");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056E4EF0
	 * 		Name   -> Function Insurgency.KitPreviewWeapon.UpdateWeaponModel
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		struct FStoredInventoryItem                        Item                                                       (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void AKitPreviewWeapon::UpdateWeaponModel(const struct FStoredInventoryItem& Item)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.KitPreviewWeapon.UpdateWeaponModel");
		
		AKitPreviewWeapon_UpdateWeaponModel_Params params {};
		params.Item = Item;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056E4DE0
	 * 		Name   -> Function Insurgency.KitPreviewWeapon.UpdateViewedWeaponSlot
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		EItemSlot                                          Slot                                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            SubSlot                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bForceRefresh                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AKitPreviewWeapon::UpdateViewedWeaponSlot(EItemSlot Slot, int32_t SubSlot, bool bForceRefresh)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.KitPreviewWeapon.UpdateViewedWeaponSlot");
		
		AKitPreviewWeapon_UpdateViewedWeaponSlot_Params params {};
		params.Slot = Slot;
		params.SubSlot = SubSlot;
		params.bForceRefresh = bForceRefresh;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056E4CE0
	 * 		Name   -> Function Insurgency.KitPreviewWeapon.SetWeaponModel
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		struct FStoredInventoryItem                        Item                                                       (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		bool                                               ForceRefresh                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AKitPreviewWeapon::SetWeaponModel(const struct FStoredInventoryItem& Item, bool ForceRefresh)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.KitPreviewWeapon.SetWeaponModel");
		
		AKitPreviewWeapon_SetWeaponModel_Params params {};
		params.Item = Item;
		params.ForceRefresh = ForceRefresh;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056E4C10
	 * 		Name   -> Function Insurgency.KitPreviewWeapon.SetUpgradeCustomDepth
	 * 		Flags  -> (Final, Native, Private)
	 * Parameters:
	 * 		EWeaponUpgradeSlot                                 UpgradeSlot                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               RenderCustomDepth                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AKitPreviewWeapon::SetUpgradeCustomDepth(EWeaponUpgradeSlot UpgradeSlot, bool RenderCustomDepth)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.KitPreviewWeapon.SetUpgradeCustomDepth");
		
		AKitPreviewWeapon_SetUpgradeCustomDepth_Params params {};
		params.UpgradeSlot = UpgradeSlot;
		params.RenderCustomDepth = RenderCustomDepth;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056E4BF0
	 * 		Name   -> Function Insurgency.KitPreviewWeapon.RemoveWeapon
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void AKitPreviewWeapon::RemoveWeapon()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.KitPreviewWeapon.RemoveWeapon");
		
		AKitPreviewWeapon_RemoveWeapon_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056E4B70
	 * 		Name   -> Function Insurgency.KitPreviewWeapon.OutlineUpgradeInSlot
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		EWeaponUpgradeSlot                                 UpgradeSlot                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AKitPreviewWeapon::OutlineUpgradeInSlot(EWeaponUpgradeSlot UpgradeSlot)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.KitPreviewWeapon.OutlineUpgradeInSlot");
		
		AKitPreviewWeapon_OutlineUpgradeInSlot_Params params {};
		params.UpgradeSlot = UpgradeSlot;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> DelegateFunction Insurgency.KitPreviewWeapon.OnViewedWeaponSlotUpdated__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 */
	void AKitPreviewWeapon::OnViewedWeaponSlotUpdated__DelegateSignature()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction Insurgency.KitPreviewWeapon.OnViewedWeaponSlotUpdated__DelegateSignature");
		
		AKitPreviewWeapon_OnViewedWeaponSlotUpdated__DelegateSignature_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AKitPreviewWeapon.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AKitPreviewWeapon::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.KitPreviewWeapon");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056E5FD0
	 * 		Name   -> Function Insurgency.KitSelectMenu.UpdateFirearmAttributes
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		EItemSlot                                          CurrentItemSlot                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            CurrentItemSubSlot                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UKitSelect_ItemAttribute*                    CaliberAttribute                                           (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UKitSelect_ItemAttribute*                    MuzzleVelocityAttribute                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UKitSelect_ItemAttribute*                    PenetrationAttribute                                       (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UKitSelect_ItemAttribute*                    EffectiveRangeAttribute                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UKitSelect_ItemAttribute*                    MagSizeAttribute                                           (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UKitSelect_ItemAttribute*                    FireModesAttribute                                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UKitSelect_ItemAttribute*                    FireRateAttribute                                          (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UKitSelect_ItemAttribute*                    VerticalHandlingAttribute                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UKitSelect_ItemAttribute*                    HorizontalHandlingAttribute                                (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UKitSelectMenu::UpdateFirearmAttributes(EItemSlot CurrentItemSlot, int32_t CurrentItemSubSlot, class UKitSelect_ItemAttribute* CaliberAttribute, class UKitSelect_ItemAttribute* MuzzleVelocityAttribute, class UKitSelect_ItemAttribute* PenetrationAttribute, class UKitSelect_ItemAttribute* EffectiveRangeAttribute, class UKitSelect_ItemAttribute* MagSizeAttribute, class UKitSelect_ItemAttribute* FireModesAttribute, class UKitSelect_ItemAttribute* FireRateAttribute, class UKitSelect_ItemAttribute* VerticalHandlingAttribute, class UKitSelect_ItemAttribute* HorizontalHandlingAttribute)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.KitSelectMenu.UpdateFirearmAttributes");
		
		UKitSelectMenu_UpdateFirearmAttributes_Params params {};
		params.CurrentItemSlot = CurrentItemSlot;
		params.CurrentItemSubSlot = CurrentItemSubSlot;
		params.CaliberAttribute = CaliberAttribute;
		params.MuzzleVelocityAttribute = MuzzleVelocityAttribute;
		params.PenetrationAttribute = PenetrationAttribute;
		params.EffectiveRangeAttribute = EffectiveRangeAttribute;
		params.MagSizeAttribute = MagSizeAttribute;
		params.FireModesAttribute = FireModesAttribute;
		params.FireRateAttribute = FireRateAttribute;
		params.VerticalHandlingAttribute = VerticalHandlingAttribute;
		params.HorizontalHandlingAttribute = HorizontalHandlingAttribute;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056E5FB0
	 * 		Name   -> Function Insurgency.KitSelectMenu.RefreshStoredWeightData
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void UKitSelectMenu::RefreshStoredWeightData()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.KitSelectMenu.RefreshStoredWeightData");
		
		UKitSelectMenu_RefreshStoredWeightData_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056E5F20
	 * 		Name   -> Function Insurgency.KitSelectMenu.IsEquippedItemVisibleInSlot
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		EItemSlot                                          ItemSlot                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UKitSelectMenu::IsEquippedItemVisibleInSlot(EItemSlot ItemSlot)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.KitSelectMenu.IsEquippedItemVisibleInSlot");
		
		UKitSelectMenu_IsEquippedItemVisibleInSlot_Params params {};
		params.ItemSlot = ItemSlot;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056E5E20
	 * 		Name   -> Function Insurgency.KitSelectMenu.HasWeaponUpgradeEquipped
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		class UClass*                                      WeaponUpgrade                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EItemSlot                                          ItemSlot                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            SubSlot                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UKitSelectMenu::HasWeaponUpgradeEquipped(class UClass* WeaponUpgrade, EItemSlot ItemSlot, int32_t SubSlot)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.KitSelectMenu.HasWeaponUpgradeEquipped");
		
		UKitSelectMenu_HasWeaponUpgradeEquipped_Params params {};
		params.WeaponUpgrade = WeaponUpgrade;
		params.ItemSlot = ItemSlot;
		params.SubSlot = SubSlot;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056E5D60
	 * 		Name   -> Function Insurgency.KitSelectMenu.HasItemInSlot
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		EItemSlot                                          ItemSlot                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            SubSlot                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UKitSelectMenu::HasItemInSlot(EItemSlot ItemSlot, int32_t SubSlot)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.KitSelectMenu.HasItemInSlot");
		
		UKitSelectMenu_HasItemInSlot_Params params {};
		params.ItemSlot = ItemSlot;
		params.SubSlot = SubSlot;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056E5CA0
	 * 		Name   -> Function Insurgency.KitSelectMenu.HasItemEquipped
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		class UClass*                                      Item                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            SubSlot                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UKitSelectMenu::HasItemEquipped(class UClass* Item, int32_t SubSlot)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.KitSelectMenu.HasItemEquipped");
		
		UKitSelectMenu_HasItemEquipped_Params params {};
		params.Item = Item;
		params.SubSlot = SubSlot;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056E5C70
	 * 		Name   -> Function Insurgency.KitSelectMenu.GetPlayerInventory
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	class UPlayerInventoryComponent* UKitSelectMenu::GetPlayerInventory()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.KitSelectMenu.GetPlayerInventory");
		
		UKitSelectMenu_GetPlayerInventory_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056E5C40
	 * 		Name   -> Function Insurgency.KitSelectMenu.GetPlayerClass
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	class UPlayerClass* UKitSelectMenu::GetPlayerClass()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.KitSelectMenu.GetPlayerClass");
		
		UKitSelectMenu_GetPlayerClass_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> Function Insurgency.KitSelectMenu.GetIsShoppingListActive
	 * 		Flags  -> (Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure)
	 */
	bool UKitSelectMenu::GetIsShoppingListActive()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.KitSelectMenu.GetIsShoppingListActive");
		
		UKitSelectMenu_GetIsShoppingListActive_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056E5C10
	 * 		Name   -> Function Insurgency.KitSelectMenu.GetEquippedTotalWeightPercent
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
	 */
	float UKitSelectMenu::GetEquippedTotalWeightPercent()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.KitSelectMenu.GetEquippedTotalWeightPercent");
		
		UKitSelectMenu_GetEquippedTotalWeightPercent_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> Function Insurgency.KitSelectMenu.DoHasActiveHoverComparison
	 * 		Flags  -> (Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure)
	 */
	bool UKitSelectMenu::DoHasActiveHoverComparison()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.KitSelectMenu.DoHasActiveHoverComparison");
		
		UKitSelectMenu_DoHasActiveHoverComparison_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> Function Insurgency.KitSelectMenu.DoDetermineFireModeImages
	 * 		Flags  -> (Event, Public, HasOutParms, BlueprintCallable, BlueprintEvent, BlueprintPure)
	 * Parameters:
	 * 		class UClass*                                      InFirearmClass                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		TArray<class UTexture2D*>                          OutFireModeImages                                          (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UKitSelectMenu::DoDetermineFireModeImages(class UClass* InFirearmClass, TArray<class UTexture2D*>* OutFireModeImages)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.KitSelectMenu.DoDetermineFireModeImages");
		
		UKitSelectMenu_DoDetermineFireModeImages_Params params {};
		params.InFirearmClass = InFirearmClass;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutFireModeImages != nullptr)
			*OutFireModeImages = params.OutFireModeImages;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056E5B40
	 * 		Name   -> Function Insurgency.KitSelectMenu.CalculateTotalWeightPercentWithHoveredUpgrade
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class UClass*                                      NewUpgradeClass                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EItemSlot                                          UpgradeItemSlot                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	float UKitSelectMenu::CalculateTotalWeightPercentWithHoveredUpgrade(class UClass* NewUpgradeClass, EItemSlot UpgradeItemSlot)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.KitSelectMenu.CalculateTotalWeightPercentWithHoveredUpgrade");
		
		UKitSelectMenu_CalculateTotalWeightPercentWithHoveredUpgrade_Params params {};
		params.NewUpgradeClass = NewUpgradeClass;
		params.UpgradeItemSlot = UpgradeItemSlot;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056E5A80
	 * 		Name   -> Function Insurgency.KitSelectMenu.CalculateTotalWeightPercentWithHoveredItem
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class UClass*                                      NewItemClass                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            ItemSubslot                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	float UKitSelectMenu::CalculateTotalWeightPercentWithHoveredItem(class UClass* NewItemClass, int32_t ItemSubslot)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.KitSelectMenu.CalculateTotalWeightPercentWithHoveredItem");
		
		UKitSelectMenu_CalculateTotalWeightPercentWithHoveredItem_Params params {};
		params.NewItemClass = NewItemClass;
		params.ItemSubslot = ItemSubslot;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UKitSelectMenu.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UKitSelectMenu::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.KitSelectMenu");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> Function Insurgency.KitSelect_ItemAttribute.DoSetImages
	 * 		Flags  -> (Event, Public, HasOutParms, BlueprintEvent)
	 * Parameters:
	 * 		TArray<class UTexture2D*>                          ImagesSelected                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		TArray<class UTexture2D*>                          ImagesHovered                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UKitSelect_ItemAttribute::DoSetImages(TArray<class UTexture2D*> ImagesSelected, TArray<class UTexture2D*> ImagesHovered)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.KitSelect_ItemAttribute.DoSetImages");
		
		UKitSelect_ItemAttribute_DoSetImages_Params params {};
		params.ImagesSelected = ImagesSelected;
		params.ImagesHovered = ImagesHovered;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UKitSelect_ItemAttribute.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UKitSelect_ItemAttribute::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.KitSelect_ItemAttribute");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056E6A00
	 * 		Name   -> Function Insurgency.KitSelect_ItemButton.UpdateNotificationVisibility
	 * 		Flags  -> (Final, Native, Protected, BlueprintCallable)
	 */
	void UKitSelect_ItemButton::UpdateNotificationVisibility()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.KitSelect_ItemButton.UpdateNotificationVisibility");
		
		UKitSelect_ItemButton_UpdateNotificationVisibility_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056E6820
	 * 		Name   -> Function Insurgency.KitSelect_ItemButton.UpdateItemData
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		class UClass*                                      InItemClass                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            InSubSlot                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bInSelected                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bInIsNewGear                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bLoadoutChanged                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            InLoadoutCategoryIndex                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UKitSelect_ItemButton::UpdateItemData(class UClass* InItemClass, int32_t InSubSlot, bool bInSelected, bool bInIsNewGear, bool bLoadoutChanged, int32_t InLoadoutCategoryIndex)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.KitSelect_ItemButton.UpdateItemData");
		
		UKitSelect_ItemButton_UpdateItemData_Params params {};
		params.InItemClass = InItemClass;
		params.InSubSlot = InSubSlot;
		params.bInSelected = bInSelected;
		params.bInIsNewGear = bInIsNewGear;
		params.bLoadoutChanged = bLoadoutChanged;
		params.InLoadoutCategoryIndex = InLoadoutCategoryIndex;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056E6800
	 * 		Name   -> Function Insurgency.KitSelect_ItemButton.SetUnequipButtonVisibility
	 * 		Flags  -> (Final, Native, Protected, BlueprintCallable)
	 */
	void UKitSelect_ItemButton::SetUnequipButtonVisibility()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.KitSelect_ItemButton.SetUnequipButtonVisibility");
		
		UKitSelect_ItemButton_SetUnequipButtonVisibility_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> Function Insurgency.KitSelect_ItemButton.SetColorScrollingTextWidget
	 * 		Flags  -> (Event, Public, HasDefaults, BlueprintEvent)
	 * Parameters:
	 * 		struct FLinearColor                                FgColor                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UKitSelect_ItemButton::SetColorScrollingTextWidget(const struct FLinearColor& FgColor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.KitSelect_ItemButton.SetColorScrollingTextWidget");
		
		UKitSelect_ItemButton_SetColorScrollingTextWidget_Params params {};
		params.FgColor = FgColor;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056E67E0
	 * 		Name   -> Function Insurgency.KitSelect_ItemButton.RefreshColors
	 * 		Flags  -> (Final, Native, Protected, BlueprintCallable)
	 */
	void UKitSelect_ItemButton::RefreshColors()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.KitSelect_ItemButton.RefreshColors");
		
		UKitSelect_ItemButton_RefreshColors_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UKitSelect_ItemButton.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UKitSelect_ItemButton::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.KitSelect_ItemButton");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056E6F60
	 * 		Name   -> Function Insurgency.KitSelect_UpgradeButton.UpdateVisualComponents
	 * 		Flags  -> (Final, Native, Protected, BlueprintCallable)
	 */
	void UKitSelect_UpgradeButton::UpdateVisualComponents()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.KitSelect_UpgradeButton.UpdateVisualComponents");
		
		UKitSelect_UpgradeButton_UpdateVisualComponents_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056E6D40
	 * 		Name   -> Function Insurgency.KitSelect_UpgradeButton.UpdateUpgradeData
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		class UClass*                                      InUpgradeClass                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EItemSlot                                          InParentItemSlot                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            InSupplyCost                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bInSupplyCostVisible                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bInSelected                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bInPurchasable                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bInIsNewGear                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UKitSelect_UpgradeButton::UpdateUpgradeData(class UClass* InUpgradeClass, EItemSlot InParentItemSlot, int32_t InSupplyCost, bool bInSupplyCostVisible, bool bInSelected, bool bInPurchasable, bool bInIsNewGear)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.KitSelect_UpgradeButton.UpdateUpgradeData");
		
		UKitSelect_UpgradeButton_UpdateUpgradeData_Params params {};
		params.InUpgradeClass = InUpgradeClass;
		params.InParentItemSlot = InParentItemSlot;
		params.InSupplyCost = InSupplyCost;
		params.bInSupplyCostVisible = bInSupplyCostVisible;
		params.bInSelected = bInSelected;
		params.bInPurchasable = bInPurchasable;
		params.bInIsNewGear = bInIsNewGear;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> Function Insurgency.KitSelect_UpgradeButton.SetScrollingText
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 */
	void UKitSelect_UpgradeButton::SetScrollingText()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.KitSelect_UpgradeButton.SetScrollingText");
		
		UKitSelect_UpgradeButton_SetScrollingText_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> Function Insurgency.KitSelect_UpgradeButton.SetColorScrollingTextWidget
	 * 		Flags  -> (Event, Protected, HasDefaults, BlueprintEvent)
	 * Parameters:
	 * 		struct FLinearColor                                FgColor                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UKitSelect_UpgradeButton::SetColorScrollingTextWidget(const struct FLinearColor& FgColor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.KitSelect_UpgradeButton.SetColorScrollingTextWidget");
		
		UKitSelect_UpgradeButton_SetColorScrollingTextWidget_Params params {};
		params.FgColor = FgColor;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056E6D20
	 * 		Name   -> Function Insurgency.KitSelect_UpgradeButton.RefreshColors
	 * 		Flags  -> (Final, Native, Protected, BlueprintCallable)
	 */
	void UKitSelect_UpgradeButton::RefreshColors()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.KitSelect_UpgradeButton.RefreshColors");
		
		UKitSelect_UpgradeButton_RefreshColors_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UKitSelect_UpgradeButton.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UKitSelect_UpgradeButton::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.KitSelect_UpgradeButton");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ALadder.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ALadder::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.Ladder");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056E7580
	 * 		Name   -> Function Insurgency.LagCompensationComponent.RewindToTime
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		float                                              Time                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ULagCompensationComponent::RewindToTime(float Time)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.LagCompensationComponent.RewindToTime");
		
		ULagCompensationComponent_RewindToTime_Params params {};
		params.Time = Time;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056E7560
	 * 		Name   -> Function Insurgency.LagCompensationComponent.RestorePosition
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void ULagCompensationComponent::RestorePosition()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.LagCompensationComponent.RestorePosition");
		
		ULagCompensationComponent_RestorePosition_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ULagCompensationComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ULagCompensationComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.LagCompensationComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056E7B80
	 * 		Name   -> Function Insurgency.LessonArea.ToggleLesson
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bNewEnabled                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ALessonArea::ToggleLesson(bool bNewEnabled)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.LessonArea.ToggleLesson");
		
		ALessonArea_ToggleLesson_Params params {};
		params.bNewEnabled = bNewEnabled;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056E7970
	 * 		Name   -> Function Insurgency.LessonArea.OnBeginAreaOverlap
	 * 		Flags  -> (Final, Native, Private, HasOutParms)
	 * Parameters:
	 * 		class UPrimitiveComponent*                         OverlappedComponent                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      OtherActor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UPrimitiveComponent*                         OtherComp                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            OtherBodyIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bFromSweep                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FHitResult                                  SweepResult                                                (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	void ALessonArea::OnBeginAreaOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32_t OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.LessonArea.OnBeginAreaOverlap");
		
		ALessonArea_OnBeginAreaOverlap_Params params {};
		params.OverlappedComponent = OverlappedComponent;
		params.OtherActor = OtherActor;
		params.OtherComp = OtherComp;
		params.OtherBodyIndex = OtherBodyIndex;
		params.bFromSweep = bFromSweep;
		params.SweepResult = SweepResult;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> DelegateFunction Insurgency.LessonArea.LessonAreaEventDelegate__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 * Parameters:
	 * 		class AINSBasePlayerController*                    PlayerController                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ALessonArea::LessonAreaEventDelegate__DelegateSignature(class AINSBasePlayerController* PlayerController)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction Insurgency.LessonArea.LessonAreaEventDelegate__DelegateSignature");
		
		ALessonArea_LessonAreaEventDelegate__DelegateSignature_Params params {};
		params.PlayerController = PlayerController;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056E78E0
	 * 		Name   -> Function Insurgency.LessonArea.HasHintedController
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class AINSBasePlayerController*                    Controller                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool ALessonArea::HasHintedController(class AINSBasePlayerController* Controller)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.LessonArea.HasHintedController");
		
		ALessonArea_HasHintedController_Params params {};
		params.Controller = Controller;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056E7860
	 * 		Name   -> Function Insurgency.LessonArea.ControllerConfirmedHint
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		class AINSBasePlayerController*                    Controller                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ALessonArea::ControllerConfirmedHint(class AINSBasePlayerController* Controller)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.LessonArea.ControllerConfirmedHint");
		
		ALessonArea_ControllerConfirmedHint_Params params {};
		params.Controller = Controller;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ALessonArea.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ALessonArea::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.LessonArea");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056E7F70
	 * 		Name   -> Function Insurgency.LessonLoadingWidget.SetLessonVideo
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void ULessonLoadingWidget::SetLessonVideo()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.LessonLoadingWidget.SetLessonVideo");
		
		ULessonLoadingWidget_SetLessonVideo_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056E7E70
	 * 		Name   -> Function Insurgency.LessonLoadingWidget.OnVideoAsyncLoadComplete
	 * 		Flags  -> (Final, Native, Public)
	 */
	void ULessonLoadingWidget::OnVideoAsyncLoadComplete()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.LessonLoadingWidget.OnVideoAsyncLoadComplete");
		
		ULessonLoadingWidget_OnVideoAsyncLoadComplete_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> Function Insurgency.LessonLoadingWidget.OnLessonVideoLoadedEvent
	 * 		Flags  -> (Event, Public, HasOutParms, BlueprintEvent)
	 */
	void ULessonLoadingWidget::OnLessonVideoLoadedEvent()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.LessonLoadingWidget.OnLessonVideoLoadedEvent");
		
		ULessonLoadingWidget_OnLessonVideoLoadedEvent_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ULessonLoadingWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ULessonLoadingWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.LessonLoadingWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056E93E0
	 * 		Name   -> Function Insurgency.LightSampler.UntrackNamedLightSource
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		class FName                                        Name                                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ALightSampler::UntrackNamedLightSource(const class FName& Name)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.LightSampler.UntrackNamedLightSource");
		
		ALightSampler_UntrackNamedLightSource_Params params {};
		params.Name = Name;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056E9120
	 * 		Name   -> Function Insurgency.LightSampler.TrackNamedLightSource
	 * 		Flags  -> (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		class FName                                        Name                                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     Position                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Intensity                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Radius                                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UActorComponent*                             Parent                                                     (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              InnerConeAngle                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              OuterConeAngle                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     Direction                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ALightSampler::TrackNamedLightSource(const class FName& Name, const struct FVector& Position, float Intensity, float Radius, class UActorComponent* Parent, float InnerConeAngle, float OuterConeAngle, const struct FVector& Direction)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.LightSampler.TrackNamedLightSource");
		
		ALightSampler_TrackNamedLightSource_Params params {};
		params.Name = Name;
		params.Position = Position;
		params.Intensity = Intensity;
		params.Radius = Radius;
		params.Parent = Parent;
		params.InnerConeAngle = InnerConeAngle;
		params.OuterConeAngle = OuterConeAngle;
		params.Direction = Direction;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056E9080
	 * 		Name   -> Function Insurgency.LightSampler.GetVolumetricLightingIntensity
	 * 		Flags  -> (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FVector                                     Position                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	float ALightSampler::GetVolumetricLightingIntensity(const struct FVector& Position)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.LightSampler.GetVolumetricLightingIntensity");
		
		ALightSampler_GetVolumetricLightingIntensity_Params params {};
		params.Position = Position;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056E8FD0
	 * 		Name   -> Function Insurgency.LightSampler.GetVolumetricLightingForPosition
	 * 		Flags  -> (Final, Native, Public, HasOutParms, HasDefaults)
	 * Parameters:
	 * 		struct FVector                                     Position                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FLinearColor ALightSampler::GetVolumetricLightingForPosition(const struct FVector& Position)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.LightSampler.GetVolumetricLightingForPosition");
		
		ALightSampler_GetVolumetricLightingForPosition_Params params {};
		params.Position = Position;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056E8F20
	 * 		Name   -> Function Insurgency.LightSampler.GetVolumetricLighting
	 * 		Flags  -> (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FVector                                     Position                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FLinearColor ALightSampler::GetVolumetricLighting(const struct FVector& Position)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.LightSampler.GetVolumetricLighting");
		
		ALightSampler_GetVolumetricLighting_Params params {};
		params.Position = Position;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056E8E80
	 * 		Name   -> Function Insurgency.LightSampler.GetUnfilteredVolumetricLightingIntensity
	 * 		Flags  -> (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FVector                                     Position                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	float ALightSampler::GetUnfilteredVolumetricLightingIntensity(const struct FVector& Position)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.LightSampler.GetUnfilteredVolumetricLightingIntensity");
		
		ALightSampler_GetUnfilteredVolumetricLightingIntensity_Params params {};
		params.Position = Position;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056E8DD0
	 * 		Name   -> Function Insurgency.LightSampler.GetUnfilteredVolumetricLightingForPosition
	 * 		Flags  -> (Final, Native, Public, HasOutParms, HasDefaults)
	 * Parameters:
	 * 		struct FVector                                     Position                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FLinearColor ALightSampler::GetUnfilteredVolumetricLightingForPosition(const struct FVector& Position)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.LightSampler.GetUnfilteredVolumetricLightingForPosition");
		
		ALightSampler_GetUnfilteredVolumetricLightingForPosition_Params params {};
		params.Position = Position;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056E8D20
	 * 		Name   -> Function Insurgency.LightSampler.GetUnfilteredVolumetricLighting
	 * 		Flags  -> (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FVector                                     Position                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FLinearColor ALightSampler::GetUnfilteredVolumetricLighting(const struct FVector& Position)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.LightSampler.GetUnfilteredVolumetricLighting");
		
		ALightSampler_GetUnfilteredVolumetricLighting_Params params {};
		params.Position = Position;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056E8C80
	 * 		Name   -> Function Insurgency.LightSampler.GetLightingIntensity
	 * 		Flags  -> (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FVector                                     Position                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	float ALightSampler::GetLightingIntensity(const struct FVector& Position)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.LightSampler.GetLightingIntensity");
		
		ALightSampler_GetLightingIntensity_Params params {};
		params.Position = Position;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056E8BA0
	 * 		Name   -> Function Insurgency.LightSampler.GetDynamicLightSources
	 * 		Flags  -> (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FVector                                     Position                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	TArray<struct FSampledLightSource> ALightSampler::GetDynamicLightSources(const struct FVector& Position)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.LightSampler.GetDynamicLightSources");
		
		ALightSampler_GetDynamicLightSources_Params params {};
		params.Position = Position;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056E8AE0
	 * 		Name   -> Function Insurgency.LightSampler.GetDynamicLightIntensityFromSources
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		TArray<struct FSampledLightSource>                 LightSources                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	float ALightSampler::GetDynamicLightIntensityFromSources(TArray<struct FSampledLightSource> LightSources)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.LightSampler.GetDynamicLightIntensityFromSources");
		
		ALightSampler_GetDynamicLightIntensityFromSources_Params params {};
		params.LightSources = LightSources;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056E8A40
	 * 		Name   -> Function Insurgency.LightSampler.GetDynamicLightIntensity
	 * 		Flags  -> (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FVector                                     Position                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	float ALightSampler::GetDynamicLightIntensity(const struct FVector& Position)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.LightSampler.GetDynamicLightIntensity");
		
		ALightSampler_GetDynamicLightIntensity_Params params {};
		params.Position = Position;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00C76AB0
	 * 		Name   -> Function Insurgency.LightSampler.DrawDebugInformation
	 * 		Flags  -> (Final, Native, Protected)
	 */
	void ALightSampler::DrawDebugInformation()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.LightSampler.DrawDebugInformation");
		
		ALightSampler_DrawDebugInformation_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056E8940
	 * 		Name   -> Function Insurgency.LightSampler.AffectsBoundsVirtualSource
	 * 		Flags  -> (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		struct FSampledLightSource                         LightSource                                                (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 * 		struct FBoxSphereBounds                            Bounds                                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	bool ALightSampler::AffectsBoundsVirtualSource(const struct FSampledLightSource& LightSource, const struct FBoxSphereBounds& Bounds)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.LightSampler.AffectsBoundsVirtualSource");
		
		ALightSampler_AffectsBoundsVirtualSource_Params params {};
		params.LightSource = LightSource;
		params.Bounds = Bounds;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056E8680
	 * 		Name   -> Function Insurgency.LightSampler.AddLightSource
	 * 		Flags  -> (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FVector                                     Position                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Intensity                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Duration                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Radius                                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UActorComponent*                             Parent                                                     (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              InnerConeAngle                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              OuterConeAngle                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     Direction                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ALightSampler::AddLightSource(const struct FVector& Position, float Intensity, float Duration, float Radius, class UActorComponent* Parent, float InnerConeAngle, float OuterConeAngle, const struct FVector& Direction)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.LightSampler.AddLightSource");
		
		ALightSampler_AddLightSource_Params params {};
		params.Position = Position;
		params.Intensity = Intensity;
		params.Duration = Duration;
		params.Radius = Radius;
		params.Parent = Parent;
		params.InnerConeAngle = InnerConeAngle;
		params.OuterConeAngle = OuterConeAngle;
		params.Direction = Direction;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ALightSampler.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ALightSampler::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.LightSampler");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056E95D0
	 * 		Name   -> Function Insurgency.LightStatics.GetLightSampler
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class ALightSampler* ULightStatics::STATIC_GetLightSampler(class UObject* WorldContextObject)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.LightStatics.GetLightSampler");
		
		ULightStatics_GetLightSampler_Params params {};
		params.WorldContextObject = WorldContextObject;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ULightStatics.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ULightStatics::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.LightStatics");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056E97F0
	 * 		Name   -> Function Insurgency.LoadCollectibleItemDataAsync.LoadCollectibleItemData
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		TArray<int32_t>                                    InItemIds                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class ULoadCollectibleItemDataAsync* ULoadCollectibleItemDataAsync::STATIC_LoadCollectibleItemData(class UObject* WorldContextObject, TArray<int32_t> InItemIds)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.LoadCollectibleItemDataAsync.LoadCollectibleItemData");
		
		ULoadCollectibleItemDataAsync_LoadCollectibleItemData_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.InItemIds = InItemIds;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ULoadCollectibleItemDataAsync.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ULoadCollectibleItemDataAsync::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.LoadCollectibleItemDataAsync");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056E9BA0
	 * 		Name   -> Function Insurgency.LoadingScreenSettings.GetThumbnailForLevel
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		class FString                                      LevelName                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FString                                      Lighting                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ULoadingScreenSettings::GetThumbnailForLevel(const class FString& LevelName, const class FString& Lighting)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.LoadingScreenSettings.GetThumbnailForLevel");
		
		ULoadingScreenSettings_GetThumbnailForLevel_Params params {};
		params.LevelName = LevelName;
		params.Lighting = Lighting;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056E9A80
	 * 		Name   -> Function Insurgency.LoadingScreenSettings.GetLoadingScreenTextureAsset
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		class FString                                      Name                                                       (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FString                                      LightingName                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ULoadingScreenSettings::GetLoadingScreenTextureAsset(const class FString& Name, const class FString& LightingName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.LoadingScreenSettings.GetLoadingScreenTextureAsset");
		
		ULoadingScreenSettings_GetLoadingScreenTextureAsset_Params params {};
		params.Name = Name;
		params.LightingName = LightingName;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ULoadingScreenSettings.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ULoadingScreenSettings::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.LoadingScreenSettings");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056EA2D0
	 * 		Name   -> Function Insurgency.LoadingScreenStatics.HideViewportLoadingScreen
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UObject*                                     WorldContext                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ULoadingScreenStatics::STATIC_HideViewportLoadingScreen(class UObject* WorldContext)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.LoadingScreenStatics.HideViewportLoadingScreen");
		
		ULoadingScreenStatics_HideViewportLoadingScreen_Params params {};
		params.WorldContext = WorldContext;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056EA240
	 * 		Name   -> Function Insurgency.LoadingScreenStatics.GetLoadingScreenProgress
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class FName                                        PackageName                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	float ULoadingScreenStatics::STATIC_GetLoadingScreenProgress(const class FName& PackageName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.LoadingScreenStatics.GetLoadingScreenProgress");
		
		ULoadingScreenStatics_GetLoadingScreenProgress_Params params {};
		params.PackageName = PackageName;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056E9FE0
	 * 		Name   -> Function Insurgency.LoadingScreenStatics.GetLoadingHints
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 */
	TArray<struct FLoadingScreenHint> ULoadingScreenStatics::STATIC_GetLoadingHints()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.LoadingScreenStatics.GetLoadingHints");
		
		ULoadingScreenStatics_GetLoadingHints_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056E9EB0
	 * 		Name   -> Function Insurgency.LoadingScreenStatics.DisplayViewportLoadingScreen
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		class UObject*                                     WorldContext                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FLoadingScreenSetup                         Setup                                                      (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void ULoadingScreenStatics::STATIC_DisplayViewportLoadingScreen(class UObject* WorldContext, const struct FLoadingScreenSetup& Setup)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.LoadingScreenStatics.DisplayViewportLoadingScreen");
		
		ULoadingScreenStatics_DisplayViewportLoadingScreen_Params params {};
		params.WorldContext = WorldContext;
		params.Setup = Setup;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ULoadingScreenStatics.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ULoadingScreenStatics::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.LoadingScreenStatics");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ULocalizableObjectInterface.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ULocalizableObjectInterface::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.LocalizableObjectInterface");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056EB850
	 * 		Name   -> Function Insurgency.MagazineDebris.SetFromAmmoContainer
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UClass*                                      AmmoContainerClass                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AMagazineDebris::SetFromAmmoContainer(class UClass* AmmoContainerClass)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.MagazineDebris.SetFromAmmoContainer");
		
		AMagazineDebris_SetFromAmmoContainer_Params params {};
		params.AmmoContainerClass = AmmoContainerClass;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AMagazineDebris.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AMagazineDebris::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.MagazineDebris");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> Function Insurgency.MainMenuWidget.InitMenu
	 * 		Flags  -> (Event, Public, BlueprintCallable, BlueprintEvent)
	 */
	void UMainMenuWidget::InitMenu()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.MainMenuWidget.InitMenu");
		
		UMainMenuWidget_InitMenu_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMainMenuWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMainMenuWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.MainMenuWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMainMenuSettings.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMainMenuSettings::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.MainMenuSettings");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> Function Insurgency.MapIconWidget.BlueprintOnTeamChange
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		unsigned char                                      TeamId                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class ATeamInfo*                                   TeamInfo                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UMapIconWidget::BlueprintOnTeamChange(unsigned char TeamId, class ATeamInfo* TeamInfo)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.MapIconWidget.BlueprintOnTeamChange");
		
		UMapIconWidget_BlueprintOnTeamChange_Params params {};
		params.TeamId = TeamId;
		params.TeamInfo = TeamInfo;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMapIconWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMapIconWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.MapIconWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056ECC60
	 * 		Name   -> Function Insurgency.MapActorWidget.UpdateFollowActor
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	bool UMapActorWidget::UpdateFollowActor()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.MapActorWidget.UpdateFollowActor");
		
		UMapActorWidget_UpdateFollowActor_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056ECC40
	 * 		Name   -> Function Insurgency.MapActorWidget.SizeToActorBounds
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void UMapActorWidget::SizeToActorBounds()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.MapActorWidget.SizeToActorBounds");
		
		UMapActorWidget_SizeToActorBounds_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056ECBB0
	 * 		Name   -> Function Insurgency.MapActorWidget.SetToTeamColor
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bHasNoTeam                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UMapActorWidget::SetToTeamColor(bool bHasNoTeam)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.MapActorWidget.SetToTeamColor");
		
		UMapActorWidget_SetToTeamColor_Params params {};
		params.bHasNoTeam = bHasNoTeam;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056ECAC0
	 * 		Name   -> Function Insurgency.MapActorWidget.GetRepresentativeLocation
	 * 		Flags  -> (Native, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		struct FVector                                     OutLocation                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FRotator                                    OutRotation                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UMapActorWidget::GetRepresentativeLocation(struct FVector* OutLocation, struct FRotator* OutRotation)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.MapActorWidget.GetRepresentativeLocation");
		
		UMapActorWidget_GetRepresentativeLocation_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutLocation != nullptr)
			*OutLocation = params.OutLocation;
		if (OutRotation != nullptr)
			*OutRotation = params.OutRotation;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056ECA90
	 * 		Name   -> Function Insurgency.MapActorWidget.GetFollowedActor
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	class AActor* UMapActorWidget::GetFollowedActor()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.MapActorWidget.GetFollowedActor");
		
		UMapActorWidget_GetFollowedActor_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMapActorWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMapActorWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.MapActorWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMapIconPointOfInterestWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMapIconPointOfInterestWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.MapIconPointOfInterestWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMapItemPickupWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMapItemPickupWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.MapItemPickupWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056ED290
	 * 		Name   -> Function Insurgency.MapRestrictedAreaWidget.GetFollowedRestrictedArea
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	class ARestrictedArea* UMapRestrictedAreaWidget::GetFollowedRestrictedArea()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.MapRestrictedAreaWidget.GetFollowedRestrictedArea");
		
		UMapRestrictedAreaWidget_GetFollowedRestrictedArea_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMapRestrictedAreaWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMapRestrictedAreaWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.MapRestrictedAreaWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056ED6B0
	 * 		Name   -> Function Insurgency.MapSoldierWidget.UpdatePlayerZOrder
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void UMapSoldierWidget::UpdatePlayerZOrder()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.MapSoldierWidget.UpdatePlayerZOrder");
		
		UMapSoldierWidget_UpdatePlayerZOrder_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056ED5F0
	 * 		Name   -> Function Insurgency.MapSoldierWidget.OnUpdateObjective
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		class AINSPlayerState*                             PlayerState                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AObjectiveBase*                              NewActiveObjective                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UMapSoldierWidget::OnUpdateObjective(class AINSPlayerState* PlayerState, class AObjectiveBase* NewActiveObjective)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.MapSoldierWidget.OnUpdateObjective");
		
		UMapSoldierWidget_OnUpdateObjective_Params params {};
		params.PlayerState = PlayerState;
		params.NewActiveObjective = NewActiveObjective;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056ED5C0
	 * 		Name   -> Function Insurgency.MapSoldierWidget.GetFollowedSoldier
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	class AINSSoldier* UMapSoldierWidget::GetFollowedSoldier()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.MapSoldierWidget.GetFollowedSoldier");
		
		UMapSoldierWidget_GetFollowedSoldier_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> Function Insurgency.MapSoldierWidget.BlueprintOnUpdateObjective
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		class AINSPlayerState*                             PlayerState                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AObjectiveBase*                              NewActiveObjective                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UMapSoldierWidget::BlueprintOnUpdateObjective(class AINSPlayerState* PlayerState, class AObjectiveBase* NewActiveObjective)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.MapSoldierWidget.BlueprintOnUpdateObjective");
		
		UMapSoldierWidget_BlueprintOnUpdateObjective_Params params {};
		params.PlayerState = PlayerState;
		params.NewActiveObjective = NewActiveObjective;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> Function Insurgency.MapSoldierWidget.BlueprintOnUpdateLocalViewTarget
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 */
	void UMapSoldierWidget::BlueprintOnUpdateLocalViewTarget()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.MapSoldierWidget.BlueprintOnUpdateLocalViewTarget");
		
		UMapSoldierWidget_BlueprintOnUpdateLocalViewTarget_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> Function Insurgency.MapSoldierWidget.BlueprintOnObjectiveStateChange
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 */
	void UMapSoldierWidget::BlueprintOnObjectiveStateChange()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.MapSoldierWidget.BlueprintOnObjectiveStateChange");
		
		UMapSoldierWidget_BlueprintOnObjectiveStateChange_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMapSoldierWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMapSoldierWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.MapSoldierWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056ED850
	 * 		Name   -> Function Insurgency.MapSpawnZoneWidget.GetFollowedSpawnZone
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	class ASpawnZone* UMapSpawnZoneWidget::GetFollowedSpawnZone()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.MapSpawnZoneWidget.GetFollowedSpawnZone");
		
		UMapSpawnZoneWidget_GetFollowedSpawnZone_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMapSpawnZoneWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMapSpawnZoneWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.MapSpawnZoneWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056EDA00
	 * 		Name   -> Function Insurgency.MapSupplyCrateActor.GetFollowedCrate
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	class ASupplyCrate* UMapSupplyCrateActor::GetFollowedCrate()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.MapSupplyCrateActor.GetFollowedCrate");
		
		UMapSupplyCrateActor_GetFollowedCrate_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMapSupplyCrateActor.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMapSupplyCrateActor::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.MapSupplyCrateActor");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056EDBB0
	 * 		Name   -> Function Insurgency.MapVehicleWidget.GetFollowedVehicle
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	class AVehicleBase* UMapVehicleWidget::GetFollowedVehicle()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.MapVehicleWidget.GetFollowedVehicle");
		
		UMapVehicleWidget_GetFollowedVehicle_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMapVehicleWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMapVehicleWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.MapVehicleWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMapVoteManager.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMapVoteManager::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.MapVoteManager");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056EEAC0
	 * 		Name   -> Function Insurgency.MapVoteButtonInterface.SetVoteCount
	 * 		Flags  -> (Native, Event, Public, BlueprintCallable, BlueprintEvent)
	 * Parameters:
	 * 		int32_t                                            NewVoteCount                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UMapVoteButtonInterface::SetVoteCount(int32_t NewVoteCount)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.MapVoteButtonInterface.SetVoteCount");
		
		UMapVoteButtonInterface_SetVoteCount_Params params {};
		params.NewVoteCount = NewVoteCount;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056EEA30
	 * 		Name   -> Function Insurgency.MapVoteButtonInterface.SetLocalVoteState
	 * 		Flags  -> (Native, Event, Public, BlueprintCallable, BlueprintEvent)
	 * Parameters:
	 * 		bool                                               bSelected                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UMapVoteButtonInterface::SetLocalVoteState(bool bSelected)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.MapVoteButtonInterface.SetLocalVoteState");
		
		UMapVoteButtonInterface_SetLocalVoteState_Params params {};
		params.bSelected = bSelected;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05662740
	 * 		Name   -> Function Insurgency.MapVoteButtonInterface.PlayWinningVoteAnimation
	 * 		Flags  -> (Native, Event, Public, BlueprintCallable, BlueprintEvent)
	 */
	void UMapVoteButtonInterface::PlayWinningVoteAnimation()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.MapVoteButtonInterface.PlayWinningVoteAnimation");
		
		UMapVoteButtonInterface_PlayWinningVoteAnimation_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056EEA10
	 * 		Name   -> Function Insurgency.MapVoteButtonInterface.PlayLosingVoteAnimation
	 * 		Flags  -> (Native, Event, Public, BlueprintCallable, BlueprintEvent)
	 */
	void UMapVoteButtonInterface::PlayLosingVoteAnimation()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.MapVoteButtonInterface.PlayLosingVoteAnimation");
		
		UMapVoteButtonInterface_PlayLosingVoteAnimation_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMapVoteButtonInterface.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMapVoteButtonInterface::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.MapVoteButtonInterface");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056EEB40
	 * 		Name   -> Function Insurgency.MapVoteWidget.SubmitMapVote
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		EMapVoteSelection                                  Selection                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UMapVoteWidget::SubmitMapVote(EMapVoteSelection Selection)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.MapVoteWidget.SubmitMapVote");
		
		UMapVoteWidget_SubmitMapVote_Params params {};
		params.Selection = Selection;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> Function Insurgency.MapVoteWidget.RestoreWidgetFocus
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 */
	void UMapVoteWidget::RestoreWidgetFocus()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.MapVoteWidget.RestoreWidgetFocus");
		
		UMapVoteWidget_RestoreWidgetFocus_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> Function Insurgency.MapVoteWidget.OnVoteWinnerChosen
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		EMapVoteSelection                                  Selection                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UMapVoteWidget::OnVoteWinnerChosen(EMapVoteSelection Selection)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.MapVoteWidget.OnVoteWinnerChosen");
		
		UMapVoteWidget_OnVoteWinnerChosen_Params params {};
		params.Selection = Selection;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> Function Insurgency.MapVoteWidget.OnVoteCountUpdated
	 * 		Flags  -> (Event, Public, HasOutParms, BlueprintEvent)
	 * Parameters:
	 * 		TArray<struct FMapVoteCount>                       Data                                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UMapVoteWidget::OnVoteCountUpdated(TArray<struct FMapVoteCount> Data)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.MapVoteWidget.OnVoteCountUpdated");
		
		UMapVoteWidget_OnVoteCountUpdated_Params params {};
		params.Data = Data;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> Function Insurgency.MapVoteWidget.OnMapVoteStarted
	 * 		Flags  -> (Event, Public, HasOutParms, BlueprintEvent)
	 * Parameters:
	 * 		TArray<struct FMapVoteOption>                      Maps                                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              EndTime                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bInCanVoteRefresh                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UMapVoteWidget::OnMapVoteStarted(TArray<struct FMapVoteOption> Maps, float EndTime, bool bInCanVoteRefresh)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.MapVoteWidget.OnMapVoteStarted");
		
		UMapVoteWidget_OnMapVoteStarted_Params params {};
		params.Maps = Maps;
		params.EndTime = EndTime;
		params.bInCanVoteRefresh = bInCanVoteRefresh;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> Function Insurgency.MapVoteWidget.OnLocalOptionSelected
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		EMapVoteSelection                                  Selection                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UMapVoteWidget::OnLocalOptionSelected(EMapVoteSelection Selection)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.MapVoteWidget.OnLocalOptionSelected");
		
		UMapVoteWidget_OnLocalOptionSelected_Params params {};
		params.Selection = Selection;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMapVoteWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMapVoteWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.MapVoteWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x057138A0
	 * 		Name   -> Function Insurgency.ProfileCharacter.UpdateVisibility
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void AProfileCharacter::UpdateVisibility()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ProfileCharacter.UpdateVisibility");
		
		AProfileCharacter_UpdateVisibility_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056B15F0
	 * 		Name   -> Function Insurgency.ProfileCharacter.StopAnimMontage
	 * 		Flags  -> (Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UAnimMontage*                                AnimMontage                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AProfileCharacter::StopAnimMontage(class UAnimMontage* AnimMontage)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ProfileCharacter.StopAnimMontage");
		
		AProfileCharacter_StopAnimMontage_Params params {};
		params.AnimMontage = AnimMontage;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05713710
	 * 		Name   -> Function Insurgency.ProfileCharacter.SpawnPreviewWeaponWithUpgrades
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable)
	 */
	void AProfileCharacter::SpawnPreviewWeaponWithUpgrades()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ProfileCharacter.SpawnPreviewWeaponWithUpgrades");
		
		AProfileCharacter_SpawnPreviewWeaponWithUpgrades_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05713610
	 * 		Name   -> Function Insurgency.ProfileCharacter.SpawnPreviewWeapon
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void AProfileCharacter::SpawnPreviewWeapon()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ProfileCharacter.SpawnPreviewWeapon");
		
		AProfileCharacter_SpawnPreviewWeapon_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05713590
	 * 		Name   -> Function Insurgency.ProfileCharacter.SetPreviewWeapon
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class AItemBase*                                   PreviewWeapon                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AProfileCharacter::SetPreviewWeapon(class AItemBase* PreviewWeapon)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ProfileCharacter.SetPreviewWeapon");
		
		AProfileCharacter_SetPreviewWeapon_Params params {};
		params.PreviewWeapon = PreviewWeapon;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05713500
	 * 		Name   -> Function Insurgency.ProfileCharacter.SetMeshVisibility
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bVisible                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AProfileCharacter::SetMeshVisibility(bool bVisible)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ProfileCharacter.SetMeshVisibility");
		
		AProfileCharacter_SetMeshVisibility_Params params {};
		params.bVisible = bVisible;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05713410
	 * 		Name   -> Function Insurgency.ProfileCharacter.SetCosmeticsFromState
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		struct FProfileCharacterCosmeticState              NewCosmeticState                                           (Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void AProfileCharacter::SetCosmeticsFromState(struct FProfileCharacterCosmeticState* NewCosmeticState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ProfileCharacter.SetCosmeticsFromState");
		
		AProfileCharacter_SetCosmeticsFromState_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (NewCosmeticState != nullptr)
			*NewCosmeticState = params.NewCosmeticState;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05713380
	 * 		Name   -> Function Insurgency.ProfileCharacter.SetCosmeticMeshVisibility
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bVisible                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AProfileCharacter::SetCosmeticMeshVisibility(bool bVisible)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ProfileCharacter.SetCosmeticMeshVisibility");
		
		AProfileCharacter_SetCosmeticMeshVisibility_Params params {};
		params.bVisible = bVisible;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05713360
	 * 		Name   -> Function Insurgency.ProfileCharacter.RemovePreviewWeapon
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void AProfileCharacter::RemovePreviewWeapon()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ProfileCharacter.RemovePreviewWeapon");
		
		AProfileCharacter_RemovePreviewWeapon_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x057132E0
	 * 		Name   -> Function Insurgency.ProfileCharacter.RemoveCosmeticByClass
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UClass*                                      Cosmetic                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AProfileCharacter::RemoveCosmeticByClass(class UClass* Cosmetic)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ProfileCharacter.RemoveCosmeticByClass");
		
		AProfileCharacter_RemoveCosmeticByClass_Params params {};
		params.Cosmetic = Cosmetic;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x057132C0
	 * 		Name   -> Function Insurgency.ProfileCharacter.RefreshAppliedCosmetics
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void AProfileCharacter::RefreshAppliedCosmetics()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ProfileCharacter.RefreshAppliedCosmetics");
		
		AProfileCharacter_RefreshAppliedCosmetics_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x057131B0
	 * 		Name   -> Function Insurgency.ProfileCharacter.PlayAnimMontage
	 * 		Flags  -> (Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UAnimMontage*                                AnimMontage                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              InPlayRate                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FName                                        StartSectionName                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	float AProfileCharacter::PlayAnimMontage(class UAnimMontage* AnimMontage, float InPlayRate, const class FName& StartSectionName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ProfileCharacter.PlayAnimMontage");
		
		AProfileCharacter_PlayAnimMontage_Params params {};
		params.AnimMontage = AnimMontage;
		params.InPlayRate = InPlayRate;
		params.StartSectionName = StartSectionName;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05713190
	 * 		Name   -> Function Insurgency.ProfileCharacter.OnSwitchFaction
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void AProfileCharacter::OnSwitchFaction()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ProfileCharacter.OnSwitchFaction");
		
		AProfileCharacter_OnSwitchFaction_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x057130C0
	 * 		Name   -> Function Insurgency.ProfileCharacter.OnProfileBlockLoaded
	 * 		Flags  -> (Final, Native, Private)
	 * Parameters:
	 * 		EProfileBlockType                                  Type                                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bFromCloud                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AProfileCharacter::OnProfileBlockLoaded(EProfileBlockType Type, bool bFromCloud)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ProfileCharacter.OnProfileBlockLoaded");
		
		AProfileCharacter_OnProfileBlockLoaded_Params params {};
		params.Type = Type;
		params.bFromCloud = bFromCloud;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05713030
	 * 		Name   -> Function Insurgency.ProfileCharacter.OnCustomizeMenuChanged
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bIsCustomizing                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AProfileCharacter::OnCustomizeMenuChanged(bool bIsCustomizing)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ProfileCharacter.OnCustomizeMenuChanged");
		
		AProfileCharacter_OnCustomizeMenuChanged_Params params {};
		params.bIsCustomizing = bIsCustomizing;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05712FB0
	 * 		Name   -> Function Insurgency.ProfileCharacter.OnCosmeticMeshesLoaded
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		class UCosmeticItem*                               Cosmetic                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AProfileCharacter::OnCosmeticMeshesLoaded(class UCosmeticItem* Cosmetic)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ProfileCharacter.OnCosmeticMeshesLoaded");
		
		AProfileCharacter_OnCosmeticMeshesLoaded_Params params {};
		params.Cosmetic = Cosmetic;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05712F90
	 * 		Name   -> Function Insurgency.ProfileCharacter.OnAllCosmeticMeshesLoaded
	 * 		Flags  -> (Final, Native, Public)
	 */
	void AProfileCharacter::OnAllCosmeticMeshesLoaded()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ProfileCharacter.OnAllCosmeticMeshesLoaded");
		
		AProfileCharacter_OnAllCosmeticMeshesLoaded_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05712F10
	 * 		Name   -> Function Insurgency.ProfileCharacter.InitProfileCharacter
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UINSLocalPlayer*                             InPlayer                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AProfileCharacter::InitProfileCharacter(class UINSLocalPlayer* InPlayer)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ProfileCharacter.InitProfileCharacter");
		
		AProfileCharacter_InitProfileCharacter_Params params {};
		params.InPlayer = InPlayer;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05691A30
	 * 		Name   -> Function Insurgency.ProfileCharacter.GetSharedCosmeticState
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	class USharedCosmeticState* AProfileCharacter::GetSharedCosmeticState()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ProfileCharacter.GetSharedCosmeticState");
		
		AProfileCharacter_GetSharedCosmeticState_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05712EE0
	 * 		Name   -> Function Insurgency.ProfileCharacter.GetCurrentMontage
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	class UAnimMontage* AProfileCharacter::GetCurrentMontage()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ProfileCharacter.GetCurrentMontage");
		
		AProfileCharacter_GetCurrentMontage_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05712E60
	 * 		Name   -> Function Insurgency.ProfileCharacter.DetachCosmeticFromMesh
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UClass*                                      Cosmetic                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AProfileCharacter::DetachCosmeticFromMesh(class UClass* Cosmetic)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ProfileCharacter.DetachCosmeticFromMesh");
		
		AProfileCharacter_DetachCosmeticFromMesh_Params params {};
		params.Cosmetic = Cosmetic;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05712E40
	 * 		Name   -> Function Insurgency.ProfileCharacter.DetachAllCosmeticsFromMesh
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void AProfileCharacter::DetachAllCosmeticsFromMesh()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ProfileCharacter.DetachAllCosmeticsFromMesh");
		
		AProfileCharacter_DetachAllCosmeticsFromMesh_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05712D10
	 * 		Name   -> Function Insurgency.ProfileCharacter.AttachCosmeticToMesh
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		struct FSelectedCosmetic                           SelectedCosmetic                                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		bool                                               bStartVisible                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AProfileCharacter::AttachCosmeticToMesh(const struct FSelectedCosmetic& SelectedCosmetic, bool bStartVisible)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ProfileCharacter.AttachCosmeticToMesh");
		
		AProfileCharacter_AttachCosmeticToMesh_Params params {};
		params.SelectedCosmetic = SelectedCosmetic;
		params.bStartVisible = bStartVisible;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05712E20
	 * 		Name   -> Function Insurgency.ProfileCharacter.AttachCosmeticsToMesh
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void AProfileCharacter::AttachCosmeticsToMesh()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ProfileCharacter.AttachCosmeticsToMesh");
		
		AProfileCharacter_AttachCosmeticsToMesh_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05712C50
	 * 		Name   -> Function Insurgency.ProfileCharacter.ApplyCosmetic
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		struct FSelectedCosmetic                           SelectedCosmetic                                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void AProfileCharacter::ApplyCosmetic(const struct FSelectedCosmetic& SelectedCosmetic)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ProfileCharacter.ApplyCosmetic");
		
		AProfileCharacter_ApplyCosmetic_Params params {};
		params.SelectedCosmetic = SelectedCosmetic;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AProfileCharacter.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AProfileCharacter::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.ProfileCharacter");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056EFEE0
	 * 		Name   -> Function Insurgency.MarketingProfileCharacter.LoadCosmetics
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void AMarketingProfileCharacter::LoadCosmetics()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.MarketingProfileCharacter.LoadCosmetics");
		
		AMarketingProfileCharacter_LoadCosmetics_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056EFBA0
	 * 		Name   -> Function Insurgency.MarketingProfileCharacter.GetWeaponFallbackDetails
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FWeaponFallbackModel                        InWeaponFallbackModel                                      (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 * 		int32_t                                            OutSlot                                                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EAttachmentFallbackMode                            OutFallbackMode                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AMarketingProfileCharacter::GetWeaponFallbackDetails(const struct FWeaponFallbackModel& InWeaponFallbackModel, int32_t* OutSlot, EAttachmentFallbackMode* OutFallbackMode)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.MarketingProfileCharacter.GetWeaponFallbackDetails");
		
		AMarketingProfileCharacter_GetWeaponFallbackDetails_Params params {};
		params.InWeaponFallbackModel = InWeaponFallbackModel;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutSlot != nullptr)
			*OutSlot = params.OutSlot;
		if (OutFallbackMode != nullptr)
			*OutFallbackMode = params.OutFallbackMode;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056EFA50
	 * 		Name   -> Function Insurgency.MarketingProfileCharacter.BP_UpdateEnum
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		class FString                                      EnumName                                                   (ConstParm, Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		TArray<class FName>                                Names                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AMarketingProfileCharacter::BP_UpdateEnum(const class FString& EnumName, TArray<class FName> Names)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.MarketingProfileCharacter.BP_UpdateEnum");
		
		AMarketingProfileCharacter_BP_UpdateEnum_Params params {};
		params.EnumName = EnumName;
		params.Names = Names;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AMarketingProfileCharacter.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AMarketingProfileCharacter::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.MarketingProfileCharacter");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AMenuGameMode.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AMenuGameMode::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.MenuGameMode");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> Function Insurgency.MenuPartyWidget.UpdateWaitingDialogInfoBP
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 */
	void UMenuPartyWidget::UpdateWaitingDialogInfoBP()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.MenuPartyWidget.UpdateWaitingDialogInfoBP");
		
		UMenuPartyWidget_UpdateWaitingDialogInfoBP_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> Function Insurgency.MenuPartyWidget.UpdateReturningDialogInfoBP
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 */
	void UMenuPartyWidget::UpdateReturningDialogInfoBP()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.MenuPartyWidget.UpdateReturningDialogInfoBP");
		
		UMenuPartyWidget_UpdateReturningDialogInfoBP_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> Function Insurgency.MenuPartyWidget.UpdateRestrictionDialogInfoBP
	 * 		Flags  -> (Event, Protected, HasOutParms, BlueprintEvent)
	 * Parameters:
	 * 		class FText                                        InConfirmableText                                          (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UMenuPartyWidget::UpdateRestrictionDialogInfoBP(const class FText& InConfirmableText)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.MenuPartyWidget.UpdateRestrictionDialogInfoBP");
		
		UMenuPartyWidget_UpdateRestrictionDialogInfoBP_Params params {};
		params.InConfirmableText = InConfirmableText;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056F0DF0
	 * 		Name   -> Function Insurgency.MenuPartyWidget.TryEnterParty
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void UMenuPartyWidget::TryEnterParty()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.MenuPartyWidget.TryEnterParty");
		
		UMenuPartyWidget_TryEnterParty_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056F0DD0
	 * 		Name   -> Function Insurgency.MenuPartyWidget.RemoveExistingDialogs
	 * 		Flags  -> (Final, Native, Protected, BlueprintCallable)
	 */
	void UMenuPartyWidget::RemoveExistingDialogs()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.MenuPartyWidget.RemoveExistingDialogs");
		
		UMenuPartyWidget_RemoveExistingDialogs_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056F0D50
	 * 		Name   -> Function Insurgency.MenuPartyWidget.ReactOnPrivilegeResult
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		EUserPrivilegeResult                               PrivilegeResult                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UMenuPartyWidget::ReactOnPrivilegeResult(EUserPrivilegeResult PrivilegeResult)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.MenuPartyWidget.ReactOnPrivilegeResult");
		
		UMenuPartyWidget_ReactOnPrivilegeResult_Params params {};
		params.PrivilegeResult = PrivilegeResult;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056F0CC0
	 * 		Name   -> Function Insurgency.MenuPartyWidget.OnPlatformConnectionStatusChanged
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		bool                                               bIsConnected                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UMenuPartyWidget::OnPlatformConnectionStatusChanged(bool bIsConnected)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.MenuPartyWidget.OnPlatformConnectionStatusChanged");
		
		UMenuPartyWidget_OnPlatformConnectionStatusChanged_Params params {};
		params.bIsConnected = bIsConnected;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056F0CA0
	 * 		Name   -> Function Insurgency.MenuPartyWidget.OnDeclineReturningDialog
	 * 		Flags  -> (Final, Native, Protected, BlueprintCallable)
	 */
	void UMenuPartyWidget::OnDeclineReturningDialog()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.MenuPartyWidget.OnDeclineReturningDialog");
		
		UMenuPartyWidget_OnDeclineReturningDialog_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056F0C80
	 * 		Name   -> Function Insurgency.MenuPartyWidget.OnCofirmeReturningDialog
	 * 		Flags  -> (Final, Native, Protected, BlueprintCallable)
	 */
	void UMenuPartyWidget::OnCofirmeReturningDialog()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.MenuPartyWidget.OnCofirmeReturningDialog");
		
		UMenuPartyWidget_OnCofirmeReturningDialog_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMenuPartyWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMenuPartyWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.MenuPartyWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056F1D00
	 * 		Name   -> Function Insurgency.MenuPlayerCameraManager.SwitchToMainCamera
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void AMenuPlayerCameraManager::SwitchToMainCamera()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.MenuPlayerCameraManager.SwitchToMainCamera");
		
		AMenuPlayerCameraManager_SwitchToMainCamera_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056F1C70
	 * 		Name   -> Function Insurgency.MenuPlayerCameraManager.SwitchToLoadoutCamera
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bCharacter                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AMenuPlayerCameraManager::SwitchToLoadoutCamera(bool bCharacter)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.MenuPlayerCameraManager.SwitchToLoadoutCamera");
		
		AMenuPlayerCameraManager_SwitchToLoadoutCamera_Params params {};
		params.bCharacter = bCharacter;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056F1B60
	 * 		Name   -> Function Insurgency.MenuPlayerCameraManager.SwitchToCosmeticCamera
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		ECharacterAppearanceSlot                           CosmeticSlot                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            SubSlot                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bForce                                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AMenuPlayerCameraManager::SwitchToCosmeticCamera(ECharacterAppearanceSlot CosmeticSlot, int32_t SubSlot, bool bForce)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.MenuPlayerCameraManager.SwitchToCosmeticCamera");
		
		AMenuPlayerCameraManager_SwitchToCosmeticCamera_Params params {};
		params.CosmeticSlot = CosmeticSlot;
		params.SubSlot = SubSlot;
		params.bForce = bForce;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056F1B40
	 * 		Name   -> Function Insurgency.MenuPlayerCameraManager.SwitchToAppearanceCamera
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void AMenuPlayerCameraManager::SwitchToAppearanceCamera()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.MenuPlayerCameraManager.SwitchToAppearanceCamera");
		
		AMenuPlayerCameraManager_SwitchToAppearanceCamera_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056F1AC0
	 * 		Name   -> Function Insurgency.MenuPlayerCameraManager.SmoothTransitionToCamera
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class ACameraActor*                                DesiredCamera                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AMenuPlayerCameraManager::SmoothTransitionToCamera(class ACameraActor* DesiredCamera)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.MenuPlayerCameraManager.SmoothTransitionToCamera");
		
		AMenuPlayerCameraManager_SmoothTransitionToCamera_Params params {};
		params.DesiredCamera = DesiredCamera;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> DelegateFunction Insurgency.MenuPlayerCameraManager.SetUsingCustomizationLightsEvent__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 * Parameters:
	 * 		bool                                               bEnabled                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AMenuPlayerCameraManager::SetUsingCustomizationLightsEvent__DelegateSignature(bool bEnabled)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction Insurgency.MenuPlayerCameraManager.SetUsingCustomizationLightsEvent__DelegateSignature");
		
		AMenuPlayerCameraManager_SetUsingCustomizationLightsEvent__DelegateSignature_Params params {};
		params.bEnabled = bEnabled;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056F19B0
	 * 		Name   -> Function Insurgency.MenuPlayerCameraManager.SetUsingCustomizationLights
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bNewUsingCustomizationLights                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AMenuPlayerCameraManager::SetUsingCustomizationLights(bool bNewUsingCustomizationLights)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.MenuPlayerCameraManager.SetUsingCustomizationLights");
		
		AMenuPlayerCameraManager_SetUsingCustomizationLights_Params params {};
		params.bNewUsingCustomizationLights = bNewUsingCustomizationLights;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056F1A40
	 * 		Name   -> Function Insurgency.MenuPlayerCameraManager.SetupMainCamera
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class ACameraActor*                                InMainCamera                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AMenuPlayerCameraManager::SetupMainCamera(class ACameraActor* InMainCamera)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.MenuPlayerCameraManager.SetupMainCamera");
		
		AMenuPlayerCameraManager_SetupMainCamera_Params params {};
		params.InMainCamera = InMainCamera;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056F18F0
	 * 		Name   -> Function Insurgency.MenuPlayerCameraManager.SetLoadoutCameras
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class ACameraActor*                                InLoadoutCharacterCamera                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class ACameraActor*                                InLoadoutWeaponCamera                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AMenuPlayerCameraManager::SetLoadoutCameras(class ACameraActor* InLoadoutCharacterCamera, class ACameraActor* InLoadoutWeaponCamera)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.MenuPlayerCameraManager.SetLoadoutCameras");
		
		AMenuPlayerCameraManager_SetLoadoutCameras_Params params {};
		params.InLoadoutCharacterCamera = InLoadoutCharacterCamera;
		params.InLoadoutWeaponCamera = InLoadoutWeaponCamera;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056F1870
	 * 		Name   -> Function Insurgency.MenuPlayerCameraManager.SetAppearanceCamera
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class ACameraActor*                                InAppearanceCharacterCamera                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AMenuPlayerCameraManager::SetAppearanceCamera(class ACameraActor* InAppearanceCharacterCamera)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.MenuPlayerCameraManager.SetAppearanceCamera");
		
		AMenuPlayerCameraManager_SetAppearanceCamera_Params params {};
		params.InAppearanceCharacterCamera = InAppearanceCharacterCamera;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056F1750
	 * 		Name   -> Function Insurgency.MenuPlayerCameraManager.RegisterMenuDynamicLights
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		TArray<class ALight*>                              InCustomizationLights                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		TArray<class ALight*>                              InDefaultLights                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AMenuPlayerCameraManager::RegisterMenuDynamicLights(TArray<class ALight*> InCustomizationLights, TArray<class ALight*> InDefaultLights)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.MenuPlayerCameraManager.RegisterMenuDynamicLights");
		
		AMenuPlayerCameraManager_RegisterMenuDynamicLights_Params params {};
		params.InCustomizationLights = InCustomizationLights;
		params.InDefaultLights = InDefaultLights;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056F1510
	 * 		Name   -> Function Insurgency.MenuPlayerCameraManager.RegisterCosmeticCameras
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		TMap<ECharacterAppearanceSlot, class ACameraActor*> InCosmeticSlotCameras                                      (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		TMap<ECharacterAppearanceSlot, struct FCameraForSubSlot> InSubSlotCamerasForSlot                                    (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void AMenuPlayerCameraManager::RegisterCosmeticCameras(TMap<ECharacterAppearanceSlot, class ACameraActor*> InCosmeticSlotCameras, TMap<ECharacterAppearanceSlot, struct FCameraForSubSlot> InSubSlotCamerasForSlot)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.MenuPlayerCameraManager.RegisterCosmeticCameras");
		
		AMenuPlayerCameraManager_RegisterCosmeticCameras_Params params {};
		params.InCosmeticSlotCameras = InCosmeticSlotCameras;
		params.InSubSlotCamerasForSlot = InSubSlotCamerasForSlot;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AMenuPlayerCameraManager.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AMenuPlayerCameraManager::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.MenuPlayerCameraManager");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056F2680
	 * 		Name   -> Function Insurgency.MenuPlayerController.SetupKitPreviewActors
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class AKitPreviewCharacter*                        NewPreviewCharacter                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AKitPreviewWeapon*                           NewPreviewWeapon                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AMenuPlayerController::SetupKitPreviewActors(class AKitPreviewCharacter* NewPreviewCharacter, class AKitPreviewWeapon* NewPreviewWeapon)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.MenuPlayerController.SetupKitPreviewActors");
		
		AMenuPlayerController_SetupKitPreviewActors_Params params {};
		params.NewPreviewCharacter = NewPreviewCharacter;
		params.NewPreviewWeapon = NewPreviewWeapon;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056F2600
	 * 		Name   -> Function Insurgency.MenuPlayerController.SetPreviewCharacter
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class AProfileCharacter*                           NewPreviewCharacter                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AMenuPlayerController::SetPreviewCharacter(class AProfileCharacter* NewPreviewCharacter)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.MenuPlayerController.SetPreviewCharacter");
		
		AMenuPlayerController_SetPreviewCharacter_Params params {};
		params.NewPreviewCharacter = NewPreviewCharacter;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056F2580
	 * 		Name   -> Function Insurgency.MenuPlayerController.SetLoadoutMenuSupplyPoints
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		int32_t                                            SupplyPoints                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AMenuPlayerController::SetLoadoutMenuSupplyPoints(int32_t SupplyPoints)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.MenuPlayerController.SetLoadoutMenuSupplyPoints");
		
		AMenuPlayerController_SetLoadoutMenuSupplyPoints_Params params {};
		params.SupplyPoints = SupplyPoints;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056F24C0
	 * 		Name   -> Function Insurgency.MenuPlayerController.SetLoadoutMenuSquadLayoutCollection
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UMenuSquadLayout*                            MenuSquadLayout                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            SectionIndex                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AMenuPlayerController::SetLoadoutMenuSquadLayoutCollection(class UMenuSquadLayout* MenuSquadLayout, int32_t SectionIndex)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.MenuPlayerController.SetLoadoutMenuSquadLayoutCollection");
		
		AMenuPlayerController_SetLoadoutMenuSquadLayoutCollection_Params params {};
		params.MenuSquadLayout = MenuSquadLayout;
		params.SectionIndex = SectionIndex;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056F23B0
	 * 		Name   -> Function Insurgency.MenuPlayerController.SetLoadoutMenuSquadLayoutAndClass
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class USquadLayout*                                SquadLayout                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UPlayerClass*                                PlayerClass                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bIsNight                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AMenuPlayerController::SetLoadoutMenuSquadLayoutAndClass(class USquadLayout* SquadLayout, class UPlayerClass* PlayerClass, bool bIsNight)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.MenuPlayerController.SetLoadoutMenuSquadLayoutAndClass");
		
		AMenuPlayerController_SetLoadoutMenuSquadLayoutAndClass_Params params {};
		params.SquadLayout = SquadLayout;
		params.PlayerClass = PlayerClass;
		params.bIsNight = bIsNight;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056F2320
	 * 		Name   -> Function Insurgency.MenuPlayerController.SaveLoadoutMenuLoadout
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bIsNight                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AMenuPlayerController::SaveLoadoutMenuLoadout(bool bIsNight)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.MenuPlayerController.SaveLoadoutMenuLoadout");
		
		AMenuPlayerController_SaveLoadoutMenuLoadout_Params params {};
		params.bIsNight = bIsNight;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> DelegateFunction Insurgency.MenuPlayerController.RefreshMenuSquadLayoutsDelegate__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate, HasOutParms)
	 */
	void AMenuPlayerController::RefreshMenuSquadLayoutsDelegate__DelegateSignature()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction Insurgency.MenuPlayerController.RefreshMenuSquadLayoutsDelegate__DelegateSignature");
		
		AMenuPlayerController_RefreshMenuSquadLayoutsDelegate__DelegateSignature_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> DelegateFunction Insurgency.MenuPlayerController.RefreshCosmeticsDelegate__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate, HasOutParms)
	 */
	void AMenuPlayerController::RefreshCosmeticsDelegate__DelegateSignature()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction Insurgency.MenuPlayerController.RefreshCosmeticsDelegate__DelegateSignature");
		
		AMenuPlayerController_RefreshCosmeticsDelegate__DelegateSignature_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> DelegateFunction Insurgency.MenuPlayerController.PlayerClassChangedDelegate__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 * Parameters:
	 * 		class UPlayerClass*                                PlayerClass                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AMenuPlayerController::PlayerClassChangedDelegate__DelegateSignature(class UPlayerClass* PlayerClass)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction Insurgency.MenuPlayerController.PlayerClassChangedDelegate__DelegateSignature");
		
		AMenuPlayerController_PlayerClassChangedDelegate__DelegateSignature_Params params {};
		params.PlayerClass = PlayerClass;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056F2250
	 * 		Name   -> Function Insurgency.MenuPlayerController.OnAvailableCosmeticsLoaded
	 * 		Flags  -> (Final, Native, Public, HasOutParms)
	 */
	void AMenuPlayerController::OnAvailableCosmeticsLoaded()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.MenuPlayerController.OnAvailableCosmeticsLoaded");
		
		AMenuPlayerController_OnAvailableCosmeticsLoaded_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056F2230
	 * 		Name   -> Function Insurgency.MenuPlayerController.LoadMenuSquadLayouts
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void AMenuPlayerController::LoadMenuSquadLayouts()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.MenuPlayerController.LoadMenuSquadLayouts");
		
		AMenuPlayerController_LoadMenuSquadLayouts_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> DelegateFunction Insurgency.MenuPlayerController.KitPreviewActorsSetDelegate__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 * Parameters:
	 * 		class AKitPreviewCharacter*                        KitPreviewCharacter                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AKitPreviewWeapon*                           KitPreviewWeapon                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AMenuPlayerController::KitPreviewActorsSetDelegate__DelegateSignature(class AKitPreviewCharacter* KitPreviewCharacter, class AKitPreviewWeapon* KitPreviewWeapon)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction Insurgency.MenuPlayerController.KitPreviewActorsSetDelegate__DelegateSignature");
		
		AMenuPlayerController_KitPreviewActorsSetDelegate__DelegateSignature_Params params {};
		params.KitPreviewCharacter = KitPreviewCharacter;
		params.KitPreviewWeapon = KitPreviewWeapon;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056F2210
	 * 		Name   -> Function Insurgency.MenuPlayerController.ClearLoadoutMenuData
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void AMenuPlayerController::ClearLoadoutMenuData()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.MenuPlayerController.ClearLoadoutMenuData");
		
		AMenuPlayerController_ClearLoadoutMenuData_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AMenuPlayerController.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AMenuPlayerController::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.MenuPlayerController");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMenuSquadLayout.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMenuSquadLayout::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.MenuSquadLayout");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> Function Insurgency.ModalPopupWidget.SetVisibleConfirmBtn
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		bool                                               bVisible                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UModalPopupWidget::SetVisibleConfirmBtn(bool bVisible)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ModalPopupWidget.SetVisibleConfirmBtn");
		
		UModalPopupWidget_SetVisibleConfirmBtn_Params params {};
		params.bVisible = bVisible;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> Function Insurgency.ModalPopupWidget.SetVisibleCancelBtn
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		bool                                               bVisible                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UModalPopupWidget::SetVisibleCancelBtn(bool bVisible)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ModalPopupWidget.SetVisibleCancelBtn");
		
		UModalPopupWidget_SetVisibleCancelBtn_Params params {};
		params.bVisible = bVisible;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> Function Insurgency.ModalPopupWidget.OnUpdatedText
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 */
	void UModalPopupWidget::OnUpdatedText()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ModalPopupWidget.OnUpdatedText");
		
		UModalPopupWidget_OnUpdatedText_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056F2E30
	 * 		Name   -> Function Insurgency.ModalPopupWidget.OnConfirmed
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void UModalPopupWidget::OnConfirmed()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ModalPopupWidget.OnConfirmed");
		
		UModalPopupWidget_OnConfirmed_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056F2E10
	 * 		Name   -> Function Insurgency.ModalPopupWidget.OnCancelled
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void UModalPopupWidget::OnCancelled()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ModalPopupWidget.OnCancelled");
		
		UModalPopupWidget_OnCancelled_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UModalPopupWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UModalPopupWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.ModalPopupWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UModData.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UModData::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.ModData");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056F3BB0
	 * 		Name   -> Function Insurgency.ModSubsystem.RenewToken
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void UModSubsystem::RenewToken()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ModSubsystem.RenewToken");
		
		UModSubsystem_RenewToken_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056F3A60
	 * 		Name   -> Function Insurgency.ModSubsystem.OnSubscribedModActivated
	 * 		Flags  -> (Final, Native, Private, HasOutParms)
	 * Parameters:
	 * 		struct FModState                                   ModState                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		bool                                               bIsUpToDate                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UModSubsystem::OnSubscribedModActivated(const struct FModState& ModState, bool bIsUpToDate)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ModSubsystem.OnSubscribedModActivated");
		
		UModSubsystem_OnSubscribedModActivated_Params params {};
		params.ModState = ModState;
		params.bIsUpToDate = bIsUpToDate;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056F39E0
	 * 		Name   -> Function Insurgency.ModSubsystem.OnOnlineAuthStateChanged
	 * 		Flags  -> (Final, Native, Private)
	 * Parameters:
	 * 		EModPlatformAuthState                              NewAuthState                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UModSubsystem::OnOnlineAuthStateChanged(EModPlatformAuthState NewAuthState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ModSubsystem.OnOnlineAuthStateChanged");
		
		UModSubsystem_OnOnlineAuthStateChanged_Params params {};
		params.NewAuthState = NewAuthState;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056F38F0
	 * 		Name   -> Function Insurgency.ModSubsystem.OnModDeactivatedFromCloud
	 * 		Flags  -> (Final, Native, Private, HasOutParms)
	 * Parameters:
	 * 		struct FModState                                   ModState                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UModSubsystem::OnModDeactivatedFromCloud(const struct FModState& ModState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ModSubsystem.OnModDeactivatedFromCloud");
		
		UModSubsystem_OnModDeactivatedFromCloud_Params params {};
		params.ModState = ModState;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056F38D0
	 * 		Name   -> Function Insurgency.ModSubsystem.OnInitialServerModDownloadsComplete
	 * 		Flags  -> (Final, Native, Private)
	 */
	void UModSubsystem::OnInitialServerModDownloadsComplete()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ModSubsystem.OnInitialServerModDownloadsComplete");
		
		UModSubsystem_OnInitialServerModDownloadsComplete_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056F38B0
	 * 		Name   -> Function Insurgency.ModSubsystem.OnAcceptedServiceTerms
	 * 		Flags  -> (Final, Native, Private)
	 */
	void UModSubsystem::OnAcceptedServiceTerms()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ModSubsystem.OnAcceptedServiceTerms");
		
		UModSubsystem_OnAcceptedServiceTerms_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056F3780
	 * 		Name   -> Function Insurgency.ModSubsystem.FindThumbnailForLevel
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		class FString                                      LevelName                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FString                                      Lighting                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UModSubsystem::FindThumbnailForLevel(const class FString& LevelName, const class FString& Lighting)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ModSubsystem.FindThumbnailForLevel");
		
		UModSubsystem_FindThumbnailForLevel_Params params {};
		params.LevelName = LevelName;
		params.Lighting = Lighting;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056F3650
	 * 		Name   -> Function Insurgency.ModSubsystem.FindLoadingScreenForLevel
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		class FString                                      LevelName                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FString                                      Lighting                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UModSubsystem::FindLoadingScreenForLevel(const class FString& LevelName, const class FString& Lighting)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ModSubsystem.FindLoadingScreenForLevel");
		
		UModSubsystem_FindLoadingScreenForLevel_Params params {};
		params.LevelName = LevelName;
		params.Lighting = Lighting;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UModSubsystem.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UModSubsystem::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.ModSubsystem");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056F3EB0
	 * 		Name   -> Function Insurgency.MountedWeapon.OnMountedWeaponReplicated
	 * 		Flags  -> (Final, Native, Protected)
	 */
	void AMountedWeapon::OnMountedWeaponReplicated()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.MountedWeapon.OnMountedWeaponReplicated");
		
		AMountedWeapon_OnMountedWeaponReplicated_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AMountedWeapon.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AMountedWeapon::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.MountedWeapon");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056F4060
	 * 		Name   -> Function Insurgency.MusicDirector.OnUIMusicBanksLoaded
	 * 		Flags  -> (Final, Native, Public)
	 */
	void UMusicDirector::OnUIMusicBanksLoaded()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.MusicDirector.OnUIMusicBanksLoaded");
		
		UMusicDirector_OnUIMusicBanksLoaded_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> DelegateFunction Insurgency.MusicDirector.MusicDirectorStateUpdate__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 * Parameters:
	 * 		EMusicDirectorState                                OldState                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EMusicDirectorState                                NewState                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UMusicDirector::MusicDirectorStateUpdate__DelegateSignature(EMusicDirectorState OldState, EMusicDirectorState NewState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction Insurgency.MusicDirector.MusicDirectorStateUpdate__DelegateSignature");
		
		UMusicDirector_MusicDirectorStateUpdate__DelegateSignature_Params params {};
		params.OldState = OldState;
		params.NewState = NewState;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMusicDirector.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMusicDirector::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.MusicDirector");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056F4630
	 * 		Name   -> Function Insurgency.MusicManagerComponent.OnPlayerMusicUpdated
	 * 		Flags  -> (Final, Native, Public, HasOutParms)
	 * Parameters:
	 * 		struct FPlayingMusic                               PlayingMusic                                               (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UMusicManagerComponent::OnPlayerMusicUpdated(const struct FPlayingMusic& PlayingMusic)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.MusicManagerComponent.OnPlayerMusicUpdated");
		
		UMusicManagerComponent_OnPlayerMusicUpdated_Params params {};
		params.PlayingMusic = PlayingMusic;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056F4570
	 * 		Name   -> Function Insurgency.MusicManagerComponent.OnMusicDirectorStateChange
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		EMusicDirectorState                                OldState                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EMusicDirectorState                                NewState                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UMusicManagerComponent::OnMusicDirectorStateChange(EMusicDirectorState OldState, EMusicDirectorState NewState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.MusicManagerComponent.OnMusicDirectorStateChange");
		
		UMusicManagerComponent_OnMusicDirectorStateChange_Params params {};
		params.OldState = OldState;
		params.NewState = NewState;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMusicManagerComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMusicManagerComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.MusicManagerComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056F7890
	 * 		Name   -> Function Insurgency.Mutator.OnTextMessageSent
	 * 		Flags  -> (Native, Event, Public, HasOutParms, BlueprintEvent)
	 * Parameters:
	 * 		class AINSPlayerController*                        Speaker                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FText                                        Message                                                    (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		bool                                               bTeamOnly                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UMutator::OnTextMessageSent(class AINSPlayerController* Speaker, const class FText& Message, bool bTeamOnly)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.Mutator.OnTextMessageSent");
		
		UMutator_OnTextMessageSent_Params params {};
		params.Speaker = Speaker;
		params.Message = Message;
		params.bTeamOnly = bTeamOnly;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056F7800
	 * 		Name   -> Function Insurgency.Mutator.OnTeamInitialized
	 * 		Flags  -> (Native, Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		class ATeamInfo*                                   Team                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UMutator::OnTeamInitialized(class ATeamInfo* Team)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.Mutator.OnTeamInitialized");
		
		UMutator_OnTeamInitialized_Params params {};
		params.Team = Team;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x04DD0020
	 * 		Name   -> Function Insurgency.Mutator.OnSwapSides
	 * 		Flags  -> (Native, Event, Public, BlueprintEvent)
	 */
	void UMutator::OnSwapSides()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.Mutator.OnSwapSides");
		
		UMutator_OnSwapSides_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x04DB5D80
	 * 		Name   -> Function Insurgency.Mutator.OnRoundStarted
	 * 		Flags  -> (Native, Event, Public, BlueprintEvent)
	 */
	void UMutator::OnRoundStarted()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.Mutator.OnRoundStarted");
		
		UMutator_OnRoundStarted_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x04DB48E0
	 * 		Name   -> Function Insurgency.Mutator.OnRoundReset
	 * 		Flags  -> (Native, Event, Public, BlueprintEvent)
	 */
	void UMutator::OnRoundReset()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.Mutator.OnRoundReset");
		
		UMutator_OnRoundReset_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056F7740
	 * 		Name   -> Function Insurgency.Mutator.OnRoundOver
	 * 		Flags  -> (Native, Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		ERoundConclusion                                   RoundEndReason                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		unsigned char                                      WinningTeam                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UMutator::OnRoundOver(ERoundConclusion RoundEndReason, unsigned char WinningTeam)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.Mutator.OnRoundOver");
		
		UMutator_OnRoundOver_Params params {};
		params.RoundEndReason = RoundEndReason;
		params.WinningTeam = WinningTeam;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056F75F0
	 * 		Name   -> Function Insurgency.Mutator.OnPlayerTeamChanged
	 * 		Flags  -> (Native, Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		class AController*                                 Controller                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		unsigned char                                      NewTeamId                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bForced                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bDidKillPlayer                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UMutator::OnPlayerTeamChanged(class AController* Controller, unsigned char NewTeamId, bool bForced, bool bDidKillPlayer)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.Mutator.OnPlayerTeamChanged");
		
		UMutator_OnPlayerTeamChanged_Params params {};
		params.Controller = Controller;
		params.NewTeamId = NewTeamId;
		params.bForced = bForced;
		params.bDidKillPlayer = bDidKillPlayer;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056F7490
	 * 		Name   -> Function Insurgency.Mutator.OnPlayerTakeAnyDamage
	 * 		Flags  -> (Native, Event, Public, HasOutParms, BlueprintEvent)
	 * Parameters:
	 * 		class AINSSoldier*                                 Victim                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AController*                                 Attacker                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      DamageCauser                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              OutDamage                                                  (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UMutator::OnPlayerTakeAnyDamage(class AINSSoldier* Victim, class AController* Attacker, class AActor* DamageCauser, float* OutDamage)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.Mutator.OnPlayerTakeAnyDamage");
		
		UMutator_OnPlayerTakeAnyDamage_Params params {};
		params.Victim = Victim;
		params.Attacker = Attacker;
		params.DamageCauser = DamageCauser;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutDamage != nullptr)
			*OutDamage = params.OutDamage;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056F7380
	 * 		Name   -> Function Insurgency.Mutator.OnPlayerSpawned
	 * 		Flags  -> (Native, Event, Public, HasOutParms, HasDefaults, BlueprintEvent)
	 * Parameters:
	 * 		class AINSSoldier*                                 Soldier                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AController*                                 NewPlayer                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FRotator                                    StartRotation                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UMutator::OnPlayerSpawned(class AINSSoldier* Soldier, class AController* NewPlayer, const struct FRotator& StartRotation)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.Mutator.OnPlayerSpawned");
		
		UMutator_OnPlayerSpawned_Params params {};
		params.Soldier = Soldier;
		params.NewPlayer = NewPlayer;
		params.StartRotation = StartRotation;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056F72F0
	 * 		Name   -> Function Insurgency.Mutator.OnPlayerPostInitialize
	 * 		Flags  -> (Native, Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		class AController*                                 Controller                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UMutator::OnPlayerPostInitialize(class AController* Controller)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.Mutator.OnPlayerPostInitialize");
		
		UMutator_OnPlayerPostInitialize_Params params {};
		params.Controller = Controller;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056F7260
	 * 		Name   -> Function Insurgency.Mutator.OnPlayerLogout
	 * 		Flags  -> (Native, Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		class AController*                                 Controller                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UMutator::OnPlayerLogout(class AController* Controller)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.Mutator.OnPlayerLogout");
		
		UMutator_OnPlayerLogout_Params params {};
		params.Controller = Controller;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056F7130
	 * 		Name   -> Function Insurgency.Mutator.OnPlayerLogin
	 * 		Flags  -> (Native, Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		class APlayerController*                           PlayerController                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FString                                      Portal                                                     (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FString                                      Options                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UMutator::OnPlayerLogin(class APlayerController* PlayerController, const class FString& Portal, const class FString& Options)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.Mutator.OnPlayerLogin");
		
		UMutator_OnPlayerLogin_Params params {};
		params.PlayerController = PlayerController;
		params.Portal = Portal;
		params.Options = Options;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056F6FA0
	 * 		Name   -> Function Insurgency.Mutator.OnPlayerKilledAnyDamage
	 * 		Flags  -> (Native, Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		class AINSSoldier*                                 Victim                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              KillingDamage                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AController*                                 Killer                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AController*                                 Assister                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      DamageCauser                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UMutator::OnPlayerKilledAnyDamage(class AINSSoldier* Victim, float KillingDamage, class AController* Killer, class AController* Assister, class AActor* DamageCauser)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.Mutator.OnPlayerKilledAnyDamage");
		
		UMutator_OnPlayerKilledAnyDamage_Params params {};
		params.Victim = Victim;
		params.KillingDamage = KillingDamage;
		params.Killer = Killer;
		params.Assister = Assister;
		params.DamageCauser = DamageCauser;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056F6ED0
	 * 		Name   -> Function Insurgency.Mutator.OnPlayerClassChanged
	 * 		Flags  -> (Native, Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		class AController*                                 Controller                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UPlayerClass*                                PlayerClass                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UMutator::OnPlayerClassChanged(class AController* Controller, class UPlayerClass* PlayerClass)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.Mutator.OnPlayerClassChanged");
		
		UMutator_OnPlayerClassChanged_Params params {};
		params.Controller = Controller;
		params.PlayerClass = PlayerClass;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056F6DD0
	 * 		Name   -> Function Insurgency.Mutator.OnObjectiveRigged
	 * 		Flags  -> (Native, Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		class AObjectiveDestructible*                      Objective                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AINSSoldier*                                 Rigger                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AProjectileBase*                             SpawnedExplosive                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UMutator::OnObjectiveRigged(class AObjectiveDestructible* Objective, class AINSSoldier* Rigger, class AProjectileBase* SpawnedExplosive)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.Mutator.OnObjectiveRigged");
		
		UMutator_OnObjectiveRigged_Params params {};
		params.Objective = Objective;
		params.Rigger = Rigger;
		params.SpawnedExplosive = SpawnedExplosive;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056F6C10
	 * 		Name   -> Function Insurgency.Mutator.OnObjectiveDestroyed
	 * 		Flags  -> (Native, Event, Public, HasOutParms, BlueprintEvent)
	 * Parameters:
	 * 		class AObjectiveDestructible*                      Objective                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		unsigned char                                      OldOwners                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		unsigned char                                      NewOwners                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		TArray<class AINSPlayerState*>                     Attackers                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bCanScore                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UMutator::OnObjectiveDestroyed(class AObjectiveDestructible* Objective, unsigned char OldOwners, unsigned char NewOwners, TArray<class AINSPlayerState*> Attackers, bool bCanScore)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.Mutator.OnObjectiveDestroyed");
		
		UMutator_OnObjectiveDestroyed_Params params {};
		params.Objective = Objective;
		params.OldOwners = OldOwners;
		params.NewOwners = NewOwners;
		params.Attackers = Attackers;
		params.bCanScore = bCanScore;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056F6B40
	 * 		Name   -> Function Insurgency.Mutator.OnObjectiveChangeOwnership
	 * 		Flags  -> (Native, Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		class AObjectiveBase*                              Objective                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		unsigned char                                      NewOwners                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UMutator::OnObjectiveChangeOwnership(class AObjectiveBase* Objective, unsigned char NewOwners)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.Mutator.OnObjectiveChangeOwnership");
		
		UMutator_OnObjectiveChangeOwnership_Params params {};
		params.Objective = Objective;
		params.NewOwners = NewOwners;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056F6A70
	 * 		Name   -> Function Insurgency.Mutator.OnObjectiveBeginRig
	 * 		Flags  -> (Native, Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		class AObjectiveDestructible*                      Objective                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AINSSoldier*                                 Rigger                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UMutator::OnObjectiveBeginRig(class AObjectiveDestructible* Objective, class AINSSoldier* Rigger)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.Mutator.OnObjectiveBeginRig");
		
		UMutator_OnObjectiveBeginRig_Params params {};
		params.Objective = Objective;
		params.Rigger = Rigger;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056F69E0
	 * 		Name   -> Function Insurgency.Mutator.OnGameStateInitialized
	 * 		Flags  -> (Native, Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		class AINSGameState*                               InGameState                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UMutator::OnGameStateInitialized(class AINSGameState* InGameState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.Mutator.OnGameStateInitialized");
		
		UMutator_OnGameStateInitialized_Params params {};
		params.InGameState = InGameState;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x04DB5D60
	 * 		Name   -> Function Insurgency.Mutator.OnGameOver
	 * 		Flags  -> (Native, Event, Public, BlueprintEvent)
	 */
	void UMutator::OnGameOver()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.Mutator.OnGameOver");
		
		UMutator_OnGameOver_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056F6930
	 * 		Name   -> Function Insurgency.Mutator.OnFactionsInitialized
	 * 		Flags  -> (Native, Event, Public, HasOutParms, BlueprintEvent)
	 * Parameters:
	 * 		TArray<class ATeamInfo*>                           Teams                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UMutator::OnFactionsInitialized(TArray<class ATeamInfo*> Teams)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.Mutator.OnFactionsInitialized");
		
		UMutator_OnFactionsInitialized_Params params {};
		params.Teams = Teams;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056F6860
	 * 		Name   -> Function Insurgency.Mutator.OnCaptureObjectiveStartCapture
	 * 		Flags  -> (Native, Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		class AObjectiveCapturable*                        Objective                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		unsigned char                                      NewCapturingTeam                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UMutator::OnCaptureObjectiveStartCapture(class AObjectiveCapturable* Objective, unsigned char NewCapturingTeam)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.Mutator.OnCaptureObjectiveStartCapture");
		
		UMutator_OnCaptureObjectiveStartCapture_Params params {};
		params.Objective = Objective;
		params.NewCapturingTeam = NewCapturingTeam;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056F6700
	 * 		Name   -> Function Insurgency.Mutator.OnCaptureObjectiveProgressTick
	 * 		Flags  -> (Native, Event, Public, HasOutParms, BlueprintEvent)
	 * Parameters:
	 * 		class AObjectiveCapturable*                        Objective                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		unsigned char                                      CapturingTeamId                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		unsigned char                                      TeamWithMostPlayersId                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		TArray<class AINSPlayerState*>                     Tickers                                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UMutator::OnCaptureObjectiveProgressTick(class AObjectiveCapturable* Objective, unsigned char CapturingTeamId, unsigned char TeamWithMostPlayersId, TArray<class AINSPlayerState*> Tickers)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.Mutator.OnCaptureObjectiveProgressTick");
		
		UMutator_OnCaptureObjectiveProgressTick_Params params {};
		params.Objective = Objective;
		params.CapturingTeamId = CapturingTeamId;
		params.TeamWithMostPlayersId = TeamWithMostPlayersId;
		params.Tickers = Tickers;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056F65D0
	 * 		Name   -> Function Insurgency.Mutator.OnCaptureObjectiveProgressReset
	 * 		Flags  -> (Native, Event, Public, HasOutParms, BlueprintEvent)
	 * Parameters:
	 * 		class AObjectiveCapturable*                        Objective                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		TArray<class AINSPlayerState*>                     Resetters                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              MaxCaptureProgress                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UMutator::OnCaptureObjectiveProgressReset(class AObjectiveCapturable* Objective, TArray<class AINSPlayerState*> Resetters, float MaxCaptureProgress)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.Mutator.OnCaptureObjectiveProgressReset");
		
		UMutator_OnCaptureObjectiveProgressReset_Params params {};
		params.Objective = Objective;
		params.Resetters = Resetters;
		params.MaxCaptureProgress = MaxCaptureProgress;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056F6410
	 * 		Name   -> Function Insurgency.Mutator.OnCaptureObjectiveChangeOwnership
	 * 		Flags  -> (Native, Event, Public, HasOutParms, BlueprintEvent)
	 * Parameters:
	 * 		class AObjectiveCapturable*                        Objective                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		unsigned char                                      OldOwners                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		unsigned char                                      NewOwners                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		TArray<class AINSPlayerState*>                     Capturers                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bCanScore                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UMutator::OnCaptureObjectiveChangeOwnership(class AObjectiveCapturable* Objective, unsigned char OldOwners, unsigned char NewOwners, TArray<class AINSPlayerState*> Capturers, bool bCanScore)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.Mutator.OnCaptureObjectiveChangeOwnership");
		
		UMutator_OnCaptureObjectiveChangeOwnership_Params params {};
		params.Objective = Objective;
		params.OldOwners = OldOwners;
		params.NewOwners = NewOwners;
		params.Capturers = Capturers;
		params.bCanScore = bCanScore;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00DE3100
	 * 		Name   -> Function Insurgency.Mutator.InitializeMutatorPostLoad
	 * 		Flags  -> (Native, Event, Public, BlueprintEvent)
	 */
	void UMutator::InitializeMutatorPostLoad()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.Mutator.InitializeMutatorPostLoad");
		
		UMutator_InitializeMutatorPostLoad_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056F6330
	 * 		Name   -> Function Insurgency.Mutator.InitializeMutator
	 * 		Flags  -> (Native, Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		class AINSGameMode*                                GameMode                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FString                                      Options                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UMutator::InitializeMutator(class AINSGameMode* GameMode, const class FString& Options)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.Mutator.InitializeMutator");
		
		UMutator_InitializeMutator_Params params {};
		params.GameMode = GameMode;
		params.Options = Options;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056F6260
	 * 		Name   -> Function Insurgency.Mutator.GivePlayerInventory
	 * 		Flags  -> (Native, Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		class AINSSoldier*                                 Player                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bFromResupply                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UMutator::GivePlayerInventory(class AINSSoldier* Player, bool bFromResupply)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.Mutator.GivePlayerInventory");
		
		UMutator_GivePlayerInventory_Params params {};
		params.Player = Player;
		params.bFromResupply = bFromResupply;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056F6040
	 * 		Name   -> Function Insurgency.Mutator.GetRulesForGameModeCopy
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		class UClass*                                      GameMode                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FRulesetGameModeRulesMinimal                OutRules                                                   (Parm, OutParm, NativeAccessSpecifierPublic)
	 */
	bool UMutator::GetRulesForGameModeCopy(class UClass* GameMode, struct FRulesetGameModeRulesMinimal* OutRules)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.Mutator.GetRulesForGameModeCopy");
		
		UMutator_GetRulesForGameModeCopy_Params params {};
		params.GameMode = GameMode;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutRules != nullptr)
			*OutRules = params.OutRules;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056F5F10
	 * 		Name   -> Function Insurgency.Mutator.GetRequiredAssets
	 * 		Flags  -> (Native, Event, Public, HasOutParms, BlueprintEvent)
	 */
	void UMutator::GetRequiredAssets()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.Mutator.GetRequiredAssets");
		
		UMutator_GetRequiredAssets_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056F5EE0
	 * 		Name   -> Function Insurgency.Mutator.GetOwnerGameMode
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	class AINSGameMode* UMutator::GetOwnerGameMode()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.Mutator.GetOwnerGameMode");
		
		UMutator_GetOwnerGameMode_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056F5DC0
	 * 		Name   -> Function Insurgency.Mutator.CanItemDrop
	 * 		Flags  -> (Native, Event, Public, HasOutParms, BlueprintEvent)
	 * Parameters:
	 * 		class AItemBase*                                   Item                                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AINSSoldier*                                 Owner                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bCanDrop                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UMutator::CanItemDrop(class AItemBase* Item, class AINSSoldier* Owner, bool* bCanDrop)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.Mutator.CanItemDrop");
		
		UMutator_CanItemDrop_Params params {};
		params.Item = Item;
		params.Owner = Owner;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (bCanDrop != nullptr)
			*bCanDrop = params.bCanDrop;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMutator.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMutator::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.Mutator");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056F7C90
	 * 		Name   -> Function Insurgency.MutatorStatics.GetMutatorDisplayNames
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		TArray<class FName>                                InNames                                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		TArray<class FText>                                OutDisplayNames                                            (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UMutatorStatics::STATIC_GetMutatorDisplayNames(TArray<class FName> InNames, TArray<class FText>* OutDisplayNames)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.MutatorStatics.GetMutatorDisplayNames");
		
		UMutatorStatics_GetMutatorDisplayNames_Params params {};
		params.InNames = InNames;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutDisplayNames != nullptr)
			*OutDisplayNames = params.OutDisplayNames;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056F7B90
	 * 		Name   -> Function Insurgency.MutatorStatics.GetMutatorDisplayName
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class FName                                        InName                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FText                                        OutDisplayName                                             (Parm, OutParm, NativeAccessSpecifierPublic)
	 */
	void UMutatorStatics::STATIC_GetMutatorDisplayName(const class FName& InName, class FText* OutDisplayName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.MutatorStatics.GetMutatorDisplayName");
		
		UMutatorStatics_GetMutatorDisplayName_Params params {};
		params.InName = InName;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutDisplayName != nullptr)
			*OutDisplayName = params.OutDisplayName;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMutatorStatics.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMutatorStatics::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.MutatorStatics");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMutator_CoopBase.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMutator_CoopBase::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.Mutator_CoopBase");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMutator_HeadshotOnly.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMutator_HeadshotOnly::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.Mutator_HeadshotOnly");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMutator_HotPotato.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMutator_HotPotato::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.Mutator_HotPotato");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMutator_LoadoutBase.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMutator_LoadoutBase::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.Mutator_LoadoutBase");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMutator_NoDrops.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMutator_NoDrops::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.Mutator_NoDrops");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMutator_OutpostBase.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMutator_OutpostBase::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.Mutator_OutpostBase");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMutator_SupplyBase.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMutator_SupplyBase::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.Mutator_SupplyBase");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMutator_SurvivalBase.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMutator_SurvivalBase::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.Mutator_SurvivalBase");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMutator_Ultralethal.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMutator_Ultralethal::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.Mutator_Ultralethal");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMutator_Vampirism.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMutator_Vampirism::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.Mutator_Vampirism");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UNavAreaExtended.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UNavAreaExtended::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.NavAreaExtended");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UNavArea_DeathArea.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UNavArea_DeathArea::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.NavArea_DeathArea");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UNavArea_DynamicAccurateObstacle.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UNavArea_DynamicAccurateObstacle::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.NavArea_DynamicAccurateObstacle");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UNavArea_Hazard.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UNavArea_Hazard::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.NavArea_Hazard");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UNavArea_SelectedEntrance.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UNavArea_SelectedEntrance::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.NavArea_SelectedEntrance");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UNavArea_SmokeArea.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UNavArea_SmokeArea::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.NavArea_SmokeArea");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UNavArea_UnwantedEntrance.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UNavArea_UnwantedEntrance::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.NavArea_UnwantedEntrance");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UNavQueryFilter_ExcludeDanger.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UNavQueryFilter_ExcludeDanger::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.NavQueryFilter_ExcludeDanger");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UNavQueryFilter_ExcludeHazards.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UNavQueryFilter_ExcludeHazards::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.NavQueryFilter_ExcludeHazards");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UNavQueryFilter_IgnoreDeathArea.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UNavQueryFilter_IgnoreDeathArea::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.NavQueryFilter_IgnoreDeathArea");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056F9E10
	 * 		Name   -> Function Insurgency.NoiseLibrary.SmoothNoise
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		int32_t                                            X                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	float UNoiseLibrary::STATIC_SmoothNoise(int32_t X)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.NoiseLibrary.SmoothNoise");
		
		UNoiseLibrary_SmoothNoise_Params params {};
		params.X = X;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056F9D10
	 * 		Name   -> Function Insurgency.NoiseLibrary.PerlinNoise
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		float                                              X                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Persistence                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            Octaves                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	float UNoiseLibrary::STATIC_PerlinNoise(float X, float Persistence, int32_t Octaves)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.NoiseLibrary.PerlinNoise");
		
		UNoiseLibrary_PerlinNoise_Params params {};
		params.X = X;
		params.Persistence = Persistence;
		params.Octaves = Octaves;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056F9C90
	 * 		Name   -> Function Insurgency.NoiseLibrary.Noise
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		int32_t                                            N                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	float UNoiseLibrary::STATIC_Noise(int32_t N)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.NoiseLibrary.Noise");
		
		UNoiseLibrary_Noise_Params params {};
		params.N = N;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056F9C10
	 * 		Name   -> Function Insurgency.NoiseLibrary.InterpolatedNoise
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		float                                              X                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	float UNoiseLibrary::STATIC_InterpolatedNoise(float X)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.NoiseLibrary.InterpolatedNoise");
		
		UNoiseLibrary_InterpolatedNoise_Params params {};
		params.X = X;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UNoiseLibrary.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UNoiseLibrary::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.NoiseLibrary");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ANonVaultingVolume.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ANonVaultingVolume::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.NonVaultingVolume");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UObjectiveAchievement.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UObjectiveAchievement::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.ObjectiveAchievement");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056FABB0
	 * 		Name   -> Function Insurgency.ObjectiveCapturedAchievement.OnRecievedObjectiveCaptured
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		class AINSPlayerController*                        PC                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AObjectiveCapturable*                        Objective                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		unsigned char                                      OldOwners                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		unsigned char                                      NewOwners                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UObjectiveCapturedAchievement::OnRecievedObjectiveCaptured(class AINSPlayerController* PC, class AObjectiveCapturable* Objective, unsigned char OldOwners, unsigned char NewOwners)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ObjectiveCapturedAchievement.OnRecievedObjectiveCaptured");
		
		UObjectiveCapturedAchievement_OnRecievedObjectiveCaptured_Params params {};
		params.PC = PC;
		params.Objective = Objective;
		params.OldOwners = OldOwners;
		params.NewOwners = NewOwners;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UObjectiveCapturedAchievement.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UObjectiveCapturedAchievement::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.ObjectiveCapturedAchievement");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056FAA60
	 * 		Name   -> Function Insurgency.CarryingAchievement.OnRecievedObjectiveCaptured
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		class AINSPlayerController*                        PC                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AObjectiveCapturable*                        Objective                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		unsigned char                                      OldOwners                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		unsigned char                                      NewOwners                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UCarryingAchievement::OnRecievedObjectiveCaptured(class AINSPlayerController* PC, class AObjectiveCapturable* Objective, unsigned char OldOwners, unsigned char NewOwners)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.CarryingAchievement.OnRecievedObjectiveCaptured");
		
		UCarryingAchievement_OnRecievedObjectiveCaptured_Params params {};
		params.PC = PC;
		params.Objective = Objective;
		params.OldOwners = OldOwners;
		params.NewOwners = NewOwners;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UCarryingAchievement.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UCarryingAchievement::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.CarryingAchievement");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056FAE10
	 * 		Name   -> Function Insurgency.TurfWarAchievement.OnRecievedObjectiveReset
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		class AINSPlayerController*                        PC                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AObjectiveCapturable*                        Objective                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UTurfWarAchievement::OnRecievedObjectiveReset(class AINSPlayerController* PC, class AObjectiveCapturable* Objective)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.TurfWarAchievement.OnRecievedObjectiveReset");
		
		UTurfWarAchievement_OnRecievedObjectiveReset_Params params {};
		params.PC = PC;
		params.Objective = Objective;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UTurfWarAchievement.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UTurfWarAchievement::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.TurfWarAchievement");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056FAD00
	 * 		Name   -> Function Insurgency.ObjectiveDestructableAchievement.OnRecievedObjectiveDestroy
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		class AINSPlayerController*                        PC                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AObjectiveDestructible*                      Objective                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bFromRig                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UObjectiveDestructableAchievement::OnRecievedObjectiveDestroy(class AINSPlayerController* PC, class AObjectiveDestructible* Objective, bool bFromRig)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ObjectiveDestructableAchievement.OnRecievedObjectiveDestroy");
		
		UObjectiveDestructableAchievement_OnRecievedObjectiveDestroy_Params params {};
		params.PC = PC;
		params.Objective = Objective;
		params.bFromRig = bFromRig;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UObjectiveDestructableAchievement.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UObjectiveDestructableAchievement::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.ObjectiveDestructableAchievement");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction USpecialDeliveryAchievement.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* USpecialDeliveryAchievement::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.SpecialDeliveryAchievement");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction USelfDestructiveAchievement.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* USelfDestructiveAchievement::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.SelfDestructiveAchievement");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDrainedAchievement.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDrainedAchievement::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.DrainedAchievement");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056FB610
	 * 		Name   -> Function Insurgency.ObjectiveAction.SetActionCompleted
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void AObjectiveAction::SetActionCompleted()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ObjectiveAction.SetActionCompleted");
		
		AObjectiveAction_SetActionCompleted_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056FB4D0
	 * 		Name   -> Function Insurgency.ObjectiveAction.OnEndObjectiveOverlap
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		class UPrimitiveComponent*                         OverlappedComponent                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      OtherActor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UPrimitiveComponent*                         OtherComp                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            OtherBodyIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AObjectiveAction::OnEndObjectiveOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32_t OtherBodyIndex)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ObjectiveAction.OnEndObjectiveOverlap");
		
		AObjectiveAction_OnEndObjectiveOverlap_Params params {};
		params.OverlappedComponent = OverlappedComponent;
		params.OtherActor = OtherActor;
		params.OtherComp = OtherComp;
		params.OtherBodyIndex = OtherBodyIndex;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056FB2C0
	 * 		Name   -> Function Insurgency.ObjectiveAction.OnBeginObjectiveOverlap
	 * 		Flags  -> (Final, Native, Public, HasOutParms)
	 * Parameters:
	 * 		class UPrimitiveComponent*                         OverlappedComponent                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      OtherActor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UPrimitiveComponent*                         OtherComp                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            OtherBodyIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bFromSweep                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FHitResult                                  SweepResult                                                (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	void AObjectiveAction::OnBeginObjectiveOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32_t OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ObjectiveAction.OnBeginObjectiveOverlap");
		
		AObjectiveAction_OnBeginObjectiveOverlap_Params params {};
		params.OverlappedComponent = OverlappedComponent;
		params.OtherActor = OtherActor;
		params.OtherComp = OtherComp;
		params.OtherBodyIndex = OtherBodyIndex;
		params.bFromSweep = bFromSweep;
		params.SweepResult = SweepResult;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056FB1B0
	 * 		Name   -> Function Insurgency.ObjectiveAction.ActionPerformedBySoldier
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class AINSSoldier*                                 Soldier                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EObjectiveActionType                               InputActionType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              CompletionDelay                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AObjectiveAction::ActionPerformedBySoldier(class AINSSoldier* Soldier, EObjectiveActionType InputActionType, float CompletionDelay)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ObjectiveAction.ActionPerformedBySoldier");
		
		AObjectiveAction_ActionPerformedBySoldier_Params params {};
		params.Soldier = Soldier;
		params.InputActionType = InputActionType;
		params.CompletionDelay = CompletionDelay;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AObjectiveAction.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AObjectiveAction::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.ObjectiveAction");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056FD610
	 * 		Name   -> Function Insurgency.ObjectiveBriefing.PopulateObjectiveBriefing
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bNewObjective                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UObjectiveBriefing::PopulateObjectiveBriefing(bool bNewObjective)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ObjectiveBriefing.PopulateObjectiveBriefing");
		
		UObjectiveBriefing_PopulateObjectiveBriefing_Params params {};
		params.bNewObjective = bNewObjective;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056FD5F0
	 * 		Name   -> Function Insurgency.ObjectiveBriefing.OnScoreboardOpened
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void UObjectiveBriefing::OnScoreboardOpened()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ObjectiveBriefing.OnScoreboardOpened");
		
		UObjectiveBriefing_OnScoreboardOpened_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056FD5D0
	 * 		Name   -> Function Insurgency.ObjectiveBriefing.OnQueueObjectiveBriefing
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void UObjectiveBriefing::OnQueueObjectiveBriefing()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ObjectiveBriefing.OnQueueObjectiveBriefing");
		
		UObjectiveBriefing_OnQueueObjectiveBriefing_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056FD460
	 * 		Name   -> Function Insurgency.ObjectiveBriefing.OnObjectiveDestroyed
	 * 		Flags  -> (Final, Native, Protected, HasOutParms)
	 * Parameters:
	 * 		class AObjectiveDestructible*                      Objective                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		unsigned char                                      OldOwners                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		unsigned char                                      NewOwners                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		TArray<class AINSPlayerState*>                     Attackers                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UObjectiveBriefing::OnObjectiveDestroyed(class AObjectiveDestructible* Objective, unsigned char OldOwners, unsigned char NewOwners, TArray<class AINSPlayerState*> Attackers)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ObjectiveBriefing.OnObjectiveDestroyed");
		
		UObjectiveBriefing_OnObjectiveDestroyed_Params params {};
		params.Objective = Objective;
		params.OldOwners = OldOwners;
		params.NewOwners = NewOwners;
		params.Attackers = Attackers;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056FD460
	 * 		Name   -> Function Insurgency.ObjectiveBriefing.OnObjectiveCaptured
	 * 		Flags  -> (Final, Native, Protected, HasOutParms)
	 * Parameters:
	 * 		class AObjectiveCapturable*                        Objective                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		unsigned char                                      OldOwners                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		unsigned char                                      NewOwners                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		TArray<class AINSPlayerState*>                     Capturers                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UObjectiveBriefing::OnObjectiveCaptured(class AObjectiveCapturable* Objective, unsigned char OldOwners, unsigned char NewOwners, TArray<class AINSPlayerState*> Capturers)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ObjectiveBriefing.OnObjectiveCaptured");
		
		UObjectiveBriefing_OnObjectiveCaptured_Params params {};
		params.Objective = Objective;
		params.OldOwners = OldOwners;
		params.NewOwners = NewOwners;
		params.Capturers = Capturers;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056FD440
	 * 		Name   -> Function Insurgency.ObjectiveBriefing.OnExitSpawnZone
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void UObjectiveBriefing::OnExitSpawnZone()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ObjectiveBriefing.OnExitSpawnZone");
		
		UObjectiveBriefing_OnExitSpawnZone_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> Function Insurgency.ObjectiveBriefing.DoCreateDestructibleObjectiveIcon
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 */
	class UUserWidget* UObjectiveBriefing::DoCreateDestructibleObjectiveIcon()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ObjectiveBriefing.DoCreateDestructibleObjectiveIcon");
		
		UObjectiveBriefing_DoCreateDestructibleObjectiveIcon_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> Function Insurgency.ObjectiveBriefing.DoCreateCapturingObjectiveIcon
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 */
	class UUserWidget* UObjectiveBriefing::DoCreateCapturingObjectiveIcon()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ObjectiveBriefing.DoCreateCapturingObjectiveIcon");
		
		UObjectiveBriefing_DoCreateCapturingObjectiveIcon_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056FD3C0
	 * 		Name   -> Function Insurgency.ObjectiveBriefing.CheckForObjectiveUpdateQueue
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		unsigned char                                      ObjectiveId                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UObjectiveBriefing::CheckForObjectiveUpdateQueue(unsigned char ObjectiveId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ObjectiveBriefing.CheckForObjectiveUpdateQueue");
		
		UObjectiveBriefing_CheckForObjectiveUpdateQueue_Params params {};
		params.ObjectiveId = ObjectiveId;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UObjectiveBriefing.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UObjectiveBriefing::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.ObjectiveBriefing");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AObjectiveCharacter.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AObjectiveCharacter::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.ObjectiveCharacter");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> Function Insurgency.ObjectiveDestructible.OnStateChanged
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 */
	void AObjectiveDestructible::OnStateChanged()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ObjectiveDestructible.OnStateChanged");
		
		AObjectiveDestructible_OnStateChanged_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056FF7E0
	 * 		Name   -> Function Insurgency.ObjectiveDestructible.OnRigObjective
	 * 		Flags  -> (Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class AINSSoldier*                                 Pawn                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AObjectiveDestructible::OnRigObjective(class AINSSoldier* Pawn)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ObjectiveDestructible.OnRigObjective");
		
		AObjectiveDestructible_OnRigObjective_Params params {};
		params.Pawn = Pawn;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056FF7C0
	 * 		Name   -> Function Insurgency.ObjectiveDestructible.OnRep_State
	 * 		Flags  -> (Final, Native, Public)
	 */
	void AObjectiveDestructible::OnRep_State()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ObjectiveDestructible.OnRep_State");
		
		AObjectiveDestructible_OnRep_State_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> Function Insurgency.ObjectiveDestructible.OnPlayDestructionEffects
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 */
	void AObjectiveDestructible::OnPlayDestructionEffects()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ObjectiveDestructible.OnPlayDestructionEffects");
		
		AObjectiveDestructible_OnPlayDestructionEffects_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> Function Insurgency.ObjectiveDestructible.OnObjectiveDestroyed
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		class AController*                                 EventInstigator                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      DamageCauser                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		unsigned char                                      OriginalOwners                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AObjectiveDestructible::OnObjectiveDestroyed(class AController* EventInstigator, class AActor* DamageCauser, unsigned char OriginalOwners)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ObjectiveDestructible.OnObjectiveDestroyed");
		
		AObjectiveDestructible_OnObjectiveDestroyed_Params params {};
		params.EventInstigator = EventInstigator;
		params.DamageCauser = DamageCauser;
		params.OriginalOwners = OriginalOwners;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> DelegateFunction Insurgency.ObjectiveDestructible.OnDestructibleObjectiveStateChangedDelegate__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 * Parameters:
	 * 		class AObjectiveDestructible*                      Objective                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EDestructibleObjectiveState                        NewState                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AObjectiveDestructible::OnDestructibleObjectiveStateChangedDelegate__DelegateSignature(class AObjectiveDestructible* Objective, EDestructibleObjectiveState NewState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction Insurgency.ObjectiveDestructible.OnDestructibleObjectiveStateChangedDelegate__DelegateSignature");
		
		AObjectiveDestructible_OnDestructibleObjectiveStateChangedDelegate__DelegateSignature_Params params {};
		params.Objective = Objective;
		params.NewState = NewState;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x04DB4340
	 * 		Name   -> Function Insurgency.ObjectiveDestructible.MulticastPlayDestructionEffects
	 * 		Flags  -> (Net, NetReliable, Native, Event, NetMulticast, Public)
	 */
	void AObjectiveDestructible::MulticastPlayDestructionEffects()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ObjectiveDestructible.MulticastPlayDestructionEffects");
		
		AObjectiveDestructible_MulticastPlayDestructionEffects_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056FF740
	 * 		Name   -> Function Insurgency.ObjectiveDestructible.MulticastCancelRigObjective
	 * 		Flags  -> (Net, NetReliable, Native, Event, NetMulticast, Public, BlueprintCallable)
	 * Parameters:
	 * 		class AINSSoldier*                                 Pawn                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AObjectiveDestructible::MulticastCancelRigObjective(class AINSSoldier* Pawn)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ObjectiveDestructible.MulticastCancelRigObjective");
		
		AObjectiveDestructible_MulticastCancelRigObjective_Params params {};
		params.Pawn = Pawn;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056FF6C0
	 * 		Name   -> Function Insurgency.ObjectiveDestructible.MulticastBeginRigObjective
	 * 		Flags  -> (Net, NetReliable, Native, Event, NetMulticast, Public, BlueprintCallable)
	 * Parameters:
	 * 		class AINSSoldier*                                 Pawn                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AObjectiveDestructible::MulticastBeginRigObjective(class AINSSoldier* Pawn)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ObjectiveDestructible.MulticastBeginRigObjective");
		
		AObjectiveDestructible_MulticastBeginRigObjective_Params params {};
		params.Pawn = Pawn;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056FF630
	 * 		Name   -> Function Insurgency.ObjectiveDestructible.IsPlanter
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		class AINSSoldier*                                 Soldier                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool AObjectiveDestructible::IsPlanter(class AINSSoldier* Soldier)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ObjectiveDestructible.IsPlanter");
		
		AObjectiveDestructible_IsPlanter_Params params {};
		params.Soldier = Soldier;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056FF600
	 * 		Name   -> Function Insurgency.ObjectiveDestructible.IsDisabledOrDestroyed
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AObjectiveDestructible::IsDisabledOrDestroyed()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ObjectiveDestructible.IsDisabledOrDestroyed");
		
		AObjectiveDestructible_IsDisabledOrDestroyed_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056FF5D0
	 * 		Name   -> Function Insurgency.ObjectiveDestructible.IsDisabled
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AObjectiveDestructible::IsDisabled()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ObjectiveDestructible.IsDisabled");
		
		AObjectiveDestructible_IsDisabled_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056FF5A0
	 * 		Name   -> Function Insurgency.ObjectiveDestructible.IsDestroyed
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AObjectiveDestructible::IsDestroyed()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ObjectiveDestructible.IsDestroyed");
		
		AObjectiveDestructible_IsDestroyed_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056FF580
	 * 		Name   -> Function Insurgency.ObjectiveDestructible.IsDecoy
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
	 */
	bool AObjectiveDestructible::IsDecoy()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ObjectiveDestructible.IsDecoy");
		
		AObjectiveDestructible_IsDecoy_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056FF550
	 * 		Name   -> Function Insurgency.ObjectiveDestructible.HasRiggedExplosives
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AObjectiveDestructible::HasRiggedExplosives()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ObjectiveDestructible.HasRiggedExplosives");
		
		AObjectiveDestructible_HasRiggedExplosives_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056FF520
	 * 		Name   -> Function Insurgency.ObjectiveDestructible.HasLiveRiggedExplosives
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AObjectiveDestructible::HasLiveRiggedExplosives()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ObjectiveDestructible.HasLiveRiggedExplosives");
		
		AObjectiveDestructible_HasLiveRiggedExplosives_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056FF490
	 * 		Name   -> Function Insurgency.ObjectiveDestructible.GetPlantedProjectile
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		class AINSSoldier*                                 Soldier                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class AProjectileBase* AObjectiveDestructible::GetPlantedProjectile(class AINSSoldier* Soldier)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ObjectiveDestructible.GetPlantedProjectile");
		
		AObjectiveDestructible_GetPlantedProjectile_Params params {};
		params.Soldier = Soldier;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056FF410
	 * 		Name   -> Function Insurgency.ObjectiveDestructible.ChangeState
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		EDestructibleObjectiveState                        NewState                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AObjectiveDestructible::ChangeState(EDestructibleObjectiveState NewState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ObjectiveDestructible.ChangeState");
		
		AObjectiveDestructible_ChangeState_Params params {};
		params.NewState = NewState;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056FF290
	 * 		Name   -> Function Insurgency.ObjectiveDestructible.BlueprintCanTakeDamage
	 * 		Flags  -> (Native, Event, Public, HasOutParms, BlueprintEvent)
	 * Parameters:
	 * 		float                                              Damage                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FDamageEvent                                DamageEvent                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		class AController*                                 EventInstigator                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      DamageCauser                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool AObjectiveDestructible::BlueprintCanTakeDamage(float Damage, const struct FDamageEvent& DamageEvent, class AController* EventInstigator, class AActor* DamageCauser)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ObjectiveDestructible.BlueprintCanTakeDamage");
		
		AObjectiveDestructible_BlueprintCanTakeDamage_Params params {};
		params.Damage = Damage;
		params.DamageEvent = DamageEvent;
		params.EventInstigator = EventInstigator;
		params.DamageCauser = DamageCauser;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056FF1D0
	 * 		Name   -> Function Insurgency.ObjectiveDestructible.ApplyExplosionDamageAndPhysics
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class AController*                                 EventInstigator                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      DamageCauser                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AObjectiveDestructible::ApplyExplosionDamageAndPhysics(class AController* EventInstigator, class AActor* DamageCauser)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ObjectiveDestructible.ApplyExplosionDamageAndPhysics");
		
		AObjectiveDestructible_ApplyExplosionDamageAndPhysics_Params params {};
		params.EventInstigator = EventInstigator;
		params.DamageCauser = DamageCauser;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AObjectiveDestructible.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AObjectiveDestructible::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.ObjectiveDestructible");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05700B70
	 * 		Name   -> Function Insurgency.ObjectiveIcon.UpdateProgress
	 * 		Flags  -> (Final, Native, Protected, BlueprintCallable)
	 * Parameters:
	 * 		class UImage*                                      Image                                                      (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UObjectiveIcon::UpdateProgress(class UImage* Image)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ObjectiveIcon.UpdateProgress");
		
		UObjectiveIcon_UpdateProgress_Params params {};
		params.Image = Image;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05700AF0
	 * 		Name   -> Function Insurgency.ObjectiveIcon.UpdateIconProgress
	 * 		Flags  -> (Native, Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		float                                              OpacityAlpha                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UObjectiveIcon::UpdateIconProgress(float OpacityAlpha)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ObjectiveIcon.UpdateIconProgress");
		
		UObjectiveIcon_UpdateIconProgress_Params params {};
		params.OpacityAlpha = OpacityAlpha;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05700950
	 * 		Name   -> Function Insurgency.ObjectiveIcon.UpdateIcon
	 * 		Flags  -> (Native, Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		float                                              InDistance                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              InFrontDot                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              InRightDot                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              InIronsightFrac                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bInIsOnScreen                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UObjectiveIcon::UpdateIcon(float InDistance, float InFrontDot, float InRightDot, float InIronsightFrac, bool bInIsOnScreen)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ObjectiveIcon.UpdateIcon");
		
		UObjectiveIcon_UpdateIcon_Params params {};
		params.InDistance = InDistance;
		params.InFrontDot = InFrontDot;
		params.InRightDot = InRightDot;
		params.InIronsightFrac = InIronsightFrac;
		params.bInIsOnScreen = bInIsOnScreen;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05700920
	 * 		Name   -> Function Insurgency.ObjectiveIcon.ShouldShowObjectiveCaptureProgress
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool UObjectiveIcon::ShouldShowObjectiveCaptureProgress()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ObjectiveIcon.ShouldShowObjectiveCaptureProgress");
		
		UObjectiveIcon_ShouldShowObjectiveCaptureProgress_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x057008A0
	 * 		Name   -> Function Insurgency.ObjectiveIcon.SetObjective
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class AObjectiveBase*                              NewObjective                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UObjectiveIcon::SetObjective(class AObjectiveBase* NewObjective)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ObjectiveIcon.SetObjective");
		
		UObjectiveIcon_SetObjective_Params params {};
		params.NewObjective = NewObjective;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> Function Insurgency.ObjectiveIcon.OnSetObjective
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		class AObjectiveBase*                              NewObjective                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UObjectiveIcon::OnSetObjective(class AObjectiveBase* NewObjective)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ObjectiveIcon.OnSetObjective");
		
		UObjectiveIcon_OnSetObjective_Params params {};
		params.NewObjective = NewObjective;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> Function Insurgency.ObjectiveIcon.OnRemoveObjective
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		class AObjectiveBase*                              OldObjective                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UObjectiveIcon::OnRemoveObjective(class AObjectiveBase* OldObjective)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ObjectiveIcon.OnRemoveObjective");
		
		UObjectiveIcon_OnRemoveObjective_Params params {};
		params.OldObjective = OldObjective;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> Function Insurgency.ObjectiveIcon.OnPlayerChangeTeam
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		unsigned char                                      TeamId                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class ATeamInfo*                                   TeamInfo                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UObjectiveIcon::OnPlayerChangeTeam(unsigned char TeamId, class ATeamInfo* TeamInfo)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ObjectiveIcon.OnPlayerChangeTeam");
		
		UObjectiveIcon_OnPlayerChangeTeam_Params params {};
		params.TeamId = TeamId;
		params.TeamInfo = TeamInfo;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> Function Insurgency.ObjectiveIcon.OnObjectiveIsCounterAttacked
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		bool                                               bNewCounterAttackState                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AObjectiveBase*                              InObjective                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UObjectiveIcon::OnObjectiveIsCounterAttacked(bool bNewCounterAttackState, class AObjectiveBase* InObjective)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ObjectiveIcon.OnObjectiveIsCounterAttacked");
		
		UObjectiveIcon_OnObjectiveIsCounterAttacked_Params params {};
		params.bNewCounterAttackState = bNewCounterAttackState;
		params.InObjective = InObjective;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> Function Insurgency.ObjectiveIcon.OnObjectiveChangeOwner
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		class AObjectiveBase*                              InObjective                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		unsigned char                                      NewOwners                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UObjectiveIcon::OnObjectiveChangeOwner(class AObjectiveBase* InObjective, unsigned char NewOwners)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ObjectiveIcon.OnObjectiveChangeOwner");
		
		UObjectiveIcon_OnObjectiveChangeOwner_Params params {};
		params.InObjective = InObjective;
		params.NewOwners = NewOwners;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> Function Insurgency.ObjectiveIcon.OnObjectiveChangeCapturingTeam
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		class AObjectiveBase*                              InObjective                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		unsigned char                                      NewCapturers                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UObjectiveIcon::OnObjectiveChangeCapturingTeam(class AObjectiveBase* InObjective, unsigned char NewCapturers)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ObjectiveIcon.OnObjectiveChangeCapturingTeam");
		
		UObjectiveIcon_OnObjectiveChangeCapturingTeam_Params params {};
		params.InObjective = InObjective;
		params.NewCapturers = NewCapturers;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> Function Insurgency.ObjectiveIcon.OnObjectiveActive
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		bool                                               bNewActiveState                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AObjectiveBase*                              InObjective                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UObjectiveIcon::OnObjectiveActive(bool bNewActiveState, class AObjectiveBase* InObjective)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ObjectiveIcon.OnObjectiveActive");
		
		UObjectiveIcon_OnObjectiveActive_Params params {};
		params.bNewActiveState = bNewActiveState;
		params.InObjective = InObjective;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> Function Insurgency.ObjectiveIcon.OnDestructibleObjectiveStateChanged
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		class AObjectiveDestructible*                      InObjective                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EDestructibleObjectiveState                        NewState                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UObjectiveIcon::OnDestructibleObjectiveStateChanged(class AObjectiveDestructible* InObjective, EDestructibleObjectiveState NewState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ObjectiveIcon.OnDestructibleObjectiveStateChanged");
		
		UObjectiveIcon_OnDestructibleObjectiveStateChanged_Params params {};
		params.InObjective = InObjective;
		params.NewState = NewState;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05700870
	 * 		Name   -> Function Insurgency.ObjectiveIcon.IsObjectiveContested
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool UObjectiveIcon::IsObjectiveContested()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ObjectiveIcon.IsObjectiveContested");
		
		UObjectiveIcon_IsObjectiveContested_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05700840
	 * 		Name   -> Function Insurgency.ObjectiveIcon.GetObjectiveType
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
	 */
	EObjectiveType UObjectiveIcon::GetObjectiveType()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ObjectiveIcon.GetObjectiveType");
		
		UObjectiveIcon_GetObjectiveType_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05700810
	 * 		Name   -> Function Insurgency.ObjectiveIcon.GetObjectiveRelationship
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
	 */
	EObjectiveRelationship UObjectiveIcon::GetObjectiveRelationship()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ObjectiveIcon.GetObjectiveRelationship");
		
		UObjectiveIcon_GetObjectiveRelationship_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05700770
	 * 		Name   -> Function Insurgency.ObjectiveIcon.GetObjectiveLetter
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
	 */
	class FText UObjectiveIcon::GetObjectiveLetter()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ObjectiveIcon.GetObjectiveLetter");
		
		UObjectiveIcon_GetObjectiveLetter_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05700730
	 * 		Name   -> Function Insurgency.ObjectiveIcon.GetObjectiveIconFillColorAndOpacity
	 * 		Flags  -> (Native, Event, Public, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
	 */
	struct FLinearColor UObjectiveIcon::GetObjectiveIconFillColorAndOpacity()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ObjectiveIcon.GetObjectiveIconFillColorAndOpacity");
		
		UObjectiveIcon_GetObjectiveIconFillColorAndOpacity_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x057006F0
	 * 		Name   -> Function Insurgency.ObjectiveIcon.GetObjectiveIconColorAndOpacity
	 * 		Flags  -> (Native, Event, Public, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
	 */
	struct FLinearColor UObjectiveIcon::GetObjectiveIconColorAndOpacity()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ObjectiveIcon.GetObjectiveIconColorAndOpacity");
		
		UObjectiveIcon_GetObjectiveIconColorAndOpacity_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x057006B0
	 * 		Name   -> Function Insurgency.ObjectiveIcon.GetObjectiveIconBorderColorAndOpacity
	 * 		Flags  -> (Final, Native, Protected, HasDefaults, BlueprintCallable, BlueprintPure)
	 */
	struct FLinearColor UObjectiveIcon::GetObjectiveIconBorderColorAndOpacity()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ObjectiveIcon.GetObjectiveIconBorderColorAndOpacity");
		
		UObjectiveIcon_GetObjectiveIconBorderColorAndOpacity_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05700680
	 * 		Name   -> Function Insurgency.ObjectiveIcon.GetObjectiveDistance
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
	 */
	float UObjectiveIcon::GetObjectiveDistance()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ObjectiveIcon.GetObjectiveDistance");
		
		UObjectiveIcon_GetObjectiveDistance_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05700640
	 * 		Name   -> Function Insurgency.ObjectiveIcon.GetObjectiveColor
	 * 		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure)
	 */
	struct FLinearColor UObjectiveIcon::GetObjectiveColor()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ObjectiveIcon.GetObjectiveColor");
		
		UObjectiveIcon_GetObjectiveColor_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05700610
	 * 		Name   -> Function Insurgency.ObjectiveIcon.GetObjectiveCaptureProgress
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
	 */
	float UObjectiveIcon::GetObjectiveCaptureProgress()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ObjectiveIcon.GetObjectiveCaptureProgress");
		
		UObjectiveIcon_GetObjectiveCaptureProgress_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x057005E0
	 * 		Name   -> Function Insurgency.ObjectiveIcon.GetObjective
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
	 */
	class AObjectiveBase* UObjectiveIcon::GetObjective()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ObjectiveIcon.GetObjective");
		
		UObjectiveIcon_GetObjective_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05700570
	 * 		Name   -> Function Insurgency.ObjectiveIcon.GetMainOpacity
	 * 		Flags  -> (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure)
	 */
	struct FSlateColor UObjectiveIcon::GetMainOpacity()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ObjectiveIcon.GetMainOpacity");
		
		UObjectiveIcon_GetMainOpacity_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x057004C0
	 * 		Name   -> Function Insurgency.ObjectiveIcon.GetIconMaterial
	 * 		Flags  -> (Final, Native, Protected, BlueprintCallable, BlueprintPure)
	 */
	struct FSlateBrush UObjectiveIcon::GetIconMaterial()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ObjectiveIcon.GetIconMaterial");
		
		UObjectiveIcon_GetIconMaterial_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05700450
	 * 		Name   -> Function Insurgency.ObjectiveIcon.GetIconCaptureProgressColorAndOpacity
	 * 		Flags  -> (Final, Native, Protected, BlueprintCallable, BlueprintPure)
	 */
	struct FSlateColor UObjectiveIcon::GetIconCaptureProgressColorAndOpacity()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ObjectiveIcon.GetIconCaptureProgressColorAndOpacity");
		
		UObjectiveIcon_GetIconCaptureProgressColorAndOpacity_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05700420
	 * 		Name   -> Function Insurgency.ObjectiveIcon.GetIconBorderVisibility
	 * 		Flags  -> (Final, Native, Protected, BlueprintCallable, BlueprintPure)
	 */
	ESlateVisibility UObjectiveIcon::GetIconBorderVisibility()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ObjectiveIcon.GetIconBorderVisibility");
		
		UObjectiveIcon_GetIconBorderVisibility_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05700380
	 * 		Name   -> Function Insurgency.ObjectiveIcon.GetFormattedObjectiveDistance
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
	 */
	class FText UObjectiveIcon::GetFormattedObjectiveDistance()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ObjectiveIcon.GetFormattedObjectiveDistance");
		
		UObjectiveIcon_GetFormattedObjectiveDistance_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05700340
	 * 		Name   -> Function Insurgency.ObjectiveIcon.GetCapturingColor
	 * 		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure)
	 */
	struct FLinearColor UObjectiveIcon::GetCapturingColor()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ObjectiveIcon.GetCapturingColor");
		
		UObjectiveIcon_GetCapturingColor_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05700290
	 * 		Name   -> Function Insurgency.ObjectiveIcon.GetBackgroundMaterial
	 * 		Flags  -> (Final, Native, Protected, BlueprintCallable, BlueprintPure)
	 */
	struct FSlateBrush UObjectiveIcon::GetBackgroundMaterial()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ObjectiveIcon.GetBackgroundMaterial");
		
		UObjectiveIcon_GetBackgroundMaterial_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UObjectiveIcon.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UObjectiveIcon::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.ObjectiveIcon");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AObjectiveTruck.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AObjectiveTruck::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.ObjectiveTruck");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05704810
	 * 		Name   -> Function Insurgency.OnlineInventorySubsystem.ValidateCosmeticOwnership
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		struct FProfileCharacterCosmeticState              State                                                      (Parm, OutParm, NativeAccessSpecifierPublic)
	 */
	bool UOnlineInventorySubsystem::ValidateCosmeticOwnership(struct FProfileCharacterCosmeticState* State)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.OnlineInventorySubsystem.ValidateCosmeticOwnership");
		
		UOnlineInventorySubsystem_ValidateCosmeticOwnership_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (State != nullptr)
			*State = params.State;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05704780
	 * 		Name   -> Function Insurgency.OnlineInventorySubsystem.SwitchToFaction
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		class FName                                        SelectedFaction                                            (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UOnlineInventorySubsystem::SwitchToFaction(class FName* SelectedFaction)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.OnlineInventorySubsystem.SwitchToFaction");
		
		UOnlineInventorySubsystem_SwitchToFaction_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (SelectedFaction != nullptr)
			*SelectedFaction = params.SelectedFaction;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05704760
	 * 		Name   -> Function Insurgency.OnlineInventorySubsystem.SwitchFaction
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void UOnlineInventorySubsystem::SwitchFaction()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.OnlineInventorySubsystem.SwitchFaction");
		
		UOnlineInventorySubsystem_SwitchFaction_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05704690
	 * 		Name   -> Function Insurgency.OnlineInventorySubsystem.SetSelectedPresetName
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		class FText                                        InPresetName                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UOnlineInventorySubsystem::SetSelectedPresetName(const class FText& InPresetName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.OnlineInventorySubsystem.SetSelectedPresetName");
		
		UOnlineInventorySubsystem_SetSelectedPresetName_Params params {};
		params.InPresetName = InPresetName;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05704610
	 * 		Name   -> Function Insurgency.OnlineInventorySubsystem.SetSecuritySelectedGender
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		ECharacterGender                                   NewGender                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UOnlineInventorySubsystem::SetSecuritySelectedGender(ECharacterGender NewGender)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.OnlineInventorySubsystem.SetSecuritySelectedGender");
		
		UOnlineInventorySubsystem_SetSecuritySelectedGender_Params params {};
		params.NewGender = NewGender;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x057044A0
	 * 		Name   -> Function Insurgency.OnlineInventorySubsystem.SaveCurrentStateAsPreset
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		class FText                                        PresetName                                                 (Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		class FText                                        PresetDesignation                                          (Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UOnlineInventorySubsystem::SaveCurrentStateAsPreset(class FText* PresetName, class FText* PresetDesignation)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.OnlineInventorySubsystem.SaveCurrentStateAsPreset");
		
		UOnlineInventorySubsystem_SaveCurrentStateAsPreset_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (PresetName != nullptr)
			*PresetName = params.PresetName;
		if (PresetDesignation != nullptr)
			*PresetDesignation = params.PresetDesignation;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05704480
	 * 		Name   -> Function Insurgency.OnlineInventorySubsystem.ResetCurrentCosmeticStateToDefault
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void UOnlineInventorySubsystem::ResetCurrentCosmeticStateToDefault()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.OnlineInventorySubsystem.ResetCurrentCosmeticStateToDefault");
		
		UOnlineInventorySubsystem_ResetCurrentCosmeticStateToDefault_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05704460
	 * 		Name   -> Function Insurgency.OnlineInventorySubsystem.RequestPlayerBalance
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void UOnlineInventorySubsystem::RequestPlayerBalance()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.OnlineInventorySubsystem.RequestPlayerBalance");
		
		UOnlineInventorySubsystem_RequestPlayerBalance_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x057043E0
	 * 		Name   -> Function Insurgency.OnlineInventorySubsystem.RequestInventoryTransaction
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		int32_t                                            ItemDefId                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UOnlineInventorySubsystem::RequestInventoryTransaction(int32_t ItemDefId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.OnlineInventorySubsystem.RequestInventoryTransaction");
		
		UOnlineInventorySubsystem_RequestInventoryTransaction_Params params {};
		params.ItemDefId = ItemDefId;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05703FC0
	 * 		Name   -> Function Insurgency.OnlineInventorySubsystem.ReQueryEntitlements
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void UOnlineInventorySubsystem::ReQueryEntitlements()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.OnlineInventorySubsystem.ReQueryEntitlements");
		
		UOnlineInventorySubsystem_ReQueryEntitlements_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05704310
	 * 		Name   -> Function Insurgency.OnlineInventorySubsystem.RemovePreset
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		class FText                                        PresetName                                                 (Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UOnlineInventorySubsystem::RemovePreset(class FText* PresetName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.OnlineInventorySubsystem.RemovePreset");
		
		UOnlineInventorySubsystem_RemovePreset_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (PresetName != nullptr)
			*PresetName = params.PresetName;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05704200
	 * 		Name   -> Function Insurgency.OnlineInventorySubsystem.RemoveCosmeticsInSlot
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		ECharacterAppearanceSlot                           Slot                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            SubSlot                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bCallDelegate                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UOnlineInventorySubsystem::RemoveCosmeticsInSlot(ECharacterAppearanceSlot Slot, int32_t SubSlot, bool bCallDelegate)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.OnlineInventorySubsystem.RemoveCosmeticsInSlot");
		
		UOnlineInventorySubsystem_RemoveCosmeticsInSlot_Params params {};
		params.Slot = Slot;
		params.SubSlot = SubSlot;
		params.bCallDelegate = bCallDelegate;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05704180
	 * 		Name   -> Function Insurgency.OnlineInventorySubsystem.RemoveCosmeticFromShoppingCart
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		int32_t                                            ItemId                                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UOnlineInventorySubsystem::RemoveCosmeticFromShoppingCart(int32_t ItemId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.OnlineInventorySubsystem.RemoveCosmeticFromShoppingCart");
		
		UOnlineInventorySubsystem_RemoveCosmeticFromShoppingCart_Params params {};
		params.ItemId = ItemId;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x057040C0
	 * 		Name   -> Function Insurgency.OnlineInventorySubsystem.RemoveCosmeticFromCurrentState
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		struct FSelectedCosmetic                           Cosmetic                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UOnlineInventorySubsystem::RemoveCosmeticFromCurrentState(const struct FSelectedCosmetic& Cosmetic)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.OnlineInventorySubsystem.RemoveCosmeticFromCurrentState");
		
		UOnlineInventorySubsystem_RemoveCosmeticFromCurrentState_Params params {};
		params.Cosmetic = Cosmetic;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05703FE0
	 * 		Name   -> Function Insurgency.OnlineInventorySubsystem.RefreshEntitledCosmetics
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void UOnlineInventorySubsystem::RefreshEntitledCosmetics()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.OnlineInventorySubsystem.RefreshEntitledCosmetics");
		
		UOnlineInventorySubsystem_RefreshEntitledCosmetics_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05703FA0
	 * 		Name   -> Function Insurgency.OnlineInventorySubsystem.RandomizeCosmeticsForPreferredFaction
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void UOnlineInventorySubsystem::RandomizeCosmeticsForPreferredFaction()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.OnlineInventorySubsystem.RandomizeCosmeticsForPreferredFaction");
		
		UOnlineInventorySubsystem_RandomizeCosmeticsForPreferredFaction_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05703E90
	 * 		Name   -> Function Insurgency.OnlineInventorySubsystem.PlaySampleFromCosmeticVoiceDictionary
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		int32_t                                            ItemId                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UOnlineInventorySubsystem::PlaySampleFromCosmeticVoiceDictionary(int32_t ItemId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.OnlineInventorySubsystem.PlaySampleFromCosmeticVoiceDictionary");
		
		UOnlineInventorySubsystem_PlaySampleFromCosmeticVoiceDictionary_Params params {};
		params.ItemId = ItemId;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05703DD0
	 * 		Name   -> Function Insurgency.OnlineInventorySubsystem.PlayRadialSampleFromCosmeticVoiceDictionary
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		int32_t                                            ItemId                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            SampleIndex                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UOnlineInventorySubsystem::PlayRadialSampleFromCosmeticVoiceDictionary(int32_t ItemId, int32_t SampleIndex)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.OnlineInventorySubsystem.PlayRadialSampleFromCosmeticVoiceDictionary");
		
		UOnlineInventorySubsystem_PlayRadialSampleFromCosmeticVoiceDictionary_Params params {};
		params.ItemId = ItemId;
		params.SampleIndex = SampleIndex;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05703F10
	 * 		Name   -> Function Insurgency.OnlineInventorySubsystem.PlayerOwnsItemId
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		int32_t                                            ItemId                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UOnlineInventorySubsystem::PlayerOwnsItemId(int32_t ItemId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.OnlineInventorySubsystem.PlayerOwnsItemId");
		
		UOnlineInventorySubsystem_PlayerOwnsItemId_Params params {};
		params.ItemId = ItemId;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05703DA0
	 * 		Name   -> Function Insurgency.OnlineInventorySubsystem.OpenPlatformStoreUI
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	bool UOnlineInventorySubsystem::OpenPlatformStoreUI()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.OnlineInventorySubsystem.OpenPlatformStoreUI");
		
		UOnlineInventorySubsystem_OpenPlatformStoreUI_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05703D10
	 * 		Name   -> Function Insurgency.OnlineInventorySubsystem.OpenDLCLinkForBundle
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UClass*                                      BundleClass                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UOnlineInventorySubsystem::OpenDLCLinkForBundle(class UClass* BundleClass)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.OnlineInventorySubsystem.OpenDLCLinkForBundle");
		
		UOnlineInventorySubsystem_OpenDLCLinkForBundle_Params params {};
		params.BundleClass = BundleClass;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> DelegateFunction Insurgency.OnlineInventorySubsystem.OnStoreComplete__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 */
	void UOnlineInventorySubsystem::OnStoreComplete__DelegateSignature()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction Insurgency.OnlineInventorySubsystem.OnStoreComplete__DelegateSignature");
		
		UOnlineInventorySubsystem_OnStoreComplete__DelegateSignature_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05630E50
	 * 		Name   -> Function Insurgency.OnlineInventorySubsystem.OnShowStoreUIClosed
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bPurchased                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UOnlineInventorySubsystem::OnShowStoreUIClosed(bool bPurchased)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.OnlineInventorySubsystem.OnShowStoreUIClosed");
		
		UOnlineInventorySubsystem_OnShowStoreUIClosed_Params params {};
		params.bPurchased = bPurchased;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> DelegateFunction Insurgency.OnlineInventorySubsystem.OnRequestSellInventoryUpdated__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 */
	void UOnlineInventorySubsystem::OnRequestSellInventoryUpdated__DelegateSignature()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction Insurgency.OnlineInventorySubsystem.OnRequestSellInventoryUpdated__DelegateSignature");
		
		UOnlineInventorySubsystem_OnRequestSellInventoryUpdated__DelegateSignature_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> DelegateFunction Insurgency.OnlineInventorySubsystem.OnRequestPurchaseInventoryUpdated__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 * Parameters:
	 * 		int32_t                                            ItemDefId                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UOnlineInventorySubsystem::OnRequestPurchaseInventoryUpdated__DelegateSignature(int32_t ItemDefId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction Insurgency.OnlineInventorySubsystem.OnRequestPurchaseInventoryUpdated__DelegateSignature");
		
		UOnlineInventorySubsystem_OnRequestPurchaseInventoryUpdated__DelegateSignature_Params params {};
		params.ItemDefId = ItemDefId;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> DelegateFunction Insurgency.OnlineInventorySubsystem.OnRequestInventoryTransactionListCompleted__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 */
	void UOnlineInventorySubsystem::OnRequestInventoryTransactionListCompleted__DelegateSignature()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction Insurgency.OnlineInventorySubsystem.OnRequestInventoryTransactionListCompleted__DelegateSignature");
		
		UOnlineInventorySubsystem_OnRequestInventoryTransactionListCompleted__DelegateSignature_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> DelegateFunction Insurgency.OnlineInventorySubsystem.OnRequestInventoryTransactionInitCompleted__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 */
	void UOnlineInventorySubsystem::OnRequestInventoryTransactionInitCompleted__DelegateSignature()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction Insurgency.OnlineInventorySubsystem.OnRequestInventoryTransactionInitCompleted__DelegateSignature");
		
		UOnlineInventorySubsystem_OnRequestInventoryTransactionInitCompleted__DelegateSignature_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> DelegateFunction Insurgency.OnlineInventorySubsystem.OnRequestInventoryTransactionCompleted__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 */
	void UOnlineInventorySubsystem::OnRequestInventoryTransactionCompleted__DelegateSignature()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction Insurgency.OnlineInventorySubsystem.OnRequestInventoryTransactionCompleted__DelegateSignature");
		
		UOnlineInventorySubsystem_OnRequestInventoryTransactionCompleted__DelegateSignature_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> DelegateFunction Insurgency.OnlineInventorySubsystem.OnReceivedNewItemClaims__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate, HasOutParms)
	 * Parameters:
	 * 		struct FOnlineItemClaimResult                      Claims                                                     (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UOnlineInventorySubsystem::OnReceivedNewItemClaims__DelegateSignature(const struct FOnlineItemClaimResult& Claims)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction Insurgency.OnlineInventorySubsystem.OnReceivedNewItemClaims__DelegateSignature");
		
		UOnlineInventorySubsystem_OnReceivedNewItemClaims__DelegateSignature_Params params {};
		params.Claims = Claims;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> DelegateFunction Insurgency.OnlineInventorySubsystem.OnQueryEntitlementsComplete__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 */
	void UOnlineInventorySubsystem::OnQueryEntitlementsComplete__DelegateSignature()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction Insurgency.OnlineInventorySubsystem.OnQueryEntitlementsComplete__DelegateSignature");
		
		UOnlineInventorySubsystem_OnQueryEntitlementsComplete__DelegateSignature_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> DelegateFunction Insurgency.OnlineInventorySubsystem.OnPreferredFactionChangedDelegate__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 * Parameters:
	 * 		class FName                                        Faction                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UOnlineInventorySubsystem::OnPreferredFactionChangedDelegate__DelegateSignature(const class FName& Faction)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction Insurgency.OnlineInventorySubsystem.OnPreferredFactionChangedDelegate__DelegateSignature");
		
		UOnlineInventorySubsystem_OnPreferredFactionChangedDelegate__DelegateSignature_Params params {};
		params.Faction = Faction;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> DelegateFunction Insurgency.OnlineInventorySubsystem.OnOwnedItemsLoadingCompleteDelegate__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 */
	void UOnlineInventorySubsystem::OnOwnedItemsLoadingCompleteDelegate__DelegateSignature()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction Insurgency.OnlineInventorySubsystem.OnOwnedItemsLoadingCompleteDelegate__DelegateSignature");
		
		UOnlineInventorySubsystem_OnOwnedItemsLoadingCompleteDelegate__DelegateSignature_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> DelegateFunction Insurgency.OnlineInventorySubsystem.OnCosmeticRemovedFromSlotDelegate__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 * Parameters:
	 * 		ECharacterAppearanceSlot                           Slot                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            SubSlot                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UOnlineInventorySubsystem::OnCosmeticRemovedFromSlotDelegate__DelegateSignature(ECharacterAppearanceSlot Slot, int32_t SubSlot)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction Insurgency.OnlineInventorySubsystem.OnCosmeticRemovedFromSlotDelegate__DelegateSignature");
		
		UOnlineInventorySubsystem_OnCosmeticRemovedFromSlotDelegate__DelegateSignature_Params params {};
		params.Slot = Slot;
		params.SubSlot = SubSlot;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> DelegateFunction Insurgency.OnlineInventorySubsystem.OnCosmeticEquippedDelegate__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate, HasOutParms)
	 * Parameters:
	 * 		struct FSelectedCosmetic                           Cosmetic                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		ECharacterAppearanceSlot                           Slot                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            SubSlot                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bActive                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UOnlineInventorySubsystem::OnCosmeticEquippedDelegate__DelegateSignature(const struct FSelectedCosmetic& Cosmetic, ECharacterAppearanceSlot Slot, int32_t SubSlot, bool bActive)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction Insurgency.OnlineInventorySubsystem.OnCosmeticEquippedDelegate__DelegateSignature");
		
		UOnlineInventorySubsystem_OnCosmeticEquippedDelegate__DelegateSignature_Params params {};
		params.Cosmetic = Cosmetic;
		params.Slot = Slot;
		params.SubSlot = SubSlot;
		params.bActive = bActive;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05703C40
	 * 		Name   -> Function Insurgency.OnlineInventorySubsystem.LoadPreset
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		class FText                                        PresetName                                                 (Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UOnlineInventorySubsystem::LoadPreset(class FText* PresetName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.OnlineInventorySubsystem.LoadPreset");
		
		UOnlineInventorySubsystem_LoadPreset_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (PresetName != nullptr)
			*PresetName = params.PresetName;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05703BB0
	 * 		Name   -> Function Insurgency.OnlineInventorySubsystem.IsEntitledToCosmetic
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		class UClass*                                      Cosmetic                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UOnlineInventorySubsystem::IsEntitledToCosmetic(class UClass* Cosmetic)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.OnlineInventorySubsystem.IsEntitledToCosmetic");
		
		UOnlineInventorySubsystem_IsEntitledToCosmetic_Params params {};
		params.Cosmetic = Cosmetic;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05703AF0
	 * 		Name   -> Function Insurgency.OnlineInventorySubsystem.IsCosmetictItemUnview
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class UClass*                                      CosmeticClass                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            ItemId                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UOnlineInventorySubsystem::IsCosmetictItemUnview(class UClass* CosmeticClass, int32_t ItemId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.OnlineInventorySubsystem.IsCosmetictItemUnview");
		
		UOnlineInventorySubsystem_IsCosmetictItemUnview_Params params {};
		params.CosmeticClass = CosmeticClass;
		params.ItemId = ItemId;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05703A30
	 * 		Name   -> Function Insurgency.OnlineInventorySubsystem.IsCosmeticIdEquipped
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		int32_t                                            ItemId                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bIncludeBase                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UOnlineInventorySubsystem::IsCosmeticIdEquipped(int32_t ItemId, bool bIncludeBase)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.OnlineInventorySubsystem.IsCosmeticIdEquipped");
		
		UOnlineInventorySubsystem_IsCosmeticIdEquipped_Params params {};
		params.ItemId = ItemId;
		params.bIncludeBase = bIncludeBase;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05703960
	 * 		Name   -> Function Insurgency.OnlineInventorySubsystem.IsCosmeticEquippedInCurrentState
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		struct FSelectedCosmetic                           Cosmetic                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	bool UOnlineInventorySubsystem::IsCosmeticEquippedInCurrentState(const struct FSelectedCosmetic& Cosmetic)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.OnlineInventorySubsystem.IsCosmeticEquippedInCurrentState");
		
		UOnlineInventorySubsystem_IsCosmeticEquippedInCurrentState_Params params {};
		params.Cosmetic = Cosmetic;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x057038A0
	 * 		Name   -> Function Insurgency.OnlineInventorySubsystem.IsCosmeticEquipped
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		class UClass*                                      Cosmetic                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bActive                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UOnlineInventorySubsystem::IsCosmeticEquipped(class UClass* Cosmetic, bool bActive)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.OnlineInventorySubsystem.IsCosmeticEquipped");
		
		UOnlineInventorySubsystem_IsCosmeticEquipped_Params params {};
		params.Cosmetic = Cosmetic;
		params.bActive = bActive;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05703870
	 * 		Name   -> Function Insurgency.OnlineInventorySubsystem.HasPreOrderEntitlement
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool UOnlineInventorySubsystem::HasPreOrderEntitlement()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.OnlineInventorySubsystem.HasPreOrderEntitlement");
		
		UOnlineInventorySubsystem_HasPreOrderEntitlement_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x057037B0
	 * 		Name   -> Function Insurgency.OnlineInventorySubsystem.HasEquippedCosmeticForSlot
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		ECharacterAppearanceSlot                           Slot                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            SubSlot                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UOnlineInventorySubsystem::HasEquippedCosmeticForSlot(ECharacterAppearanceSlot Slot, int32_t SubSlot)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.OnlineInventorySubsystem.HasEquippedCosmeticForSlot");
		
		UOnlineInventorySubsystem_HasEquippedCosmeticForSlot_Params params {};
		params.Slot = Slot;
		params.SubSlot = SubSlot;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x057036E0
	 * 		Name   -> Function Insurgency.OnlineInventorySubsystem.GrantCosmeticEntitlement
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UClass*                                      Cosmetic                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bShouldEquip                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UOnlineInventorySubsystem::GrantCosmeticEntitlement(class UClass* Cosmetic, bool bShouldEquip)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.OnlineInventorySubsystem.GrantCosmeticEntitlement");
		
		UOnlineInventorySubsystem_GrantCosmeticEntitlement_Params params {};
		params.Cosmetic = Cosmetic;
		params.bShouldEquip = bShouldEquip;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x057036C0
	 * 		Name   -> Function Insurgency.OnlineInventorySubsystem.GiveDefaultCosmeticsForPreferredFaction
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void UOnlineInventorySubsystem::GiveDefaultCosmeticsForPreferredFaction()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.OnlineInventorySubsystem.GiveDefaultCosmeticsForPreferredFaction");
		
		UOnlineInventorySubsystem_GiveDefaultCosmeticsForPreferredFaction_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x057035C0
	 * 		Name   -> Function Insurgency.OnlineInventorySubsystem.GetTotalEntitledCosmeticsForSubSlot
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		ECharacterAppearanceSlot                           Slot                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            SubSlot                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bActive                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	int32_t UOnlineInventorySubsystem::GetTotalEntitledCosmeticsForSubSlot(ECharacterAppearanceSlot Slot, int32_t SubSlot, bool bActive)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.OnlineInventorySubsystem.GetTotalEntitledCosmeticsForSubSlot");
		
		UOnlineInventorySubsystem_GetTotalEntitledCosmeticsForSubSlot_Params params {};
		params.Slot = Slot;
		params.SubSlot = SubSlot;
		params.bActive = bActive;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x057034F0
	 * 		Name   -> Function Insurgency.OnlineInventorySubsystem.GetTotalEntitledCosmeticsForSlot
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		ECharacterAppearanceSlot                           Slot                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bActive                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	int32_t UOnlineInventorySubsystem::GetTotalEntitledCosmeticsForSlot(ECharacterAppearanceSlot Slot, bool bActive)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.OnlineInventorySubsystem.GetTotalEntitledCosmeticsForSlot");
		
		UOnlineInventorySubsystem_GetTotalEntitledCosmeticsForSlot_Params params {};
		params.Slot = Slot;
		params.bActive = bActive;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05703420
	 * 		Name   -> Function Insurgency.OnlineInventorySubsystem.GetTauntSamplesForCosmetic
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		int32_t                                            ItemId                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	TArray<int32_t> UOnlineInventorySubsystem::GetTauntSamplesForCosmetic(int32_t ItemId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.OnlineInventorySubsystem.GetTauntSamplesForCosmetic");
		
		UOnlineInventorySubsystem_GetTauntSamplesForCosmetic_Params params {};
		params.ItemId = ItemId;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05703280
	 * 		Name   -> Function Insurgency.OnlineInventorySubsystem.GetRandomOwnedCosmeticInSlotForState
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		struct FProfileCharacterCosmeticState              CosmeticState                                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		ECharacterAppearanceSlot                           Slot                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            SubSlot                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	int32_t UOnlineInventorySubsystem::GetRandomOwnedCosmeticInSlotForState(const struct FProfileCharacterCosmeticState& CosmeticState, ECharacterAppearanceSlot Slot, int32_t SubSlot)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.OnlineInventorySubsystem.GetRandomOwnedCosmeticInSlotForState");
		
		UOnlineInventorySubsystem_GetRandomOwnedCosmeticInSlotForState_Params params {};
		params.CosmeticState = CosmeticState;
		params.Slot = Slot;
		params.SubSlot = SubSlot;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05703150
	 * 		Name   -> Function Insurgency.OnlineInventorySubsystem.GetPresetCosmeticStateByName
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		class FText                                        PresetName                                                 (Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	struct FProfileCharacterCosmeticState UOnlineInventorySubsystem::GetPresetCosmeticStateByName(class FText* PresetName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.OnlineInventorySubsystem.GetPresetCosmeticStateByName");
		
		UOnlineInventorySubsystem_GetPresetCosmeticStateByName_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (PresetName != nullptr)
			*PresetName = params.PresetName;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05703120
	 * 		Name   -> Function Insurgency.OnlineInventorySubsystem.GetLastKnownBalance
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	int32_t UOnlineInventorySubsystem::GetLastKnownBalance()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.OnlineInventorySubsystem.GetLastKnownBalance");
		
		UOnlineInventorySubsystem_GetLastKnownBalance_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05703050
	 * 		Name   -> Function Insurgency.OnlineInventorySubsystem.GetEquippedCosmeticForSlot
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		ECharacterAppearanceSlot                           Slot                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            SubSlot                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UClass* UOnlineInventorySubsystem::GetEquippedCosmeticForSlot(ECharacterAppearanceSlot Slot, int32_t SubSlot)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.OnlineInventorySubsystem.GetEquippedCosmeticForSlot");
		
		UOnlineInventorySubsystem_GetEquippedCosmeticForSlot_Params params {};
		params.Slot = Slot;
		params.SubSlot = SubSlot;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05702F00
	 * 		Name   -> Function Insurgency.OnlineInventorySubsystem.GetEntitledCosmeticsInSlot
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		ECharacterAppearanceSlot                           Slot                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            SubSlot                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bActive                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	TArray<class UClass*> UOnlineInventorySubsystem::GetEntitledCosmeticsInSlot(ECharacterAppearanceSlot Slot, int32_t SubSlot, bool bActive)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.OnlineInventorySubsystem.GetEntitledCosmeticsInSlot");
		
		UOnlineInventorySubsystem_GetEntitledCosmeticsInSlot_Params params {};
		params.Slot = Slot;
		params.SubSlot = SubSlot;
		params.bActive = bActive;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05702DF0
	 * 		Name   -> Function Insurgency.OnlineInventorySubsystem.GetDefaultCosmeticForSlot
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		class FName                                        Faction                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		ECharacterAppearanceSlot                           Slot                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            SubSlot                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UClass* UOnlineInventorySubsystem::GetDefaultCosmeticForSlot(const class FName& Faction, ECharacterAppearanceSlot Slot, int32_t SubSlot)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.OnlineInventorySubsystem.GetDefaultCosmeticForSlot");
		
		UOnlineInventorySubsystem_GetDefaultCosmeticForSlot_Params params {};
		params.Faction = Faction;
		params.Slot = Slot;
		params.SubSlot = SubSlot;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05702B70
	 * 		Name   -> Function Insurgency.OnlineInventorySubsystem.GetCosmeticVariationsArray
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		class UClass*                                      CosmeticClass                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	TArray<class UClass*> UOnlineInventorySubsystem::GetCosmeticVariationsArray(class UClass* CosmeticClass)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.OnlineInventorySubsystem.GetCosmeticVariationsArray");
		
		UOnlineInventorySubsystem_GetCosmeticVariationsArray_Params params {};
		params.CosmeticClass = CosmeticClass;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05702A50
	 * 		Name   -> Function Insurgency.OnlineInventorySubsystem.GetCosmeticVariations
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		class UClass*                                      CosmeticClass                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		TArray<struct FSelectedCosmetic>                   CosmeticVariations                                         (Parm, OutParm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UOnlineInventorySubsystem::GetCosmeticVariations(class UClass* CosmeticClass, TArray<struct FSelectedCosmetic>* CosmeticVariations)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.OnlineInventorySubsystem.GetCosmeticVariations");
		
		UOnlineInventorySubsystem_GetCosmeticVariations_Params params {};
		params.CosmeticClass = CosmeticClass;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (CosmeticVariations != nullptr)
			*CosmeticVariations = params.CosmeticVariations;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05702C50
	 * 		Name   -> Function Insurgency.OnlineInventorySubsystem.GetCosmeticsCountForSlot
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		class FName                                        FactionRestriction                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		ECharacterAppearanceSlot                           Slot                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            SubSlot                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            CountOwned                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            CountTotal                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UOnlineInventorySubsystem::GetCosmeticsCountForSlot(const class FName& FactionRestriction, ECharacterAppearanceSlot Slot, int32_t SubSlot, int32_t* CountOwned, int32_t* CountTotal)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.OnlineInventorySubsystem.GetCosmeticsCountForSlot");
		
		UOnlineInventorySubsystem_GetCosmeticsCountForSlot_Params params {};
		params.FactionRestriction = FactionRestriction;
		params.Slot = Slot;
		params.SubSlot = SubSlot;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (CountOwned != nullptr)
			*CountOwned = params.CountOwned;
		if (CountTotal != nullptr)
			*CountTotal = params.CountTotal;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x057029C0
	 * 		Name   -> Function Insurgency.OnlineInventorySubsystem.GetCosmeticByItemDefId
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		int32_t                                            ItemDefId                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UClass* UOnlineInventorySubsystem::GetCosmeticByItemDefId(int32_t ItemDefId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.OnlineInventorySubsystem.GetCosmeticByItemDefId");
		
		UOnlineInventorySubsystem_GetCosmeticByItemDefId_Params params {};
		params.ItemDefId = ItemDefId;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05702870
	 * 		Name   -> Function Insurgency.OnlineInventorySubsystem.GetCharacterCosmeticState
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		class FName                                        FactionName                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bIncludeShoppingCart                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FProfileCharacterCosmeticState UOnlineInventorySubsystem::GetCharacterCosmeticState(const class FName& FactionName, bool bIncludeShoppingCart)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.OnlineInventorySubsystem.GetCharacterCosmeticState");
		
		UOnlineInventorySubsystem_GetCharacterCosmeticState_Params params {};
		params.FactionName = FactionName;
		params.bIncludeShoppingCart = bIncludeShoppingCart;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05702710
	 * 		Name   -> Function Insurgency.OnlineInventorySubsystem.GetAvailableScoreboardBadges
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		TArray<struct FScoreboardBadge>                    OutBadges                                                  (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UOnlineInventorySubsystem::GetAvailableScoreboardBadges(TArray<struct FScoreboardBadge>* OutBadges)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.OnlineInventorySubsystem.GetAvailableScoreboardBadges");
		
		UOnlineInventorySubsystem_GetAvailableScoreboardBadges_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutBadges != nullptr)
			*OutBadges = params.OutBadges;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05702690
	 * 		Name   -> Function Insurgency.OnlineInventorySubsystem.EquipCosmeticByItemId
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		int32_t                                            ItemId                                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UOnlineInventorySubsystem::EquipCosmeticByItemId(int32_t ItemId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.OnlineInventorySubsystem.EquipCosmeticByItemId");
		
		UOnlineInventorySubsystem_EquipCosmeticByItemId_Params params {};
		params.ItemId = ItemId;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x057025D0
	 * 		Name   -> Function Insurgency.OnlineInventorySubsystem.EquipCosmetic
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		struct FSelectedCosmetic                           Cosmetic                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UOnlineInventorySubsystem::EquipCosmetic(const struct FSelectedCosmetic& Cosmetic)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.OnlineInventorySubsystem.EquipCosmetic");
		
		UOnlineInventorySubsystem_EquipCosmetic_Params params {};
		params.Cosmetic = Cosmetic;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05702540
	 * 		Name   -> Function Insurgency.OnlineInventorySubsystem.EmptyShoppingCart
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		class FName                                        SelectedFaction                                            (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UOnlineInventorySubsystem::EmptyShoppingCart(class FName* SelectedFaction)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.OnlineInventorySubsystem.EmptyShoppingCart");
		
		UOnlineInventorySubsystem_EmptyShoppingCart_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (SelectedFaction != nullptr)
			*SelectedFaction = params.SelectedFaction;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x057024B0
	 * 		Name   -> Function Insurgency.OnlineInventorySubsystem.DoesPlayerOwnCosmeticItemId
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		int32_t                                            ItemId                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UOnlineInventorySubsystem::DoesPlayerOwnCosmeticItemId(int32_t ItemId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.OnlineInventorySubsystem.DoesPlayerOwnCosmeticItemId");
		
		UOnlineInventorySubsystem_DoesPlayerOwnCosmeticItemId_Params params {};
		params.ItemId = ItemId;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x057023E0
	 * 		Name   -> Function Insurgency.OnlineInventorySubsystem.DoesPlayerOwnCosmetic
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		struct FSelectedCosmetic                           Cosmetic                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	bool UOnlineInventorySubsystem::DoesPlayerOwnCosmetic(const struct FSelectedCosmetic& Cosmetic)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.OnlineInventorySubsystem.DoesPlayerOwnCosmetic");
		
		UOnlineInventorySubsystem_DoesPlayerOwnCosmetic_Params params {};
		params.Cosmetic = Cosmetic;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05702350
	 * 		Name   -> Function Insurgency.OnlineInventorySubsystem.DoesPlayerOwnCompetitiveCosmeticItemId
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		int32_t                                            ItemId                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UOnlineInventorySubsystem::DoesPlayerOwnCompetitiveCosmeticItemId(int32_t ItemId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.OnlineInventorySubsystem.DoesPlayerOwnCompetitiveCosmeticItemId");
		
		UOnlineInventorySubsystem_DoesPlayerOwnCompetitiveCosmeticItemId_Params params {};
		params.ItemId = ItemId;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05702250
	 * 		Name   -> Function Insurgency.OnlineInventorySubsystem.DoesCosmeticSlotSupportEmpty
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		ECharacterAppearanceSlot                           Slot                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            SubSlot                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FName                                        Faction                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UOnlineInventorySubsystem::DoesCosmeticSlotSupportEmpty(ECharacterAppearanceSlot Slot, int32_t SubSlot, const class FName& Faction)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.OnlineInventorySubsystem.DoesCosmeticSlotSupportEmpty");
		
		UOnlineInventorySubsystem_DoesCosmeticSlotSupportEmpty_Params params {};
		params.Slot = Slot;
		params.SubSlot = SubSlot;
		params.Faction = Faction;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x057021C0
	 * 		Name   -> Function Insurgency.OnlineInventorySubsystem.DoesCosmeticSlotContainSubSlots
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		ECharacterAppearanceSlot                           Slot                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UOnlineInventorySubsystem::DoesCosmeticSlotContainSubSlots(ECharacterAppearanceSlot Slot)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.OnlineInventorySubsystem.DoesCosmeticSlotContainSubSlots");
		
		UOnlineInventorySubsystem_DoesCosmeticSlotContainSubSlots_Params params {};
		params.Slot = Slot;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05702130
	 * 		Name   -> Function Insurgency.OnlineInventorySubsystem.DoesCosmeticHaveParent
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		class UClass*                                      Cosmetic                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UOnlineInventorySubsystem::DoesCosmeticHaveParent(class UClass* Cosmetic)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.OnlineInventorySubsystem.DoesCosmeticHaveParent");
		
		UOnlineInventorySubsystem_DoesCosmeticHaveParent_Params params {};
		params.Cosmetic = Cosmetic;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05702070
	 * 		Name   -> Function Insurgency.OnlineInventorySubsystem.DoesCosmeticHaveChildren
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		class UClass*                                      Cosmetic                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bEquippedOnly                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UOnlineInventorySubsystem::DoesCosmeticHaveChildren(class UClass* Cosmetic, bool bEquippedOnly)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.OnlineInventorySubsystem.DoesCosmeticHaveChildren");
		
		UOnlineInventorySubsystem_DoesCosmeticHaveChildren_Params params {};
		params.Cosmetic = Cosmetic;
		params.bEquippedOnly = bEquippedOnly;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05702040
	 * 		Name   -> Function Insurgency.OnlineInventorySubsystem.CanPurchase
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool UOnlineInventorySubsystem::CanPurchase()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.OnlineInventorySubsystem.CanPurchase");
		
		UOnlineInventorySubsystem_CanPurchase_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05702020
	 * 		Name   -> Function Insurgency.OnlineInventorySubsystem.AttemptToClaimTutorialCredits
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void UOnlineInventorySubsystem::AttemptToClaimTutorialCredits()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.OnlineInventorySubsystem.AttemptToClaimTutorialCredits");
		
		UOnlineInventorySubsystem_AttemptToClaimTutorialCredits_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05701F50
	 * 		Name   -> Function Insurgency.OnlineInventorySubsystem.AddNewStoredCosmeticState
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		class FText                                        NewStateName                                               (Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UOnlineInventorySubsystem::AddNewStoredCosmeticState(class FText* NewStateName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.OnlineInventorySubsystem.AddNewStoredCosmeticState");
		
		UOnlineInventorySubsystem_AddNewStoredCosmeticState_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (NewStateName != nullptr)
			*NewStateName = params.NewStateName;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05701ED0
	 * 		Name   -> Function Insurgency.OnlineInventorySubsystem.AddCosmeticToShoppingCart
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		int32_t                                            ItemId                                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UOnlineInventorySubsystem::AddCosmeticToShoppingCart(int32_t ItemId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.OnlineInventorySubsystem.AddCosmeticToShoppingCart");
		
		UOnlineInventorySubsystem_AddCosmeticToShoppingCart_Params params {};
		params.ItemId = ItemId;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05701E10
	 * 		Name   -> Function Insurgency.OnlineInventorySubsystem.AddCosmeticToCurrentState
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		struct FSelectedCosmetic                           NewCosmetic                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UOnlineInventorySubsystem::AddCosmeticToCurrentState(const struct FSelectedCosmetic& NewCosmetic)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.OnlineInventorySubsystem.AddCosmeticToCurrentState");
		
		UOnlineInventorySubsystem_AddCosmeticToCurrentState_Params params {};
		params.NewCosmetic = NewCosmetic;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UOnlineInventorySubsystem.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UOnlineInventorySubsystem::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.OnlineInventorySubsystem");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UOnlineStoreSubsystem.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UOnlineStoreSubsystem::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.OnlineStoreSubsystem");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> Function Insurgency.OSSStatusWidget.OnPlatformStateUpdated
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		EOSSNetworkState                                   OldState                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EOSSNetworkState                                   NewState                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UOSSStatusWidget::OnPlatformStateUpdated(EOSSNetworkState OldState, EOSSNetworkState NewState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.OSSStatusWidget.OnPlatformStateUpdated");
		
		UOSSStatusWidget_OnPlatformStateUpdated_Params params {};
		params.OldState = OldState;
		params.NewState = NewState;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> Function Insurgency.OSSStatusWidget.OnNewWorldStateUpdated
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		EOSSNetworkState                                   OldState                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EOSSNetworkState                                   NewState                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UOSSStatusWidget::OnNewWorldStateUpdated(EOSSNetworkState OldState, EOSSNetworkState NewState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.OSSStatusWidget.OnNewWorldStateUpdated");
		
		UOSSStatusWidget_OnNewWorldStateUpdated_Params params {};
		params.OldState = OldState;
		params.NewState = NewState;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UOSSStatusWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UOSSStatusWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.OSSStatusWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05705760
	 * 		Name   -> Function Insurgency.OutpostHUD.GetINSUserSettings
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	class UINSGameUserSettings* UOutpostHUD::GetINSUserSettings()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.OutpostHUD.GetINSUserSettings");
		
		UOutpostHUD_GetINSUserSettings_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UOutpostHUD.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UOutpostHUD::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.OutpostHUD");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05705FA0
	 * 		Name   -> Function Insurgency.PainCausingVolumeComponent.OnEndAreaOverlap
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		class UPrimitiveComponent*                         OverlappedComponent                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      OtherActor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UPrimitiveComponent*                         OtherComp                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            OtherBodyIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UPainCausingVolumeComponent::OnEndAreaOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32_t OtherBodyIndex)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.PainCausingVolumeComponent.OnEndAreaOverlap");
		
		UPainCausingVolumeComponent_OnEndAreaOverlap_Params params {};
		params.OverlappedComponent = OverlappedComponent;
		params.OtherActor = OtherActor;
		params.OtherComp = OtherComp;
		params.OtherBodyIndex = OtherBodyIndex;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05705D90
	 * 		Name   -> Function Insurgency.PainCausingVolumeComponent.OnBeginAreaOverlap
	 * 		Flags  -> (Final, Native, Public, HasOutParms)
	 * Parameters:
	 * 		class UPrimitiveComponent*                         OverlappedComponent                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      OtherActor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UPrimitiveComponent*                         OtherComp                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            OtherBodyIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bFromSweep                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FHitResult                                  SweepResult                                                (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	void UPainCausingVolumeComponent::OnBeginAreaOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32_t OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.PainCausingVolumeComponent.OnBeginAreaOverlap");
		
		UPainCausingVolumeComponent_OnBeginAreaOverlap_Params params {};
		params.OverlappedComponent = OverlappedComponent;
		params.OtherActor = OtherActor;
		params.OtherComp = OtherComp;
		params.OtherBodyIndex = OtherBodyIndex;
		params.bFromSweep = bFromSweep;
		params.SweepResult = SweepResult;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UPainCausingVolumeComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UPainCausingVolumeComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.PainCausingVolumeComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00CD91F0
	 * 		Name   -> Function Insurgency.PerFrameCallQueueWorldSubsystem.GetPerFrameCallQueue
	 * 		Flags  -> (Final, Native, Public)
	 */
	class UPerFrameCallQueue* UPerFrameCallQueueWorldSubsystem::GetPerFrameCallQueue()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.PerFrameCallQueueWorldSubsystem.GetPerFrameCallQueue");
		
		UPerFrameCallQueueWorldSubsystem_GetPerFrameCallQueue_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UPerFrameCallQueueWorldSubsystem.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UPerFrameCallQueueWorldSubsystem::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.PerFrameCallQueueWorldSubsystem");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UPerFrameCallQueue.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UPerFrameCallQueue::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.PerFrameCallQueue");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05706BE0
	 * 		Name   -> Function Insurgency.PlayableArea.OnEndAreaOverlap
	 * 		Flags  -> (Final, Native, Private)
	 * Parameters:
	 * 		class UPrimitiveComponent*                         OverlappedComponent                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      OtherActor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UPrimitiveComponent*                         OtherComp                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            OtherBodyIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void APlayableArea::OnEndAreaOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32_t OtherBodyIndex)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.PlayableArea.OnEndAreaOverlap");
		
		APlayableArea_OnEndAreaOverlap_Params params {};
		params.OverlappedComponent = OverlappedComponent;
		params.OtherActor = OtherActor;
		params.OtherComp = OtherComp;
		params.OtherBodyIndex = OtherBodyIndex;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x057069D0
	 * 		Name   -> Function Insurgency.PlayableArea.OnBeginAreaOverlap
	 * 		Flags  -> (Final, Native, Private, HasOutParms)
	 * Parameters:
	 * 		class UPrimitiveComponent*                         OverlappedComponent                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      OtherActor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UPrimitiveComponent*                         OtherComp                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            OtherBodyIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bFromSweep                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FHitResult                                  SweepResult                                                (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	void APlayableArea::OnBeginAreaOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32_t OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.PlayableArea.OnBeginAreaOverlap");
		
		APlayableArea_OnBeginAreaOverlap_Params params {};
		params.OverlappedComponent = OverlappedComponent;
		params.OtherActor = OtherActor;
		params.OtherComp = OtherComp;
		params.OtherBodyIndex = OtherBodyIndex;
		params.bFromSweep = bFromSweep;
		params.SweepResult = SweepResult;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x057069A0
	 * 		Name   -> Function Insurgency.PlayableArea.IsValidPlayableArea
	 * 		Flags  -> (Final, Native, Private)
	 */
	bool APlayableArea::IsValidPlayableArea()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.PlayableArea.IsValidPlayableArea");
		
		APlayableArea_IsValidPlayableArea_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05706970
	 * 		Name   -> Function Insurgency.PlayableArea.IsScenarioPlayableArea
	 * 		Flags  -> (Final, Native, Public)
	 */
	bool APlayableArea::IsScenarioPlayableArea()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.PlayableArea.IsScenarioPlayableArea");
		
		APlayableArea_IsScenarioPlayableArea_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05706940
	 * 		Name   -> Function Insurgency.PlayableArea.IsOverviewArea
	 * 		Flags  -> (Final, Native, Public)
	 */
	bool APlayableArea::IsOverviewArea()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.PlayableArea.IsOverviewArea");
		
		APlayableArea_IsOverviewArea_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction APlayableArea.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* APlayableArea::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.PlayableArea");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05706E90
	 * 		Name   -> Function Insurgency.PlayerAccountStatusAsync.BeginGetAccountStatus
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		int32_t                                            UserId                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UPlayerAccountStatusAsync* UPlayerAccountStatusAsync::STATIC_BeginGetAccountStatus(int32_t UserId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.PlayerAccountStatusAsync.BeginGetAccountStatus");
		
		UPlayerAccountStatusAsync_BeginGetAccountStatus_Params params {};
		params.UserId = UserId;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UPlayerAccountStatusAsync.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UPlayerAccountStatusAsync::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.PlayerAccountStatusAsync");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05707AC0
	 * 		Name   -> Function Insurgency.PlayerClass.PlayerClassHasFlag
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		EPlayerClassFlags                                  CheckFlag                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UPlayerClass::PlayerClassHasFlag(EPlayerClassFlags CheckFlag)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.PlayerClass.PlayerClassHasFlag");
		
		UPlayerClass_PlayerClassHasFlag_Params params {};
		params.CheckFlag = CheckFlag;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05707A20
	 * 		Name   -> Function Insurgency.PlayerClass.GetDefaultItems
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		bool                                               bIsNight                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	TArray<struct FLoadoutWeapon> UPlayerClass::GetDefaultItems(bool bIsNight)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.PlayerClass.GetDefaultItems");
		
		UPlayerClass_GetDefaultItems_Params params {};
		params.bIsNight = bIsNight;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UPlayerClass.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UPlayerClass::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.PlayerClass");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> Function Insurgency.PlayerClassComponent.OnKilled
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		class AINSSoldier*                                 Soldier                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UPlayerClassComponent::OnKilled(class AINSSoldier* Soldier)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.PlayerClassComponent.OnKilled");
		
		UPlayerClassComponent_OnKilled_Params params {};
		params.Soldier = Soldier;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> Function Insurgency.PlayerClassComponent.OnDeactivate
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		class AINSSoldier*                                 Soldier                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UPlayerClassComponent::OnDeactivate(class AINSSoldier* Soldier)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.PlayerClassComponent.OnDeactivate");
		
		UPlayerClassComponent_OnDeactivate_Params params {};
		params.Soldier = Soldier;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> Function Insurgency.PlayerClassComponent.OnActivate
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		class AINSSoldier*                                 Soldier                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UPlayerClassComponent::OnActivate(class AINSSoldier* Soldier)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.PlayerClassComponent.OnActivate");
		
		UPlayerClassComponent_OnActivate_Params params {};
		params.Soldier = Soldier;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UPlayerClassComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UPlayerClassComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.PlayerClassComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UPlayerClassVIP.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UPlayerClassVIP::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.PlayerClassVIP");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x057083E0
	 * 		Name   -> Function Insurgency.PlayerDetailsWidget.RequestDetails
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class FString                                      SteamId                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bNameOnly                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UPlayerDetailsWidget::RequestDetails(const class FString& SteamId, bool bNameOnly)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.PlayerDetailsWidget.RequestDetails");
		
		UPlayerDetailsWidget_RequestDetails_Params params {};
		params.SteamId = SteamId;
		params.bNameOnly = bNameOnly;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> Function Insurgency.PlayerDetailsWidget.OnTextureUpdated
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		class UTexture2D*                                  Texture                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UPlayerDetailsWidget::OnTextureUpdated(class UTexture2D* Texture)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.PlayerDetailsWidget.OnTextureUpdated");
		
		UPlayerDetailsWidget_OnTextureUpdated_Params params {};
		params.Texture = Texture;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> Function Insurgency.PlayerDetailsWidget.OnNameUpdated
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		class FString                                      Name                                                       (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UPlayerDetailsWidget::OnNameUpdated(const class FString& Name)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.PlayerDetailsWidget.OnNameUpdated");
		
		UPlayerDetailsWidget_OnNameUpdated_Params params {};
		params.Name = Name;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UPlayerDetailsWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UPlayerDetailsWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.PlayerDetailsWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05709110
	 * 		Name   -> Function Insurgency.PlayerEquipmentCollection.ContainsWeaponUpgrade
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		class UClass*                                      Upgrade                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UPlayerEquipmentCollection::ContainsWeaponUpgrade(class UClass* Upgrade)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.PlayerEquipmentCollection.ContainsWeaponUpgrade");
		
		UPlayerEquipmentCollection_ContainsWeaponUpgrade_Params params {};
		params.Upgrade = Upgrade;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05709080
	 * 		Name   -> Function Insurgency.PlayerEquipmentCollection.ContainsItem
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		class UClass*                                      Item                                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UPlayerEquipmentCollection::ContainsItem(class UClass* Item)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.PlayerEquipmentCollection.ContainsItem");
		
		UPlayerEquipmentCollection_ContainsItem_Params params {};
		params.Item = Item;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05708FD0
	 * 		Name   -> Function Insurgency.PlayerEquipmentCollection.AppendWeaponUpgradesToUpgradeArray
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		TArray<class UClass*>                              OutUpgradeArray                                            (Parm, OutParm, ZeroConstructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UPlayerEquipmentCollection::AppendWeaponUpgradesToUpgradeArray(TArray<class UClass*>* OutUpgradeArray)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.PlayerEquipmentCollection.AppendWeaponUpgradesToUpgradeArray");
		
		UPlayerEquipmentCollection_AppendWeaponUpgradesToUpgradeArray_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutUpgradeArray != nullptr)
			*OutUpgradeArray = params.OutUpgradeArray;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05708F00
	 * 		Name   -> Function Insurgency.PlayerEquipmentCollection.AppendWeaponUpgradesToSoftUpgradeArray
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable)
	 */
	void UPlayerEquipmentCollection::AppendWeaponUpgradesToSoftUpgradeArray()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.PlayerEquipmentCollection.AppendWeaponUpgradesToSoftUpgradeArray");
		
		UPlayerEquipmentCollection_AppendWeaponUpgradesToSoftUpgradeArray_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05708E30
	 * 		Name   -> Function Insurgency.PlayerEquipmentCollection.AppendItemsToSoftItemArray
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable)
	 */
	void UPlayerEquipmentCollection::AppendItemsToSoftItemArray()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.PlayerEquipmentCollection.AppendItemsToSoftItemArray");
		
		UPlayerEquipmentCollection_AppendItemsToSoftItemArray_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05708D80
	 * 		Name   -> Function Insurgency.PlayerEquipmentCollection.AppendItemsToItemArray
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		TArray<class UClass*>                              OutItemsArray                                              (Parm, OutParm, ZeroConstructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UPlayerEquipmentCollection::AppendItemsToItemArray(TArray<class UClass*>* OutItemsArray)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.PlayerEquipmentCollection.AppendItemsToItemArray");
		
		UPlayerEquipmentCollection_AppendItemsToItemArray_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutItemsArray != nullptr)
			*OutItemsArray = params.OutItemsArray;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05708C50
	 * 		Name   -> Function Insurgency.PlayerEquipmentCollection.AppendAllowedEquipmentArray
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		TArray<struct FPlayerAllowedEquipment>             OutAllowedEquipmentArray                                   (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UPlayerEquipmentCollection::AppendAllowedEquipmentArray(TArray<struct FPlayerAllowedEquipment>* OutAllowedEquipmentArray)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.PlayerEquipmentCollection.AppendAllowedEquipmentArray");
		
		UPlayerEquipmentCollection_AppendAllowedEquipmentArray_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutAllowedEquipmentArray != nullptr)
			*OutAllowedEquipmentArray = params.OutAllowedEquipmentArray;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05708AC0
	 * 		Name   -> Function Insurgency.PlayerEquipmentCollection.AddWeaponUpgradesToSet
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable)
	 */
	void UPlayerEquipmentCollection::AddWeaponUpgradesToSet()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.PlayerEquipmentCollection.AddWeaponUpgradesToSet");
		
		UPlayerEquipmentCollection_AddWeaponUpgradesToSet_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05708930
	 * 		Name   -> Function Insurgency.PlayerEquipmentCollection.AddItemsToSet
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable)
	 */
	void UPlayerEquipmentCollection::AddItemsToSet()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.PlayerEquipmentCollection.AddItemsToSet");
		
		UPlayerEquipmentCollection_AddItemsToSet_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UPlayerEquipmentCollection.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UPlayerEquipmentCollection::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.PlayerEquipmentCollection");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0570E660
	 * 		Name   -> Function Insurgency.PlayerInventoryComponent.UpdatePointShootPreference
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               Mode                                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UPlayerInventoryComponent::UpdatePointShootPreference(bool Mode)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.PlayerInventoryComponent.UpdatePointShootPreference");
		
		UPlayerInventoryComponent_UpdatePointShootPreference_Params params {};
		params.Mode = Mode;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0570E520
	 * 		Name   -> Function Insurgency.PlayerInventoryComponent.UpdateOpticPreference
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		int32_t                                            Mode                                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UPlayerInventoryComponent::UpdateOpticPreference(int32_t Mode)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.PlayerInventoryComponent.UpdateOpticPreference");
		
		UPlayerInventoryComponent_UpdateOpticPreference_Params params {};
		params.Mode = Mode;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0570E3E0
	 * 		Name   -> Function Insurgency.PlayerInventoryComponent.UpdateFiremodePreference
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		EFirearmFiremode                                   Firemode                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UPlayerInventoryComponent::UpdateFiremodePreference(EFirearmFiremode Firemode)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.PlayerInventoryComponent.UpdateFiremodePreference");
		
		UPlayerInventoryComponent_UpdateFiremodePreference_Params params {};
		params.Firemode = Firemode;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0570E300
	 * 		Name   -> Function Insurgency.PlayerInventoryComponent.SetLoadout
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		TArray<struct FBasicLoadoutItem>                   Loadout                                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UPlayerInventoryComponent::SetLoadout(TArray<struct FBasicLoadoutItem> Loadout)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.PlayerInventoryComponent.SetLoadout");
		
		UPlayerInventoryComponent_SetLoadout_Params params {};
		params.Loadout = Loadout;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0570E230
	 * 		Name   -> Function Insurgency.PlayerInventoryComponent.SetItemSlotLocked
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		EItemSlot                                          ItemSlot                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               Blocked                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UPlayerInventoryComponent::SetItemSlotLocked(EItemSlot ItemSlot, bool Blocked)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.PlayerInventoryComponent.SetItemSlotLocked");
		
		UPlayerInventoryComponent_SetItemSlotLocked_Params params {};
		params.ItemSlot = ItemSlot;
		params.Blocked = Blocked;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0570E140
	 * 		Name   -> Function Insurgency.PlayerInventoryComponent.ServerUpdatePointShootPreference
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetServer, BlueprintCallable, NetValidate)
	 * Parameters:
	 * 		class UClass*                                      PointShootClass                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               Mode                                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UPlayerInventoryComponent::ServerUpdatePointShootPreference(class UClass* PointShootClass, bool Mode)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.PlayerInventoryComponent.ServerUpdatePointShootPreference");
		
		UPlayerInventoryComponent_ServerUpdatePointShootPreference_Params params {};
		params.PointShootClass = PointShootClass;
		params.Mode = Mode;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0570E050
	 * 		Name   -> Function Insurgency.PlayerInventoryComponent.ServerUpdateOpticPreference
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetServer, BlueprintCallable, NetValidate)
	 * Parameters:
	 * 		class UClass*                                      OpticClass                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            Mode                                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UPlayerInventoryComponent::ServerUpdateOpticPreference(class UClass* OpticClass, int32_t Mode)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.PlayerInventoryComponent.ServerUpdateOpticPreference");
		
		UPlayerInventoryComponent_ServerUpdateOpticPreference_Params params {};
		params.OpticClass = OpticClass;
		params.Mode = Mode;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0570DF50
	 * 		Name   -> Function Insurgency.PlayerInventoryComponent.ServerUpdateFiremodePreference
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetServer, BlueprintCallable, NetValidate)
	 * Parameters:
	 * 		class UClass*                                      FirearmClass                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EFirearmFiremode                                   Firemode                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UPlayerInventoryComponent::ServerUpdateFiremodePreference(class UClass* FirearmClass, EFirearmFiremode Firemode)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.PlayerInventoryComponent.ServerUpdateFiremodePreference");
		
		UPlayerInventoryComponent_ServerUpdateFiremodePreference_Params params {};
		params.FirearmClass = FirearmClass;
		params.Firemode = Firemode;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0570DE30
	 * 		Name   -> Function Insurgency.PlayerInventoryComponent.ServerSetLoadout
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
	 * Parameters:
	 * 		TArray<struct FBasicLoadoutItem>                   Loadout                                                    (ConstParm, Parm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UPlayerInventoryComponent::ServerSetLoadout(TArray<struct FBasicLoadoutItem> Loadout)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.PlayerInventoryComponent.ServerSetLoadout");
		
		UPlayerInventoryComponent_ServerSetLoadout_Params params {};
		params.Loadout = Loadout;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0570DD80
	 * 		Name   -> Function Insurgency.PlayerInventoryComponent.ServerResetLoadout
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
	 * Parameters:
	 * 		bool                                               bIsNight                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UPlayerInventoryComponent::ServerResetLoadout(bool bIsNight)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.PlayerInventoryComponent.ServerResetLoadout");
		
		UPlayerInventoryComponent_ServerResetLoadout_Params params {};
		params.bIsNight = bIsNight;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0570DC70
	 * 		Name   -> Function Insurgency.PlayerInventoryComponent.ServerRefundWeaponUpgrade
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetServer, BlueprintCallable, NetValidate)
	 * Parameters:
	 * 		int32_t                                            WeaponIndex                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UPlayerInventoryComponent::ServerRefundWeaponUpgrade(int32_t WeaponIndex)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.PlayerInventoryComponent.ServerRefundWeaponUpgrade");
		
		UPlayerInventoryComponent_ServerRefundWeaponUpgrade_Params params {};
		params.WeaponIndex = WeaponIndex;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0570DBC0
	 * 		Name   -> Function Insurgency.PlayerInventoryComponent.ServerRefundItem
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetServer, BlueprintCallable, NetValidate)
	 * Parameters:
	 * 		int32_t                                            Index                                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UPlayerInventoryComponent::ServerRefundItem(int32_t Index)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.PlayerInventoryComponent.ServerRefundItem");
		
		UPlayerInventoryComponent_ServerRefundItem_Params params {};
		params.Index = Index;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0570DAB0
	 * 		Name   -> Function Insurgency.PlayerInventoryComponent.ServerPurchaseWeaponUpgrade
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetServer, BlueprintCallable, NetValidate)
	 * Parameters:
	 * 		int32_t                                            PurchaseIndex                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UPlayerInventoryComponent::ServerPurchaseWeaponUpgrade(int32_t PurchaseIndex)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.PlayerInventoryComponent.ServerPurchaseWeaponUpgrade");
		
		UPlayerInventoryComponent_ServerPurchaseWeaponUpgrade_Params params {};
		params.PurchaseIndex = PurchaseIndex;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0570D9A0
	 * 		Name   -> Function Insurgency.PlayerInventoryComponent.ServerPurchaseItem
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetServer, BlueprintCallable, NetValidate)
	 * Parameters:
	 * 		int32_t                                            SubSlot                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UPlayerInventoryComponent::ServerPurchaseItem(int32_t SubSlot)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.PlayerInventoryComponent.ServerPurchaseItem");
		
		UPlayerInventoryComponent_ServerPurchaseItem_Params params {};
		params.SubSlot = SubSlot;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0570D950
	 * 		Name   -> Function Insurgency.PlayerInventoryComponent.ServerEmptyLoadout
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
	 */
	void UPlayerInventoryComponent::ServerEmptyLoadout()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.PlayerInventoryComponent.ServerEmptyLoadout");
		
		UPlayerInventoryComponent_ServerEmptyLoadout_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0570D930
	 * 		Name   -> Function Insurgency.PlayerInventoryComponent.ResetSupplyPoints
	 * 		Flags  -> (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
	 */
	void UPlayerInventoryComponent::ResetSupplyPoints()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.PlayerInventoryComponent.ResetSupplyPoints");
		
		UPlayerInventoryComponent_ResetSupplyPoints_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0570D860
	 * 		Name   -> Function Insurgency.PlayerInventoryComponent.ResetLoadoutToPlayerClass
	 * 		Flags  -> (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UPlayerClass*                                PlayerClass                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bIsNight                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UPlayerInventoryComponent::ResetLoadoutToPlayerClass(class UPlayerClass* PlayerClass, bool bIsNight)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.PlayerInventoryComponent.ResetLoadoutToPlayerClass");
		
		UPlayerInventoryComponent_ResetLoadoutToPlayerClass_Params params {};
		params.PlayerClass = PlayerClass;
		params.bIsNight = bIsNight;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0570D840
	 * 		Name   -> Function Insurgency.PlayerInventoryComponent.ResetLoadoutLocks
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void UPlayerInventoryComponent::ResetLoadoutLocks()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.PlayerInventoryComponent.ResetLoadoutLocks");
		
		UPlayerInventoryComponent_ResetLoadoutLocks_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0570D7B0
	 * 		Name   -> Function Insurgency.PlayerInventoryComponent.ResetLoadout
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bIsNight                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UPlayerInventoryComponent::ResetLoadout(bool bIsNight)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.PlayerInventoryComponent.ResetLoadout");
		
		UPlayerInventoryComponent_ResetLoadout_Params params {};
		params.bIsNight = bIsNight;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0570D6F0
	 * 		Name   -> Function Insurgency.PlayerInventoryComponent.RefundWeaponUpgrade
	 * 		Flags  -> (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		int32_t                                            WeaponIndex                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UClass*                                      UpgradeClass                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	ERefundResult UPlayerInventoryComponent::RefundWeaponUpgrade(int32_t WeaponIndex, class UClass* UpgradeClass)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.PlayerInventoryComponent.RefundWeaponUpgrade");
		
		UPlayerInventoryComponent_RefundWeaponUpgrade_Params params {};
		params.WeaponIndex = WeaponIndex;
		params.UpgradeClass = UpgradeClass;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0570D5E0
	 * 		Name   -> Function Insurgency.PlayerInventoryComponent.RefundItem
	 * 		Flags  -> (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		int32_t                                            Index                                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bCheckSlots                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bForceLocked                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	ERefundResult UPlayerInventoryComponent::RefundItem(int32_t Index, bool bCheckSlots, bool bForceLocked)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.PlayerInventoryComponent.RefundItem");
		
		UPlayerInventoryComponent_RefundItem_Params params {};
		params.Index = Index;
		params.bCheckSlots = bCheckSlots;
		params.bForceLocked = bForceLocked;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0570D520
	 * 		Name   -> Function Insurgency.PlayerInventoryComponent.PurchaseWeaponUpgrade
	 * 		Flags  -> (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		int32_t                                            PurchaseIndex                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UClass*                                      UpgradeClass                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	EPurchaseResult UPlayerInventoryComponent::PurchaseWeaponUpgrade(int32_t PurchaseIndex, class UClass* UpgradeClass)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.PlayerInventoryComponent.PurchaseWeaponUpgrade");
		
		UPlayerInventoryComponent_PurchaseWeaponUpgrade_Params params {};
		params.PurchaseIndex = PurchaseIndex;
		params.UpgradeClass = UpgradeClass;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0570D420
	 * 		Name   -> Function Insurgency.PlayerInventoryComponent.PurchaseLoadoutItem
	 * 		Flags  -> (Final, BlueprintAuthorityOnly, Native, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		struct FLoadoutWeapon                              PurchaseWeapon                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UPlayerInventoryComponent::PurchaseLoadoutItem(const struct FLoadoutWeapon& PurchaseWeapon)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.PlayerInventoryComponent.PurchaseLoadoutItem");
		
		UPlayerInventoryComponent_PurchaseLoadoutItem_Params params {};
		params.PurchaseWeapon = PurchaseWeapon;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0570D340
	 * 		Name   -> Function Insurgency.PlayerInventoryComponent.PurchaseItems
	 * 		Flags  -> (Final, BlueprintAuthorityOnly, Native, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		TArray<struct FLoadoutWeapon>                      InLoadout                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UPlayerInventoryComponent::PurchaseItems(TArray<struct FLoadoutWeapon> InLoadout)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.PlayerInventoryComponent.PurchaseItems");
		
		UPlayerInventoryComponent_PurchaseItems_Params params {};
		params.InLoadout = InLoadout;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0570D190
	 * 		Name   -> Function Insurgency.PlayerInventoryComponent.PurchaseItem
	 * 		Flags  -> (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UClass*                                      ItemClass                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            SubSlot                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bLockSlot                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bSortNow                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bCheckRedirect                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	EPurchaseResult UPlayerInventoryComponent::PurchaseItem(class UClass* ItemClass, int32_t SubSlot, bool bLockSlot, bool bSortNow, bool bCheckRedirect)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.PlayerInventoryComponent.PurchaseItem");
		
		UPlayerInventoryComponent_PurchaseItem_Params params {};
		params.ItemClass = ItemClass;
		params.SubSlot = SubSlot;
		params.bLockSlot = bLockSlot;
		params.bSortNow = bSortNow;
		params.bCheckRedirect = bCheckRedirect;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> DelegateFunction Insurgency.PlayerInventoryComponent.PlayerInventorySupplyChangedDelegate__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 * Parameters:
	 * 		int32_t                                            AvailableSupply                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UPlayerInventoryComponent::PlayerInventorySupplyChangedDelegate__DelegateSignature(int32_t AvailableSupply)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction Insurgency.PlayerInventoryComponent.PlayerInventorySupplyChangedDelegate__DelegateSignature");
		
		UPlayerInventoryComponent_PlayerInventorySupplyChangedDelegate__DelegateSignature_Params params {};
		params.AvailableSupply = AvailableSupply;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> DelegateFunction Insurgency.PlayerInventoryComponent.PlayerInventoryRefundFailDelegate__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 * Parameters:
	 * 		ERefundResult                                      Result                                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UPlayerInventoryComponent::PlayerInventoryRefundFailDelegate__DelegateSignature(ERefundResult Result)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction Insurgency.PlayerInventoryComponent.PlayerInventoryRefundFailDelegate__DelegateSignature");
		
		UPlayerInventoryComponent_PlayerInventoryRefundFailDelegate__DelegateSignature_Params params {};
		params.Result = Result;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> DelegateFunction Insurgency.PlayerInventoryComponent.PlayerInventoryPurchaseFailDelegate__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 * Parameters:
	 * 		EPurchaseResult                                    Result                                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UPlayerInventoryComponent::PlayerInventoryPurchaseFailDelegate__DelegateSignature(EPurchaseResult Result)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction Insurgency.PlayerInventoryComponent.PlayerInventoryPurchaseFailDelegate__DelegateSignature");
		
		UPlayerInventoryComponent_PlayerInventoryPurchaseFailDelegate__DelegateSignature_Params params {};
		params.Result = Result;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0570D170
	 * 		Name   -> Function Insurgency.PlayerInventoryComponent.OnRep_TotalSupply
	 * 		Flags  -> (Final, Native, Private)
	 */
	void UPlayerInventoryComponent::OnRep_TotalSupply()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.PlayerInventoryComponent.OnRep_TotalSupply");
		
		UPlayerInventoryComponent_OnRep_TotalSupply_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0570D150
	 * 		Name   -> Function Insurgency.PlayerInventoryComponent.OnRep_AvailableSupply
	 * 		Flags  -> (Final, Native, Private)
	 */
	void UPlayerInventoryComponent::OnRep_AvailableSupply()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.PlayerInventoryComponent.OnRep_AvailableSupply");
		
		UPlayerInventoryComponent_OnRep_AvailableSupply_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0570D050
	 * 		Name   -> Function Insurgency.PlayerInventoryComponent.IsWeaponUpgradeAllowedOnWeapon
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		class UClass*                                      Upgrade                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UClass*                                      Weapon                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bIsAlreadyAllowed                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UPlayerInventoryComponent::IsWeaponUpgradeAllowedOnWeapon(class UClass* Upgrade, class UClass* Weapon, bool bIsAlreadyAllowed)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.PlayerInventoryComponent.IsWeaponUpgradeAllowedOnWeapon");
		
		UPlayerInventoryComponent_IsWeaponUpgradeAllowedOnWeapon_Params params {};
		params.Upgrade = Upgrade;
		params.Weapon = Weapon;
		params.bIsAlreadyAllowed = bIsAlreadyAllowed;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0570CFC0
	 * 		Name   -> Function Insurgency.PlayerInventoryComponent.IsWeaponUpgradeAllowed
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		class UClass*                                      Upgrade                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UPlayerInventoryComponent::IsWeaponUpgradeAllowed(class UClass* Upgrade)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.PlayerInventoryComponent.IsWeaponUpgradeAllowed");
		
		UPlayerInventoryComponent_IsWeaponUpgradeAllowed_Params params {};
		params.Upgrade = Upgrade;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0570CF30
	 * 		Name   -> Function Insurgency.PlayerInventoryComponent.IsItemSlotLocked
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		EItemSlot                                          CheckSlot                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UPlayerInventoryComponent::IsItemSlotLocked(EItemSlot CheckSlot)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.PlayerInventoryComponent.IsItemSlotLocked");
		
		UPlayerInventoryComponent_IsItemSlotLocked_Params params {};
		params.CheckSlot = CheckSlot;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0570CEA0
	 * 		Name   -> Function Insurgency.PlayerInventoryComponent.IsItemAllowed
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		class UClass*                                      Item                                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UPlayerInventoryComponent::IsItemAllowed(class UClass* Item)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.PlayerInventoryComponent.IsItemAllowed");
		
		UPlayerInventoryComponent_IsItemAllowed_Params params {};
		params.Item = Item;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0570CDE0
	 * 		Name   -> Function Insurgency.PlayerInventoryComponent.HasUpgradeInSlot
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		int32_t                                            PurchaseIndex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EWeaponUpgradeSlot                                 UpgradeSlot                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UPlayerInventoryComponent::HasUpgradeInSlot(int32_t PurchaseIndex, EWeaponUpgradeSlot UpgradeSlot)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.PlayerInventoryComponent.HasUpgradeInSlot");
		
		UPlayerInventoryComponent_HasUpgradeInSlot_Params params {};
		params.PurchaseIndex = PurchaseIndex;
		params.UpgradeSlot = UpgradeSlot;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0570CD20
	 * 		Name   -> Function Insurgency.PlayerInventoryComponent.HasUpgradeBeenAttachedToWeapon
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		class UClass*                                      Weapon                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UClass*                                      Upgrade                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UPlayerInventoryComponent::HasUpgradeBeenAttachedToWeapon(class UClass* Weapon, class UClass* Upgrade)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.PlayerInventoryComponent.HasUpgradeBeenAttachedToWeapon");
		
		UPlayerInventoryComponent_HasUpgradeBeenAttachedToWeapon_Params params {};
		params.Weapon = Weapon;
		params.Upgrade = Upgrade;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0570CC90
	 * 		Name   -> Function Insurgency.PlayerInventoryComponent.HasAllowedWeaponUpgradesForWeapon
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		class UClass*                                      For                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UPlayerInventoryComponent::HasAllowedWeaponUpgradesForWeapon(class UClass* For)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.PlayerInventoryComponent.HasAllowedWeaponUpgradesForWeapon");
		
		UPlayerInventoryComponent_HasAllowedWeaponUpgradesForWeapon_Params params {};
		params.For = For;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0570CC00
	 * 		Name   -> Function Insurgency.PlayerInventoryComponent.HasAllowedItemsForSlot
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		EItemSlot                                          Slot                                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UPlayerInventoryComponent::HasAllowedItemsForSlot(EItemSlot Slot)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.PlayerInventoryComponent.HasAllowedItemsForSlot");
		
		UPlayerInventoryComponent_HasAllowedItemsForSlot_Params params {};
		params.Slot = Slot;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0570CBE0
	 * 		Name   -> Function Insurgency.PlayerInventoryComponent.GiveInventoryItems
	 * 		Flags  -> (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
	 */
	void UPlayerInventoryComponent::GiveInventoryItems()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.PlayerInventoryComponent.GiveInventoryItems");
		
		UPlayerInventoryComponent_GiveInventoryItems_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0570CB10
	 * 		Name   -> Function Insurgency.PlayerInventoryComponent.GetUpgradeMutalExclusion
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		int32_t                                            PurchaseIndex                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UClass*                                      Upgrade                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UClass* UPlayerInventoryComponent::GetUpgradeMutalExclusion(int32_t PurchaseIndex, class UClass* Upgrade)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.PlayerInventoryComponent.GetUpgradeMutalExclusion");
		
		UPlayerInventoryComponent_GetUpgradeMutalExclusion_Params params {};
		params.PurchaseIndex = PurchaseIndex;
		params.Upgrade = Upgrade;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0570CA80
	 * 		Name   -> Function Insurgency.PlayerInventoryComponent.GetSupplyCostForWeaponUpgradeClass
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		class UClass*                                      WeaponUpgradeClass                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	int32_t UPlayerInventoryComponent::GetSupplyCostForWeaponUpgradeClass(class UClass* WeaponUpgradeClass)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.PlayerInventoryComponent.GetSupplyCostForWeaponUpgradeClass");
		
		UPlayerInventoryComponent_GetSupplyCostForWeaponUpgradeClass_Params params {};
		params.WeaponUpgradeClass = WeaponUpgradeClass;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0570C9F0
	 * 		Name   -> Function Insurgency.PlayerInventoryComponent.GetSupplyCostForWeaponUpgrade
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		class UWeaponUpgradeComponent*                     WeaponUpgradeInstance                                      (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	int32_t UPlayerInventoryComponent::GetSupplyCostForWeaponUpgrade(class UWeaponUpgradeComponent* WeaponUpgradeInstance)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.PlayerInventoryComponent.GetSupplyCostForWeaponUpgrade");
		
		UPlayerInventoryComponent_GetSupplyCostForWeaponUpgrade_Params params {};
		params.WeaponUpgradeInstance = WeaponUpgradeInstance;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0570C960
	 * 		Name   -> Function Insurgency.PlayerInventoryComponent.GetSupplyCostForItemClass
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		class UClass*                                      ItemClass                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	int32_t UPlayerInventoryComponent::GetSupplyCostForItemClass(class UClass* ItemClass)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.PlayerInventoryComponent.GetSupplyCostForItemClass");
		
		UPlayerInventoryComponent_GetSupplyCostForItemClass_Params params {};
		params.ItemClass = ItemClass;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0570C8D0
	 * 		Name   -> Function Insurgency.PlayerInventoryComponent.GetSupplyCostForItem
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		class AItemBase*                                   ItemInstance                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	int32_t UPlayerInventoryComponent::GetSupplyCostForItem(class AItemBase* ItemInstance)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.PlayerInventoryComponent.GetSupplyCostForItem");
		
		UPlayerInventoryComponent_GetSupplyCostForItem_Params params {};
		params.ItemInstance = ItemInstance;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0570C7A0
	 * 		Name   -> Function Insurgency.PlayerInventoryComponent.GetSubslotUnlockItems
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		EItemSlot                                          Slot                                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            SubSlot                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		TArray<class UClass*>                              OutItems                                                   (Parm, OutParm, ZeroConstructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UPlayerInventoryComponent::GetSubslotUnlockItems(EItemSlot Slot, int32_t SubSlot, TArray<class UClass*>* OutItems)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.PlayerInventoryComponent.GetSubslotUnlockItems");
		
		UPlayerInventoryComponent_GetSubslotUnlockItems_Params params {};
		params.Slot = Slot;
		params.SubSlot = SubSlot;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutItems != nullptr)
			*OutItems = params.OutItems;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0570C770
	 * 		Name   -> Function Insurgency.PlayerInventoryComponent.GetSquadLayout
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	class USquadLayout* UPlayerInventoryComponent::GetSquadLayout()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.PlayerInventoryComponent.GetSquadLayout");
		
		UPlayerInventoryComponent_GetSquadLayout_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0570C740
	 * 		Name   -> Function Insurgency.PlayerInventoryComponent.GetSpentSupply
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	int32_t UPlayerInventoryComponent::GetSpentSupply()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.PlayerInventoryComponent.GetSpentSupply");
		
		UPlayerInventoryComponent_GetSpentSupply_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0570C6B0
	 * 		Name   -> Function Insurgency.PlayerInventoryComponent.GetShouldShowSupplyCostForWeaponUpgradeClass
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		class UClass*                                      WeaponUpgradeClass                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UPlayerInventoryComponent::GetShouldShowSupplyCostForWeaponUpgradeClass(class UClass* WeaponUpgradeClass)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.PlayerInventoryComponent.GetShouldShowSupplyCostForWeaponUpgradeClass");
		
		UPlayerInventoryComponent_GetShouldShowSupplyCostForWeaponUpgradeClass_Params params {};
		params.WeaponUpgradeClass = WeaponUpgradeClass;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0570C520
	 * 		Name   -> Function Insurgency.PlayerInventoryComponent.GetPotentialCapacityForSlots
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		TMap<EItemSlot, int32_t>                           OutSlotMap                                                 (Parm, OutParm, NativeAccessSpecifierPublic)
	 */
	void UPlayerInventoryComponent::GetPotentialCapacityForSlots(TMap<EItemSlot, int32_t>* OutSlotMap)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.PlayerInventoryComponent.GetPotentialCapacityForSlots");
		
		UPlayerInventoryComponent_GetPotentialCapacityForSlots_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutSlotMap != nullptr)
			*OutSlotMap = params.OutSlotMap;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0570C490
	 * 		Name   -> Function Insurgency.PlayerInventoryComponent.GetPotentialCapacityForSlot
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		EItemSlot                                          Slot                                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	int32_t UPlayerInventoryComponent::GetPotentialCapacityForSlot(EItemSlot Slot)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.PlayerInventoryComponent.GetPotentialCapacityForSlot");
		
		UPlayerInventoryComponent_GetPotentialCapacityForSlot_Params params {};
		params.Slot = Slot;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0570C460
	 * 		Name   -> Function Insurgency.PlayerInventoryComponent.GetOuterPlayerState
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	class AINSPlayerState* UPlayerInventoryComponent::GetOuterPlayerState()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.PlayerInventoryComponent.GetOuterPlayerState");
		
		UPlayerInventoryComponent_GetOuterPlayerState_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0570C430
	 * 		Name   -> Function Insurgency.PlayerInventoryComponent.GetOuterPlayerClass
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	class UPlayerClass* UPlayerInventoryComponent::GetOuterPlayerClass()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.PlayerInventoryComponent.GetOuterPlayerClass");
		
		UPlayerInventoryComponent_GetOuterPlayerClass_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0570C400
	 * 		Name   -> Function Insurgency.PlayerInventoryComponent.GetOuterFaction
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	class UFactionDefinition* UPlayerInventoryComponent::GetOuterFaction()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.PlayerInventoryComponent.GetOuterFaction");
		
		UPlayerInventoryComponent_GetOuterFaction_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0570C1F0
	 * 		Name   -> Function Insurgency.PlayerInventoryComponent.GetMutualInclusionsUpgradesForWeapon
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		class UClass*                                      Upgrade                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UPlayerInventoryComponent::GetMutualInclusionsUpgradesForWeapon(class UClass* Upgrade)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.PlayerInventoryComponent.GetMutualInclusionsUpgradesForWeapon");
		
		UPlayerInventoryComponent_GetMutualInclusionsUpgradesForWeapon_Params params {};
		params.Upgrade = Upgrade;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0570C0C0
	 * 		Name   -> Function Insurgency.PlayerInventoryComponent.GetLoadout
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		TArray<struct FBasicLoadoutItem>                   OutLoadout                                                 (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bIncludeLocked                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UPlayerInventoryComponent::GetLoadout(TArray<struct FBasicLoadoutItem>* OutLoadout, bool bIncludeLocked)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.PlayerInventoryComponent.GetLoadout");
		
		UPlayerInventoryComponent_GetLoadout_Params params {};
		params.bIncludeLocked = bIncludeLocked;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutLoadout != nullptr)
			*OutLoadout = params.OutLoadout;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0570C000
	 * 		Name   -> Function Insurgency.PlayerInventoryComponent.GetItemSlotValue
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		EItemSlot                                          Slot                                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            SubSlot                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	int32_t UPlayerInventoryComponent::GetItemSlotValue(EItemSlot Slot, int32_t SubSlot)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.PlayerInventoryComponent.GetItemSlotValue");
		
		UPlayerInventoryComponent_GetItemSlotValue_Params params {};
		params.Slot = Slot;
		params.SubSlot = SubSlot;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0570BF40
	 * 		Name   -> Function Insurgency.PlayerInventoryComponent.GetItemIndexForSlot
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		EItemSlot                                          Slot                                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            SubSlot                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	int32_t UPlayerInventoryComponent::GetItemIndexForSlot(EItemSlot Slot, int32_t SubSlot)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.PlayerInventoryComponent.GetItemIndexForSlot");
		
		UPlayerInventoryComponent_GetItemIndexForSlot_Params params {};
		params.Slot = Slot;
		params.SubSlot = SubSlot;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0570BEB0
	 * 		Name   -> Function Insurgency.PlayerInventoryComponent.GetItemEquippedCount
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		class UClass*                                      Item                                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	int32_t UPlayerInventoryComponent::GetItemEquippedCount(class UClass* Item)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.PlayerInventoryComponent.GetItemEquippedCount");
		
		UPlayerInventoryComponent_GetItemEquippedCount_Params params {};
		params.Item = Item;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0570BE20
	 * 		Name   -> Function Insurgency.PlayerInventoryComponent.GetItemCountForSlot
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		EItemSlot                                          Slot                                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	int32_t UPlayerInventoryComponent::GetItemCountForSlot(EItemSlot Slot)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.PlayerInventoryComponent.GetItemCountForSlot");
		
		UPlayerInventoryComponent_GetItemCountForSlot_Params params {};
		params.Slot = Slot;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0570BB60
	 * 		Name   -> Function Insurgency.PlayerInventoryComponent.GetInventoryItem
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class UClass*                                      UpgradeForDisplay                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FInventorySlot                              Weapon                                                     (Parm, NativeAccessSpecifierPublic)
	 */
	struct FStoredInventoryItem UPlayerInventoryComponent::STATIC_GetInventoryItem(class UClass* UpgradeForDisplay, const struct FInventorySlot& Weapon)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.PlayerInventoryComponent.GetInventoryItem");
		
		UPlayerInventoryComponent_GetInventoryItem_Params params {};
		params.UpgradeForDisplay = UpgradeForDisplay;
		params.Weapon = Weapon;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0570BAD0
	 * 		Name   -> Function Insurgency.PlayerInventoryComponent.GetHideIfCannotPurchase
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		class UClass*                                      Upgrade                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UPlayerInventoryComponent::GetHideIfCannotPurchase(class UClass* Upgrade)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.PlayerInventoryComponent.GetHideIfCannotPurchase");
		
		UPlayerInventoryComponent_GetHideIfCannotPurchase_Params params {};
		params.Upgrade = Upgrade;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0570BA40
	 * 		Name   -> Function Insurgency.PlayerInventoryComponent.GetFirearmsInCategoryCount
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		EFirearmCategory                                   Category                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	int32_t UPlayerInventoryComponent::GetFirearmsInCategoryCount(EFirearmCategory Category)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.PlayerInventoryComponent.GetFirearmsInCategoryCount");
		
		UPlayerInventoryComponent_GetFirearmsInCategoryCount_Params params {};
		params.Category = Category;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0570B9B0
	 * 		Name   -> Function Insurgency.PlayerInventoryComponent.GetFirearmCategoryLimit
	 * 		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		EFirearmCategory                                   Category                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	int32_t UPlayerInventoryComponent::GetFirearmCategoryLimit(EFirearmCategory Category)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.PlayerInventoryComponent.GetFirearmCategoryLimit");
		
		UPlayerInventoryComponent_GetFirearmCategoryLimit_Params params {};
		params.Category = Category;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0570B810
	 * 		Name   -> Function Insurgency.PlayerInventoryComponent.GetFilteredWeaponUpgradesForWeaponInSlot
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		TArray<class UClass*>                              InUpgrades                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UClass*                                      For                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EWeaponUpgradeSlot                                 UpgradeSlot                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		TArray<class UClass*>                              OutResults                                                 (Parm, OutParm, ZeroConstructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UPlayerInventoryComponent::GetFilteredWeaponUpgradesForWeaponInSlot(TArray<class UClass*> InUpgrades, class UClass* For, EWeaponUpgradeSlot UpgradeSlot, TArray<class UClass*>* OutResults)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.PlayerInventoryComponent.GetFilteredWeaponUpgradesForWeaponInSlot");
		
		UPlayerInventoryComponent_GetFilteredWeaponUpgradesForWeaponInSlot_Params params {};
		params.InUpgrades = InUpgrades;
		params.For = For;
		params.UpgradeSlot = UpgradeSlot;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutResults != nullptr)
			*OutResults = params.OutResults;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0570B6B0
	 * 		Name   -> Function Insurgency.PlayerInventoryComponent.GetFilteredWeaponUpgradesForWeapon
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		TArray<class UClass*>                              InUpgrades                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UClass*                                      For                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		TArray<class UClass*>                              OutResults                                                 (Parm, OutParm, ZeroConstructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UPlayerInventoryComponent::GetFilteredWeaponUpgradesForWeapon(TArray<class UClass*> InUpgrades, class UClass* For, TArray<class UClass*>* OutResults)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.PlayerInventoryComponent.GetFilteredWeaponUpgradesForWeapon");
		
		UPlayerInventoryComponent_GetFilteredWeaponUpgradesForWeapon_Params params {};
		params.InUpgrades = InUpgrades;
		params.For = For;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutResults != nullptr)
			*OutResults = params.OutResults;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0570B550
	 * 		Name   -> Function Insurgency.PlayerInventoryComponent.GetFilteredWeaponUpgradesForSlot
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		TArray<class UClass*>                              InUpgrades                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EWeaponUpgradeSlot                                 UpgradeSlot                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		TArray<class UClass*>                              OutResults                                                 (Parm, OutParm, ZeroConstructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UPlayerInventoryComponent::GetFilteredWeaponUpgradesForSlot(TArray<class UClass*> InUpgrades, EWeaponUpgradeSlot UpgradeSlot, TArray<class UClass*>* OutResults)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.PlayerInventoryComponent.GetFilteredWeaponUpgradesForSlot");
		
		UPlayerInventoryComponent_GetFilteredWeaponUpgradesForSlot_Params params {};
		params.InUpgrades = InUpgrades;
		params.UpgradeSlot = UpgradeSlot;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutResults != nullptr)
			*OutResults = params.OutResults;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0570B3A0
	 * 		Name   -> Function Insurgency.PlayerInventoryComponent.GetFilteredItemsForSlot
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		TArray<class UClass*>                              InItems                                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EItemSlot                                          Slot                                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		TArray<class UClass*>                              OutResults                                                 (Parm, OutParm, ZeroConstructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            SubSlot                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UPlayerInventoryComponent::GetFilteredItemsForSlot(TArray<class UClass*> InItems, EItemSlot Slot, TArray<class UClass*>* OutResults, int32_t SubSlot)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.PlayerInventoryComponent.GetFilteredItemsForSlot");
		
		UPlayerInventoryComponent_GetFilteredItemsForSlot_Params params {};
		params.InItems = InItems;
		params.Slot = Slot;
		params.SubSlot = SubSlot;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutResults != nullptr)
			*OutResults = params.OutResults;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0570B310
	 * 		Name   -> Function Insurgency.PlayerInventoryComponent.GetCapacityForSlot
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		EItemSlot                                          Slot                                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	int32_t UPlayerInventoryComponent::GetCapacityForSlot(EItemSlot Slot)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.PlayerInventoryComponent.GetCapacityForSlot");
		
		UPlayerInventoryComponent_GetCapacityForSlot_Params params {};
		params.Slot = Slot;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0570B280
	 * 		Name   -> Function Insurgency.PlayerInventoryComponent.GetAvailableItemSlot
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		EItemSlot                                          Slot                                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	int32_t UPlayerInventoryComponent::GetAvailableItemSlot(EItemSlot Slot)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.PlayerInventoryComponent.GetAvailableItemSlot");
		
		UPlayerInventoryComponent_GetAvailableItemSlot_Params params {};
		params.Slot = Slot;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0570B150
	 * 		Name   -> Function Insurgency.PlayerInventoryComponent.GetAllowedWeaponUpgradesForWeaponInSlot
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		class UClass*                                      For                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EWeaponUpgradeSlot                                 UpgradeSlot                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		TArray<class UClass*>                              OutResults                                                 (Parm, OutParm, ZeroConstructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UPlayerInventoryComponent::GetAllowedWeaponUpgradesForWeaponInSlot(class UClass* For, EWeaponUpgradeSlot UpgradeSlot, TArray<class UClass*>* OutResults)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.PlayerInventoryComponent.GetAllowedWeaponUpgradesForWeaponInSlot");
		
		UPlayerInventoryComponent_GetAllowedWeaponUpgradesForWeaponInSlot_Params params {};
		params.For = For;
		params.UpgradeSlot = UpgradeSlot;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutResults != nullptr)
			*OutResults = params.OutResults;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0570B060
	 * 		Name   -> Function Insurgency.PlayerInventoryComponent.GetAllowedWeaponUpgradesForWeapon
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		class UClass*                                      For                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		TArray<class UClass*>                              OutResults                                                 (Parm, OutParm, ZeroConstructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UPlayerInventoryComponent::GetAllowedWeaponUpgradesForWeapon(class UClass* For, TArray<class UClass*>* OutResults)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.PlayerInventoryComponent.GetAllowedWeaponUpgradesForWeapon");
		
		UPlayerInventoryComponent_GetAllowedWeaponUpgradesForWeapon_Params params {};
		params.For = For;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutResults != nullptr)
			*OutResults = params.OutResults;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0570AFB0
	 * 		Name   -> Function Insurgency.PlayerInventoryComponent.GetAllowedWeaponUpgradesForPlayerWithoutSort
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		TArray<class UClass*>                              OutResults                                                 (Parm, OutParm, ZeroConstructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UPlayerInventoryComponent::GetAllowedWeaponUpgradesForPlayerWithoutSort(TArray<class UClass*>* OutResults)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.PlayerInventoryComponent.GetAllowedWeaponUpgradesForPlayerWithoutSort");
		
		UPlayerInventoryComponent_GetAllowedWeaponUpgradesForPlayerWithoutSort_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutResults != nullptr)
			*OutResults = params.OutResults;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0570AF00
	 * 		Name   -> Function Insurgency.PlayerInventoryComponent.GetAllowedWeaponUpgradesForPlayer
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		TArray<class UClass*>                              OutResults                                                 (Parm, OutParm, ZeroConstructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UPlayerInventoryComponent::GetAllowedWeaponUpgradesForPlayer(TArray<class UClass*>* OutResults)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.PlayerInventoryComponent.GetAllowedWeaponUpgradesForPlayer");
		
		UPlayerInventoryComponent_GetAllowedWeaponUpgradesForPlayer_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutResults != nullptr)
			*OutResults = params.OutResults;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0570AE50
	 * 		Name   -> Function Insurgency.PlayerInventoryComponent.GetAllowedItemsWithoutSort
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		TArray<class UClass*>                              OutResults                                                 (Parm, OutParm, ZeroConstructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UPlayerInventoryComponent::GetAllowedItemsWithoutSort(TArray<class UClass*>* OutResults)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.PlayerInventoryComponent.GetAllowedItemsWithoutSort");
		
		UPlayerInventoryComponent_GetAllowedItemsWithoutSort_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutResults != nullptr)
			*OutResults = params.OutResults;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0570AD30
	 * 		Name   -> Function Insurgency.PlayerInventoryComponent.GetAllowedItemsForSlot
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		EItemSlot                                          Slot                                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		TArray<class UClass*>                              OutResults                                                 (Parm, OutParm, ZeroConstructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            SubSlot                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UPlayerInventoryComponent::GetAllowedItemsForSlot(EItemSlot Slot, TArray<class UClass*>* OutResults, int32_t SubSlot)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.PlayerInventoryComponent.GetAllowedItemsForSlot");
		
		UPlayerInventoryComponent_GetAllowedItemsForSlot_Params params {};
		params.Slot = Slot;
		params.SubSlot = SubSlot;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutResults != nullptr)
			*OutResults = params.OutResults;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0570AC80
	 * 		Name   -> Function Insurgency.PlayerInventoryComponent.GetAllowedItems
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		TArray<class UClass*>                              OutResults                                                 (Parm, OutParm, ZeroConstructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UPlayerInventoryComponent::GetAllowedItems(TArray<class UClass*>* OutResults)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.PlayerInventoryComponent.GetAllowedItems");
		
		UPlayerInventoryComponent_GetAllowedItems_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutResults != nullptr)
			*OutResults = params.OutResults;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0570AC60
	 * 		Name   -> Function Insurgency.PlayerInventoryComponent.GearCheckWeaponSlots
	 * 		Flags  -> (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
	 */
	void UPlayerInventoryComponent::GearCheckWeaponSlots()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.PlayerInventoryComponent.GearCheckWeaponSlots");
		
		UPlayerInventoryComponent_GearCheckWeaponSlots_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0570ABE0
	 * 		Name   -> Function Insurgency.PlayerInventoryComponent.ForwardInventoryPreferences
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UINSPlayerLocalProfile*                      Profile                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UPlayerInventoryComponent::ForwardInventoryPreferences(class UINSPlayerLocalProfile* Profile)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.PlayerInventoryComponent.ForwardInventoryPreferences");
		
		UPlayerInventoryComponent_ForwardInventoryPreferences_Params params {};
		params.Profile = Profile;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0570AB50
	 * 		Name   -> Function Insurgency.PlayerInventoryComponent.EmptyLoadout
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bForceLocked                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UPlayerInventoryComponent::EmptyLoadout(bool bForceLocked)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.PlayerInventoryComponent.EmptyLoadout");
		
		UPlayerInventoryComponent_EmptyLoadout_Params params {};
		params.bForceLocked = bForceLocked;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0570AAD0
	 * 		Name   -> Function Insurgency.PlayerInventoryComponent.ClientRefundFail
	 * 		Flags  -> (Net, Native, Event, Public, NetClient)
	 * Parameters:
	 * 		ERefundResult                                      Result                                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UPlayerInventoryComponent::ClientRefundFail(ERefundResult Result)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.PlayerInventoryComponent.ClientRefundFail");
		
		UPlayerInventoryComponent_ClientRefundFail_Params params {};
		params.Result = Result;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0570AA50
	 * 		Name   -> Function Insurgency.PlayerInventoryComponent.ClientPurchaseFail
	 * 		Flags  -> (Net, Native, Event, Public, NetClient)
	 * Parameters:
	 * 		EPurchaseResult                                    Result                                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UPlayerInventoryComponent::ClientPurchaseFail(EPurchaseResult Result)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.PlayerInventoryComponent.ClientPurchaseFail");
		
		UPlayerInventoryComponent_ClientPurchaseFail_Params params {};
		params.Result = Result;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0570A950
	 * 		Name   -> Function Insurgency.PlayerInventoryComponent.CanPurchaseWeaponUpgrade
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		int32_t                                            PurchaseIndex                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UClass*                                      Upgrade                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bIsAlreadyAllowed                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	EPurchaseResult UPlayerInventoryComponent::CanPurchaseWeaponUpgrade(int32_t PurchaseIndex, class UClass* Upgrade, bool bIsAlreadyAllowed)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.PlayerInventoryComponent.CanPurchaseWeaponUpgrade");
		
		UPlayerInventoryComponent_CanPurchaseWeaponUpgrade_Params params {};
		params.PurchaseIndex = PurchaseIndex;
		params.Upgrade = Upgrade;
		params.bIsAlreadyAllowed = bIsAlreadyAllowed;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0570A850
	 * 		Name   -> Function Insurgency.PlayerInventoryComponent.CanPurchaseItem
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		class UClass*                                      Item                                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            SubSlot                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bIsAlreadyAllowed                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	EPurchaseResult UPlayerInventoryComponent::CanPurchaseItem(class UClass* Item, int32_t SubSlot, bool bIsAlreadyAllowed)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.PlayerInventoryComponent.CanPurchaseItem");
		
		UPlayerInventoryComponent_CanPurchaseItem_Params params {};
		params.Item = Item;
		params.SubSlot = SubSlot;
		params.bIsAlreadyAllowed = bIsAlreadyAllowed;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0570A7D0
	 * 		Name   -> Function Insurgency.PlayerInventoryComponent.AwardSupplyPoints
	 * 		Flags  -> (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		int32_t                                            Amount                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UPlayerInventoryComponent::AwardSupplyPoints(int32_t Amount)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.PlayerInventoryComponent.AwardSupplyPoints");
		
		UPlayerInventoryComponent_AwardSupplyPoints_Params params {};
		params.Amount = Amount;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UPlayerInventoryComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UPlayerInventoryComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.PlayerInventoryComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0570ED50
	 * 		Name   -> Function Insurgency.PlayerReportsAsync.BeginReportSubmit
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		class UINSGameInstance*                            INSGameInstance                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EReportCategoryEnum                                Category                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FUniqueNetIdRepl                            ReporterId                                                 (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FUniqueNetIdRepl                            TargetId                                                   (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FString                                      Comments                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UPlayerReportsAsync* UPlayerReportsAsync::STATIC_BeginReportSubmit(class UINSGameInstance* INSGameInstance, EReportCategoryEnum Category, const struct FUniqueNetIdRepl& ReporterId, const struct FUniqueNetIdRepl& TargetId, const class FString& Comments)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.PlayerReportsAsync.BeginReportSubmit");
		
		UPlayerReportsAsync_BeginReportSubmit_Params params {};
		params.INSGameInstance = INSGameInstance;
		params.Category = Category;
		params.ReporterId = ReporterId;
		params.TargetId = TargetId;
		params.Comments = Comments;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UPlayerReportsAsync.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UPlayerReportsAsync::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.PlayerReportsAsync");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> Function Insurgency.PlayerVoteWidget.RestoreWidgetFocus
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 */
	void UPlayerVoteWidget::RestoreWidgetFocus()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.PlayerVoteWidget.RestoreWidgetFocus");
		
		UPlayerVoteWidget_RestoreWidgetFocus_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UPlayerVoteWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UPlayerVoteWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.PlayerVoteWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> DelegateFunction Insurgency.PlayerVotingComponent.VoteDataChangedDelegate__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 */
	void UPlayerVotingComponent::VoteDataChangedDelegate__DelegateSignature()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction Insurgency.PlayerVotingComponent.VoteDataChangedDelegate__DelegateSignature");
		
		UPlayerVotingComponent_VoteDataChangedDelegate__DelegateSignature_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05710140
	 * 		Name   -> Function Insurgency.PlayerVotingComponent.ResetVoteWithDelay
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		float                                              Time                                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UPlayerVotingComponent::ResetVoteWithDelay(float Time)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.PlayerVotingComponent.ResetVoteWithDelay");
		
		UPlayerVotingComponent_ResetVoteWithDelay_Params params {};
		params.Time = Time;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05710120
	 * 		Name   -> Function Insurgency.PlayerVotingComponent.ResetVote
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void UPlayerVotingComponent::ResetVote()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.PlayerVotingComponent.ResetVote");
		
		UPlayerVotingComponent_ResetVote_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05710100
	 * 		Name   -> Function Insurgency.PlayerVotingComponent.OnVoteTimeout
	 * 		Flags  -> (Final, Native, Public)
	 */
	void UPlayerVotingComponent::OnVoteTimeout()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.PlayerVotingComponent.OnVoteTimeout");
		
		UPlayerVotingComponent_OnVoteTimeout_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x057100E0
	 * 		Name   -> Function Insurgency.PlayerVotingComponent.OnVoteConcluded
	 * 		Flags  -> (Final, Native, Public)
	 */
	void UPlayerVotingComponent::OnVoteConcluded()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.PlayerVotingComponent.OnVoteConcluded");
		
		UPlayerVotingComponent_OnVoteConcluded_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x057100C0
	 * 		Name   -> Function Insurgency.PlayerVotingComponent.OnRep_ReplicatedVoteInfo
	 * 		Flags  -> (Final, Native, Protected)
	 */
	void UPlayerVotingComponent::OnRep_ReplicatedVoteInfo()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.PlayerVotingComponent.OnRep_ReplicatedVoteInfo");
		
		UPlayerVotingComponent_OnRep_ReplicatedVoteInfo_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05710090
	 * 		Name   -> Function Insurgency.PlayerVotingComponent.IsVoteInProgress
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool UPlayerVotingComponent::IsVoteInProgress()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.PlayerVotingComponent.IsVoteInProgress");
		
		UPlayerVotingComponent_IsVoteInProgress_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0570FFF0
	 * 		Name   -> Function Insurgency.PlayerVotingComponent.IsEligibleVoter
	 * 		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		class APlayerState*                                PlayerState                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UPlayerVotingComponent::IsEligibleVoter(class APlayerState* PlayerState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.PlayerVotingComponent.IsEligibleVoter");
		
		UPlayerVotingComponent_IsEligibleVoter_Params params {};
		params.PlayerState = PlayerState;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0570FFC0
	 * 		Name   -> Function Insurgency.PlayerVotingComponent.HasVotePassed
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool UPlayerVotingComponent::HasVotePassed()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.PlayerVotingComponent.HasVotePassed");
		
		UPlayerVotingComponent_HasVotePassed_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0570FF90
	 * 		Name   -> Function Insurgency.PlayerVotingComponent.HasVoteFailed
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool UPlayerVotingComponent::HasVoteFailed()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.PlayerVotingComponent.HasVoteFailed");
		
		UPlayerVotingComponent_HasVoteFailed_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0570FF60
	 * 		Name   -> Function Insurgency.PlayerVotingComponent.HasVoteConcluded
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool UPlayerVotingComponent::HasVoteConcluded()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.PlayerVotingComponent.HasVoteConcluded");
		
		UPlayerVotingComponent_HasVoteConcluded_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0570FED0
	 * 		Name   -> Function Insurgency.PlayerVotingComponent.HasRecentlyVoted
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		class APlayerState*                                PlayerState                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UPlayerVotingComponent::HasRecentlyVoted(class APlayerState* PlayerState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.PlayerVotingComponent.HasRecentlyVoted");
		
		UPlayerVotingComponent_HasRecentlyVoted_Params params {};
		params.PlayerState = PlayerState;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0570FE40
	 * 		Name   -> Function Insurgency.PlayerVotingComponent.GetVoteIssueForClass
	 * 		Flags  -> (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class UClass*                                      Issue                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UVoteIssue* UPlayerVotingComponent::GetVoteIssueForClass(class UClass* Issue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.PlayerVotingComponent.GetVoteIssueForClass");
		
		UPlayerVotingComponent_GetVoteIssueForClass_Params params {};
		params.Issue = Issue;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0570FDA0
	 * 		Name   -> Function Insurgency.PlayerVotingComponent.GetLastVoteTime
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		class APlayerState*                                PlayerState                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	float UPlayerVotingComponent::GetLastVoteTime(class APlayerState* PlayerState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.PlayerVotingComponent.GetLastVoteTime");
		
		UPlayerVotingComponent_GetLastVoteTime_Params params {};
		params.PlayerState = PlayerState;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0570FCF0
	 * 		Name   -> Function Insurgency.PlayerVotingComponent.GetEligibleVoters
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		TArray<class APlayerState*>                        OutPlayers                                                 (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UPlayerVotingComponent::GetEligibleVoters(TArray<class APlayerState*>* OutPlayers)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.PlayerVotingComponent.GetEligibleVoters");
		
		UPlayerVotingComponent_GetEligibleVoters_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutPlayers != nullptr)
			*OutPlayers = params.OutPlayers;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0570FCC0
	 * 		Name   -> Function Insurgency.PlayerVotingComponent.CountEligibleVoters
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	int32_t UPlayerVotingComponent::CountEligibleVoters()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.PlayerVotingComponent.CountEligibleVoters");
		
		UPlayerVotingComponent_CountEligibleVoters_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0570FC90
	 * 		Name   -> Function Insurgency.PlayerVotingComponent.CanVoteStart
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool UPlayerVotingComponent::CanVoteStart()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.PlayerVotingComponent.CanVoteStart");
		
		UPlayerVotingComponent_CanVoteStart_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0570FC00
	 * 		Name   -> Function Insurgency.PlayerVotingComponent.CanStartVote
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		class APlayerState*                                PlayerState                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UPlayerVotingComponent::CanStartVote(class APlayerState* PlayerState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.PlayerVotingComponent.CanStartVote");
		
		UPlayerVotingComponent_CanStartVote_Params params {};
		params.PlayerState = PlayerState;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UPlayerVotingComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UPlayerVotingComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.PlayerVotingComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05710A60
	 * 		Name   -> Function Insurgency.PlayerVotingStatics.GetVoteSuccessTextForVoteInfo
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FReplicatedVoteInfo                         VoteInfo                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		class FText                                        OutSuccessText                                             (Parm, OutParm, NativeAccessSpecifierPublic)
	 */
	void UPlayerVotingStatics::STATIC_GetVoteSuccessTextForVoteInfo(const struct FReplicatedVoteInfo& VoteInfo, class FText* OutSuccessText)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.PlayerVotingStatics.GetVoteSuccessTextForVoteInfo");
		
		UPlayerVotingStatics_GetVoteSuccessTextForVoteInfo_Params params {};
		params.VoteInfo = VoteInfo;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutSuccessText != nullptr)
			*OutSuccessText = params.OutSuccessText;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x057108D0
	 * 		Name   -> Function Insurgency.PlayerVotingStatics.GetVotePromptTextForVoteInfo
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FReplicatedVoteInfo                         VoteInfo                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		class FText                                        OutVotePrompt                                              (Parm, OutParm, NativeAccessSpecifierPublic)
	 */
	void UPlayerVotingStatics::STATIC_GetVotePromptTextForVoteInfo(const struct FReplicatedVoteInfo& VoteInfo, class FText* OutVotePrompt)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.PlayerVotingStatics.GetVotePromptTextForVoteInfo");
		
		UPlayerVotingStatics_GetVotePromptTextForVoteInfo_Params params {};
		params.VoteInfo = VoteInfo;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutVotePrompt != nullptr)
			*OutVotePrompt = params.OutVotePrompt;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05710850
	 * 		Name   -> Function Insurgency.PlayerVotingStatics.GetVoteIssueDefaults
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class UClass*                                      VoteIssueClass                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UVoteIssue* UPlayerVotingStatics::STATIC_GetVoteIssueDefaults(class UClass* VoteIssueClass)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.PlayerVotingStatics.GetVoteIssueDefaults");
		
		UPlayerVotingStatics_GetVoteIssueDefaults_Params params {};
		params.VoteIssueClass = VoteIssueClass;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05710620
	 * 		Name   -> Function Insurgency.PlayerVotingStatics.FormatVotingParameters
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class FText                                        FormattingText                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		struct FReplicatedVoteInfo                         VoteInfo                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		class FText                                        OutVotePrompt                                              (Parm, OutParm, NativeAccessSpecifierPublic)
	 */
	void UPlayerVotingStatics::STATIC_FormatVotingParameters(const class FText& FormattingText, const struct FReplicatedVoteInfo& VoteInfo, class FText* OutVotePrompt)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.PlayerVotingStatics.FormatVotingParameters");
		
		UPlayerVotingStatics_FormatVotingParameters_Params params {};
		params.FormattingText = FormattingText;
		params.VoteInfo = VoteInfo;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutVotePrompt != nullptr)
			*OutVotePrompt = params.OutVotePrompt;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x057105A0
	 * 		Name   -> Function Insurgency.PlayerVotingStatics.DoesIssueNeedPlayerList
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class UClass*                                      VoteIssueClass                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UPlayerVotingStatics::STATIC_DoesIssueNeedPlayerList(class UClass* VoteIssueClass)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.PlayerVotingStatics.DoesIssueNeedPlayerList");
		
		UPlayerVotingStatics_DoesIssueNeedPlayerList_Params params {};
		params.VoteIssueClass = VoteIssueClass;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UPlayerVotingStatics.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UPlayerVotingStatics::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.PlayerVotingStatics");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UPlaylistFeature.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UPlaylistFeature::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.PlaylistFeature");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UPlaylist.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UPlaylist::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.Playlist");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> Function Insurgency.PlaylistBrowserWidget.OnUpdateNetworkStatus
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		bool                                               bIsConnectedToWorldServices                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UPlaylistBrowserWidget::OnUpdateNetworkStatus(bool bIsConnectedToWorldServices)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.PlaylistBrowserWidget.OnUpdateNetworkStatus");
		
		UPlaylistBrowserWidget_OnUpdateNetworkStatus_Params params {};
		params.bIsConnectedToWorldServices = bIsConnectedToWorldServices;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05711860
	 * 		Name   -> Function Insurgency.PlaylistBrowserWidget.GetPlaylistsOfType
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		EPlaylistType                                      Type                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	TArray<class UPlaylist*> UPlaylistBrowserWidget::GetPlaylistsOfType(EPlaylistType Type)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.PlaylistBrowserWidget.GetPlaylistsOfType");
		
		UPlaylistBrowserWidget_GetPlaylistsOfType_Params params {};
		params.Type = Type;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UPlaylistBrowserWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UPlaylistBrowserWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.PlaylistBrowserWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05711D60
	 * 		Name   -> Function Insurgency.PointOfInterestActorComponent.ShouldShowOnTacticalMap
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		class AINSSoldier*                                 ForPlayer                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UPointOfInterestActorComponent::ShouldShowOnTacticalMap(class AINSSoldier* ForPlayer)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.PointOfInterestActorComponent.ShouldShowOnTacticalMap");
		
		UPointOfInterestActorComponent_ShouldShowOnTacticalMap_Params params {};
		params.ForPlayer = ForPlayer;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05711CD0
	 * 		Name   -> Function Insurgency.PointOfInterestActorComponent.ShouldShowInProximity
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		class AINSSoldier*                                 ForPlayer                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UPointOfInterestActorComponent::ShouldShowInProximity(class AINSSoldier* ForPlayer)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.PointOfInterestActorComponent.ShouldShowInProximity");
		
		UPointOfInterestActorComponent_ShouldShowInProximity_Params params {};
		params.ForPlayer = ForPlayer;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05711C30
	 * 		Name   -> Function Insurgency.PointOfInterestActorComponent.SetShouldShowOnTacticalMapEvent
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class FScriptDelegate                              Event                                                      (Parm, ZeroConstructor, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UPointOfInterestActorComponent::SetShouldShowOnTacticalMapEvent(const class FScriptDelegate& Event)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.PointOfInterestActorComponent.SetShouldShowOnTacticalMapEvent");
		
		UPointOfInterestActorComponent_SetShouldShowOnTacticalMapEvent_Params params {};
		params.Event = Event;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05711B90
	 * 		Name   -> Function Insurgency.PointOfInterestActorComponent.SetShouldShowInProximityEvent
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class FScriptDelegate                              Event                                                      (Parm, ZeroConstructor, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UPointOfInterestActorComponent::SetShouldShowInProximityEvent(const class FScriptDelegate& Event)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.PointOfInterestActorComponent.SetShouldShowInProximityEvent");
		
		UPointOfInterestActorComponent_SetShouldShowInProximityEvent_Params params {};
		params.Event = Event;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UPointOfInterestActorComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UPointOfInterestActorComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.PointOfInterestActorComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05711FC0
	 * 		Name   -> Function Insurgency.PointShootingUpgradeInterface.ShouldEnterPointShootMode
	 * 		Flags  -> (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
	 */
	bool UPointShootingUpgradeInterface::ShouldEnterPointShootMode()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.PointShootingUpgradeInterface.ShouldEnterPointShootMode");
		
		UPointShootingUpgradeInterface_ShouldEnterPointShootMode_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UPointShootingUpgradeInterface.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UPointShootingUpgradeInterface::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.PointShootingUpgradeInterface");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UPostMergeManager.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UPostMergeManager::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.PostMergeManager");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05712510
	 * 		Name   -> Function Insurgency.ProfaneWordCollection.DoesContainProfaneWord
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		class FString                                      inString                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FString                                      OutString                                                  (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UProfaneWordCollection::DoesContainProfaneWord(const class FString& inString, class FString* OutString)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ProfaneWordCollection.DoesContainProfaneWord");
		
		UProfaneWordCollection_DoesContainProfaneWord_Params params {};
		params.inString = inString;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutString != nullptr)
			*OutString = params.OutString;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UProfaneWordCollection.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UProfaneWordCollection::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.ProfaneWordCollection");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05714BA0
	 * 		Name   -> Function Insurgency.ProjectileBase.SetupThrow
	 * 		Flags  -> (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FTransform                                  Transform                                                  (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		float                                              ThrowSpeed                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AProjectileBase::SetupThrow(const struct FTransform& Transform, float ThrowSpeed)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ProjectileBase.SetupThrow");
		
		AProjectileBase_SetupThrow_Params params {};
		params.Transform = Transform;
		params.ThrowSpeed = ThrowSpeed;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05714AD0
	 * 		Name   -> Function Insurgency.ProjectileBase.SetEstimatedFlightTimeAndLocation
	 * 		Flags  -> (Native, Public, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		float                                              FlightTime                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     Location                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AProjectileBase::SetEstimatedFlightTimeAndLocation(float FlightTime, const struct FVector& Location)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ProjectileBase.SetEstimatedFlightTimeAndLocation");
		
		AProjectileBase_SetEstimatedFlightTimeAndLocation_Params params {};
		params.FlightTime = FlightTime;
		params.Location = Location;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05714AB0
	 * 		Name   -> Function Insurgency.ProjectileBase.PlayIncomingAudio
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void AProjectileBase::PlayIncomingAudio()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ProjectileBase.PlayIncomingAudio");
		
		AProjectileBase_PlayIncomingAudio_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05714910
	 * 		Name   -> Function Insurgency.ProjectileBase.OnSoundscapeUpdate
	 * 		Flags  -> (Final, Native, Public, HasOutParms)
	 * Parameters:
	 * 		struct FSoundscapeStateRepl                        State                                                      (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void AProjectileBase::OnSoundscapeUpdate(const struct FSoundscapeStateRepl& State)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ProjectileBase.OnSoundscapeUpdate");
		
		AProjectileBase_OnSoundscapeUpdate_Params params {};
		params.State = State;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x057148F0
	 * 		Name   -> Function Insurgency.ProjectileBase.OnRep_InitialVelocity
	 * 		Flags  -> (Final, Native, Private)
	 */
	void AProjectileBase::OnRep_InitialVelocity()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ProjectileBase.OnRep_InitialVelocity");
		
		AProjectileBase_OnRep_InitialVelocity_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05714810
	 * 		Name   -> Function Insurgency.ProjectileBase.OnProjectileStopped
	 * 		Flags  -> (Native, Public, HasOutParms)
	 * Parameters:
	 * 		struct FHitResult                                  HitResult                                                  (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	void AProjectileBase::OnProjectileStopped(const struct FHitResult& HitResult)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ProjectileBase.OnProjectileStopped");
		
		AProjectileBase_OnProjectileStopped_Params params {};
		params.HitResult = HitResult;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05714700
	 * 		Name   -> Function Insurgency.ProjectileBase.Multicast_SetupThrow
	 * 		Flags  -> (Net, NetReliable, Native, Event, NetMulticast, Public, HasDefaults)
	 * Parameters:
	 * 		struct FTransform                                  Transform                                                  (ConstParm, Parm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		float                                              ThrowSpeed                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AProjectileBase::Multicast_SetupThrow(const struct FTransform& Transform, float ThrowSpeed)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ProjectileBase.Multicast_SetupThrow");
		
		AProjectileBase_Multicast_SetupThrow_Params params {};
		params.Transform = Transform;
		params.ThrowSpeed = ThrowSpeed;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x04DB3EA0
	 * 		Name   -> Function Insurgency.ProjectileBase.DetachFromUser
	 * 		Flags  -> (Native, Public, BlueprintCallable)
	 */
	void AProjectileBase::DetachFromUser()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ProjectileBase.DetachFromUser");
		
		AProjectileBase_DetachFromUser_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x057146E0
	 * 		Name   -> Function Insurgency.ProjectileBase.BroadcastIncomingAudio
	 * 		Flags  -> (Net, Native, Event, NetMulticast, Public)
	 */
	void AProjectileBase::BroadcastIncomingAudio()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ProjectileBase.BroadcastIncomingAudio");
		
		AProjectileBase_BroadcastIncomingAudio_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x04DCE2D0
	 * 		Name   -> Function Insurgency.ProjectileBase.AttachToUser
	 * 		Flags  -> (Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class AINSSoldier*                                 User                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AProjectileBase::AttachToUser(class AINSSoldier* User)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ProjectileBase.AttachToUser");
		
		AProjectileBase_AttachToUser_Params params {};
		params.User = User;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AProjectileBase.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AProjectileBase::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.ProjectileBase");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x057169F0
	 * 		Name   -> Function Insurgency.ProjectileGrenade.StopActiveGrenadeSurfaceReactions
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void AProjectileGrenade::StopActiveGrenadeSurfaceReactions()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ProjectileGrenade.StopActiveGrenadeSurfaceReactions");
		
		AProjectileGrenade_StopActiveGrenadeSurfaceReactions_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05716930
	 * 		Name   -> Function Insurgency.ProjectileGrenade.SetPlantAttachmentActor
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class AActor*                                      InActor                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UPrimitiveComponent*                         InAttachedComponent                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AProjectileGrenade::SetPlantAttachmentActor(class AActor* InActor, class UPrimitiveComponent* InAttachedComponent)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ProjectileGrenade.SetPlantAttachmentActor");
		
		AProjectileGrenade_SetPlantAttachmentActor_Params params {};
		params.InActor = InActor;
		params.InAttachedComponent = InAttachedComponent;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x057168B0
	 * 		Name   -> Function Insurgency.ProjectileGrenade.SetCookTimer
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		float                                              Timer                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AProjectileGrenade::SetCookTimer(float Timer)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ProjectileGrenade.SetCookTimer");
		
		AProjectileGrenade_SetCookTimer_Params params {};
		params.Timer = Timer;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05716790
	 * 		Name   -> Function Insurgency.ProjectileGrenade.PlayGrenadeSurfaceReactionWithHit
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		class USurfaceReaction*                            InSurfaceReaction                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FHitResult                                  HitResult                                                  (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	void AProjectileGrenade::PlayGrenadeSurfaceReactionWithHit(class USurfaceReaction* InSurfaceReaction, const struct FHitResult& HitResult)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ProjectileGrenade.PlayGrenadeSurfaceReactionWithHit");
		
		AProjectileGrenade_PlayGrenadeSurfaceReactionWithHit_Params params {};
		params.InSurfaceReaction = InSurfaceReaction;
		params.HitResult = HitResult;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x057166C0
	 * 		Name   -> Function Insurgency.ProjectileGrenade.PlayGrenadeSurfaceReactionAtLocation
	 * 		Flags  -> (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		class USurfaceReaction*                            InSurfaceReaction                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     HitLocation                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AProjectileGrenade::PlayGrenadeSurfaceReactionAtLocation(class USurfaceReaction* InSurfaceReaction, const struct FVector& HitLocation)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ProjectileGrenade.PlayGrenadeSurfaceReactionAtLocation");
		
		AProjectileGrenade_PlayGrenadeSurfaceReactionAtLocation_Params params {};
		params.InSurfaceReaction = InSurfaceReaction;
		params.HitLocation = HitLocation;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05716640
	 * 		Name   -> Function Insurgency.ProjectileGrenade.PlayGrenadeSurfaceReaction
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class USurfaceReaction*                            InSurfaceReaction                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AProjectileGrenade::PlayGrenadeSurfaceReaction(class USurfaceReaction* InSurfaceReaction)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ProjectileGrenade.PlayGrenadeSurfaceReaction");
		
		AProjectileGrenade_PlayGrenadeSurfaceReaction_Params params {};
		params.InSurfaceReaction = InSurfaceReaction;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05716510
	 * 		Name   -> Function Insurgency.ProjectileGrenade.PlayGrenadeBounce
	 * 		Flags  -> (Final, Native, Private, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		struct FHitResult                                  ImpactResult                                               (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 * 		float                                              Scale                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AProjectileGrenade::PlayGrenadeBounce(const struct FHitResult& ImpactResult, float Scale)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ProjectileGrenade.PlayGrenadeBounce");
		
		AProjectileGrenade_PlayGrenadeBounce_Params params {};
		params.ImpactResult = ImpactResult;
		params.Scale = Scale;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x057164E0
	 * 		Name   -> Function Insurgency.ProjectileGrenade.PendingDetonationOrHasDetonated
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AProjectileGrenade::PendingDetonationOrHasDetonated()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ProjectileGrenade.PendingDetonationOrHasDetonated");
		
		AProjectileGrenade_PendingDetonationOrHasDetonated_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x057163B0
	 * 		Name   -> Function Insurgency.ProjectileGrenade.OnProjectileBounce
	 * 		Flags  -> (Final, Native, Public, HasOutParms, HasDefaults)
	 * Parameters:
	 * 		struct FHitResult                                  ImpactResult                                               (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     ImpactVelocity                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AProjectileGrenade::OnProjectileBounce(const struct FHitResult& ImpactResult, const struct FVector& ImpactVelocity)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ProjectileGrenade.OnProjectileBounce");
		
		AProjectileGrenade_OnProjectileBounce_Params params {};
		params.ImpactResult = ImpactResult;
		params.ImpactVelocity = ImpactVelocity;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x057162F0
	 * 		Name   -> Function Insurgency.ProjectileGrenade.OnPlantParentEndPlay
	 * 		Flags  -> (Final, Native, Private)
	 * Parameters:
	 * 		class AActor*                                      Actor                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EEndPlayReason                                     EndPlayReason                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AProjectileGrenade::OnPlantParentEndPlay(class AActor* Actor, EEndPlayReason EndPlayReason)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ProjectileGrenade.OnPlantParentEndPlay");
		
		AProjectileGrenade_OnPlantParentEndPlay_Params params {};
		params.Actor = Actor;
		params.EndPlayReason = EndPlayReason;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05716120
	 * 		Name   -> Function Insurgency.ProjectileGrenade.OnGrenadeHit
	 * 		Flags  -> (Final, Native, Public, HasOutParms, HasDefaults)
	 * Parameters:
	 * 		class UPrimitiveComponent*                         HitComponent                                               (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      OtherActor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UPrimitiveComponent*                         OtherComp                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     NormalImpulse                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FHitResult                                  Hit                                                        (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	void AProjectileGrenade::OnGrenadeHit(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, const struct FVector& NormalImpulse, const struct FHitResult& Hit)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ProjectileGrenade.OnGrenadeHit");
		
		AProjectileGrenade_OnGrenadeHit_Params params {};
		params.HitComponent = HitComponent;
		params.OtherActor = OtherActor;
		params.OtherComp = OtherComp;
		params.NormalImpulse = NormalImpulse;
		params.Hit = Hit;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05715FF0
	 * 		Name   -> Function Insurgency.ProjectileGrenade.OnGrenadeBounced
	 * 		Flags  -> (Final, Native, Public, HasOutParms, HasDefaults)
	 * Parameters:
	 * 		struct FHitResult                                  ImpactResult                                               (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     ImpactVelocity                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AProjectileGrenade::OnGrenadeBounced(const struct FHitResult& ImpactResult, const struct FVector& ImpactVelocity)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ProjectileGrenade.OnGrenadeBounced");
		
		AProjectileGrenade_OnGrenadeBounced_Params params {};
		params.ImpactResult = ImpactResult;
		params.ImpactVelocity = ImpactVelocity;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05715FD0
	 * 		Name   -> Function Insurgency.ProjectileGrenade.OnAttachedBreakableBroken
	 * 		Flags  -> (Final, Native, Protected)
	 */
	void AProjectileGrenade::OnAttachedBreakableBroken()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ProjectileGrenade.OnAttachedBreakableBroken");
		
		AProjectileGrenade_OnAttachedBreakableBroken_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05715EA0
	 * 		Name   -> Function Insurgency.ProjectileGrenade.MulticastExplodeAt
	 * 		Flags  -> (Final, Net, NetReliable, Native, Event, NetMulticast, Private, HasDefaults)
	 * Parameters:
	 * 		struct FVector                                     HitLocation                                                (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FHitResult                                  HitResult                                                  (ConstParm, Parm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	void AProjectileGrenade::MulticastExplodeAt(const struct FVector& HitLocation, const struct FHitResult& HitResult)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ProjectileGrenade.MulticastExplodeAt");
		
		AProjectileGrenade_MulticastExplodeAt_Params params {};
		params.HitLocation = HitLocation;
		params.HitResult = HitResult;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05715FB0
	 * 		Name   -> Function Insurgency.ProjectileGrenade.Multicast_PlantedBreakOff
	 * 		Flags  -> (Net, NetReliable, Native, Event, NetMulticast, Public, BlueprintCallable)
	 */
	void AProjectileGrenade::Multicast_PlantedBreakOff()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ProjectileGrenade.Multicast_PlantedBreakOff");
		
		AProjectileGrenade_Multicast_PlantedBreakOff_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05715E80
	 * 		Name   -> Function Insurgency.ProjectileGrenade.MakeDudAndDestroy
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void AProjectileGrenade::MakeDudAndDestroy()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ProjectileGrenade.MakeDudAndDestroy");
		
		AProjectileGrenade_MakeDudAndDestroy_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05715E60
	 * 		Name   -> Function Insurgency.ProjectileGrenade.MakeDud
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void AProjectileGrenade::MakeDud()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ProjectileGrenade.MakeDud");
		
		AProjectileGrenade_MakeDud_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05715E30
	 * 		Name   -> Function Insurgency.ProjectileGrenade.IsDetonationTimerActive
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AProjectileGrenade::IsDetonationTimerActive()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ProjectileGrenade.IsDetonationTimerActive");
		
		AProjectileGrenade_IsDetonationTimerActive_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05715E00
	 * 		Name   -> Function Insurgency.ProjectileGrenade.HasTimedFuze
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AProjectileGrenade::HasTimedFuze()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ProjectileGrenade.HasTimedFuze");
		
		AProjectileGrenade_HasTimedFuze_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05715DD0
	 * 		Name   -> Function Insurgency.ProjectileGrenade.GetExplosionElapsedTime
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	float AProjectileGrenade::GetExplosionElapsedTime()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ProjectileGrenade.GetExplosionElapsedTime");
		
		AProjectileGrenade_GetExplosionElapsedTime_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05715DA0
	 * 		Name   -> Function Insurgency.ProjectileGrenade.GetCookRemainingTime
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	float AProjectileGrenade::GetCookRemainingTime()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ProjectileGrenade.GetCookRemainingTime");
		
		AProjectileGrenade_GetCookRemainingTime_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05715C60
	 * 		Name   -> Function Insurgency.ProjectileGrenade.ExplodeAt
	 * 		Flags  -> (Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FVector                                     HitLocation                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FHitResult                                  HitResult                                                  (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	void AProjectileGrenade::ExplodeAt(const struct FVector& HitLocation, const struct FHitResult& HitResult)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ProjectileGrenade.ExplodeAt");
		
		AProjectileGrenade_ExplodeAt_Params params {};
		params.HitLocation = HitLocation;
		params.HitResult = HitResult;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00CBA790
	 * 		Name   -> Function Insurgency.ProjectileGrenade.Explode
	 * 		Flags  -> (Native, Public, BlueprintCallable)
	 */
	void AProjectileGrenade::Explode()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ProjectileGrenade.Explode");
		
		AProjectileGrenade_Explode_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00CBAAA0
	 * 		Name   -> Function Insurgency.ProjectileGrenade.Detonate
	 * 		Flags  -> (Native, Public, BlueprintCallable)
	 */
	void AProjectileGrenade::Detonate()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ProjectileGrenade.Detonate");
		
		AProjectileGrenade_Detonate_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05715C40
	 * 		Name   -> Function Insurgency.ProjectileGrenade.ClearCookTimer
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void AProjectileGrenade::ClearCookTimer()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ProjectileGrenade.ClearCookTimer");
		
		AProjectileGrenade_ClearCookTimer_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> Function Insurgency.ProjectileGrenade.BlueprintOnExplode
	 * 		Flags  -> (Event, Public, HasOutParms, HasDefaults, BlueprintEvent)
	 * Parameters:
	 * 		struct FVector                                     Location                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AProjectileGrenade::BlueprintOnExplode(const struct FVector& Location)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ProjectileGrenade.BlueprintOnExplode");
		
		AProjectileGrenade_BlueprintOnExplode_Params params {};
		params.Location = Location;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05715BB0
	 * 		Name   -> Function Insurgency.ProjectileGrenade.ApplyExplosionDamage
	 * 		Flags  -> (Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FVector                                     HitLocation                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AProjectileGrenade::ApplyExplosionDamage(const struct FVector& HitLocation)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ProjectileGrenade.ApplyExplosionDamage");
		
		AProjectileGrenade_ApplyExplosionDamage_Params params {};
		params.HitLocation = HitLocation;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05715A00
	 * 		Name   -> Function Insurgency.ProjectileGrenade.ApplyExplosionCustomDamage
	 * 		Flags  -> (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FVector                                     HitLocation                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              InDamage                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              InRadius                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bApplyForce                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bDoShellShock                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AProjectileGrenade::ApplyExplosionCustomDamage(const struct FVector& HitLocation, float InDamage, float InRadius, bool bApplyForce, bool bDoShellShock)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ProjectileGrenade.ApplyExplosionCustomDamage");
		
		AProjectileGrenade_ApplyExplosionCustomDamage_Params params {};
		params.HitLocation = HitLocation;
		params.InDamage = InDamage;
		params.InRadius = InRadius;
		params.bApplyForce = bApplyForce;
		params.bDoShellShock = bDoShellShock;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AProjectileGrenade.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AProjectileGrenade::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.ProjectileGrenade");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05714F00
	 * 		Name   -> Function Insurgency.ProjectileFlashbang.GetPercentageFlashed
	 * 		Flags  -> (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FVector                                     HitLocation                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     VictimLocation                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AINSSoldier*                                 Victim                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	float AProjectileFlashbang::GetPercentageFlashed(const struct FVector& HitLocation, const struct FVector& VictimLocation, class AINSSoldier* Victim)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ProjectileFlashbang.GetPercentageFlashed");
		
		AProjectileFlashbang_GetPercentageFlashed_Params params {};
		params.HitLocation = HitLocation;
		params.VictimLocation = VictimLocation;
		params.Victim = Victim;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05714E70
	 * 		Name   -> Function Insurgency.ProjectileFlashbang.DoFlashEffect
	 * 		Flags  -> (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FVector                                     HitLocation                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AProjectileFlashbang::DoFlashEffect(const struct FVector& HitLocation)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ProjectileFlashbang.DoFlashEffect");
		
		AProjectileFlashbang_DoFlashEffect_Params params {};
		params.HitLocation = HitLocation;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AProjectileFlashbang.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AProjectileFlashbang::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.ProjectileFlashbang");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05716C50
	 * 		Name   -> Function Insurgency.ProjectileMine.OnMineBeginOverlap
	 * 		Flags  -> (Native, Public, HasOutParms)
	 * Parameters:
	 * 		class UPrimitiveComponent*                         OverlappedComponent                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      OtherActor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UPrimitiveComponent*                         OtherComp                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            OtherBodyIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bFromSweep                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FHitResult                                  SweepResult                                                (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	void AProjectileMine::OnMineBeginOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32_t OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ProjectileMine.OnMineBeginOverlap");
		
		AProjectileMine_OnMineBeginOverlap_Params params {};
		params.OverlappedComponent = OverlappedComponent;
		params.OtherActor = OtherActor;
		params.OtherComp = OtherComp;
		params.OtherBodyIndex = OtherBodyIndex;
		params.bFromSweep = bFromSweep;
		params.SweepResult = SweepResult;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05716BC0
	 * 		Name   -> Function Insurgency.ProjectileMine.CanActorTriggerMine
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		class AActor*                                      TriggerActor                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool AProjectileMine::CanActorTriggerMine(class AActor* TriggerActor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ProjectileMine.CanActorTriggerMine");
		
		AProjectileMine_CanActorTriggerMine_Params params {};
		params.TriggerActor = TriggerActor;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AProjectileMine.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AProjectileMine::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.ProjectileMine");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AProjectilePlantableGrenade.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AProjectilePlantableGrenade::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.ProjectilePlantableGrenade");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x057174F0
	 * 		Name   -> Function Insurgency.ProjectileRocket.SuppressTarget
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class AINSSoldier*                                 Soldier                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AProjectileRocket::SuppressTarget(class AINSSoldier* Soldier)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ProjectileRocket.SuppressTarget");
		
		AProjectileRocket_SuppressTarget_Params params {};
		params.Soldier = Soldier;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x057172E0
	 * 		Name   -> Function Insurgency.ProjectileRocket.OnSuppressionBoxOverlapped
	 * 		Flags  -> (Final, Native, Private, HasOutParms)
	 * Parameters:
	 * 		class UPrimitiveComponent*                         OverlappedComponent                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      OtherActor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UPrimitiveComponent*                         OtherComp                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            OtherBodyIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bFromSweep                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FHitResult                                  SweepResult                                                (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	void AProjectileRocket::OnSuppressionBoxOverlapped(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32_t OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ProjectileRocket.OnSuppressionBoxOverlapped");
		
		AProjectileRocket_OnSuppressionBoxOverlapped_Params params {};
		params.OverlappedComponent = OverlappedComponent;
		params.OtherActor = OtherActor;
		params.OtherComp = OtherComp;
		params.OtherBodyIndex = OtherBodyIndex;
		params.bFromSweep = bFromSweep;
		params.SweepResult = SweepResult;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x057171A0
	 * 		Name   -> Function Insurgency.ProjectileRocket.OnSuppressionBoxEndOverlap
	 * 		Flags  -> (Final, Native, Private)
	 * Parameters:
	 * 		class UPrimitiveComponent*                         OverlappedComponent                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      OtherActor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UPrimitiveComponent*                         OtherComp                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            OtherBodyIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AProjectileRocket::OnSuppressionBoxEndOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32_t OtherBodyIndex)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ProjectileRocket.OnSuppressionBoxEndOverlap");
		
		AProjectileRocket_OnSuppressionBoxEndOverlap_Params params {};
		params.OverlappedComponent = OverlappedComponent;
		params.OtherActor = OtherActor;
		params.OtherComp = OtherComp;
		params.OtherBodyIndex = OtherBodyIndex;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AProjectileRocket.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AProjectileRocket::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.ProjectileRocket");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05717930
	 * 		Name   -> Function Insurgency.ProjectileSmokeGrenade.OnEndBlockerOverlap
	 * 		Flags  -> (Final, Native, Protected)
	 * Parameters:
	 * 		class UPrimitiveComponent*                         OverlappedComponent                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      OtherActor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UPrimitiveComponent*                         OtherComp                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            OtherBodyIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AProjectileSmokeGrenade::OnEndBlockerOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32_t OtherBodyIndex)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ProjectileSmokeGrenade.OnEndBlockerOverlap");
		
		AProjectileSmokeGrenade_OnEndBlockerOverlap_Params params {};
		params.OverlappedComponent = OverlappedComponent;
		params.OtherActor = OtherActor;
		params.OtherComp = OtherComp;
		params.OtherBodyIndex = OtherBodyIndex;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05717720
	 * 		Name   -> Function Insurgency.ProjectileSmokeGrenade.OnBeginBlockerOverlap
	 * 		Flags  -> (Final, Native, Protected, HasOutParms)
	 * Parameters:
	 * 		class UPrimitiveComponent*                         OverlappedComponent                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      OtherActor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UPrimitiveComponent*                         OtherComp                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            OtherBodyIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bFromSweep                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FHitResult                                  SweepResult                                                (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	void AProjectileSmokeGrenade::OnBeginBlockerOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32_t OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ProjectileSmokeGrenade.OnBeginBlockerOverlap");
		
		AProjectileSmokeGrenade_OnBeginBlockerOverlap_Params params {};
		params.OverlappedComponent = OverlappedComponent;
		params.OtherActor = OtherActor;
		params.OtherComp = OtherComp;
		params.OtherBodyIndex = OtherBodyIndex;
		params.bFromSweep = bFromSweep;
		params.SweepResult = SweepResult;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AProjectileSmokeGrenade.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AProjectileSmokeGrenade::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.ProjectileSmokeGrenade");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05717D40
	 * 		Name   -> Function Insurgency.ProjectileThermiteGrenade.IsLocationThreatenedByFire
	 * 		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		struct FVector                                     Location                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool AProjectileThermiteGrenade::IsLocationThreatenedByFire(const struct FVector& Location)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ProjectileThermiteGrenade.IsLocationThreatenedByFire");
		
		AProjectileThermiteGrenade_IsLocationThreatenedByFire_Params params {};
		params.Location = Location;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05717D20
	 * 		Name   -> Function Insurgency.ProjectileThermiteGrenade.Extinguish
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void AProjectileThermiteGrenade::Extinguish()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ProjectileThermiteGrenade.Extinguish");
		
		AProjectileThermiteGrenade_Extinguish_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05717D00
	 * 		Name   -> Function Insurgency.ProjectileThermiteGrenade.DoExtinguish
	 * 		Flags  -> (Final, Native, Protected)
	 */
	void AProjectileThermiteGrenade::DoExtinguish()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ProjectileThermiteGrenade.DoExtinguish");
		
		AProjectileThermiteGrenade_DoExtinguish_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x04DB4340
	 * 		Name   -> Function Insurgency.ProjectileThermiteGrenade.BroadcastExtinguish
	 * 		Flags  -> (Final, Net, Native, Event, NetMulticast, Private)
	 */
	void AProjectileThermiteGrenade::BroadcastExtinguish()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ProjectileThermiteGrenade.BroadcastExtinguish");
		
		AProjectileThermiteGrenade_BroadcastExtinguish_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x009DAB60
	 * 		Name   -> Function Insurgency.ProjectileThermiteGrenade.BroadcastAreaDamageEnd
	 * 		Flags  -> (Final, Net, Native, Event, NetMulticast, Private)
	 */
	void AProjectileThermiteGrenade::BroadcastAreaDamageEnd()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ProjectileThermiteGrenade.BroadcastAreaDamageEnd");
		
		AProjectileThermiteGrenade_BroadcastAreaDamageEnd_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AProjectileThermiteGrenade.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AProjectileThermiteGrenade::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.ProjectileThermiteGrenade");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x057188D0
	 * 		Name   -> Function Insurgency.PropBreakable.SetupMeshCollision
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UStaticMeshComponent*                        InMeshComponent                                            (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void APropBreakable::SetupMeshCollision(class UStaticMeshComponent* InMeshComponent)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.PropBreakable.SetupMeshCollision");
		
		APropBreakable_SetupMeshCollision_Params params {};
		params.InMeshComponent = InMeshComponent;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05718850
	 * 		Name   -> Function Insurgency.PropBreakable.SetBrokenMaterials
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UStaticMeshComponent*                        AffectedComponent                                          (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void APropBreakable::SetBrokenMaterials(class UStaticMeshComponent* AffectedComponent)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.PropBreakable.SetBrokenMaterials");
		
		APropBreakable_SetBrokenMaterials_Params params {};
		params.AffectedComponent = AffectedComponent;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x04DB3EA0
	 * 		Name   -> Function Insurgency.PropBreakable.ResetBreakable
	 * 		Flags  -> (Native, Public, BlueprintCallable)
	 */
	void APropBreakable::ResetBreakable()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.PropBreakable.ResetBreakable");
		
		APropBreakable_ResetBreakable_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05718830
	 * 		Name   -> Function Insurgency.PropBreakable.RemoveChildDecals
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void APropBreakable::RemoveChildDecals()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.PropBreakable.RemoveChildDecals");
		
		APropBreakable_RemoveChildDecals_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> Function Insurgency.PropBreakable.OnReset
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 */
	void APropBreakable::OnReset()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.PropBreakable.OnReset");
		
		APropBreakable_OnReset_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05718810
	 * 		Name   -> Function Insurgency.PropBreakable.OnRep_Health
	 * 		Flags  -> (Final, Native, Private)
	 */
	void APropBreakable::OnRep_Health()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.PropBreakable.OnRep_Health");
		
		APropBreakable_OnRep_Health_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00CBA850
	 * 		Name   -> Function Insurgency.PropBreakable.OnRep_bBrokenAuthority
	 * 		Flags  -> (Native, Public)
	 */
	void APropBreakable::OnRep_bBrokenAuthority()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.PropBreakable.OnRep_bBrokenAuthority");
		
		APropBreakable_OnRep_bBrokenAuthority_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05718780
	 * 		Name   -> Function Insurgency.PropBreakable.MulticastBreak
	 * 		Flags  -> (Net, Native, Event, NetMulticast, Public)
	 * Parameters:
	 * 		struct FDamageEvent                                DamageEvent                                                (ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void APropBreakable::MulticastBreak(const struct FDamageEvent& DamageEvent)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.PropBreakable.MulticastBreak");
		
		APropBreakable_MulticastBreak_Params params {};
		params.DamageEvent = DamageEvent;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05718750
	 * 		Name   -> Function Insurgency.PropBreakable.IsBroken
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool APropBreakable::IsBroken()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.PropBreakable.IsBroken");
		
		APropBreakable_IsBroken_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x057186D0
	 * 		Name   -> Function Insurgency.PropBreakable.InflictBreakDamage
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class AController*                                 EventInstigator                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void APropBreakable::InflictBreakDamage(class AController* EventInstigator)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.PropBreakable.InflictBreakDamage");
		
		APropBreakable_InflictBreakDamage_Params params {};
		params.EventInstigator = EventInstigator;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x057186A0
	 * 		Name   -> Function Insurgency.PropBreakable.ConvertToGib
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	class APropGib* APropBreakable::ConvertToGib()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.PropBreakable.ConvertToGib");
		
		APropBreakable_ConvertToGib_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05718680
	 * 		Name   -> Function Insurgency.PropBreakable.ChangeMesh
	 * 		Flags  -> (Final, Native, Private)
	 */
	void APropBreakable::ChangeMesh()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.PropBreakable.ChangeMesh");
		
		APropBreakable_ChangeMesh_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05718650
	 * 		Name   -> Function Insurgency.PropBreakable.CanBreakThrough
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool APropBreakable::CanBreakThrough()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.PropBreakable.CanBreakThrough");
		
		APropBreakable_CanBreakThrough_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x057185B0
	 * 		Name   -> Function Insurgency.PropBreakable.Break
	 * 		Flags  -> (Final, Native, Public, HasOutParms)
	 * Parameters:
	 * 		struct FDamageEvent                                DamageEvent                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void APropBreakable::Break(const struct FDamageEvent& DamageEvent)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.PropBreakable.Break");
		
		APropBreakable_Break_Params params {};
		params.DamageEvent = DamageEvent;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> Function Insurgency.PropBreakable.BlueprintOnHealthChanged
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 */
	void APropBreakable::BlueprintOnHealthChanged()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.PropBreakable.BlueprintOnHealthChanged");
		
		APropBreakable_BlueprintOnHealthChanged_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> Function Insurgency.PropBreakable.BlueprintOnBreak
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 */
	void APropBreakable::BlueprintOnBreak()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.PropBreakable.BlueprintOnBreak");
		
		APropBreakable_BlueprintOnBreak_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction APropBreakable.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* APropBreakable::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.PropBreakable");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05718CA0
	 * 		Name   -> Function Insurgency.PropFan.UpdateFanSpeed
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		float                                              NewFanSpeed                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void APropFan::UpdateFanSpeed(float NewFanSpeed)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.PropFan.UpdateFanSpeed");
		
		APropFan_UpdateFanSpeed_Params params {};
		params.NewFanSpeed = NewFanSpeed;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction APropFan.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* APropFan::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.PropFan");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction APropGib.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* APropGib::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.PropGib");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction APropVehicle.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* APropVehicle::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.PropVehicle");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URadialMenu.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URadialMenu::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.RadialMenu");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00C76AB0
	 * 		Name   -> Function Insurgency.Ragdoll.VisualizeDebugInformation
	 * 		Flags  -> (Final, Native, Protected)
	 */
	void ARagdoll::VisualizeDebugInformation()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.Ragdoll.VisualizeDebugInformation");
		
		ARagdoll_VisualizeDebugInformation_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0571B260
	 * 		Name   -> Function Insurgency.Ragdoll.Vaporize
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bShouldObliterate                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARagdoll::Vaporize(bool bShouldObliterate)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.Ragdoll.Vaporize");
		
		ARagdoll_Vaporize_Params params {};
		params.bShouldObliterate = bShouldObliterate;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05630E50
	 * 		Name   -> Function Insurgency.Ragdoll.UpdateMaterialSlotVisibility
	 * 		Flags  -> (Final, Native, Protected)
	 * Parameters:
	 * 		bool                                               bNotViewTarget                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARagdoll::UpdateMaterialSlotVisibility(bool bNotViewTarget)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.Ragdoll.UpdateMaterialSlotVisibility");
		
		ARagdoll_UpdateMaterialSlotVisibility_Params params {};
		params.bNotViewTarget = bNotViewTarget;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0571B240
	 * 		Name   -> Function Insurgency.Ragdoll.UpdateBloodPool
	 * 		Flags  -> (Final, Native, Protected)
	 */
	void ARagdoll::UpdateBloodPool()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.Ragdoll.UpdateBloodPool");
		
		ARagdoll_UpdateBloodPool_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0571B1C0
	 * 		Name   -> Function Insurgency.Ragdoll.TearRandomLimbs
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		int32_t                                            Limbs                                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARagdoll::TearRandomLimbs(int32_t Limbs)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.Ragdoll.TearRandomLimbs");
		
		ARagdoll_TearRandomLimbs_Params params {};
		params.Limbs = Limbs;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0571B0E0
	 * 		Name   -> Function Insurgency.Ragdoll.TearLimb
	 * 		Flags  -> (Final, Native, Protected)
	 * Parameters:
	 * 		class FName                                        LimbName                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	TArray<class FName> ARagdoll::TearLimb(const class FName& LimbName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.Ragdoll.TearLimb");
		
		ARagdoll_TearLimb_Params params {};
		params.LimbName = LimbName;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0571B0C0
	 * 		Name   -> Function Insurgency.Ragdoll.SprinkleSprayDecals
	 * 		Flags  -> (Final, Native, Protected)
	 */
	void ARagdoll::SprinkleSprayDecals()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.Ragdoll.SprinkleSprayDecals");
		
		ARagdoll_SprinkleSprayDecals_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0571AEA0
	 * 		Name   -> Function Insurgency.Ragdoll.SimplifiedDamage
	 * 		Flags  -> (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		float                                              DamageAmount                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UClass*                                      DamageType                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     HitPosition                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     DamageForce                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AController*                                 Killer                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      DamageCauser                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bApplyModifiers                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARagdoll::SimplifiedDamage(float DamageAmount, class UClass* DamageType, const struct FVector& HitPosition, const struct FVector& DamageForce, class AController* Killer, class AActor* DamageCauser, bool bApplyModifiers)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.Ragdoll.SimplifiedDamage");
		
		ARagdoll_SimplifiedDamage_Params params {};
		params.DamageAmount = DamageAmount;
		params.DamageType = DamageType;
		params.HitPosition = HitPosition;
		params.DamageForce = DamageForce;
		params.Killer = Killer;
		params.DamageCauser = DamageCauser;
		params.bApplyModifiers = bApplyModifiers;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0571AD90
	 * 		Name   -> Function Insurgency.Ragdoll.SetupSkinTint
	 * 		Flags  -> (Final, Native, Protected)
	 * Parameters:
	 * 		class UMaterialInstanceDynamic*                    Material                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bStoreSkinTint                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bApplySkinTint                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARagdoll::SetupSkinTint(class UMaterialInstanceDynamic* Material, bool bStoreSkinTint, bool bApplySkinTint)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.Ragdoll.SetupSkinTint");
		
		ARagdoll_SetupSkinTint_Params params {};
		params.Material = Material;
		params.bStoreSkinTint = bStoreSkinTint;
		params.bApplySkinTint = bApplySkinTint;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0571AD10
	 * 		Name   -> Function Insurgency.Ragdoll.SetDismembermentSet
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UDismembermentSet*                           DismembermentSetIn                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARagdoll::SetDismembermentSet(class UDismembermentSet* DismembermentSetIn)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.Ragdoll.SetDismembermentSet");
		
		ARagdoll_SetDismembermentSet_Params params {};
		params.DismembermentSetIn = DismembermentSetIn;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0571ACF0
	 * 		Name   -> Function Insurgency.Ragdoll.RefreshDismembermentData
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void ARagdoll::RefreshDismembermentData()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.Ragdoll.RefreshDismembermentData");
		
		ARagdoll_RefreshDismembermentData_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0571AC70
	 * 		Name   -> Function Insurgency.Ragdoll.QueueTearLimb
	 * 		Flags  -> (Final, Native, Protected, BlueprintCallable)
	 * Parameters:
	 * 		class FName                                        LimbName                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARagdoll::QueueTearLimb(const class FName& LimbName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.Ragdoll.QueueTearLimb");
		
		ARagdoll_QueueTearLimb_Params params {};
		params.LimbName = LimbName;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0571AC50
	 * 		Name   -> Function Insurgency.Ragdoll.PopQueuedLimb
	 * 		Flags  -> (Final, Native, Protected)
	 */
	void ARagdoll::PopQueuedLimb()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.Ragdoll.PopQueuedLimb");
		
		ARagdoll_PopQueuedLimb_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0571AA80
	 * 		Name   -> Function Insurgency.Ragdoll.OnComponentHit
	 * 		Flags  -> (Final, Native, Protected, HasOutParms, HasDefaults)
	 * Parameters:
	 * 		class UPrimitiveComponent*                         HitComponent                                               (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      OtherActor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UPrimitiveComponent*                         OtherComp                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     NormalImpulse                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FHitResult                                  Hit                                                        (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	void ARagdoll::OnComponentHit(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, const struct FVector& NormalImpulse, const struct FHitResult& Hit)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.Ragdoll.OnComponentHit");
		
		ARagdoll_OnComponentHit_Params params {};
		params.HitComponent = HitComponent;
		params.OtherActor = OtherActor;
		params.OtherComp = OtherComp;
		params.NormalImpulse = NormalImpulse;
		params.Hit = Hit;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0571AA50
	 * 		Name   -> Function Insurgency.Ragdoll.GetMesh
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	class URagdollMeshComponent* ARagdoll::GetMesh()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.Ragdoll.GetMesh");
		
		ARagdoll_GetMesh_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0571A9B0
	 * 		Name   -> Function Insurgency.Ragdoll.GetDamageModifierForLimb
	 * 		Flags  -> (Final, Native, Protected, HasOutParms)
	 * Parameters:
	 * 		class FName                                        LimbName                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	float ARagdoll::GetDamageModifierForLimb(const class FName& LimbName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.Ragdoll.GetDamageModifierForLimb");
		
		ARagdoll_GetDamageModifierForLimb_Params params {};
		params.LimbName = LimbName;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0571A8E0
	 * 		Name   -> Function Insurgency.Ragdoll.EnablePhysicsForComponent
	 * 		Flags  -> (Final, Native, Protected, BlueprintCallable, Const)
	 * Parameters:
	 * 		class UMeshComponent*                              Component                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bShouldEnable                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARagdoll::EnablePhysicsForComponent(class UMeshComponent* Component, bool bShouldEnable)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.Ragdoll.EnablePhysicsForComponent");
		
		ARagdoll_EnablePhysicsForComponent_Params params {};
		params.Component = Component;
		params.bShouldEnable = bShouldEnable;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0571A800
	 * 		Name   -> Function Insurgency.Ragdoll.DamageLimb
	 * 		Flags  -> (Final, Native, Protected, HasOutParms)
	 * Parameters:
	 * 		class FName                                        LimbName                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              DamageAmount                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARagdoll::DamageLimb(const class FName& LimbName, float DamageAmount)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.Ragdoll.DamageLimb");
		
		ARagdoll_DamageLimb_Params params {};
		params.LimbName = LimbName;
		params.DamageAmount = DamageAmount;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0571A620
	 * 		Name   -> Function Insurgency.Ragdoll.CreateRagdollBloodSplatter
	 * 		Flags  -> (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FVector                                     HitPosition                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     HitDirection                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bDismemberment                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bHeadshot                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bVaporized                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARagdoll::CreateRagdollBloodSplatter(const struct FVector& HitPosition, const struct FVector& HitDirection, bool bDismemberment, bool bHeadshot, bool bVaporized)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.Ragdoll.CreateRagdollBloodSplatter");
		
		ARagdoll_CreateRagdollBloodSplatter_Params params {};
		params.HitPosition = HitPosition;
		params.HitDirection = HitDirection;
		params.bDismemberment = bDismemberment;
		params.bHeadshot = bHeadshot;
		params.bVaporized = bVaporized;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0571A4C0
	 * 		Name   -> Function Insurgency.Ragdoll.CreateMaterialsForMesh
	 * 		Flags  -> (Final, Native, Protected)
	 * Parameters:
	 * 		class UMeshComponent*                              MeshComponent                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bStoreSkinTint                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bApplySkinTint                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FName                                        LimbName                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARagdoll::CreateMaterialsForMesh(class UMeshComponent* MeshComponent, bool bStoreSkinTint, bool bApplySkinTint, const class FName& LimbName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.Ragdoll.CreateMaterialsForMesh");
		
		ARagdoll_CreateMaterialsForMesh_Params params {};
		params.MeshComponent = MeshComponent;
		params.bStoreSkinTint = bStoreSkinTint;
		params.bApplySkinTint = bApplySkinTint;
		params.LimbName = LimbName;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0571A4A0
	 * 		Name   -> Function Insurgency.Ragdoll.CreateBloodPool
	 * 		Flags  -> (Final, Native, Protected)
	 */
	void ARagdoll::CreateBloodPool()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.Ragdoll.CreateBloodPool");
		
		ARagdoll_CreateBloodPool_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0571A310
	 * 		Name   -> Function Insurgency.Ragdoll.ConstrainLimb
	 * 		Flags  -> (Final, Native, Protected, HasOutParms, HasDefaults)
	 * Parameters:
	 * 		class FName                                        LimbName                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     BoneLocation                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FQuat                                       BoneRotation                                               (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		class UMeshComponent*                              LimbComponent                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARagdoll::ConstrainLimb(const class FName& LimbName, const struct FVector& BoneLocation, const struct FQuat& BoneRotation, class UMeshComponent* LimbComponent)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.Ragdoll.ConstrainLimb");
		
		ARagdoll_ConstrainLimb_Params params {};
		params.LimbName = LimbName;
		params.BoneLocation = BoneLocation;
		params.BoneRotation = BoneRotation;
		params.LimbComponent = LimbComponent;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0571A250
	 * 		Name   -> Function Insurgency.Ragdoll.ConfigureRagdollMesh
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class USkeletalMeshComponent*                      SkeletalMeshComponent                                      (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UPhysicsAsset*                               PhysicsAsset                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARagdoll::ConfigureRagdollMesh(class USkeletalMeshComponent* SkeletalMeshComponent, class UPhysicsAsset* PhysicsAsset)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.Ragdoll.ConfigureRagdollMesh");
		
		ARagdoll_ConfigureRagdollMesh_Params params {};
		params.SkeletalMeshComponent = SkeletalMeshComponent;
		params.PhysicsAsset = PhysicsAsset;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0571A230
	 * 		Name   -> Function Insurgency.Ragdoll.ConfigurePhysicsAnimation
	 * 		Flags  -> (Final, Native, Protected)
	 */
	void ARagdoll::ConfigurePhysicsAnimation()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.Ragdoll.ConfigurePhysicsAnimation");
		
		ARagdoll_ConfigurePhysicsAnimation_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0571A210
	 * 		Name   -> Function Insurgency.Ragdoll.ConfigureMaterialEffects
	 * 		Flags  -> (Final, Native, Protected)
	 */
	void ARagdoll::ConfigureMaterialEffects()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.Ragdoll.ConfigureMaterialEffects");
		
		ARagdoll_ConfigureMaterialEffects_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0571A1F0
	 * 		Name   -> Function Insurgency.Ragdoll.CheckForSuddenVelocityChanges
	 * 		Flags  -> (Final, Native, Protected)
	 */
	void ARagdoll::CheckForSuddenVelocityChanges()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.Ragdoll.CheckForSuddenVelocityChanges");
		
		ARagdoll_CheckForSuddenVelocityChanges_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ARagdoll.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ARagdoll::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.Ragdoll");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URagdollManager.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URagdollManager::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.RagdollManager");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URagdollMeshComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URagdollMeshComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.RagdollMeshComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0571C6A0
	 * 		Name   -> Function Insurgency.RandomWeaponCrate.SpawnRandomWeapon
	 * 		Flags  -> (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class AINSSoldier*                                 ForUser                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARandomWeaponCrate::SpawnRandomWeapon(class AINSSoldier* ForUser)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.RandomWeaponCrate.SpawnRandomWeapon");
		
		ARandomWeaponCrate_SpawnRandomWeapon_Params params {};
		params.ForUser = ForUser;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0571C610
	 * 		Name   -> Function Insurgency.RandomWeaponCrate.ShowShowPointOfInterest
	 * 		Flags  -> (Final, Native, Private)
	 * Parameters:
	 * 		class AINSSoldier*                                 ForPlayer                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool ARandomWeaponCrate::ShowShowPointOfInterest(class AINSSoldier* ForPlayer)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.RandomWeaponCrate.ShowShowPointOfInterest");
		
		ARandomWeaponCrate_ShowShowPointOfInterest_Params params {};
		params.ForPlayer = ForPlayer;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0571C580
	 * 		Name   -> Function Insurgency.RandomWeaponCrate.SetOpened
	 * 		Flags  -> (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bNewOpened                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARandomWeaponCrate::SetOpened(bool bNewOpened)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.RandomWeaponCrate.SetOpened");
		
		ARandomWeaponCrate_SetOpened_Params params {};
		params.bNewOpened = bNewOpened;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0571C4F0
	 * 		Name   -> Function Insurgency.RandomWeaponCrate.SetEnabled
	 * 		Flags  -> (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bNewEnabled                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARandomWeaponCrate::SetEnabled(bool bNewEnabled)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.RandomWeaponCrate.SetEnabled");
		
		ARandomWeaponCrate_SetEnabled_Params params {};
		params.bNewEnabled = bNewEnabled;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0571C470
	 * 		Name   -> Function Insurgency.RandomWeaponCrate.SetCrateDataAsset
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class URandomWeaponCrateDataAsset*                 NewCrateData                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARandomWeaponCrate::SetCrateDataAsset(class URandomWeaponCrateDataAsset* NewCrateData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.RandomWeaponCrate.SetCrateDataAsset");
		
		ARandomWeaponCrate_SetCrateDataAsset_Params params {};
		params.NewCrateData = NewCrateData;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0571C3F0
	 * 		Name   -> Function Insurgency.RandomWeaponCrate.ResupplyLoadout
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		class AINSSoldier*                                 Pawn                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARandomWeaponCrate::ResupplyLoadout(class AINSSoldier* Pawn)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.RandomWeaponCrate.ResupplyLoadout");
		
		ARandomWeaponCrate_ResupplyLoadout_Params params {};
		params.Pawn = Pawn;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0571C3D0
	 * 		Name   -> Function Insurgency.RandomWeaponCrate.ResetUseLimits
	 * 		Flags  -> (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
	 */
	void ARandomWeaponCrate::ResetUseLimits()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.RandomWeaponCrate.ResetUseLimits");
		
		ARandomWeaponCrate_ResetUseLimits_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0571C350
	 * 		Name   -> Function Insurgency.RandomWeaponCrate.PlaySoundEffect
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UAkAudioEvent*                               InSoundEffect                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARandomWeaponCrate::PlaySoundEffect(class UAkAudioEvent* InSoundEffect)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.RandomWeaponCrate.PlaySoundEffect");
		
		ARandomWeaponCrate_PlaySoundEffect_Params params {};
		params.InSoundEffect = InSoundEffect;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0571C330
	 * 		Name   -> Function Insurgency.RandomWeaponCrate.OnRep_Opened
	 * 		Flags  -> (Final, Native, Private)
	 */
	void ARandomWeaponCrate::OnRep_Opened()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.RandomWeaponCrate.OnRep_Opened");
		
		ARandomWeaponCrate_OnRep_Opened_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0571C310
	 * 		Name   -> Function Insurgency.RandomWeaponCrate.OnRep_Enabled
	 * 		Flags  -> (Final, Native, Private)
	 */
	void ARandomWeaponCrate::OnRep_Enabled()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.RandomWeaponCrate.OnRep_Enabled");
		
		ARandomWeaponCrate_OnRep_Enabled_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0571C250
	 * 		Name   -> Function Insurgency.RandomWeaponCrate.OnPickupPickedUp
	 * 		Flags  -> (Final, Native, Private)
	 * Parameters:
	 * 		class AItemEquipable*                              PickedUpItem                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AINSSoldier*                                 Soldier                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARandomWeaponCrate::OnPickupPickedUp(class AItemEquipable* PickedUpItem, class AINSSoldier* Soldier)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.RandomWeaponCrate.OnPickupPickedUp");
		
		ARandomWeaponCrate_OnPickupPickedUp_Params params {};
		params.PickedUpItem = PickedUpItem;
		params.Soldier = Soldier;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0571C1D0
	 * 		Name   -> Function Insurgency.RandomWeaponCrate.OnPickupDestroyed
	 * 		Flags  -> (Final, Native, Private)
	 * Parameters:
	 * 		class AActor*                                      DestroyedActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARandomWeaponCrate::OnPickupDestroyed(class AActor* DestroyedActor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.RandomWeaponCrate.OnPickupDestroyed");
		
		ARandomWeaponCrate_OnPickupDestroyed_Params params {};
		params.DestroyedActor = DestroyedActor;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0571C110
	 * 		Name   -> Function Insurgency.RandomWeaponCrate.OnPickupClearAmmo
	 * 		Flags  -> (Final, Native, Private)
	 * Parameters:
	 * 		class AItemEquipable*                              PickedUpItem                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AINSSoldier*                                 Soldier                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARandomWeaponCrate::OnPickupClearAmmo(class AItemEquipable* PickedUpItem, class AINSSoldier* Soldier)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.RandomWeaponCrate.OnPickupClearAmmo");
		
		ARandomWeaponCrate_OnPickupClearAmmo_Params params {};
		params.PickedUpItem = PickedUpItem;
		params.Soldier = Soldier;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x04DB5CB0
	 * 		Name   -> Function Insurgency.RandomWeaponCrate.OnCrateOpened
	 * 		Flags  -> (BlueprintAuthorityOnly, Native, Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		class AINSSoldier*                                 OpenedBy                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARandomWeaponCrate::OnCrateOpened(class AINSSoldier* OpenedBy)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.RandomWeaponCrate.OnCrateOpened");
		
		ARandomWeaponCrate_OnCrateOpened_Params params {};
		params.OpenedBy = OpenedBy;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0571C050
	 * 		Name   -> Function Insurgency.RandomWeaponCrate.IncrementTotalUseCount
	 * 		Flags  -> (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		int32_t                                            Amount                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bIncrementLinked                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARandomWeaponCrate::IncrementTotalUseCount(int32_t Amount, bool bIncrementLinked)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.RandomWeaponCrate.IncrementTotalUseCount");
		
		ARandomWeaponCrate_IncrementTotalUseCount_Params params {};
		params.Amount = Amount;
		params.bIncrementLinked = bIncrementLinked;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0571BF00
	 * 		Name   -> Function Insurgency.RandomWeaponCrate.IncrementPlayerUseCount
	 * 		Flags  -> (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class AINSSoldier*                                 ForPlayer                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            Amount                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bIncrementTotal                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bIncrementLinked                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARandomWeaponCrate::IncrementPlayerUseCount(class AINSSoldier* ForPlayer, int32_t Amount, bool bIncrementTotal, bool bIncrementLinked)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.RandomWeaponCrate.IncrementPlayerUseCount");
		
		ARandomWeaponCrate_IncrementPlayerUseCount_Params params {};
		params.ForPlayer = ForPlayer;
		params.Amount = Amount;
		params.bIncrementTotal = bIncrementTotal;
		params.bIncrementLinked = bIncrementLinked;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0571BE30
	 * 		Name   -> Function Insurgency.RandomWeaponCrate.GiveLoadoutItems
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		class AINSSoldier*                                 Pawn                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bExcludePrimaryFromRemoval                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARandomWeaponCrate::GiveLoadoutItems(class AINSSoldier* Pawn, bool bExcludePrimaryFromRemoval)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.RandomWeaponCrate.GiveLoadoutItems");
		
		ARandomWeaponCrate_GiveLoadoutItems_Params params {};
		params.Pawn = Pawn;
		params.bExcludePrimaryFromRemoval = bExcludePrimaryFromRemoval;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0571BD80
	 * 		Name   -> Function Insurgency.RandomWeaponCrate.GetLinkedWeaponCrates
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		TArray<class ARandomWeaponCrate*>                  OutLinkedCrates                                            (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARandomWeaponCrate::GetLinkedWeaponCrates(TArray<class ARandomWeaponCrate*>* OutLinkedCrates)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.RandomWeaponCrate.GetLinkedWeaponCrates");
		
		ARandomWeaponCrate_GetLinkedWeaponCrates_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutLinkedCrates != nullptr)
			*OutLinkedCrates = params.OutLinkedCrates;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ARandomWeaponCrate.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ARandomWeaponCrate::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.RandomWeaponCrate");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0571CFE0
	 * 		Name   -> Function Insurgency.RandomWeaponCrateDataAsset.GetTotalWeaponPoolChance
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	float URandomWeaponCrateDataAsset::GetTotalWeaponPoolChance()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.RandomWeaponCrateDataAsset.GetTotalWeaponPoolChance");
		
		URandomWeaponCrateDataAsset_GetTotalWeaponPoolChance_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URandomWeaponCrateDataAsset.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URandomWeaponCrateDataAsset::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.RandomWeaponCrateDataAsset");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UWeaponUpgradeFilterTest.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UWeaponUpgradeFilterTest::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.WeaponUpgradeFilterTest");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UWeaponUpgradeFilter.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UWeaponUpgradeFilter::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.WeaponUpgradeFilter");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UWeaponUpgradeTagFilter.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UWeaponUpgradeTagFilter::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.WeaponUpgradeTagFilter");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UWeaponUpgradeEquippedFilter.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UWeaponUpgradeEquippedFilter::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.WeaponUpgradeEquippedFilter");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0571E050
	 * 		Name   -> Function Insurgency.ReinforcementSystemComponent.StartWave
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		float                                              Delay                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UReinforcementSystemComponent::StartWave(float Delay)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ReinforcementSystemComponent.StartWave");
		
		UReinforcementSystemComponent_StartWave_Params params {};
		params.Delay = Delay;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0571E020
	 * 		Name   -> Function Insurgency.ReinforcementSystemComponent.ShouldTriggerReinforcementWave
	 * 		Flags  -> (Native, Event, Public, BlueprintEvent, Const)
	 */
	bool UReinforcementSystemComponent::ShouldTriggerReinforcementWave()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ReinforcementSystemComponent.ShouldTriggerReinforcementWave");
		
		UReinforcementSystemComponent_ShouldTriggerReinforcementWave_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056367A0
	 * 		Name   -> Function Insurgency.ReinforcementSystemComponent.ShouldDeductReinforcementWave
	 * 		Flags  -> (Native, Event, Public, BlueprintEvent, Const)
	 */
	bool UReinforcementSystemComponent::ShouldDeductReinforcementWave()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ReinforcementSystemComponent.ShouldDeductReinforcementWave");
		
		UReinforcementSystemComponent_ShouldDeductReinforcementWave_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0571DFA0
	 * 		Name   -> Function Insurgency.ReinforcementSystemComponent.SetWaves
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		int32_t                                            Waves                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UReinforcementSystemComponent::SetWaves(int32_t Waves)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ReinforcementSystemComponent.SetWaves");
		
		UReinforcementSystemComponent_SetWaves_Params params {};
		params.Waves = Waves;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> DelegateFunction Insurgency.ReinforcementSystemComponent.OnWaveGainDelegate__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 * Parameters:
	 * 		class UReinforcementSystemComponent*               ReinforcementSystemComponent                               (ConstParm, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            OldWaveCount                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UReinforcementSystemComponent::OnWaveGainDelegate__DelegateSignature(class UReinforcementSystemComponent* ReinforcementSystemComponent, int32_t OldWaveCount)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction Insurgency.ReinforcementSystemComponent.OnWaveGainDelegate__DelegateSignature");
		
		UReinforcementSystemComponent_OnWaveGainDelegate__DelegateSignature_Params params {};
		params.ReinforcementSystemComponent = ReinforcementSystemComponent;
		params.OldWaveCount = OldWaveCount;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> DelegateFunction Insurgency.ReinforcementSystemComponent.OnWaveDepletionDelegate__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 * Parameters:
	 * 		class UReinforcementSystemComponent*               ReinforcementSystemComponent                               (ConstParm, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UReinforcementSystemComponent::OnWaveDepletionDelegate__DelegateSignature(class UReinforcementSystemComponent* ReinforcementSystemComponent)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction Insurgency.ReinforcementSystemComponent.OnWaveDepletionDelegate__DelegateSignature");
		
		UReinforcementSystemComponent_OnWaveDepletionDelegate__DelegateSignature_Params params {};
		params.ReinforcementSystemComponent = ReinforcementSystemComponent;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x04DB0CA0
	 * 		Name   -> Function Insurgency.ReinforcementSystemComponent.OnRoundReset
	 * 		Flags  -> (Native, Event, Public, BlueprintEvent)
	 */
	void UReinforcementSystemComponent::OnRoundReset()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ReinforcementSystemComponent.OnRoundReset");
		
		UReinforcementSystemComponent_OnRoundReset_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00DE3140
	 * 		Name   -> Function Insurgency.ReinforcementSystemComponent.OnPlayerDeath
	 * 		Flags  -> (Native, Event, Public, BlueprintEvent)
	 */
	void UReinforcementSystemComponent::OnPlayerDeath()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ReinforcementSystemComponent.OnPlayerDeath");
		
		UReinforcementSystemComponent_OnPlayerDeath_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0571DF70
	 * 		Name   -> Function Insurgency.ReinforcementSystemComponent.GetWaves
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	int32_t UReinforcementSystemComponent::GetWaves()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ReinforcementSystemComponent.GetWaves");
		
		UReinforcementSystemComponent_GetWaves_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0571DEE0
	 * 		Name   -> Function Insurgency.ReinforcementSystemComponent.ExecuteRapidDeployment
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bDeductWave                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UReinforcementSystemComponent::ExecuteRapidDeployment(bool bDeductWave)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ReinforcementSystemComponent.ExecuteRapidDeployment");
		
		UReinforcementSystemComponent_ExecuteRapidDeployment_Params params {};
		params.bDeductWave = bDeductWave;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0571DEC0
	 * 		Name   -> Function Insurgency.ReinforcementSystemComponent.DeductWave
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void UReinforcementSystemComponent::DeductWave()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ReinforcementSystemComponent.DeductWave");
		
		UReinforcementSystemComponent_DeductWave_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> DelegateFunction Insurgency.ReinforcementSystemComponent.DeductReinforcementWaveDelegate__DelegateSignature
	 * 		Flags  -> (Public, Delegate)
	 * Parameters:
	 * 		class UReinforcementSystemComponent*               ReinforcementSystemComponent                               (ConstParm, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UReinforcementSystemComponent::DeductReinforcementWaveDelegate__DelegateSignature(class UReinforcementSystemComponent* ReinforcementSystemComponent)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction Insurgency.ReinforcementSystemComponent.DeductReinforcementWaveDelegate__DelegateSignature");
		
		UReinforcementSystemComponent_DeductReinforcementWaveDelegate__DelegateSignature_Params params {};
		params.ReinforcementSystemComponent = ReinforcementSystemComponent;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0571DEA0
	 * 		Name   -> Function Insurgency.ReinforcementSystemComponent.CheckStartWave
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void UReinforcementSystemComponent::CheckStartWave()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ReinforcementSystemComponent.CheckStartWave");
		
		UReinforcementSystemComponent_CheckStartWave_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0571DDE0
	 * 		Name   -> Function Insurgency.ReinforcementSystemComponent.CanRedeployPlayers
	 * 		Flags  -> (Native, Event, Public, BlueprintEvent, Const)
	 */
	bool UReinforcementSystemComponent::CanRedeployPlayers()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ReinforcementSystemComponent.CanRedeployPlayers");
		
		UReinforcementSystemComponent_CanRedeployPlayers_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0571DE10
	 * 		Name   -> Function Insurgency.ReinforcementSystemComponent.CancelWave
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bInformTeam                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UReinforcementSystemComponent::CancelWave(bool bInformTeam)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ReinforcementSystemComponent.CancelWave");
		
		UReinforcementSystemComponent_CancelWave_Params params {};
		params.bInformTeam = bInformTeam;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0571DD60
	 * 		Name   -> Function Insurgency.ReinforcementSystemComponent.AddWaves
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		int32_t                                            Waves                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UReinforcementSystemComponent::AddWaves(int32_t Waves)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ReinforcementSystemComponent.AddWaves");
		
		UReinforcementSystemComponent_AddWaves_Params params {};
		params.Waves = Waves;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UReinforcementSystemComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UReinforcementSystemComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.ReinforcementSystemComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0571E3A0
	 * 		Name   -> Function Insurgency.RenderTargetController.GetTextureRenderTarget
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		ERenderTargetSlot                                  TargetType                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UTextureRenderTarget2D* URenderTargetController::GetTextureRenderTarget(ERenderTargetSlot TargetType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.RenderTargetController.GetTextureRenderTarget");
		
		URenderTargetController_GetTextureRenderTarget_Params params {};
		params.TargetType = TargetType;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0571E2D0
	 * 		Name   -> Function Insurgency.RenderTargetController.GetDesiredResolutionForTarget
	 * 		Flags  -> (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		ERenderTargetSlot                                  TargetType                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FIntPoint                                   OutSize                                                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void URenderTargetController::GetDesiredResolutionForTarget(ERenderTargetSlot TargetType, struct FIntPoint* OutSize)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.RenderTargetController.GetDesiredResolutionForTarget");
		
		URenderTargetController_GetDesiredResolutionForTarget_Params params {};
		params.TargetType = TargetType;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutSize != nullptr)
			*OutSize = params.OutSize;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URenderTargetController.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URenderTargetController::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.RenderTargetController");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0571EB40
	 * 		Name   -> Function Insurgency.RestrictedArea.ShouldBeRestricted
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		class AINSSoldier*                                 TargetSoldier                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool ARestrictedArea::ShouldBeRestricted(class AINSSoldier* TargetSoldier)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.RestrictedArea.ShouldBeRestricted");
		
		ARestrictedArea_ShouldBeRestricted_Params params {};
		params.TargetSoldier = TargetSoldier;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0571EAB0
	 * 		Name   -> Function Insurgency.RestrictedArea.SetEnabled
	 * 		Flags  -> (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bState                                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARestrictedArea::SetEnabled(bool bState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.RestrictedArea.SetEnabled");
		
		ARestrictedArea_SetEnabled_Params params {};
		params.bState = bState;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0571E970
	 * 		Name   -> Function Insurgency.RestrictedArea.OnEndAreaOverlap
	 * 		Flags  -> (Final, Native, Private)
	 * Parameters:
	 * 		class UPrimitiveComponent*                         OverlappedComponent                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      OtherActor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UPrimitiveComponent*                         OtherComp                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            OtherBodyIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ARestrictedArea::OnEndAreaOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32_t OtherBodyIndex)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.RestrictedArea.OnEndAreaOverlap");
		
		ARestrictedArea_OnEndAreaOverlap_Params params {};
		params.OverlappedComponent = OverlappedComponent;
		params.OtherActor = OtherActor;
		params.OtherComp = OtherComp;
		params.OtherBodyIndex = OtherBodyIndex;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0571E760
	 * 		Name   -> Function Insurgency.RestrictedArea.OnBeginAreaOverlap
	 * 		Flags  -> (Final, Native, Private, HasOutParms)
	 * Parameters:
	 * 		class UPrimitiveComponent*                         OverlappedComponent                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      OtherActor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UPrimitiveComponent*                         OtherComp                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            OtherBodyIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bFromSweep                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FHitResult                                  SweepResult                                                (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	void ARestrictedArea::OnBeginAreaOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32_t OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.RestrictedArea.OnBeginAreaOverlap");
		
		ARestrictedArea_OnBeginAreaOverlap_Params params {};
		params.OverlappedComponent = OverlappedComponent;
		params.OtherActor = OtherActor;
		params.OtherComp = OtherComp;
		params.OtherBodyIndex = OtherBodyIndex;
		params.bFromSweep = bFromSweep;
		params.SweepResult = SweepResult;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0571E730
	 * 		Name   -> Function Insurgency.RestrictedArea.IsEnabled
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool ARestrictedArea::IsEnabled()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.RestrictedArea.IsEnabled");
		
		ARestrictedArea_IsEnabled_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ARestrictedArea.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ARestrictedArea::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.RestrictedArea");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ARestrictedFireSupportVolume.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ARestrictedFireSupportVolume::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.RestrictedFireSupportVolume");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URichTextTeamColorDecorator.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URichTextTeamColorDecorator::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.RichTextTeamColorDecorator");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URoundResetComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URoundResetComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.RoundResetComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URoundResetInterface.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URoundResetInterface::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.RoundResetInterface");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URuleset.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URuleset::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.Ruleset");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00CD91F0
	 * 		Name   -> Function Insurgency.SABERUtilsWidgetWorldSubsystem.GetUtilsWidgetWorldSubsystem
	 * 		Flags  -> (Final, Native, Public)
	 */
	class USABERUtilsWidget* USABERUtilsWidgetWorldSubsystem::GetUtilsWidgetWorldSubsystem()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.SABERUtilsWidgetWorldSubsystem.GetUtilsWidgetWorldSubsystem");
		
		USABERUtilsWidgetWorldSubsystem_GetUtilsWidgetWorldSubsystem_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction USABERUtilsWidgetWorldSubsystem.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* USABERUtilsWidgetWorldSubsystem::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.SABERUtilsWidgetWorldSubsystem");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0565F8F0
	 * 		Name   -> Function Insurgency.SABERUtilsWidget.IsShippingBuild
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 */
	bool USABERUtilsWidget::STATIC_IsShippingBuild()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.SABERUtilsWidget.IsShippingBuild");
		
		USABERUtilsWidget_IsShippingBuild_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x057209F0
	 * 		Name   -> Function Insurgency.SABERUtilsWidget.GetUtilsWidgetInstance
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 */
	class USABERUtilsWidget* USABERUtilsWidget::STATIC_GetUtilsWidgetInstance()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.SABERUtilsWidget.GetUtilsWidgetInstance");
		
		USABERUtilsWidget_GetUtilsWidgetInstance_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05720F50
	 * 		Name   -> Function Insurgency.SABERUtilsWidget.GetShowOnlineStore
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 */
	bool USABERUtilsWidget::STATIC_GetShowOnlineStore()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.SABERUtilsWidget.GetShowOnlineStore");
		
		USABERUtilsWidget_GetShowOnlineStore_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05720F20
	 * 		Name   -> Function Insurgency.SABERUtilsWidget.GetShowAmbushModeProperties
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 */
	bool USABERUtilsWidget::STATIC_GetShowAmbushModeProperties()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.SABERUtilsWidget.GetShowAmbushModeProperties");
		
		USABERUtilsWidget_GetShowAmbushModeProperties_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05720EA0
	 * 		Name   -> Function Insurgency.SABERUtilsWidget.GetFeedbackURL
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 */
	class FString USABERUtilsWidget::STATIC_GetFeedbackURL()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.SABERUtilsWidget.GetFeedbackURL");
		
		USABERUtilsWidget_GetFeedbackURL_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05720E70
	 * 		Name   -> Function Insurgency.SABERUtilsWidget.GetDisableVideoSettingsForConsoles
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 */
	bool USABERUtilsWidget::STATIC_GetDisableVideoSettingsForConsoles()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.SABERUtilsWidget.GetDisableVideoSettingsForConsoles");
		
		USABERUtilsWidget_GetDisableVideoSettingsForConsoles_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05720E40
	 * 		Name   -> Function Insurgency.SABERUtilsWidget.GetDisableTextChatForConsoles
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 */
	bool USABERUtilsWidget::STATIC_GetDisableTextChatForConsoles()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.SABERUtilsWidget.GetDisableTextChatForConsoles");
		
		USABERUtilsWidget_GetDisableTextChatForConsoles_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05720E10
	 * 		Name   -> Function Insurgency.SABERUtilsWidget.GetDisableSubmitFeedbackForConsoles
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 */
	bool USABERUtilsWidget::STATIC_GetDisableSubmitFeedbackForConsoles()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.SABERUtilsWidget.GetDisableSubmitFeedbackForConsoles");
		
		USABERUtilsWidget_GetDisableSubmitFeedbackForConsoles_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05720DE0
	 * 		Name   -> Function Insurgency.SABERUtilsWidget.GetDisableShootingRangePropsShadows
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 */
	bool USABERUtilsWidget::STATIC_GetDisableShootingRangePropsShadows()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.SABERUtilsWidget.GetDisableShootingRangePropsShadows");
		
		USABERUtilsWidget_GetDisableShootingRangePropsShadows_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05720DB0
	 * 		Name   -> Function Insurgency.SABERUtilsWidget.GetDisableServerBrowserForConsoles
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 */
	bool USABERUtilsWidget::STATIC_GetDisableServerBrowserForConsoles()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.SABERUtilsWidget.GetDisableServerBrowserForConsoles");
		
		USABERUtilsWidget_GetDisableServerBrowserForConsoles_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05720D80
	 * 		Name   -> Function Insurgency.SABERUtilsWidget.GetDisableSectionHistoryForConsoles
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 */
	bool USABERUtilsWidget::STATIC_GetDisableSectionHistoryForConsoles()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.SABERUtilsWidget.GetDisableSectionHistoryForConsoles");
		
		USABERUtilsWidget_GetDisableSectionHistoryForConsoles_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05720D50
	 * 		Name   -> Function Insurgency.SABERUtilsWidget.GetDisableSectionAchievementsForConsoles
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 */
	bool USABERUtilsWidget::STATIC_GetDisableSectionAchievementsForConsoles()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.SABERUtilsWidget.GetDisableSectionAchievementsForConsoles");
		
		USABERUtilsWidget_GetDisableSectionAchievementsForConsoles_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05720D20
	 * 		Name   -> Function Insurgency.SABERUtilsWidget.GetDisableScoreboardViewProfileEOS
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 */
	bool USABERUtilsWidget::STATIC_GetDisableScoreboardViewProfileEOS()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.SABERUtilsWidget.GetDisableScoreboardViewProfileEOS");
		
		USABERUtilsWidget_GetDisableScoreboardViewProfileEOS_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05720CF0
	 * 		Name   -> Function Insurgency.SABERUtilsWidget.GetDisableReportButtonForConsoles
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 */
	bool USABERUtilsWidget::STATIC_GetDisableReportButtonForConsoles()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.SABERUtilsWidget.GetDisableReportButtonForConsoles");
		
		USABERUtilsWidget_GetDisableReportButtonForConsoles_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05720CC0
	 * 		Name   -> Function Insurgency.SABERUtilsWidget.GetDisableReplaysForConsoles
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 */
	bool USABERUtilsWidget::STATIC_GetDisableReplaysForConsoles()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.SABERUtilsWidget.GetDisableReplaysForConsoles");
		
		USABERUtilsWidget_GetDisableReplaysForConsoles_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05720C90
	 * 		Name   -> Function Insurgency.SABERUtilsWidget.GetDisableProfanityFilterSettingForConsoles
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 */
	bool USABERUtilsWidget::STATIC_GetDisableProfanityFilterSettingForConsoles()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.SABERUtilsWidget.GetDisableProfanityFilterSettingForConsoles");
		
		USABERUtilsWidget_GetDisableProfanityFilterSettingForConsoles_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05720C60
	 * 		Name   -> Function Insurgency.SABERUtilsWidget.GetDisablePostMatchStatsForConsoles
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 */
	bool USABERUtilsWidget::STATIC_GetDisablePostMatchStatsForConsoles()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.SABERUtilsWidget.GetDisablePostMatchStatsForConsoles");
		
		USABERUtilsWidget_GetDisablePostMatchStatsForConsoles_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05720C30
	 * 		Name   -> Function Insurgency.SABERUtilsWidget.GetDisablePlayerStatisticsForConsoles
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 */
	bool USABERUtilsWidget::STATIC_GetDisablePlayerStatisticsForConsoles()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.SABERUtilsWidget.GetDisablePlayerStatisticsForConsoles");
		
		USABERUtilsWidget_GetDisablePlayerStatisticsForConsoles_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05720C00
	 * 		Name   -> Function Insurgency.SABERUtilsWidget.GetDisablePlayerCounterForConsoles
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 */
	bool USABERUtilsWidget::STATIC_GetDisablePlayerCounterForConsoles()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.SABERUtilsWidget.GetDisablePlayerCounterForConsoles");
		
		USABERUtilsWidget_GetDisablePlayerCounterForConsoles_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05720BD0
	 * 		Name   -> Function Insurgency.SABERUtilsWidget.GetDisablePartyButtonForConsoles
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 */
	bool USABERUtilsWidget::STATIC_GetDisablePartyButtonForConsoles()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.SABERUtilsWidget.GetDisablePartyButtonForConsoles");
		
		USABERUtilsWidget_GetDisablePartyButtonForConsoles_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05720BA0
	 * 		Name   -> Function Insurgency.SABERUtilsWidget.GetDisableOtherScenarioButton
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 */
	bool USABERUtilsWidget::STATIC_GetDisableOtherScenarioButton()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.SABERUtilsWidget.GetDisableOtherScenarioButton");
		
		USABERUtilsWidget_GetDisableOtherScenarioButton_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05720B70
	 * 		Name   -> Function Insurgency.SABERUtilsWidget.GetDisableOnlineStoreForConsoles
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 */
	bool USABERUtilsWidget::STATIC_GetDisableOnlineStoreForConsoles()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.SABERUtilsWidget.GetDisableOnlineStoreForConsoles");
		
		USABERUtilsWidget_GetDisableOnlineStoreForConsoles_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05720B40
	 * 		Name   -> Function Insurgency.SABERUtilsWidget.GetDisableNewsWidgetsForConsoles
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 */
	bool USABERUtilsWidget::STATIC_GetDisableNewsWidgetsForConsoles()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.SABERUtilsWidget.GetDisableNewsWidgetsForConsoles");
		
		USABERUtilsWidget_GetDisableNewsWidgetsForConsoles_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05720B10
	 * 		Name   -> Function Insurgency.SABERUtilsWidget.GetDisableInventoryForConsoles
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 */
	bool USABERUtilsWidget::STATIC_GetDisableInventoryForConsoles()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.SABERUtilsWidget.GetDisableInventoryForConsoles");
		
		USABERUtilsWidget_GetDisableInventoryForConsoles_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05720AE0
	 * 		Name   -> Function Insurgency.SABERUtilsWidget.GetDisableFilterCommunityForConsoles
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 */
	bool USABERUtilsWidget::STATIC_GetDisableFilterCommunityForConsoles()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.SABERUtilsWidget.GetDisableFilterCommunityForConsoles");
		
		USABERUtilsWidget_GetDisableFilterCommunityForConsoles_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05720AB0
	 * 		Name   -> Function Insurgency.SABERUtilsWidget.GetDisableDLCContentForConsoles
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 */
	bool USABERUtilsWidget::STATIC_GetDisableDLCContentForConsoles()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.SABERUtilsWidget.GetDisableDLCContentForConsoles");
		
		USABERUtilsWidget_GetDisableDLCContentForConsoles_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05720A80
	 * 		Name   -> Function Insurgency.SABERUtilsWidget.GetDisableCreditMenuForConsoles
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 */
	bool USABERUtilsWidget::STATIC_GetDisableCreditMenuForConsoles()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.SABERUtilsWidget.GetDisableCreditMenuForConsoles");
		
		USABERUtilsWidget_GetDisableCreditMenuForConsoles_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05720A50
	 * 		Name   -> Function Insurgency.SABERUtilsWidget.GetDisableCompetitiveModeForConsoles
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 */
	bool USABERUtilsWidget::STATIC_GetDisableCompetitiveModeForConsoles()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.SABERUtilsWidget.GetDisableCompetitiveModeForConsoles");
		
		USABERUtilsWidget_GetDisableCompetitiveModeForConsoles_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05720A20
	 * 		Name   -> Function Insurgency.SABERUtilsWidget.GetDisableBindsSettingSectionForConsoles
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 */
	bool USABERUtilsWidget::STATIC_GetDisableBindsSettingSectionForConsoles()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.SABERUtilsWidget.GetDisableBindsSettingSectionForConsoles");
		
		USABERUtilsWidget_GetDisableBindsSettingSectionForConsoles_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x057209F0
	 * 		Name   -> Function Insurgency.SABERUtilsWidget.Get
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 */
	class USABERUtilsWidget* USABERUtilsWidget::STATIC_Get()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.SABERUtilsWidget.Get");
		
		USABERUtilsWidget_Get_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x057208A0
	 * 		Name   -> Function Insurgency.SABERUtilsWidget.ConvertUniqueNetIdReplToString
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FUniqueNetIdRepl                            UniqueId                                                   (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class FString USABERUtilsWidget::STATIC_ConvertUniqueNetIdReplToString(const struct FUniqueNetIdRepl& UniqueId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.SABERUtilsWidget.ConvertUniqueNetIdReplToString");
		
		USABERUtilsWidget_ConvertUniqueNetIdReplToString_Params params {};
		params.UniqueId = UniqueId;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05720710
	 * 		Name   -> Function Insurgency.SABERUtilsWidget.ConvertStringToUniqueNetIdRepl
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class FString                                      InStringUniqueId                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FUniqueNetIdRepl USABERUtilsWidget::STATIC_ConvertStringToUniqueNetIdRepl(const class FString& InStringUniqueId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.SABERUtilsWidget.ConvertStringToUniqueNetIdRepl");
		
		USABERUtilsWidget_ConvertStringToUniqueNetIdRepl_Params params {};
		params.InStringUniqueId = InStringUniqueId;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction USABERUtilsWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* USABERUtilsWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.SABERUtilsWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05722520
	 * 		Name   -> Function Insurgency.SemperParatus.OnDamagedBlocked
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		float                                              Damage                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UClass*                                      DamageTypeClass                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AController*                                 EventInstigator                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      DamageCauser                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void USemperParatus::OnDamagedBlocked(float Damage, class UClass* DamageTypeClass, class AController* EventInstigator, class AActor* DamageCauser)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.SemperParatus.OnDamagedBlocked");
		
		USemperParatus_OnDamagedBlocked_Params params {};
		params.Damage = Damage;
		params.DamageTypeClass = DamageTypeClass;
		params.EventInstigator = EventInstigator;
		params.DamageCauser = DamageCauser;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction USemperParatus.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* USemperParatus::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.SemperParatus");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05722B40
	 * 		Name   -> Function Insurgency.TakeTheWheelAchievement.OnSeatTakenOver
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		class AINSCharacter*                               OldCharacter                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AController*                                 Controller                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UTakeTheWheelAchievement::OnSeatTakenOver(class AINSCharacter* OldCharacter, class AController* Controller)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.TakeTheWheelAchievement.OnSeatTakenOver");
		
		UTakeTheWheelAchievement_OnSeatTakenOver_Params params {};
		params.OldCharacter = OldCharacter;
		params.Controller = Controller;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UTakeTheWheelAchievement.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UTakeTheWheelAchievement::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.TakeTheWheelAchievement");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05722670
	 * 		Name   -> Function Insurgency.DesignatedDriverAchievement.OnDesignatedDriver
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		class AINSBasePlayerController*                    PC                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UDesignatedDriverAchievement::OnDesignatedDriver(class AINSBasePlayerController* PC)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.DesignatedDriverAchievement.OnDesignatedDriver");
		
		UDesignatedDriverAchievement_OnDesignatedDriver_Params params {};
		params.PC = PC;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDesignatedDriverAchievement.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDesignatedDriverAchievement::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.DesignatedDriverAchievement");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05722A10
	 * 		Name   -> Function Insurgency.MVPAchievement.OnRoundOver
	 * 		Flags  -> (Final, Native, Public, HasOutParms)
	 * Parameters:
	 * 		ERoundConclusion                                   RoundEndReason                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		unsigned char                                      WinningFaction                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		TArray<struct FOtherPlayerAwardedTagline>          Taglines                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UMVPAchievement::OnRoundOver(ERoundConclusion RoundEndReason, unsigned char WinningFaction, TArray<struct FOtherPlayerAwardedTagline> Taglines)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.MVPAchievement.OnRoundOver");
		
		UMVPAchievement_OnRoundOver_Params params {};
		params.RoundEndReason = RoundEndReason;
		params.WinningFaction = WinningFaction;
		params.Taglines = Taglines;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMVPAchievement.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMVPAchievement::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.MVPAchievement");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05722840
	 * 		Name   -> Function Insurgency.PlayToWin.OnRecievedObjectiveCaptured
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		class AINSPlayerController*                        PC                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AObjectiveCapturable*                        Objective                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		unsigned char                                      OldOwners                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		unsigned char                                      NewOwners                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UPlayToWin::OnRecievedObjectiveCaptured(class AINSPlayerController* PC, class AObjectiveCapturable* Objective, unsigned char OldOwners, unsigned char NewOwners)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.PlayToWin.OnRecievedObjectiveCaptured");
		
		UPlayToWin_OnRecievedObjectiveCaptured_Params params {};
		params.PC = PC;
		params.Objective = Objective;
		params.OldOwners = OldOwners;
		params.NewOwners = NewOwners;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UPlayToWin.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UPlayToWin::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.PlayToWin");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05722990
	 * 		Name   -> Function Insurgency.ThereForYou.OnRequestSupport
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		class AINSPlayerController*                        PlayerController                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UThereForYou::OnRequestSupport(class AINSPlayerController* PlayerController)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ThereForYou.OnRequestSupport");
		
		UThereForYou_OnRequestSupport_Params params {};
		params.PlayerController = PlayerController;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UThereForYou.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UThereForYou::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.ThereForYou");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05722780
	 * 		Name   -> Function Insurgency.GameModeAchievement.OnMatchEnd
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		unsigned char                                      WinningFaction                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UClass*                                      GameMode                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UGameModeAchievement::OnMatchEnd(unsigned char WinningFaction, class UClass* GameMode)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.GameModeAchievement.OnMatchEnd");
		
		UGameModeAchievement_OnMatchEnd_Params params {};
		params.WinningFaction = WinningFaction;
		params.GameMode = GameMode;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGameModeAchievement.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGameModeAchievement::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.GameModeAchievement");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UCTBVictory.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UCTBVictory::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.CTBVictory");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction USkirmishVictory.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* USkirmishVictory::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.SkirmishVictory");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UFirefightVictory.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UFirefightVictory::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.FirefightVictory");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UPushVictory.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UPushVictory::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.PushVictory");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UCheckpointVictory.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UCheckpointVictory::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.CheckpointVictory");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UWetFeet.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UWetFeet::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.WetFeet");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction USandstormGauntletBenchmarkReplay.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* USandstormGauntletBenchmarkReplay::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.SandstormGauntletBenchmarkReplay");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction USandstormGauntletBootTest.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* USandstormGauntletBootTest::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.SandstormGauntletBootTest");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction USandstormGauntletBotGameplay.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* USandstormGauntletBotGameplay::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.SandstormGauntletBotGameplay");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction USandstormGauntletGeneratePakOrder.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* USandstormGauntletGeneratePakOrder::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.SandstormGauntletGeneratePakOrder");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05695FE0
	 * 		Name   -> Function Insurgency.SandstormGauntletLevelFlythrough.OnHealthSnapshot
	 * 		Flags  -> (Final, Native, Protected)
	 */
	void USandstormGauntletLevelFlythrough::OnHealthSnapshot()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.SandstormGauntletLevelFlythrough.OnHealthSnapshot");
		
		USandstormGauntletLevelFlythrough_OnHealthSnapshot_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x057234A0
	 * 		Name   -> Function Insurgency.SandstormGauntletLevelFlythrough.OnBenchmarkStart
	 * 		Flags  -> (Final, Native, Protected)
	 */
	void USandstormGauntletLevelFlythrough::OnBenchmarkStart()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.SandstormGauntletLevelFlythrough.OnBenchmarkStart");
		
		USandstormGauntletLevelFlythrough_OnBenchmarkStart_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05723480
	 * 		Name   -> Function Insurgency.SandstormGauntletLevelFlythrough.OnBenchmarkFinished
	 * 		Flags  -> (Final, Native, Protected)
	 */
	void USandstormGauntletLevelFlythrough::OnBenchmarkFinished()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.SandstormGauntletLevelFlythrough.OnBenchmarkFinished");
		
		USandstormGauntletLevelFlythrough_OnBenchmarkFinished_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction USandstormGauntletLevelFlythrough.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* USandstormGauntletLevelFlythrough::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.SandstormGauntletLevelFlythrough");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05695FE0
	 * 		Name   -> Function Insurgency.SandstormGauntletSmokeBuild.OnHealthSnapshot
	 * 		Flags  -> (Final, Native, Protected)
	 */
	void USandstormGauntletSmokeBuild::OnHealthSnapshot()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.SandstormGauntletSmokeBuild.OnHealthSnapshot");
		
		USandstormGauntletSmokeBuild_OnHealthSnapshot_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction USandstormGauntletSmokeBuild.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* USandstormGauntletSmokeBuild::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.SandstormGauntletSmokeBuild");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction USandstormStatsCollectionComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* USandstormStatsCollectionComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.SandstormStatsCollectionComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UScenarioBase.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UScenarioBase::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.ScenarioBase");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AScenarioLevelFactory.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AScenarioLevelFactory::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.ScenarioLevelFactory");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UScenarioMission.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UScenarioMission::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.ScenarioMission");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UScenarioMultiplayer.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UScenarioMultiplayer::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.ScenarioMultiplayer");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05725630
	 * 		Name   -> Function Insurgency.ScoreboardBadgeSettings.IsValidBadgeIndex
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		int32_t                                            BadgeIndex                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UScoreboardBadgeSettings::IsValidBadgeIndex(int32_t BadgeIndex)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ScoreboardBadgeSettings.IsValidBadgeIndex");
		
		UScoreboardBadgeSettings_IsValidBadgeIndex_Params params {};
		params.BadgeIndex = BadgeIndex;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05725600
	 * 		Name   -> Function Insurgency.ScoreboardBadgeSettings.GetScoreboardBadgeSettings
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 */
	class UScoreboardBadgeSettings* UScoreboardBadgeSettings::STATIC_GetScoreboardBadgeSettings()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ScoreboardBadgeSettings.GetScoreboardBadgeSettings");
		
		UScoreboardBadgeSettings_GetScoreboardBadgeSettings_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05725550
	 * 		Name   -> Function Insurgency.ScoreboardBadgeSettings.GetScoreboardBadgeImage
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		int32_t                                            BadgeIndex                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UScoreboardBadgeSettings::GetScoreboardBadgeImage(int32_t BadgeIndex)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ScoreboardBadgeSettings.GetScoreboardBadgeImage");
		
		UScoreboardBadgeSettings_GetScoreboardBadgeImage_Params params {};
		params.BadgeIndex = BadgeIndex;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x057254C0
	 * 		Name   -> Function Insurgency.ScoreboardBadgeSettings.GetItemIdFromBadgeIndex
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		int32_t                                            BadgeIndex                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	int32_t UScoreboardBadgeSettings::GetItemIdFromBadgeIndex(int32_t BadgeIndex)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ScoreboardBadgeSettings.GetItemIdFromBadgeIndex");
		
		UScoreboardBadgeSettings_GetItemIdFromBadgeIndex_Params params {};
		params.BadgeIndex = BadgeIndex;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05725430
	 * 		Name   -> Function Insurgency.ScoreboardBadgeSettings.GetBadgeIndexByItemId
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		int32_t                                            ItemId                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	int32_t UScoreboardBadgeSettings::GetBadgeIndexByItemId(int32_t ItemId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ScoreboardBadgeSettings.GetBadgeIndexByItemId");
		
		UScoreboardBadgeSettings_GetBadgeIndexByItemId_Params params {};
		params.ItemId = ItemId;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UScoreboardBadgeSettings.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UScoreboardBadgeSettings::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.ScoreboardBadgeSettings");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> Function Insurgency.ScoreboardBase.OnScoreboardShown
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 */
	void UScoreboardBase::OnScoreboardShown()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ScoreboardBase.OnScoreboardShown");
		
		UScoreboardBase_OnScoreboardShown_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> Function Insurgency.ScoreboardBase.OnScoreboardHidden
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 */
	void UScoreboardBase::OnScoreboardHidden()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ScoreboardBase.OnScoreboardHidden");
		
		UScoreboardBase_OnScoreboardHidden_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UScoreboardBase.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UScoreboardBase::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.ScoreboardBase");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UServerListEntry.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UServerListEntry::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.ServerListEntry");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction USharedCosmeticState.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* USharedCosmeticState::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.SharedCosmeticState");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> Function Insurgency.SmartActor.ShouldFinish
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		class AINSAISoldierController*                     Me                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool ASmartActor::ShouldFinish(class AINSAISoldierController* Me)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.SmartActor.ShouldFinish");
		
		ASmartActor_ShouldFinish_Params params {};
		params.Me = Me;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05726EC0
	 * 		Name   -> Function Insurgency.SmartActor.SetEnabled
	 * 		Flags  -> (Final, Native, Protected, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bNewEnabled                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASmartActor::SetEnabled(bool bNewEnabled)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.SmartActor.SetEnabled");
		
		ASmartActor_SetEnabled_Params params {};
		params.bNewEnabled = bNewEnabled;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> Function Insurgency.SmartActor.OnUpdate
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 * Parameters:
	 * 		class AINSAISoldierController*                     Me                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASmartActor::OnUpdate(class AINSAISoldierController* Me)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.SmartActor.OnUpdate");
		
		ASmartActor_OnUpdate_Params params {};
		params.Me = Me;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> Function Insurgency.SmartActor.OnStart
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 * Parameters:
	 * 		class AINSAISoldierController*                     Me                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASmartActor::OnStart(class AINSAISoldierController* Me)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.SmartActor.OnStart");
		
		ASmartActor_OnStart_Params params {};
		params.Me = Me;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> Function Insurgency.SmartActor.OnFinish
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 * Parameters:
	 * 		class AINSAISoldierController*                     Me                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASmartActor::OnFinish(class AINSAISoldierController* Me)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.SmartActor.OnFinish");
		
		ASmartActor_OnFinish_Params params {};
		params.Me = Me;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05726DF0
	 * 		Name   -> Function Insurgency.SmartActor.HasVisibleEnemyAndWithinRadiusToSmartActor
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class AINSAISoldierController*                     Me                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Radius                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool ASmartActor::HasVisibleEnemyAndWithinRadiusToSmartActor(class AINSAISoldierController* Me, float Radius)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.SmartActor.HasVisibleEnemyAndWithinRadiusToSmartActor");
		
		ASmartActor_HasVisibleEnemyAndWithinRadiusToSmartActor_Params params {};
		params.Me = Me;
		params.Radius = Radius;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> Function Insurgency.SmartActor.CanInteract
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		class AINSAISoldierController*                     Me                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool ASmartActor::CanInteract(class AINSAISoldierController* Me)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.SmartActor.CanInteract");
		
		ASmartActor_CanInteract_Params params {};
		params.Me = Me;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ASmartActor.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ASmartActor::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.SmartActor");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05728720
	 * 		Name   -> Function Insurgency.SoldierMovementComponent.Server_ToggleLadderADS
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
	 * Parameters:
	 * 		ELadderState                                       ViewState                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void USoldierMovementComponent::Server_ToggleLadderADS(ELadderState ViewState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.SoldierMovementComponent.Server_ToggleLadderADS");
		
		USoldierMovementComponent_Server_ToggleLadderADS_Params params {};
		params.ViewState = ViewState;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x057286D0
	 * 		Name   -> Function Insurgency.SoldierMovementComponent.Server_StopVaulting
	 * 		Flags  -> (Final, Net, NetReliable, Native, Event, Private, NetServer, NetValidate)
	 */
	void USoldierMovementComponent::Server_StopVaulting()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.SoldierMovementComponent.Server_StopVaulting");
		
		USoldierMovementComponent_Server_StopVaulting_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05728550
	 * 		Name   -> Function Insurgency.SoldierMovementComponent.Server_PerformVaultAction
	 * 		Flags  -> (Final, Net, NetReliable, Native, Event, Private, NetServer, HasDefaults, NetValidate)
	 * Parameters:
	 * 		struct FVector                                     Location                                                   (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EVaultAction                                       VaultAction                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     InVaultTraceImpactPoint                                    (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Speed                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void USoldierMovementComponent::Server_PerformVaultAction(const struct FVector& Location, EVaultAction VaultAction, const struct FVector& InVaultTraceImpactPoint, float Speed)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.SoldierMovementComponent.Server_PerformVaultAction");
		
		USoldierMovementComponent_Server_PerformVaultAction_Params params {};
		params.Location = Location;
		params.VaultAction = VaultAction;
		params.InVaultTraceImpactPoint = InVaultTraceImpactPoint;
		params.Speed = Speed;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05728500
	 * 		Name   -> Function Insurgency.SoldierMovementComponent.Server_LeapFromLadder
	 * 		Flags  -> (Net, NetReliable, Native, Event, Protected, NetServer, NetValidate)
	 */
	void USoldierMovementComponent::Server_LeapFromLadder()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.SoldierMovementComponent.Server_LeapFromLadder");
		
		USoldierMovementComponent_Server_LeapFromLadder_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05728450
	 * 		Name   -> Function Insurgency.SoldierMovementComponent.Server_ExitLadder
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
	 * Parameters:
	 * 		ELadderState                                       ExitState                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void USoldierMovementComponent::Server_ExitLadder(ELadderState ExitState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.SoldierMovementComponent.Server_ExitLadder");
		
		USoldierMovementComponent_Server_ExitLadder_Params params {};
		params.ExitState = ExitState;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05728350
	 * 		Name   -> Function Insurgency.SoldierMovementComponent.Server_EnterLadder
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
	 * Parameters:
	 * 		ELadderState                                       ExitState                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class ALadder*                                     Ladder                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void USoldierMovementComponent::Server_EnterLadder(ELadderState ExitState, class ALadder* Ladder)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.SoldierMovementComponent.Server_EnterLadder");
		
		USoldierMovementComponent_Server_EnterLadder_Params params {};
		params.ExitState = ExitState;
		params.Ladder = Ladder;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05728330
	 * 		Name   -> Function Insurgency.SoldierMovementComponent.Server_EndCharge
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetServer)
	 */
	void USoldierMovementComponent::Server_EndCharge()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.SoldierMovementComponent.Server_EndCharge");
		
		USoldierMovementComponent_Server_EndCharge_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x057282B0
	 * 		Name   -> Function Insurgency.SoldierMovementComponent.Server_ChargeHit
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetServer)
	 * Parameters:
	 * 		class AActor*                                      HitActor                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void USoldierMovementComponent::Server_ChargeHit(class AActor* HitActor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.SoldierMovementComponent.Server_ChargeHit");
		
		USoldierMovementComponent_Server_ChargeHit_Params params {};
		params.HitActor = HitActor;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05728260
	 * 		Name   -> Function Insurgency.SoldierMovementComponent.Server_Charge
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
	 */
	void USoldierMovementComponent::Server_Charge()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.SoldierMovementComponent.Server_Charge");
		
		USoldierMovementComponent_Server_Charge_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05728210
	 * 		Name   -> Function Insurgency.SoldierMovementComponent.Server_CancelVault
	 * 		Flags  -> (Final, Net, NetReliable, Native, Event, Private, NetServer, NetValidate)
	 */
	void USoldierMovementComponent::Server_CancelVault()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.SoldierMovementComponent.Server_CancelVault");
		
		USoldierMovementComponent_Server_CancelVault_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x04DB38C0
	 * 		Name   -> Function Insurgency.SoldierMovementComponent.Multicast_HandleChargeRecoil
	 * 		Flags  -> (Net, NetReliable, Native, Event, NetMulticast, Protected)
	 */
	void USoldierMovementComponent::Multicast_HandleChargeRecoil()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.SoldierMovementComponent.Multicast_HandleChargeRecoil");
		
		USoldierMovementComponent_Multicast_HandleChargeRecoil_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x057281E0
	 * 		Name   -> Function Insurgency.SoldierMovementComponent.IsVaultActionClimbAction
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool USoldierMovementComponent::IsVaultActionClimbAction()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.SoldierMovementComponent.IsVaultActionClimbAction");
		
		USoldierMovementComponent_IsVaultActionClimbAction_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x057281B0
	 * 		Name   -> Function Insurgency.SoldierMovementComponent.IsCurrentlyVaulting
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool USoldierMovementComponent::IsCurrentlyVaulting()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.SoldierMovementComponent.IsCurrentlyVaulting");
		
		USoldierMovementComponent_IsCurrentlyVaulting_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05728180
	 * 		Name   -> Function Insurgency.SoldierMovementComponent.InChargeMode
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool USoldierMovementComponent::InChargeMode()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.SoldierMovementComponent.InChargeMode");
		
		USoldierMovementComponent_InChargeMode_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05728150
	 * 		Name   -> Function Insurgency.SoldierMovementComponent.HasSprintEnoughForFullSprint
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool USoldierMovementComponent::HasSprintEnoughForFullSprint()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.SoldierMovementComponent.HasSprintEnoughForFullSprint");
		
		USoldierMovementComponent_HasSprintEnoughForFullSprint_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05727FA0
	 * 		Name   -> Function Insurgency.SoldierMovementComponent.GetWalkingMaxSpeed
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	float USoldierMovementComponent::GetWalkingMaxSpeed()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.SoldierMovementComponent.GetWalkingMaxSpeed");
		
		USoldierMovementComponent_GetWalkingMaxSpeed_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05728120
	 * 		Name   -> Function Insurgency.SoldierMovementComponent.GetTimeSinceLastCharge
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	float USoldierMovementComponent::GetTimeSinceLastCharge()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.SoldierMovementComponent.GetTimeSinceLastCharge");
		
		USoldierMovementComponent_GetTimeSinceLastCharge_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x057280F0
	 * 		Name   -> Function Insurgency.SoldierMovementComponent.GetStance
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	ESoldierStance USoldierMovementComponent::GetStance()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.SoldierMovementComponent.GetStance");
		
		USoldierMovementComponent_GetStance_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x057280C0
	 * 		Name   -> Function Insurgency.SoldierMovementComponent.GetMovementSpeedScaling
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	float USoldierMovementComponent::GetMovementSpeedScaling()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.SoldierMovementComponent.GetMovementSpeedScaling");
		
		USoldierMovementComponent_GetMovementSpeedScaling_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05728090
	 * 		Name   -> Function Insurgency.SoldierMovementComponent.GetMaxWalkingSpeed
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	float USoldierMovementComponent::GetMaxWalkingSpeed()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.SoldierMovementComponent.GetMaxWalkingSpeed");
		
		USoldierMovementComponent_GetMaxWalkingSpeed_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05728060
	 * 		Name   -> Function Insurgency.SoldierMovementComponent.GetMaxSprintSpeed
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	float USoldierMovementComponent::GetMaxSprintSpeed()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.SoldierMovementComponent.GetMaxSprintSpeed");
		
		USoldierMovementComponent_GetMaxSprintSpeed_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05727FD0
	 * 		Name   -> Function Insurgency.SoldierMovementComponent.GetMaxSpeedForStance
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		ESoldierStance                                     Stance                                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	float USoldierMovementComponent::GetMaxSpeedForStance(ESoldierStance Stance)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.SoldierMovementComponent.GetMaxSpeedForStance");
		
		USoldierMovementComponent_GetMaxSpeedForStance_Params params {};
		params.Stance = Stance;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05727FA0
	 * 		Name   -> Function Insurgency.SoldierMovementComponent.GetMaxSpeedForCurrentStance
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	float USoldierMovementComponent::GetMaxSpeedForCurrentStance()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.SoldierMovementComponent.GetMaxSpeedForCurrentStance");
		
		USoldierMovementComponent_GetMaxSpeedForCurrentStance_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05727F70
	 * 		Name   -> Function Insurgency.SoldierMovementComponent.GetMaxSlideSpeed
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	float USoldierMovementComponent::GetMaxSlideSpeed()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.SoldierMovementComponent.GetMaxSlideSpeed");
		
		USoldierMovementComponent_GetMaxSlideSpeed_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05727F40
	 * 		Name   -> Function Insurgency.SoldierMovementComponent.GetMaxRunSpeed
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	float USoldierMovementComponent::GetMaxRunSpeed()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.SoldierMovementComponent.GetMaxRunSpeed");
		
		USoldierMovementComponent_GetMaxRunSpeed_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05727F10
	 * 		Name   -> Function Insurgency.SoldierMovementComponent.GetMaxProneSpeed
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	float USoldierMovementComponent::GetMaxProneSpeed()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.SoldierMovementComponent.GetMaxProneSpeed");
		
		USoldierMovementComponent_GetMaxProneSpeed_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05727E80
	 * 		Name   -> Function Insurgency.SoldierMovementComponent.GetHeightForStance
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		ESoldierStance                                     Stance                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	float USoldierMovementComponent::GetHeightForStance(ESoldierStance Stance)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.SoldierMovementComponent.GetHeightForStance");
		
		USoldierMovementComponent_GetHeightForStance_Params params {};
		params.Stance = Stance;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05727E00
	 * 		Name   -> Function Insurgency.SoldierMovementComponent.ClientExitLadder
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetClient)
	 * Parameters:
	 * 		ELadderState                                       ExitState                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void USoldierMovementComponent::ClientExitLadder(ELadderState ExitState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.SoldierMovementComponent.ClientExitLadder");
		
		USoldierMovementComponent_ClientExitLadder_Params params {};
		params.ExitState = ExitState;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05727DD0
	 * 		Name   -> Function Insurgency.SoldierMovementComponent.CanPerformVaultAction
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool USoldierMovementComponent::CanPerformVaultAction()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.SoldierMovementComponent.CanPerformVaultAction");
		
		USoldierMovementComponent_CanPerformVaultAction_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05727DA0
	 * 		Name   -> Function Insurgency.SoldierMovementComponent.AllowVaulting
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool USoldierMovementComponent::AllowVaulting()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.SoldierMovementComponent.AllowVaulting");
		
		USoldierMovementComponent_AllowVaulting_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction USoldierMovementComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* USoldierMovementComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.SoldierMovementComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction USoldierPathFollowingComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* USoldierPathFollowingComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.SoldierPathFollowingComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> DelegateFunction Insurgency.SoundscapeComponent.SoundscapeUpdate__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate, HasOutParms)
	 * Parameters:
	 * 		struct FSoundscapeStateRepl                        State                                                      (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void USoundscapeComponent::SoundscapeUpdate__DelegateSignature(const struct FSoundscapeStateRepl& State)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction Insurgency.SoundscapeComponent.SoundscapeUpdate__DelegateSignature");
		
		USoundscapeComponent_SoundscapeUpdate__DelegateSignature_Params params {};
		params.State = State;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05729620
	 * 		Name   -> Function Insurgency.SoundscapeComponent.OnRep_ReplicatedState
	 * 		Flags  -> (Final, Native, Public)
	 */
	void USoundscapeComponent::OnRep_ReplicatedState()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.SoundscapeComponent.OnRep_ReplicatedState");
		
		USoundscapeComponent_OnRep_ReplicatedState_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05729600
	 * 		Name   -> Function Insurgency.SoundscapeComponent.OnRep_BaseIndoorDefinition
	 * 		Flags  -> (Final, Native, Public)
	 */
	void USoundscapeComponent::OnRep_BaseIndoorDefinition()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.SoundscapeComponent.OnRep_BaseIndoorDefinition");
		
		USoundscapeComponent_OnRep_BaseIndoorDefinition_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05729580
	 * 		Name   -> Function Insurgency.SoundscapeComponent.OnEndTouchingTransitionSphere
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		class ASoundscapeTriggerDoor*                      TriggerActor                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void USoundscapeComponent::OnEndTouchingTransitionSphere(class ASoundscapeTriggerDoor* TriggerActor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.SoundscapeComponent.OnEndTouchingTransitionSphere");
		
		USoundscapeComponent_OnEndTouchingTransitionSphere_Params params {};
		params.TriggerActor = TriggerActor;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05729500
	 * 		Name   -> Function Insurgency.SoundscapeComponent.OnEndTouchingOutdoorVolume
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		class ASoundscapeOutdoorVolume*                    TriggerActor                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void USoundscapeComponent::OnEndTouchingOutdoorVolume(class ASoundscapeOutdoorVolume* TriggerActor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.SoundscapeComponent.OnEndTouchingOutdoorVolume");
		
		USoundscapeComponent_OnEndTouchingOutdoorVolume_Params params {};
		params.TriggerActor = TriggerActor;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05729480
	 * 		Name   -> Function Insurgency.SoundscapeComponent.OnBeginTouchingTransitionSphere
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		class ASoundscapeTriggerDoor*                      TriggerActor                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void USoundscapeComponent::OnBeginTouchingTransitionSphere(class ASoundscapeTriggerDoor* TriggerActor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.SoundscapeComponent.OnBeginTouchingTransitionSphere");
		
		USoundscapeComponent_OnBeginTouchingTransitionSphere_Params params {};
		params.TriggerActor = TriggerActor;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05729400
	 * 		Name   -> Function Insurgency.SoundscapeComponent.OnBeginTouchingOutdoorVolume
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		class ASoundscapeOutdoorVolume*                    TriggerActor                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void USoundscapeComponent::OnBeginTouchingOutdoorVolume(class ASoundscapeOutdoorVolume* TriggerActor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.SoundscapeComponent.OnBeginTouchingOutdoorVolume");
		
		USoundscapeComponent_OnBeginTouchingOutdoorVolume_Params params {};
		params.TriggerActor = TriggerActor;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction USoundscapeComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* USoundscapeComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.SoundscapeComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction USoundscapeDefinition.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* USoundscapeDefinition::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.SoundscapeDefinition");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ASoundscapeEmitter.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ASoundscapeEmitter::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.SoundscapeEmitter");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0572A1C0
	 * 		Name   -> Function Insurgency.SoundscapeOutdoorVolume.OnEndOverlap
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		class UPrimitiveComponent*                         OverlappedComponent                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      OtherActor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UPrimitiveComponent*                         OtherComp                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            OtherBodyIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASoundscapeOutdoorVolume::OnEndOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32_t OtherBodyIndex)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.SoundscapeOutdoorVolume.OnEndOverlap");
		
		ASoundscapeOutdoorVolume_OnEndOverlap_Params params {};
		params.OverlappedComponent = OverlappedComponent;
		params.OtherActor = OtherActor;
		params.OtherComp = OtherComp;
		params.OtherBodyIndex = OtherBodyIndex;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05729FB0
	 * 		Name   -> Function Insurgency.SoundscapeOutdoorVolume.OnBeginOverlap
	 * 		Flags  -> (Final, Native, Public, HasOutParms)
	 * Parameters:
	 * 		class UPrimitiveComponent*                         OverlappedComponent                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      OtherActor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UPrimitiveComponent*                         OtherComp                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            OtherBodyIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bFromSweep                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FHitResult                                  SweepResult                                                (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	void ASoundscapeOutdoorVolume::OnBeginOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32_t OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.SoundscapeOutdoorVolume.OnBeginOverlap");
		
		ASoundscapeOutdoorVolume_OnBeginOverlap_Params params {};
		params.OverlappedComponent = OverlappedComponent;
		params.OtherActor = OtherActor;
		params.OtherComp = OtherComp;
		params.OtherBodyIndex = OtherBodyIndex;
		params.bFromSweep = bFromSweep;
		params.SweepResult = SweepResult;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ASoundscapeOutdoorVolume.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ASoundscapeOutdoorVolume::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.SoundscapeOutdoorVolume");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction USoundscapeState.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* USoundscapeState::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.SoundscapeState");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0572A9F0
	 * 		Name   -> Function Insurgency.SoundscapeTriggerDoor.OnTransitionSphereEndOverlap
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		class UPrimitiveComponent*                         OverlappedComponent                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      OtherActor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UPrimitiveComponent*                         OtherComp                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            OtherBodyIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASoundscapeTriggerDoor::OnTransitionSphereEndOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32_t OtherBodyIndex)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.SoundscapeTriggerDoor.OnTransitionSphereEndOverlap");
		
		ASoundscapeTriggerDoor_OnTransitionSphereEndOverlap_Params params {};
		params.OverlappedComponent = OverlappedComponent;
		params.OtherActor = OtherActor;
		params.OtherComp = OtherComp;
		params.OtherBodyIndex = OtherBodyIndex;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0572A7E0
	 * 		Name   -> Function Insurgency.SoundscapeTriggerDoor.OnTransitionSphereBeginOverlap
	 * 		Flags  -> (Final, Native, Public, HasOutParms)
	 * Parameters:
	 * 		class UPrimitiveComponent*                         OverlappedComponent                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      OtherActor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UPrimitiveComponent*                         OtherComp                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            OtherBodyIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bFromSweep                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FHitResult                                  SweepResult                                                (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	void ASoundscapeTriggerDoor::OnTransitionSphereBeginOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32_t OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.SoundscapeTriggerDoor.OnTransitionSphereBeginOverlap");
		
		ASoundscapeTriggerDoor_OnTransitionSphereBeginOverlap_Params params {};
		params.OverlappedComponent = OverlappedComponent;
		params.OtherActor = OtherActor;
		params.OtherComp = OtherComp;
		params.OtherBodyIndex = OtherBodyIndex;
		params.bFromSweep = bFromSweep;
		params.SweepResult = SweepResult;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0572A6A0
	 * 		Name   -> Function Insurgency.SoundscapeTriggerDoor.OnSoundscapeTriggerEndOverlap
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		class UPrimitiveComponent*                         OverlappedComponent                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      OtherActor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UPrimitiveComponent*                         OtherComp                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            OtherBodyIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASoundscapeTriggerDoor::OnSoundscapeTriggerEndOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32_t OtherBodyIndex)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.SoundscapeTriggerDoor.OnSoundscapeTriggerEndOverlap");
		
		ASoundscapeTriggerDoor_OnSoundscapeTriggerEndOverlap_Params params {};
		params.OverlappedComponent = OverlappedComponent;
		params.OtherActor = OtherActor;
		params.OtherComp = OtherComp;
		params.OtherBodyIndex = OtherBodyIndex;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ASoundscapeTriggerDoor.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ASoundscapeTriggerDoor::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.SoundscapeTriggerDoor");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x04DB39A0
	 * 		Name   -> Function Insurgency.SpawnerBase.SpawnPawns
	 * 		Flags  -> (Native, Public, BlueprintCallable)
	 */
	void ASpawnerBase::SpawnPawns()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.SpawnerBase.SpawnPawns");
		
		ASpawnerBase_SpawnPawns_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0572B310
	 * 		Name   -> Function Insurgency.SpawnerBase.SetTeamId
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		unsigned char                                      NewTeamId                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASpawnerBase::SetTeamId(unsigned char NewTeamId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.SpawnerBase.SetTeamId");
		
		ASpawnerBase_SetTeamId_Params params {};
		params.NewTeamId = NewTeamId;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0572B2F0
	 * 		Name   -> Function Insurgency.SpawnerBase.ResetKilledPawns
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void ASpawnerBase::ResetKilledPawns()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.SpawnerBase.ResetKilledPawns");
		
		ASpawnerBase_ResetKilledPawns_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0572B270
	 * 		Name   -> Function Insurgency.SpawnerBase.OnTeamReinforced
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		int32_t                                            PlayersSpawned                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASpawnerBase::OnTeamReinforced(int32_t PlayersSpawned)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.SpawnerBase.OnTeamReinforced");
		
		ASpawnerBase_OnTeamReinforced_Params params {};
		params.PlayersSpawned = PlayersSpawned;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0572B1F0
	 * 		Name   -> Function Insurgency.SpawnerBase.OnSpawnedControllerPossessed
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		class APawn*                                       NeWPawn                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASpawnerBase::OnSpawnedControllerPossessed(class APawn* NeWPawn)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.SpawnerBase.OnSpawnedControllerPossessed");
		
		ASpawnerBase_OnSpawnedControllerPossessed_Params params {};
		params.NeWPawn = NeWPawn;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0572B160
	 * 		Name   -> Function Insurgency.SpawnerBase.OnLinkedSpawnZoneToggled
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		bool                                               bNewState                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASpawnerBase::OnLinkedSpawnZoneToggled(bool bNewState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.SpawnerBase.OnLinkedSpawnZoneToggled");
		
		ASpawnerBase_OnLinkedSpawnZoneToggled_Params params {};
		params.bNewState = bNewState;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0572B130
	 * 		Name   -> Function Insurgency.SpawnerBase.IsUnderSpawnQuota
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool ASpawnerBase::IsUnderSpawnQuota()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.SpawnerBase.IsUnderSpawnQuota");
		
		ASpawnerBase_IsUnderSpawnQuota_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0572B100
	 * 		Name   -> Function Insurgency.SpawnerBase.IsSpawnRestricted
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool ASpawnerBase::IsSpawnRestricted()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.SpawnerBase.IsSpawnRestricted");
		
		ASpawnerBase_IsSpawnRestricted_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0572B080
	 * 		Name   -> Function Insurgency.SpawnerBase.GetSpawnedPawns
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
	 */
	TArray<class APawn*> ASpawnerBase::GetSpawnedPawns()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.SpawnerBase.GetSpawnedPawns");
		
		ASpawnerBase_GetSpawnedPawns_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0572B060
	 * 		Name   -> Function Insurgency.SpawnerBase.GetNumKilledPawns
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
	 */
	int32_t ASpawnerBase::GetNumKilledPawns()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.SpawnerBase.GetNumKilledPawns");
		
		ASpawnerBase_GetNumKilledPawns_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0572B030
	 * 		Name   -> Function Insurgency.SpawnerBase.GetExistingPawnCount
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	int32_t ASpawnerBase::GetExistingPawnCount()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.SpawnerBase.GetExistingPawnCount");
		
		ASpawnerBase_GetExistingPawnCount_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0572B000
	 * 		Name   -> Function Insurgency.SpawnerBase.GameStateAllowsSpawning
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool ASpawnerBase::GameStateAllowsSpawning()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.SpawnerBase.GameStateAllowsSpawning");
		
		ASpawnerBase_GameStateAllowsSpawning_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0572AF80
	 * 		Name   -> Function Insurgency.SpawnerBase.DeferredSpawnPawns
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		float                                              Delay                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASpawnerBase::DeferredSpawnPawns(float Delay)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.SpawnerBase.DeferredSpawnPawns");
		
		ASpawnerBase_DeferredSpawnPawns_Params params {};
		params.Delay = Delay;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x04DB4AC0
	 * 		Name   -> Function Insurgency.SpawnerBase.CleanupSpawnedPawns
	 * 		Flags  -> (Native, Public, BlueprintCallable)
	 */
	void ASpawnerBase::CleanupSpawnedPawns()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.SpawnerBase.CleanupSpawnedPawns");
		
		ASpawnerBase_CleanupSpawnedPawns_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x009DAA00
	 * 		Name   -> Function Insurgency.SpawnerBase.CheckPawnAbandonment
	 * 		Flags  -> (Native, Public, BlueprintCallable)
	 */
	void ASpawnerBase::CheckPawnAbandonment()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.SpawnerBase.CheckPawnAbandonment");
		
		ASpawnerBase_CheckPawnAbandonment_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056FC900
	 * 		Name   -> Function Insurgency.SpawnerBase.CanSpawnPawns
	 * 		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool ASpawnerBase::CanSpawnPawns()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.SpawnerBase.CanSpawnPawns");
		
		ASpawnerBase_CanSpawnPawns_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ASpawnerBase.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ASpawnerBase::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.SpawnerBase");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ASpawnerSquad.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ASpawnerSquad::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.SpawnerSquad");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0572B680
	 * 		Name   -> Function Insurgency.SpawnerVehicle.IsSpawnObstructed
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool ASpawnerVehicle::IsSpawnObstructed()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.SpawnerVehicle.IsSpawnObstructed");
		
		ASpawnerVehicle_IsSpawnObstructed_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ASpawnerVehicle.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ASpawnerVehicle::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.SpawnerVehicle");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction USpawnProtectedDamageReflectMessage.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* USpawnProtectedDamageReflectMessage::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.SpawnProtectedDamageReflectMessage");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction USpawnProtectedMessage.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* USpawnProtectedMessage::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.SpawnProtectedMessage");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0572BDC0
	 * 		Name   -> Function Insurgency.SpawnZone.SetTeamId
	 * 		Flags  -> (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		unsigned char                                      NewTeamId                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASpawnZone::SetTeamId(unsigned char NewTeamId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.SpawnZone.SetTeamId");
		
		ASpawnZone_SetTeamId_Params params {};
		params.NewTeamId = NewTeamId;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0572BD30
	 * 		Name   -> Function Insurgency.SpawnZone.SetEnabled
	 * 		Flags  -> (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bNewState                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASpawnZone::SetEnabled(bool bNewState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.SpawnZone.SetEnabled");
		
		ASpawnZone_SetEnabled_Params params {};
		params.bNewState = bNewState;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> DelegateFunction Insurgency.SpawnZone.OnSpawnZoneToggledDelegate__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 * Parameters:
	 * 		bool                                               bNewState                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASpawnZone::OnSpawnZoneToggledDelegate__DelegateSignature(bool bNewState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction Insurgency.SpawnZone.OnSpawnZoneToggledDelegate__DelegateSignature");
		
		ASpawnZone_OnSpawnZoneToggledDelegate__DelegateSignature_Params params {};
		params.bNewState = bNewState;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0572BD10
	 * 		Name   -> Function Insurgency.SpawnZone.OnRep_Enabled
	 * 		Flags  -> (Final, Native, Public)
	 */
	void ASpawnZone::OnRep_Enabled()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.SpawnZone.OnRep_Enabled");
		
		ASpawnZone_OnRep_Enabled_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0572BC90
	 * 		Name   -> Function Insurgency.SpawnZone.AssociateRestrictedArea
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class ARestrictedArea*                             Area                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASpawnZone::AssociateRestrictedArea(class ARestrictedArea* Area)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.SpawnZone.AssociateRestrictedArea");
		
		ASpawnZone_AssociateRestrictedArea_Params params {};
		params.Area = Area;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0572BC00
	 * 		Name   -> Function Insurgency.SpawnZone.AssociatePlayerStart
	 * 		Flags  -> (Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class AINSPlayerStart*                             PlayerStart                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASpawnZone::AssociatePlayerStart(class AINSPlayerStart* PlayerStart)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.SpawnZone.AssociatePlayerStart");
		
		ASpawnZone_AssociatePlayerStart_Params params {};
		params.PlayerStart = PlayerStart;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ASpawnZone.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ASpawnZone::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.SpawnZone");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ASpawnZoneCounterAttack.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ASpawnZoneCounterAttack::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.SpawnZoneCounterAttack");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0572C150
	 * 		Name   -> Function Insurgency.SpawnZoneTriggeredActorInterface.OnSpawnZoneEnabled
	 * 		Flags  -> (Native, Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		class ASpawnZone*                                  InSpawnZone                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bNewEnabled                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void USpawnZoneTriggeredActorInterface::OnSpawnZoneEnabled(class ASpawnZone* InSpawnZone, bool bNewEnabled)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.SpawnZoneTriggeredActorInterface.OnSpawnZoneEnabled");
		
		USpawnZoneTriggeredActorInterface_OnSpawnZoneEnabled_Params params {};
		params.InSpawnZone = InSpawnZone;
		params.bNewEnabled = bNewEnabled;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction USpawnZoneTriggeredActorInterface.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* USpawnZoneTriggeredActorInterface::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.SpawnZoneTriggeredActorInterface");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0572C5D0
	 * 		Name   -> Function Insurgency.SquadLayout.HasPlayerClassInLayout
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		class UPlayerClass*                                InPlayerClass                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool USquadLayout::HasPlayerClassInLayout(class UPlayerClass* InPlayerClass)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.SquadLayout.HasPlayerClassInLayout");
		
		USquadLayout_HasPlayerClassInLayout_Params params {};
		params.InPlayerClass = InPlayerClass;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction USquadLayout.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* USquadLayout::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.SquadLayout");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UStatAchievement.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UStatAchievement::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.StatAchievement");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UStationDialogueDictionary.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UStationDialogueDictionary::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.StationDialogueDictionary");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0572D440
	 * 		Name   -> Function Insurgency.StatisticsManager.VehicleDestroyedEvent
	 * 		Flags  -> (Final, Native, Public, HasOutParms)
	 * Parameters:
	 * 		class AController*                                 KillerPlayer                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		TArray<class AController*>                         AssisterPlayers                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UStatisticsManager::VehicleDestroyedEvent(class AController* KillerPlayer, TArray<class AController*> AssisterPlayers)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.StatisticsManager.VehicleDestroyedEvent");
		
		UStatisticsManager_VehicleDestroyedEvent_Params params {};
		params.KillerPlayer = KillerPlayer;
		params.AssisterPlayers = AssisterPlayers;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0572D2D0
	 * 		Name   -> Function Insurgency.StatisticsManager.ObjectiveEvent
	 * 		Flags  -> (Final, Native, Public, HasOutParms)
	 * Parameters:
	 * 		int32_t                                            ObjectiveId                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		unsigned char                                      OldOwners                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		unsigned char                                      NewOwners                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		TArray<class AINSPlayerState*>                     Capturers                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UStatisticsManager::ObjectiveEvent(int32_t ObjectiveId, unsigned char OldOwners, unsigned char NewOwners, TArray<class AINSPlayerState*> Capturers)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.StatisticsManager.ObjectiveEvent");
		
		UStatisticsManager_ObjectiveEvent_Params params {};
		params.ObjectiveId = ObjectiveId;
		params.OldOwners = OldOwners;
		params.NewOwners = NewOwners;
		params.Capturers = Capturers;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0572D160
	 * 		Name   -> Function Insurgency.StatisticsManager.ObjectiveDestroyedEvent
	 * 		Flags  -> (Final, Native, Public, HasOutParms)
	 * Parameters:
	 * 		class AObjectiveDestructible*                      Objective                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		unsigned char                                      OldOwners                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		unsigned char                                      NewOwners                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		TArray<class AINSPlayerState*>                     Capturers                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UStatisticsManager::ObjectiveDestroyedEvent(class AObjectiveDestructible* Objective, unsigned char OldOwners, unsigned char NewOwners, TArray<class AINSPlayerState*> Capturers)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.StatisticsManager.ObjectiveDestroyedEvent");
		
		UStatisticsManager_ObjectiveDestroyedEvent_Params params {};
		params.Objective = Objective;
		params.OldOwners = OldOwners;
		params.NewOwners = NewOwners;
		params.Capturers = Capturers;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0572CFF0
	 * 		Name   -> Function Insurgency.StatisticsManager.ObjectiveCapturedEvent
	 * 		Flags  -> (Final, Native, Public, HasOutParms)
	 * Parameters:
	 * 		class AObjectiveCapturable*                        Objective                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		unsigned char                                      OldOwners                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		unsigned char                                      NewOwners                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		TArray<class AINSPlayerState*>                     Capturers                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UStatisticsManager::ObjectiveCapturedEvent(class AObjectiveCapturable* Objective, unsigned char OldOwners, unsigned char NewOwners, TArray<class AINSPlayerState*> Capturers)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.StatisticsManager.ObjectiveCapturedEvent");
		
		UStatisticsManager_ObjectiveCapturedEvent_Params params {};
		params.Objective = Objective;
		params.OldOwners = OldOwners;
		params.NewOwners = NewOwners;
		params.Capturers = Capturers;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UStatisticsManager.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UStatisticsManager::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.StatisticsManager");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UStatisticsPlayer.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UStatisticsPlayer::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.StatisticsPlayer");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x057304E0
	 * 		Name   -> Function Insurgency.StatisticsProfile.SetWeaponStatsSortState
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		EeWeaponStatsSortState                             NewFilterState                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UStatisticsProfile::SetWeaponStatsSortState(EeWeaponStatsSortState NewFilterState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.StatisticsProfile.SetWeaponStatsSortState");
		
		UStatisticsProfile_SetWeaponStatsSortState_Params params {};
		params.NewFilterState = NewFilterState;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x057304C0
	 * 		Name   -> Function Insurgency.StatisticsProfile.Reset
	 * 		Flags  -> (Final, Native, Public)
	 */
	void UStatisticsProfile::Reset()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.StatisticsProfile.Reset");
		
		UStatisticsProfile_Reset_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05730410
	 * 		Name   -> Function Insurgency.StatisticsProfile.ParseProfileFromJsonString
	 * 		Flags  -> (Final, Native, Public, HasOutParms)
	 * Parameters:
	 * 		class FString                                      profileJson                                                (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UStatisticsProfile::ParseProfileFromJsonString(class FString* profileJson)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.StatisticsProfile.ParseProfileFromJsonString");
		
		UStatisticsProfile_ParseProfileFromJsonString_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (profileJson != nullptr)
			*profileJson = params.profileJson;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x057302F0
	 * 		Name   -> Function Insurgency.StatisticsProfile.GetWinRecord
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	TArray<struct FStatisticsPlayerWinRecordItem> UStatisticsProfile::GetWinRecord()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.StatisticsProfile.GetWinRecord");
		
		UStatisticsProfile_GetWinRecord_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05730220
	 * 		Name   -> Function Insurgency.StatisticsProfile.GetWinPercentForMode
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		class FString                                      ModeName                                                   (Parm, OutParm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class FString UStatisticsProfile::GetWinPercentForMode(class FString* ModeName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.StatisticsProfile.GetWinPercentForMode");
		
		UStatisticsProfile_GetWinPercentForMode_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (ModeName != nullptr)
			*ModeName = params.ModeName;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05730150
	 * 		Name   -> Function Insurgency.StatisticsProfile.GetWinPercentForMap
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		class FString                                      MapName                                                    (Parm, OutParm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class FString UStatisticsProfile::GetWinPercentForMap(class FString* MapName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.StatisticsProfile.GetWinPercentForMap");
		
		UStatisticsProfile_GetWinPercentForMap_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (MapName != nullptr)
			*MapName = params.MapName;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0572FFC0
	 * 		Name   -> Function Insurgency.StatisticsProfile.GetWeaponStats
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		TArray<struct FStatisticsPlayerWeaponStats>        inArray                                                    (Parm, OutParm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UStatisticsProfile::GetWeaponStats(TArray<struct FStatisticsPlayerWeaponStats>* inArray)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.StatisticsProfile.GetWeaponStats");
		
		UStatisticsProfile_GetWeaponStats_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (inArray != nullptr)
			*inArray = params.inArray;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0572FEF0
	 * 		Name   -> Function Insurgency.StatisticsProfile.GetTimePlayedForMode
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		class FString                                      ModeName                                                   (Parm, OutParm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class FString UStatisticsProfile::GetTimePlayedForMode(class FString* ModeName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.StatisticsProfile.GetTimePlayedForMode");
		
		UStatisticsProfile_GetTimePlayedForMode_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (ModeName != nullptr)
			*ModeName = params.ModeName;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0572FE20
	 * 		Name   -> Function Insurgency.StatisticsProfile.GetTimePlayedForMap
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		class FString                                      MapName                                                    (Parm, OutParm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class FString UStatisticsProfile::GetTimePlayedForMap(class FString* MapName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.StatisticsProfile.GetTimePlayedForMap");
		
		UStatisticsProfile_GetTimePlayedForMap_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (MapName != nullptr)
			*MapName = params.MapName;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0572FBF0
	 * 		Name   -> Function Insurgency.StatisticsProfile.GetStatsForWeapons
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		TArray<class FString>                              WeaponNames                                                (Parm, OutParm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bFilterByGameType                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bFilterByMode                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bFilterByMap                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	TMap<class FString, struct FStatisticsPlayerWeaponStats> UStatisticsProfile::GetStatsForWeapons(TArray<class FString>* WeaponNames, bool bFilterByGameType, bool bFilterByMode, bool bFilterByMap)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.StatisticsProfile.GetStatsForWeapons");
		
		UStatisticsProfile_GetStatsForWeapons_Params params {};
		params.bFilterByGameType = bFilterByGameType;
		params.bFilterByMode = bFilterByMode;
		params.bFilterByMap = bFilterByMap;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (WeaponNames != nullptr)
			*WeaponNames = params.WeaponNames;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0572FBC0
	 * 		Name   -> Function Insurgency.StatisticsProfile.GetScore
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	int32_t UStatisticsProfile::GetScore()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.StatisticsProfile.GetScore");
		
		UStatisticsProfile_GetScore_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0572F810
	 * 		Name   -> Function Insurgency.StatisticsProfile.GetScenarioStatsSummary
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bFilterMap                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bFilterMode                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bFilterGameType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bFilterTeam                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FStatisticsPlayerProfileScenarioStats UStatisticsProfile::GetScenarioStatsSummary(bool bFilterMap, bool bFilterMode, bool bFilterGameType, bool bFilterTeam)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.StatisticsProfile.GetScenarioStatsSummary");
		
		UStatisticsProfile_GetScenarioStatsSummary_Params params {};
		params.bFilterMap = bFilterMap;
		params.bFilterMode = bFilterMode;
		params.bFilterGameType = bFilterGameType;
		params.bFilterTeam = bFilterTeam;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0572F790
	 * 		Name   -> Function Insurgency.StatisticsProfile.GetRankTierForRank
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		int32_t                                            PlayerLevel                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	int32_t UStatisticsProfile::STATIC_GetRankTierForRank(int32_t PlayerLevel)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.StatisticsProfile.GetRankTierForRank");
		
		UStatisticsProfile_GetRankTierForRank_Params params {};
		params.PlayerLevel = PlayerLevel;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0572F710
	 * 		Name   -> Function Insurgency.StatisticsProfile.GetRankTierForExp
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		int32_t                                            PlayerExperience                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	int32_t UStatisticsProfile::STATIC_GetRankTierForExp(int32_t PlayerExperience)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.StatisticsProfile.GetRankTierForExp");
		
		UStatisticsProfile_GetRankTierForExp_Params params {};
		params.PlayerExperience = PlayerExperience;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0572F690
	 * 		Name   -> Function Insurgency.StatisticsProfile.GetRankProgressPercent
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		int32_t                                            PlayerExperience                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	float UStatisticsProfile::STATIC_GetRankProgressPercent(int32_t PlayerExperience)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.StatisticsProfile.GetRankProgressPercent");
		
		UStatisticsProfile_GetRankProgressPercent_Params params {};
		params.PlayerExperience = PlayerExperience;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0572F610
	 * 		Name   -> Function Insurgency.StatisticsProfile.GetRankPrestigeForExp
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		int32_t                                            PlayerExperience                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	int32_t UStatisticsProfile::STATIC_GetRankPrestigeForExp(int32_t PlayerExperience)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.StatisticsProfile.GetRankPrestigeForExp");
		
		UStatisticsProfile_GetRankPrestigeForExp_Params params {};
		params.PlayerExperience = PlayerExperience;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0572F590
	 * 		Name   -> Function Insurgency.StatisticsProfile.GetRankLevelThresholdForTier
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		int32_t                                            RankTier                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	int32_t UStatisticsProfile::STATIC_GetRankLevelThresholdForTier(int32_t RankTier)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.StatisticsProfile.GetRankLevelThresholdForTier");
		
		UStatisticsProfile_GetRankLevelThresholdForTier_Params params {};
		params.RankTier = RankTier;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0572F510
	 * 		Name   -> Function Insurgency.StatisticsProfile.GetRankLevelThreshold
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		int32_t                                            RankLevel                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	int32_t UStatisticsProfile::STATIC_GetRankLevelThreshold(int32_t RankLevel)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.StatisticsProfile.GetRankLevelThreshold");
		
		UStatisticsProfile_GetRankLevelThreshold_Params params {};
		params.RankLevel = RankLevel;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0572F490
	 * 		Name   -> Function Insurgency.StatisticsProfile.GetRankLevelForRank
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		int32_t                                            PlayerRank                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	int32_t UStatisticsProfile::STATIC_GetRankLevelForRank(int32_t PlayerRank)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.StatisticsProfile.GetRankLevelForRank");
		
		UStatisticsProfile_GetRankLevelForRank_Params params {};
		params.PlayerRank = PlayerRank;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0572F410
	 * 		Name   -> Function Insurgency.StatisticsProfile.GetRankLevelForExp
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		int32_t                                            PlayerExperience                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	int32_t UStatisticsProfile::STATIC_GetRankLevelForExp(int32_t PlayerExperience)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.StatisticsProfile.GetRankLevelForExp");
		
		UStatisticsProfile_GetRankLevelForExp_Params params {};
		params.PlayerExperience = PlayerExperience;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0572F390
	 * 		Name   -> Function Insurgency.StatisticsProfile.GetRankExperienceThreshold
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		int32_t                                            PlayerRank                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	int32_t UStatisticsProfile::STATIC_GetRankExperienceThreshold(int32_t PlayerRank)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.StatisticsProfile.GetRankExperienceThreshold");
		
		UStatisticsProfile_GetRankExperienceThreshold_Params params {};
		params.PlayerRank = PlayerRank;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0572F2C0
	 * 		Name   -> Function Insurgency.StatisticsProfile.GetPlayerClassStats
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	TArray<struct FStatisticsPlayerClassStats> UStatisticsProfile::GetPlayerClassStats()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.StatisticsProfile.GetPlayerClassStats");
		
		UStatisticsProfile_GetPlayerClassStats_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0572F200
	 * 		Name   -> Function Insurgency.StatisticsProfile.GetNextRankProgressPercent
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		int32_t                                            PlayerCurrentExperience                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            NextPlayerRank                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	float UStatisticsProfile::STATIC_GetNextRankProgressPercent(int32_t PlayerCurrentExperience, int32_t NextPlayerRank)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.StatisticsProfile.GetNextRankProgressPercent");
		
		UStatisticsProfile_GetNextRankProgressPercent_Params params {};
		params.PlayerCurrentExperience = PlayerCurrentExperience;
		params.NextPlayerRank = NextPlayerRank;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0572F180
	 * 		Name   -> Function Insurgency.StatisticsProfile.GetNextRankExperienceThreshold
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		int32_t                                            PlayerExperience                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	int32_t UStatisticsProfile::STATIC_GetNextRankExperienceThreshold(int32_t PlayerExperience)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.StatisticsProfile.GetNextRankExperienceThreshold");
		
		UStatisticsProfile_GetNextRankExperienceThreshold_Params params {};
		params.PlayerExperience = PlayerExperience;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0572EFB0
	 * 		Name   -> Function Insurgency.StatisticsProfile.GetMostUsedWeaponForGameTypeAndTeam
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		class FText                                        GameType                                                   (Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		int32_t                                            GameTeam                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              PercentKillsOfTotal                                        (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class FString UStatisticsProfile::GetMostUsedWeaponForGameTypeAndTeam(class FText* GameType, int32_t GameTeam, float* PercentKillsOfTotal)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.StatisticsProfile.GetMostUsedWeaponForGameTypeAndTeam");
		
		UStatisticsProfile_GetMostUsedWeaponForGameTypeAndTeam_Params params {};
		params.GameTeam = GameTeam;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (GameType != nullptr)
			*GameType = params.GameType;
		if (PercentKillsOfTotal != nullptr)
			*PercentKillsOfTotal = params.PercentKillsOfTotal;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0572EDE0
	 * 		Name   -> Function Insurgency.StatisticsProfile.GetMostUsedClassForGameTypeAndTeam
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		class FText                                        GameType                                                   (Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		int32_t                                            GameTeam                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              PercentTimeOfTotal                                         (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class FString UStatisticsProfile::GetMostUsedClassForGameTypeAndTeam(class FText* GameType, int32_t GameTeam, float* PercentTimeOfTotal)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.StatisticsProfile.GetMostUsedClassForGameTypeAndTeam");
		
		UStatisticsProfile_GetMostUsedClassForGameTypeAndTeam_Params params {};
		params.GameTeam = GameTeam;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (GameType != nullptr)
			*GameType = params.GameType;
		if (PercentTimeOfTotal != nullptr)
			*PercentTimeOfTotal = params.PercentTimeOfTotal;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0572EDB0
	 * 		Name   -> Function Insurgency.StatisticsProfile.GetKills
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	int32_t UStatisticsProfile::GetKills()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.StatisticsProfile.GetKills");
		
		UStatisticsProfile_GetKills_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0572ED80
	 * 		Name   -> Function Insurgency.StatisticsProfile.GetExperience
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	int32_t UStatisticsProfile::GetExperience()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.StatisticsProfile.GetExperience");
		
		UStatisticsProfile_GetExperience_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0572ED50
	 * 		Name   -> Function Insurgency.StatisticsProfile.GetDeaths
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	int32_t UStatisticsProfile::GetDeaths()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.StatisticsProfile.GetDeaths");
		
		UStatisticsProfile_GetDeaths_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0572ECD0
	 * 		Name   -> Function Insurgency.StatisticsProfile.GetCurrentRankExperienceThreshold
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		int32_t                                            PlayerExperience                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	int32_t UStatisticsProfile::STATIC_GetCurrentRankExperienceThreshold(int32_t PlayerExperience)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.StatisticsProfile.GetCurrentRankExperienceThreshold");
		
		UStatisticsProfile_GetCurrentRankExperienceThreshold_Params params {};
		params.PlayerExperience = PlayerExperience;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0572EC50
	 * 		Name   -> Function Insurgency.StatisticsProfile.GetCurrentRank
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		int32_t                                            PlayerExperience                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	int32_t UStatisticsProfile::STATIC_GetCurrentRank(int32_t PlayerExperience)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.StatisticsProfile.GetCurrentRank");
		
		UStatisticsProfile_GetCurrentRank_Params params {};
		params.PlayerExperience = PlayerExperience;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0572EC20
	 * 		Name   -> Function Insurgency.StatisticsProfile.GetBalance
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	int32_t UStatisticsProfile::GetBalance()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.StatisticsProfile.GetBalance");
		
		UStatisticsProfile_GetBalance_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0572EAC0
	 * 		Name   -> Function Insurgency.StatisticsProfile.GetAvailableModesForWeaponStats
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		TArray<class FString>                              inArray                                                    (Parm, OutParm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bFilterByMap                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bFilterByGameType                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UStatisticsProfile::GetAvailableModesForWeaponStats(TArray<class FString>* inArray, bool bFilterByMap, bool bFilterByGameType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.StatisticsProfile.GetAvailableModesForWeaponStats");
		
		UStatisticsProfile_GetAvailableModesForWeaponStats_Params params {};
		params.bFilterByMap = bFilterByMap;
		params.bFilterByGameType = bFilterByGameType;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (inArray != nullptr)
			*inArray = params.inArray;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0572E900
	 * 		Name   -> Function Insurgency.StatisticsProfile.GetAvailableModesForScenarioStats
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		TArray<class FString>                              inArray                                                    (Parm, OutParm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bFilterByTeam                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bFilterByGameType                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bFilterByMap                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UStatisticsProfile::GetAvailableModesForScenarioStats(TArray<class FString>* inArray, bool bFilterByTeam, bool bFilterByGameType, bool bFilterByMap)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.StatisticsProfile.GetAvailableModesForScenarioStats");
		
		UStatisticsProfile_GetAvailableModesForScenarioStats_Params params {};
		params.bFilterByTeam = bFilterByTeam;
		params.bFilterByGameType = bFilterByGameType;
		params.bFilterByMap = bFilterByMap;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (inArray != nullptr)
			*inArray = params.inArray;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0572E7E0
	 * 		Name   -> Function Insurgency.StatisticsProfile.GetAvailableMapsForWeaponStats
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		TArray<class FString>                              inArray                                                    (Parm, OutParm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bFilterByGameType                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UStatisticsProfile::GetAvailableMapsForWeaponStats(TArray<class FString>* inArray, bool bFilterByGameType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.StatisticsProfile.GetAvailableMapsForWeaponStats");
		
		UStatisticsProfile_GetAvailableMapsForWeaponStats_Params params {};
		params.bFilterByGameType = bFilterByGameType;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (inArray != nullptr)
			*inArray = params.inArray;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0572E620
	 * 		Name   -> Function Insurgency.StatisticsProfile.GetAvailableMapsForScenarioStats
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		TArray<class FString>                              inArray                                                    (Parm, OutParm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bFilterByTeam                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bFilterByGameType                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bFilterByMode                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UStatisticsProfile::GetAvailableMapsForScenarioStats(TArray<class FString>* inArray, bool bFilterByTeam, bool bFilterByGameType, bool bFilterByMode)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.StatisticsProfile.GetAvailableMapsForScenarioStats");
		
		UStatisticsProfile_GetAvailableMapsForScenarioStats_Params params {};
		params.bFilterByTeam = bFilterByTeam;
		params.bFilterByGameType = bFilterByGameType;
		params.bFilterByMode = bFilterByMode;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (inArray != nullptr)
			*inArray = params.inArray;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0572E550
	 * 		Name   -> Function Insurgency.StatisticsProfile.GetAvailableGameTypesForWeaponStats
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		TArray<class FString>                              inArray                                                    (Parm, OutParm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UStatisticsProfile::GetAvailableGameTypesForWeaponStats(TArray<class FString>* inArray)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.StatisticsProfile.GetAvailableGameTypesForWeaponStats");
		
		UStatisticsProfile_GetAvailableGameTypesForWeaponStats_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (inArray != nullptr)
			*inArray = params.inArray;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0572E470
	 * 		Name   -> Function Insurgency.StatisticsProfile.DescribeWinRatio
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		int32_t                                            Wins                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            Games                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class FString UStatisticsProfile::DescribeWinRatio(int32_t Wins, int32_t Games)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.StatisticsProfile.DescribeWinRatio");
		
		UStatisticsProfile_DescribeWinRatio_Params params {};
		params.Wins = Wins;
		params.Games = Games;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0572E3D0
	 * 		Name   -> Function Insurgency.StatisticsProfile.DescribeTimePlayedAsHoursMinutes
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		int32_t                                            TimePlayed                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class FString UStatisticsProfile::STATIC_DescribeTimePlayedAsHoursMinutes(int32_t TimePlayed)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.StatisticsProfile.DescribeTimePlayedAsHoursMinutes");
		
		UStatisticsProfile_DescribeTimePlayedAsHoursMinutes_Params params {};
		params.TimePlayed = TimePlayed;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0572E330
	 * 		Name   -> Function Insurgency.StatisticsProfile.DescribeTimePlayed
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		int32_t                                            TimePlayed                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class FString UStatisticsProfile::STATIC_DescribeTimePlayed(int32_t TimePlayed)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.StatisticsProfile.DescribeTimePlayed");
		
		UStatisticsProfile_DescribeTimePlayed_Params params {};
		params.TimePlayed = TimePlayed;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0572E250
	 * 		Name   -> Function Insurgency.StatisticsProfile.DescribeKillDeathRatio
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		int32_t                                            Kills                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            Deaths                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class FString UStatisticsProfile::DescribeKillDeathRatio(int32_t Kills, int32_t Deaths)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.StatisticsProfile.DescribeKillDeathRatio");
		
		UStatisticsProfile_DescribeKillDeathRatio_Params params {};
		params.Kills = Kills;
		params.Deaths = Deaths;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UStatisticsProfile.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UStatisticsProfile::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.StatisticsProfile");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UStatisticsRound.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UStatisticsRound::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.StatisticsRound");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UStoreItem.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UStoreItem::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.StoreItem");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UStoreBundle.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UStoreBundle::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.StoreBundle");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UStoreHandlerBase.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UStoreHandlerBase::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.StoreHandlerBase");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UStoreHandlerEOS.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UStoreHandlerEOS::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.StoreHandlerEOS");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UStoreHandlerSteam.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UStoreHandlerSteam::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.StoreHandlerSteam");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UStoreItemsList.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UStoreItemsList::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.StoreItemsList");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AStructure.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AStructure::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.Structure");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UStructureCollection.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UStructureCollection::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.StructureCollection");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UStructureElement.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UStructureElement::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.StructureElement");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05736690
	 * 		Name   -> Function Insurgency.SupplyCrate.ShowShowPointOfInterest
	 * 		Flags  -> (Final, Native, Private)
	 * Parameters:
	 * 		class AINSSoldier*                                 ForPlayer                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool ASupplyCrate::ShowShowPointOfInterest(class AINSSoldier* ForPlayer)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.SupplyCrate.ShowShowPointOfInterest");
		
		ASupplyCrate_ShowShowPointOfInterest_Params params {};
		params.ForPlayer = ForPlayer;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05736610
	 * 		Name   -> Function Insurgency.SupplyCrate.SetMeshLidAnimation
	 * 		Flags  -> (Net, NetReliable, Native, Event, NetMulticast, Public, HasDefaults)
	 * Parameters:
	 * 		struct FRotator                                    NewTargetRotation                                          (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void ASupplyCrate::SetMeshLidAnimation(const struct FRotator& NewTargetRotation)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.SupplyCrate.SetMeshLidAnimation");
		
		ASupplyCrate_SetMeshLidAnimation_Params params {};
		params.NewTargetRotation = NewTargetRotation;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05736590
	 * 		Name   -> Function Insurgency.SupplyCrate.PerformResupplyForPlayer
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		class AINSSoldier*                                 Pawn                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASupplyCrate::PerformResupplyForPlayer(class AINSSoldier* Pawn)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.SupplyCrate.PerformResupplyForPlayer");
		
		ASupplyCrate_PerformResupplyForPlayer_Params params {};
		params.Pawn = Pawn;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05736570
	 * 		Name   -> Function Insurgency.SupplyCrate.OpenSupplyCrate
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void ASupplyCrate::OpenSupplyCrate()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.SupplyCrate.OpenSupplyCrate");
		
		ASupplyCrate_OpenSupplyCrate_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x057364E0
	 * 		Name   -> Function Insurgency.SupplyCrate.OnSpawnZoneToggled
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		bool                                               bNewState                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASupplyCrate::OnSpawnZoneToggled(bool bNewState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.SupplyCrate.OnSpawnZoneToggled");
		
		ASupplyCrate_OnSpawnZoneToggled_Params params {};
		params.bNewState = bNewState;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x057364C0
	 * 		Name   -> Function Insurgency.SupplyCrate.OnRep_UsesLeft
	 * 		Flags  -> (Final, Native, Public)
	 */
	void ASupplyCrate::OnRep_UsesLeft()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.SupplyCrate.OnRep_UsesLeft");
		
		ASupplyCrate_OnRep_UsesLeft_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x057364A0
	 * 		Name   -> Function Insurgency.SupplyCrate.OnRep_PlayersWhoHaveResupplied
	 * 		Flags  -> (Final, Native, Public)
	 */
	void ASupplyCrate::OnRep_PlayersWhoHaveResupplied()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.SupplyCrate.OnRep_PlayersWhoHaveResupplied");
		
		ASupplyCrate_OnRep_PlayersWhoHaveResupplied_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05736480
	 * 		Name   -> Function Insurgency.SupplyCrate.OnRep_LinkedSpawnZoneActive
	 * 		Flags  -> (Final, Native, Public)
	 */
	void ASupplyCrate::OnRep_LinkedSpawnZoneActive()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.SupplyCrate.OnRep_LinkedSpawnZoneActive");
		
		ASupplyCrate_OnRep_LinkedSpawnZoneActive_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05736460
	 * 		Name   -> Function Insurgency.SupplyCrate.OnRep_IsActive
	 * 		Flags  -> (Final, Native, Public)
	 */
	void ASupplyCrate::OnRep_IsActive()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.SupplyCrate.OnRep_IsActive");
		
		ASupplyCrate_OnRep_IsActive_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x057363A0
	 * 		Name   -> Function Insurgency.SupplyCrate.OnObjectiveActive
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		bool                                               bNewState                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AObjectiveBase*                              Objective                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASupplyCrate::OnObjectiveActive(bool bNewState, class AObjectiveBase* Objective)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.SupplyCrate.OnObjectiveActive");
		
		ASupplyCrate_OnObjectiveActive_Params params {};
		params.bNewState = bNewState;
		params.Objective = Objective;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05736380
	 * 		Name   -> Function Insurgency.SupplyCrate.CloseSupplyCrate
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void ASupplyCrate::CloseSupplyCrate()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.SupplyCrate.CloseSupplyCrate");
		
		ASupplyCrate_CloseSupplyCrate_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> Function Insurgency.SupplyCrate.BlueprintOnUsesLeftUpdated
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 */
	void ASupplyCrate::BlueprintOnUsesLeftUpdated()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.SupplyCrate.BlueprintOnUsesLeftUpdated");
		
		ASupplyCrate_BlueprintOnUsesLeftUpdated_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ASupplyCrate.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ASupplyCrate::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.SupplyCrate");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction USupplyGainMessage.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* USupplyGainMessage::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.SupplyGainMessage");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05736B80
	 * 		Name   -> Function Insurgency.SurfaceReaction.PlaySurfaceReactions
	 * 		Flags  -> (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EPhysicalSurface                                   SurfaceType                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     Location                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FRotator                                    Rotation                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     HitDirection                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UPrimitiveComponent*                         HitComponent                                               (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FName                                        HitBoneName                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UPhysicalMaterial*                           HitMaterial                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EDecalTransformMask                                DecalTransformMask                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void USurfaceReaction::PlaySurfaceReactions(class UObject* WorldContextObject, EPhysicalSurface SurfaceType, const struct FVector& Location, const struct FRotator& Rotation, const struct FVector& HitDirection, class UPrimitiveComponent* HitComponent, const class FName& HitBoneName, class UPhysicalMaterial* HitMaterial, EDecalTransformMask DecalTransformMask)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.SurfaceReaction.PlaySurfaceReactions");
		
		USurfaceReaction_PlaySurfaceReactions_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.SurfaceType = SurfaceType;
		params.Location = Location;
		params.Rotation = Rotation;
		params.HitDirection = HitDirection;
		params.HitComponent = HitComponent;
		params.HitBoneName = HitBoneName;
		params.HitMaterial = HitMaterial;
		params.DecalTransformMask = DecalTransformMask;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05736A10
	 * 		Name   -> Function Insurgency.SurfaceReaction.PlaySurfaceHitReactions
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FHitResult                                  HitInfo                                                    (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 * 		EDecalTransformMask                                DecalTransformMask                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void USurfaceReaction::PlaySurfaceHitReactions(class UObject* WorldContextObject, const struct FHitResult& HitInfo, EDecalTransformMask DecalTransformMask)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.SurfaceReaction.PlaySurfaceHitReactions");
		
		USurfaceReaction_PlaySurfaceHitReactions_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.HitInfo = HitInfo;
		params.DecalTransformMask = DecalTransformMask;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction USurfaceReaction.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* USurfaceReaction::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.SurfaceReaction");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x04DB5CB0
	 * 		Name   -> Function Insurgency.SurfaceReactionManager.OnPooledParticleSystemFinished
	 * 		Flags  -> (Native, Public)
	 * Parameters:
	 * 		class UParticleSystemComponent*                    FinishedComponent                                          (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ASurfaceReactionManager::OnPooledParticleSystemFinished(class UParticleSystemComponent* FinishedComponent)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.SurfaceReactionManager.OnPooledParticleSystemFinished");
		
		ASurfaceReactionManager_OnPooledParticleSystemFinished_Params params {};
		params.FinishedComponent = FinishedComponent;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ASurfaceReactionManager.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ASurfaceReactionManager::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.SurfaceReactionManager");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05705760
	 * 		Name   -> Function Insurgency.SurvivalHUD.GetINSUserSettings
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	class UINSGameUserSettings* USurvivalHUD::GetINSUserSettings()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.SurvivalHUD.GetINSUserSettings");
		
		USurvivalHUD_GetINSUserSettings_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction USurvivalHUD.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* USurvivalHUD::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.SurvivalHUD");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ASurvivalObjective.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ASurvivalObjective::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.SurvivalObjective");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05738150
	 * 		Name   -> Function Insurgency.SurvivalRouteConfig.LogRouteInfo
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void ASurvivalRouteConfig::LogRouteInfo()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.SurvivalRouteConfig.LogRouteInfo");
		
		ASurvivalRouteConfig_LogRouteInfo_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ASurvivalRouteConfig.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ASurvivalRouteConfig::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.SurvivalRouteConfig");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction USurvivalScenarioData.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* USurvivalScenarioData::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.SurvivalScenarioData");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05738690
	 * 		Name   -> Function Insurgency.TacticalGrid.TestPathfinding
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void ATacticalGrid::TestPathfinding()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.TacticalGrid.TestPathfinding");
		
		ATacticalGrid_TestPathfinding_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05738670
	 * 		Name   -> Function Insurgency.TacticalGrid.GenerateTacticalInfo
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void ATacticalGrid::GenerateTacticalInfo()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.TacticalGrid.GenerateTacticalInfo");
		
		ATacticalGrid_GenerateTacticalInfo_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05738650
	 * 		Name   -> Function Insurgency.TacticalGrid.GenerateData
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void ATacticalGrid::GenerateData()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.TacticalGrid.GenerateData");
		
		ATacticalGrid_GenerateData_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ATacticalGrid.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ATacticalGrid::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.TacticalGrid");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UTacticalGridRenderingComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UTacticalGridRenderingComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.TacticalGridRenderingComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ATacticalGridTestingPawn.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ATacticalGridTestingPawn::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.TacticalGridTestingPawn");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x057395A0
	 * 		Name   -> Function Insurgency.TacticalMapWidget.ScaleWorldSizeToMapSize
	 * 		Flags  -> (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		struct FVector2D                                   InSize                                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector2D                                   OutSize                                                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UTacticalMapWidget::ScaleWorldSizeToMapSize(const struct FVector2D& InSize, struct FVector2D* OutSize)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.TacticalMapWidget.ScaleWorldSizeToMapSize");
		
		UTacticalMapWidget_ScaleWorldSizeToMapSize_Params params {};
		params.InSize = InSize;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutSize != nullptr)
			*OutSize = params.OutSize;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05739580
	 * 		Name   -> Function Insurgency.TacticalMapWidget.RefreshObjectives
	 * 		Flags  -> (Final, Native, Private)
	 */
	void UTacticalMapWidget::RefreshObjectives()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.TacticalMapWidget.RefreshObjectives");
		
		UTacticalMapWidget_RefreshObjectives_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> Function Insurgency.TacticalMapWidget.OnVehicleWidgetCreated
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		class AVehicleBase*                                Vehicle                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UUserWidget*                                 Widget                                                     (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UTacticalMapWidget::OnVehicleWidgetCreated(class AVehicleBase* Vehicle, class UUserWidget* Widget)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.TacticalMapWidget.OnVehicleWidgetCreated");
		
		UTacticalMapWidget_OnVehicleWidgetCreated_Params params {};
		params.Vehicle = Vehicle;
		params.Widget = Widget;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x057394C0
	 * 		Name   -> Function Insurgency.TacticalMapWidget.OnTeamChanged
	 * 		Flags  -> (Final, Native, Private)
	 * Parameters:
	 * 		unsigned char                                      TeamId                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class ATeamInfo*                                   TeamInfo                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UTacticalMapWidget::OnTeamChanged(unsigned char TeamId, class ATeamInfo* TeamInfo)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.TacticalMapWidget.OnTeamChanged");
		
		UTacticalMapWidget_OnTeamChanged_Params params {};
		params.TeamId = TeamId;
		params.TeamInfo = TeamInfo;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> Function Insurgency.TacticalMapWidget.OnSupplyCrateWidgetCreated
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		class ASupplyCrate*                                Vehicle                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UUserWidget*                                 Widget                                                     (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UTacticalMapWidget::OnSupplyCrateWidgetCreated(class ASupplyCrate* Vehicle, class UUserWidget* Widget)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.TacticalMapWidget.OnSupplyCrateWidgetCreated");
		
		UTacticalMapWidget_OnSupplyCrateWidgetCreated_Params params {};
		params.Vehicle = Vehicle;
		params.Widget = Widget;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> Function Insurgency.TacticalMapWidget.OnSpawnZoneWidgetCreated
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		class ASpawnZone*                                  SpawnZone                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UUserWidget*                                 Widget                                                     (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UTacticalMapWidget::OnSpawnZoneWidgetCreated(class ASpawnZone* SpawnZone, class UUserWidget* Widget)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.TacticalMapWidget.OnSpawnZoneWidgetCreated");
		
		UTacticalMapWidget_OnSpawnZoneWidgetCreated_Params params {};
		params.SpawnZone = SpawnZone;
		params.Widget = Widget;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> Function Insurgency.TacticalMapWidget.OnObjectiveWidgetCreated
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		class AObjectiveBase*                              Objective                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UUserWidget*                                 Widget                                                     (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UTacticalMapWidget::OnObjectiveWidgetCreated(class AObjectiveBase* Objective, class UUserWidget* Widget)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.TacticalMapWidget.OnObjectiveWidgetCreated");
		
		UTacticalMapWidget_OnObjectiveWidgetCreated_Params params {};
		params.Objective = Objective;
		params.Widget = Widget;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x057394A0
	 * 		Name   -> Function Insurgency.TacticalMapWidget.OnLightingScenarioChanged
	 * 		Flags  -> (Final, Native, Public)
	 */
	void UTacticalMapWidget::OnLightingScenarioChanged()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.TacticalMapWidget.OnLightingScenarioChanged");
		
		UTacticalMapWidget_OnLightingScenarioChanged_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05739410
	 * 		Name   -> Function Insurgency.TacticalMapWidget.HasWidgetForActor
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		class AActor*                                      Actor                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UTacticalMapWidget::HasWidgetForActor(class AActor* Actor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.TacticalMapWidget.HasWidgetForActor");
		
		UTacticalMapWidget_HasWidgetForActor_Params params {};
		params.Actor = Actor;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05739380
	 * 		Name   -> Function Insurgency.TacticalMapWidget.GetWidgetForActor
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		class AActor*                                      Actor                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UMapActorWidget* UTacticalMapWidget::GetWidgetForActor(class AActor* Actor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.TacticalMapWidget.GetWidgetForActor");
		
		UTacticalMapWidget_GetWidgetForActor_Params params {};
		params.Actor = Actor;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05739350
	 * 		Name   -> Function Insurgency.TacticalMapWidget.GetMapRotation
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	float UTacticalMapWidget::GetMapRotation()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.TacticalMapWidget.GetMapRotation");
		
		UTacticalMapWidget_GetMapRotation_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05739310
	 * 		Name   -> Function Insurgency.TacticalMapWidget.GetMapBounds
	 * 		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
	 */
	struct FBox UTacticalMapWidget::GetMapBounds()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.TacticalMapWidget.GetMapBounds");
		
		UTacticalMapWidget_GetMapBounds_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05739110
	 * 		Name   -> Function Insurgency.TacticalMapWidget.GetCanvasPositionFromWorldLocation
	 * 		Flags  -> (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		struct FGeometry                                   MyGeometry                                                 (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     WorldLocation                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bClampToFit                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector2D                                   OutCanvasPosition                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               IsUsingLevelBox                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UTacticalMapWidget::GetCanvasPositionFromWorldLocation(const struct FGeometry& MyGeometry, const struct FVector& WorldLocation, bool bClampToFit, struct FVector2D* OutCanvasPosition, bool IsUsingLevelBox)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.TacticalMapWidget.GetCanvasPositionFromWorldLocation");
		
		UTacticalMapWidget_GetCanvasPositionFromWorldLocation_Params params {};
		params.MyGeometry = MyGeometry;
		params.WorldLocation = WorldLocation;
		params.bClampToFit = bClampToFit;
		params.IsUsingLevelBox = IsUsingLevelBox;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutCanvasPosition != nullptr)
			*OutCanvasPosition = params.OutCanvasPosition;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05738FE0
	 * 		Name   -> Function Insurgency.TacticalMapWidget.CreateMapIcon
	 * 		Flags  -> (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		class UClass*                                      WidgetClass                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     WorldLocation                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FRotator                                    WorldRotation                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	class UMapIconWidget* UTacticalMapWidget::CreateMapIcon(class UClass* WidgetClass, const struct FVector& WorldLocation, const struct FRotator& WorldRotation)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.TacticalMapWidget.CreateMapIcon");
		
		UTacticalMapWidget_CreateMapIcon_Params params {};
		params.WidgetClass = WidgetClass;
		params.WorldLocation = WorldLocation;
		params.WorldRotation = WorldRotation;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05738F20
	 * 		Name   -> Function Insurgency.TacticalMapWidget.CreateMapActorWidget
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UClass*                                      WidgetClass                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      ForActor                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UMapActorWidget* UTacticalMapWidget::CreateMapActorWidget(class UClass* WidgetClass, class AActor* ForActor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.TacticalMapWidget.CreateMapActorWidget");
		
		UTacticalMapWidget_CreateMapActorWidget_Params params {};
		params.WidgetClass = WidgetClass;
		params.ForActor = ForActor;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05738EA0
	 * 		Name   -> Function Insurgency.TacticalMapWidget.AddMapActorWidget
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UMapActorWidget*                             NewWidget                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UTacticalMapWidget::AddMapActorWidget(class UMapActorWidget* NewWidget)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.TacticalMapWidget.AddMapActorWidget");
		
		UTacticalMapWidget_AddMapActorWidget_Params params {};
		params.NewWidget = NewWidget;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UTacticalMapWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UTacticalMapWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.TacticalMapWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ATacticalRecastNavMesh.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ATacticalRecastNavMesh::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.TacticalRecastNavMesh");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05739EE0
	 * 		Name   -> Function Insurgency.Tagline.EvaluateTaglineThresholdInt
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		int32_t                                            Value                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            Threshold                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		ETaglineEvaluation                                 Method                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UTagline::STATIC_EvaluateTaglineThresholdInt(int32_t Value, int32_t Threshold, ETaglineEvaluation Method)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.Tagline.EvaluateTaglineThresholdInt");
		
		UTagline_EvaluateTaglineThresholdInt_Params params {};
		params.Value = Value;
		params.Threshold = Threshold;
		params.Method = Method;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05739E20
	 * 		Name   -> Function Insurgency.Tagline.CheckPlayerEligibility
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		class AINSPlayerState*                             Player                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		unsigned char                                      WinningTeam                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UTagline::CheckPlayerEligibility(class AINSPlayerState* Player, unsigned char WinningTeam)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.Tagline.CheckPlayerEligibility");
		
		UTagline_CheckPlayerEligibility_Params params {};
		params.Player = Player;
		params.WinningTeam = WinningTeam;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> Function Insurgency.Tagline.BlueprintOnRoundReset
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 */
	void UTagline::BlueprintOnRoundReset()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.Tagline.BlueprintOnRoundReset");
		
		UTagline_BlueprintOnRoundReset_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> Function Insurgency.Tagline.BlueprintOnCheckRoundEndAward
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		class AINSGameState*                               InGameState                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		unsigned char                                      LastWinningTeam                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UTagline::BlueprintOnCheckRoundEndAward(class AINSGameState* InGameState, unsigned char LastWinningTeam)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.Tagline.BlueprintOnCheckRoundEndAward");
		
		UTagline_BlueprintOnCheckRoundEndAward_Params params {};
		params.InGameState = InGameState;
		params.LastWinningTeam = LastWinningTeam;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> Function Insurgency.Tagline.BlueprintInit
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		class AINSGameMode*                                GameMode                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UTagline::BlueprintInit(class AINSGameMode* GameMode)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.Tagline.BlueprintInit");
		
		UTagline_BlueprintInit_Params params {};
		params.GameMode = GameMode;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05739D10
	 * 		Name   -> Function Insurgency.Tagline.AwardTaglineWithFloatContext
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class AINSPlayerState*                             Player                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              ContextValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bAsPercentage                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UTagline::AwardTaglineWithFloatContext(class AINSPlayerState* Player, float ContextValue, bool bAsPercentage)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.Tagline.AwardTaglineWithFloatContext");
		
		UTagline_AwardTaglineWithFloatContext_Params params {};
		params.Player = Player;
		params.ContextValue = ContextValue;
		params.bAsPercentage = bAsPercentage;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05739C50
	 * 		Name   -> Function Insurgency.Tagline.AwardTaglineWithContext
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class AINSPlayerState*                             Player                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            ContextValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UTagline::AwardTaglineWithContext(class AINSPlayerState* Player, int32_t ContextValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.Tagline.AwardTaglineWithContext");
		
		UTagline_AwardTaglineWithContext_Params params {};
		params.Player = Player;
		params.ContextValue = ContextValue;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05739BD0
	 * 		Name   -> Function Insurgency.Tagline.AwardTagline
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class AINSPlayerState*                             Player                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UTagline::AwardTagline(class AINSPlayerState* Player)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.Tagline.AwardTagline");
		
		UTagline_AwardTagline_Params params {};
		params.Player = Player;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UTagline.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UTagline::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.Tagline");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0573A520
	 * 		Name   -> Function Insurgency.TaglineStatRequirement.GetPlayerValueInt
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		class AINSPlayerState*                             Player                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	int32_t UTaglineStatRequirement::GetPlayerValueInt(class AINSPlayerState* Player)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.TaglineStatRequirement.GetPlayerValueInt");
		
		UTaglineStatRequirement_GetPlayerValueInt_Params params {};
		params.Player = Player;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0573A410
	 * 		Name   -> Function Insurgency.TaglineStatRequirement.EvaluatePlayerGetValue
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		class AINSPlayerState*                             Player                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            Threshold                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            OutValue                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UTaglineStatRequirement::EvaluatePlayerGetValue(class AINSPlayerState* Player, int32_t Threshold, int32_t* OutValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.TaglineStatRequirement.EvaluatePlayerGetValue");
		
		UTaglineStatRequirement_EvaluatePlayerGetValue_Params params {};
		params.Player = Player;
		params.Threshold = Threshold;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutValue != nullptr)
			*OutValue = params.OutValue;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0573A350
	 * 		Name   -> Function Insurgency.TaglineStatRequirement.EvaluatePlayer
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		class AINSPlayerState*                             Player                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            Threshold                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UTaglineStatRequirement::EvaluatePlayer(class AINSPlayerState* Player, int32_t Threshold)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.TaglineStatRequirement.EvaluatePlayer");
		
		UTaglineStatRequirement_EvaluatePlayer_Params params {};
		params.Player = Player;
		params.Threshold = Threshold;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UTaglineStatRequirement.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UTaglineStatRequirement::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.TaglineStatRequirement");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UTaglineStatHighest.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UTaglineStatHighest::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.TaglineStatHighest");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UQueuedRadioEvent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UQueuedRadioEvent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.QueuedRadioEvent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UTeamInterface.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UTeamInterface::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.TeamInterface");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0573F190
	 * 		Name   -> Function Insurgency.TeamStatics.IsDedicatedSpectator
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class AINSBasePlayerController*                    PlayerController                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UTeamStatics::STATIC_IsDedicatedSpectator(class AINSBasePlayerController* PlayerController)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.TeamStatics.IsDedicatedSpectator");
		
		UTeamStatics_IsDedicatedSpectator_Params params {};
		params.PlayerController = PlayerController;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0573F020
	 * 		Name   -> Function Insurgency.TeamStatics.IsClassRestricted
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FPlayerClassLimit                           ClassLimit                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		int32_t                                            PlayerExperience                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UTeamStatics::STATIC_IsClassRestricted(const struct FPlayerClassLimit& ClassLimit, int32_t PlayerExperience)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.TeamStatics.IsClassRestricted");
		
		UTeamStatics_IsClassRestricted_Params params {};
		params.ClassLimit = ClassLimit;
		params.PlayerExperience = PlayerExperience;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0573EF20
	 * 		Name   -> Function Insurgency.TeamStatics.GetTeamRoleText
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		ETeamRole                                          TeamRole                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FText                                        OutRoleText                                                (Parm, OutParm, NativeAccessSpecifierPublic)
	 */
	void UTeamStatics::STATIC_GetTeamRoleText(ETeamRole TeamRole, class FText* OutRoleText)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.TeamStatics.GetTeamRoleText");
		
		UTeamStatics_GetTeamRoleText_Params params {};
		params.TeamRole = TeamRole;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutRoleText != nullptr)
			*OutRoleText = params.OutRoleText;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0573EE60
	 * 		Name   -> Function Insurgency.TeamStatics.GetTeamRelationship
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class AActor*                                      Actor                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		unsigned char                                      TeamId                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	ETeamRelationship UTeamStatics::STATIC_GetTeamRelationship(class AActor* Actor, unsigned char TeamId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.TeamStatics.GetTeamRelationship");
		
		UTeamStatics_GetTeamRelationship_Params params {};
		params.Actor = Actor;
		params.TeamId = TeamId;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0573EDA0
	 * 		Name   -> Function Insurgency.TeamStatics.GetTeamInfo
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		unsigned char                                      TeamId                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class ATeamInfo* UTeamStatics::STATIC_GetTeamInfo(class UObject* WorldContextObject, unsigned char TeamId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.TeamStatics.GetTeamInfo");
		
		UTeamStatics_GetTeamInfo_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.TeamId = TeamId;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0573EC80
	 * 		Name   -> Function Insurgency.TeamStatics.GetRoundOverCaption
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class AINSBasePlayerController*                    For                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		unsigned char                                      WinningTeam                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class FText UTeamStatics::STATIC_GetRoundOverCaption(class AINSBasePlayerController* For, unsigned char WinningTeam)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.TeamStatics.GetRoundOverCaption");
		
		UTeamStatics_GetRoundOverCaption_Params params {};
		params.For = For;
		params.WinningTeam = WinningTeam;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0573EBB0
	 * 		Name   -> Function Insurgency.TeamStatics.GetPlayerColor
	 * 		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class AINSPlayerState*                             PlayerState                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AINSPlayerState*                             RelativePlayer                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FLinearColor UTeamStatics::STATIC_GetPlayerColor(class AINSPlayerState* PlayerState, class AINSPlayerState* RelativePlayer)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.TeamStatics.GetPlayerColor");
		
		UTeamStatics_GetPlayerColor_Params params {};
		params.PlayerState = PlayerState;
		params.RelativePlayer = RelativePlayer;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0573EAF0
	 * 		Name   -> Function Insurgency.TeamStatics.GetPartyRelationship
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class AINSPlayerState*                             PlayerState                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AINSPlayerState*                             RelativePlayer                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	EPartyRelationship UTeamStatics::STATIC_GetPartyRelationship(class AINSPlayerState* PlayerState, class AINSPlayerState* RelativePlayer)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.TeamStatics.GetPartyRelationship");
		
		UTeamStatics_GetPartyRelationship_Params params {};
		params.PlayerState = PlayerState;
		params.RelativePlayer = RelativePlayer;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0573E9C0
	 * 		Name   -> Function Insurgency.TeamStatics.GetNextClassToUnlock
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		TArray<struct FPlayerClassLimit>                   ClassSlots                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            PlayerExperience                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UPlayerClass* UTeamStatics::STATIC_GetNextClassToUnlock(TArray<struct FPlayerClassLimit> ClassSlots, int32_t PlayerExperience)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.TeamStatics.GetNextClassToUnlock");
		
		UTeamStatics_GetNextClassToUnlock_Params params {};
		params.ClassSlots = ClassSlots;
		params.PlayerExperience = PlayerExperience;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0573E8E0
	 * 		Name   -> Function Insurgency.TeamStatics.GetFormattedPlayerName
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class AINSPlayerState*                             PlayerState                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class FText UTeamStatics::STATIC_GetFormattedPlayerName(class AINSPlayerState* PlayerState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.TeamStatics.GetFormattedPlayerName");
		
		UTeamStatics_GetFormattedPlayerName_Params params {};
		params.PlayerState = PlayerState;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0573E7C0
	 * 		Name   -> Function Insurgency.TeamStatics.GetFormattedFactionName
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		unsigned char                                      TeamId                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class FText UTeamStatics::STATIC_GetFormattedFactionName(class UObject* WorldContextObject, unsigned char TeamId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.TeamStatics.GetFormattedFactionName");
		
		UTeamStatics_GetFormattedFactionName_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.TeamId = TeamId;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0573E700
	 * 		Name   -> Function Insurgency.TeamStatics.GetFactionDefinitionForTeam
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		unsigned char                                      TeamId                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UFactionDefinition* UTeamStatics::STATIC_GetFactionDefinitionForTeam(class UObject* WorldContextObject, unsigned char TeamId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.TeamStatics.GetFactionDefinitionForTeam");
		
		UTeamStatics_GetFactionDefinitionForTeam_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.TeamId = TeamId;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0573E600
	 * 		Name   -> Function Insurgency.TeamStatics.GetFactionColor
	 * 		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		unsigned char                                      TeamId                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AINSPlayerState*                             RelativePlayer                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FLinearColor UTeamStatics::STATIC_GetFactionColor(class UObject* WorldContextObject, unsigned char TeamId, class AINSPlayerState* RelativePlayer)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.TeamStatics.GetFactionColor");
		
		UTeamStatics_GetFactionColor_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.TeamId = TeamId;
		params.RelativePlayer = RelativePlayer;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0573E540
	 * 		Name   -> Function Insurgency.TeamStatics.GetEnemyTeam
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		unsigned char                                      TeamId                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class ATeamInfo* UTeamStatics::STATIC_GetEnemyTeam(class UObject* WorldContextObject, unsigned char TeamId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.TeamStatics.GetEnemyTeam");
		
		UTeamStatics_GetEnemyTeam_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.TeamId = TeamId;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0573E3F0
	 * 		Name   -> Function Insurgency.TeamStatics.GetDefaultTeamVictoryDescription
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		unsigned char                                      TeamId                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		ERoundConclusion                                   RoundConclusion                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class FText UTeamStatics::STATIC_GetDefaultTeamVictoryDescription(class UObject* WorldContextObject, unsigned char TeamId, ERoundConclusion RoundConclusion)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.TeamStatics.GetDefaultTeamVictoryDescription");
		
		UTeamStatics_GetDefaultTeamVictoryDescription_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.TeamId = TeamId;
		params.RoundConclusion = RoundConclusion;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0573E280
	 * 		Name   -> Function Insurgency.TeamStatics.GetClassLimitForTeamSize
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FPlayerClassLimit                           ClassLimit                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		int32_t                                            TeamSize                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	int32_t UTeamStatics::STATIC_GetClassLimitForTeamSize(const struct FPlayerClassLimit& ClassLimit, int32_t TeamSize)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.TeamStatics.GetClassLimitForTeamSize");
		
		UTeamStatics_GetClassLimitForTeamSize_Params params {};
		params.ClassLimit = ClassLimit;
		params.TeamSize = TeamSize;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0573E0D0
	 * 		Name   -> Function Insurgency.TeamStatics.GetClassLimitForTeamId
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FPlayerClassLimit                           ClassLimit                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		unsigned char                                      TeamId                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	int32_t UTeamStatics::STATIC_GetClassLimitForTeamId(class UObject* WorldContextObject, const struct FPlayerClassLimit& ClassLimit, unsigned char TeamId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.TeamStatics.GetClassLimitForTeamId");
		
		UTeamStatics_GetClassLimitForTeamId_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.ClassLimit = ClassLimit;
		params.TeamId = TeamId;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0573DF60
	 * 		Name   -> Function Insurgency.TeamStatics.GetClassLimitForTeam
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FPlayerClassLimit                           ClassLimit                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		class ATeamInfo*                                   Team                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	int32_t UTeamStatics::STATIC_GetClassLimitForTeam(const struct FPlayerClassLimit& ClassLimit, class ATeamInfo* Team)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.TeamStatics.GetClassLimitForTeam");
		
		UTeamStatics_GetClassLimitForTeam_Params params {};
		params.ClassLimit = ClassLimit;
		params.Team = Team;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0573DEA0
	 * 		Name   -> Function Insurgency.TeamStatics.GetActorTeamRelationship
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class AActor*                                      Actor                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      OtherActor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	ETeamRelationship UTeamStatics::STATIC_GetActorTeamRelationship(class AActor* Actor, class AActor* OtherActor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.TeamStatics.GetActorTeamRelationship");
		
		UTeamStatics_GetActorTeamRelationship_Params params {};
		params.Actor = Actor;
		params.OtherActor = OtherActor;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UTeamStatics.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UTeamStatics::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.TeamStatics");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0573F3E0
	 * 		Name   -> Function Insurgency.TempHUD.TextWithShadow_Clipped
	 * 		Flags  -> (Final, Native, Private, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		float                                              PosX                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              PosY                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FText                                        Text                                                       (Parm, NativeAccessSpecifierPublic)
	 * 		class UFont*                                       Font                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FLinearColor                                TextColor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Scale                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Width                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Height                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ATempHUD::TextWithShadow_Clipped(float PosX, float PosY, const class FText& Text, class UFont* Font, const struct FLinearColor& TextColor, float Scale, float Width, float Height)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.TempHUD.TextWithShadow_Clipped");
		
		ATempHUD_TextWithShadow_Clipped_Params params {};
		params.PosX = PosX;
		params.PosY = PosY;
		params.Text = Text;
		params.Font = Font;
		params.TextColor = TextColor;
		params.Scale = Scale;
		params.Width = Width;
		params.Height = Height;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ATempHUD.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ATempHUD::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.TempHUD");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UTheaterDefinition.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UTheaterDefinition::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.TheaterDefinition");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05740EC0
	 * 		Name   -> Function Insurgency.ThirdPersonAnimInstance.UpdateWeightShift
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void UThirdPersonAnimInstance::UpdateWeightShift()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ThirdPersonAnimInstance.UpdateWeightShift");
		
		UThirdPersonAnimInstance_UpdateWeightShift_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05740EA0
	 * 		Name   -> Function Insurgency.ThirdPersonAnimInstance.UpdateTransforms
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void UThirdPersonAnimInstance::UpdateTransforms()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ThirdPersonAnimInstance.UpdateTransforms");
		
		UThirdPersonAnimInstance_UpdateTransforms_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05740E80
	 * 		Name   -> Function Insurgency.ThirdPersonAnimInstance.UpdateMovementWeightShift
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void UThirdPersonAnimInstance::UpdateMovementWeightShift()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ThirdPersonAnimInstance.UpdateMovementWeightShift");
		
		UThirdPersonAnimInstance_UpdateMovementWeightShift_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05740E60
	 * 		Name   -> Function Insurgency.ThirdPersonAnimInstance.UpdateInterpNorthRoll
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void UThirdPersonAnimInstance::UpdateInterpNorthRoll()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ThirdPersonAnimInstance.UpdateInterpNorthRoll");
		
		UThirdPersonAnimInstance_UpdateInterpNorthRoll_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05740E40
	 * 		Name   -> Function Insurgency.ThirdPersonAnimInstance.UpdateIKHandTargetMounted
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void UThirdPersonAnimInstance::UpdateIKHandTargetMounted()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ThirdPersonAnimInstance.UpdateIKHandTargetMounted");
		
		UThirdPersonAnimInstance_UpdateIKHandTargetMounted_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05740E20
	 * 		Name   -> Function Insurgency.ThirdPersonAnimInstance.UpdateIKCurves
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void UThirdPersonAnimInstance::UpdateIKCurves()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ThirdPersonAnimInstance.UpdateIKCurves");
		
		UThirdPersonAnimInstance_UpdateIKCurves_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05740E00
	 * 		Name   -> Function Insurgency.ThirdPersonAnimInstance.UpdateHandIK
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void UThirdPersonAnimInstance::UpdateHandIK()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ThirdPersonAnimInstance.UpdateHandIK");
		
		UThirdPersonAnimInstance_UpdateHandIK_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05740DE0
	 * 		Name   -> Function Insurgency.ThirdPersonAnimInstance.UpdateDeployedAlpha
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void UThirdPersonAnimInstance::UpdateDeployedAlpha()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ThirdPersonAnimInstance.UpdateDeployedAlpha");
		
		UThirdPersonAnimInstance_UpdateDeployedAlpha_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05740DC0
	 * 		Name   -> Function Insurgency.ThirdPersonAnimInstance.UpdateActiveLeftHandPose
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void UThirdPersonAnimInstance::UpdateActiveLeftHandPose()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ThirdPersonAnimInstance.UpdateActiveLeftHandPose");
		
		UThirdPersonAnimInstance_UpdateActiveLeftHandPose_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05740BC0
	 * 		Name   -> Function Insurgency.ThirdPersonAnimInstance.IKCurveAlpha
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		float                                              Interp                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bInterpolate                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bCondition                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bSubtract                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FName                                        CurveName                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              OutInterp                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	float UThirdPersonAnimInstance::IKCurveAlpha(float Interp, bool bInterpolate, bool bCondition, bool bSubtract, const class FName& CurveName, float* OutInterp)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ThirdPersonAnimInstance.IKCurveAlpha");
		
		UThirdPersonAnimInstance_IKCurveAlpha_Params params {};
		params.Interp = Interp;
		params.bInterpolate = bInterpolate;
		params.bCondition = bCondition;
		params.bSubtract = bSubtract;
		params.CurveName = CurveName;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutInterp != nullptr)
			*OutInterp = params.OutInterp;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05740AF0
	 * 		Name   -> Function Insurgency.ThirdPersonAnimInstance.DeltaRotatorAxis
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		float                                              A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              B                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	float UThirdPersonAnimInstance::DeltaRotatorAxis(float A, float B)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ThirdPersonAnimInstance.DeltaRotatorAxis");
		
		UThirdPersonAnimInstance_DeltaRotatorAxis_Params params {};
		params.A = A;
		params.B = B;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x057409E0
	 * 		Name   -> Function Insurgency.ThirdPersonAnimInstance.CalcVariableInterp
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		float                                              Current                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Target                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Speed                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	float UThirdPersonAnimInstance::CalcVariableInterp(float Current, float Target, float Speed)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ThirdPersonAnimInstance.CalcVariableInterp");
		
		UThirdPersonAnimInstance_CalcVariableInterp_Params params {};
		params.Current = Current;
		params.Target = Target;
		params.Speed = Speed;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05740880
	 * 		Name   -> Function Insurgency.ThirdPersonAnimInstance.CalcRotatorInterp
	 * 		Flags  -> (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		struct FRotator                                    Current                                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		struct FRotator                                    Target                                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		float                                              Speed                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FRotator UThirdPersonAnimInstance::CalcRotatorInterp(const struct FRotator& Current, const struct FRotator& Target, float Speed)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ThirdPersonAnimInstance.CalcRotatorInterp");
		
		UThirdPersonAnimInstance_CalcRotatorInterp_Params params {};
		params.Current = Current;
		params.Target = Target;
		params.Speed = Speed;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05740700
	 * 		Name   -> Function Insurgency.ThirdPersonAnimInstance.CalcRelativeTransform
	 * 		Flags  -> (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		struct FTransform                                  Child                                                      (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		struct FTransform                                  Parent                                                     (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	struct FTransform UThirdPersonAnimInstance::CalcRelativeTransform(const struct FTransform& Child, const struct FTransform& Parent)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ThirdPersonAnimInstance.CalcRelativeTransform");
		
		UThirdPersonAnimInstance_CalcRelativeTransform_Params params {};
		params.Child = Child;
		params.Parent = Parent;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x057406E0
	 * 		Name   -> Function Insurgency.ThirdPersonAnimInstance.CalcGroinAngle
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void UThirdPersonAnimInstance::CalcGroinAngle()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ThirdPersonAnimInstance.CalcGroinAngle");
		
		UThirdPersonAnimInstance_CalcGroinAngle_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05740520
	 * 		Name   -> Function Insurgency.ThirdPersonAnimInstance.CalcGenericFloatAlpha
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		float                                              Target                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              AlphaInput                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Speed                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bConstant                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              OutAlpha                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UThirdPersonAnimInstance::CalcGenericFloatAlpha(float Target, float AlphaInput, float Speed, bool bConstant, float* OutAlpha)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ThirdPersonAnimInstance.CalcGenericFloatAlpha");
		
		UThirdPersonAnimInstance_CalcGenericFloatAlpha_Params params {};
		params.Target = Target;
		params.AlphaInput = AlphaInput;
		params.Speed = Speed;
		params.bConstant = bConstant;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutAlpha != nullptr)
			*OutAlpha = params.OutAlpha;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05740270
	 * 		Name   -> Function Insurgency.ThirdPersonAnimInstance.CalcGenericAlpha
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		bool                                               bDifferentDegrade                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bTarget                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              AlphaInput                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Speed                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              SpeedDegrade                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bOverrideCondition                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              OverrideValue                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bConstant                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              OutAlpha                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UThirdPersonAnimInstance::CalcGenericAlpha(bool bDifferentDegrade, bool bTarget, float AlphaInput, float Speed, float SpeedDegrade, bool bOverrideCondition, float OverrideValue, bool bConstant, float* OutAlpha)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ThirdPersonAnimInstance.CalcGenericAlpha");
		
		UThirdPersonAnimInstance_CalcGenericAlpha_Params params {};
		params.bDifferentDegrade = bDifferentDegrade;
		params.bTarget = bTarget;
		params.AlphaInput = AlphaInput;
		params.Speed = Speed;
		params.SpeedDegrade = SpeedDegrade;
		params.bOverrideCondition = bOverrideCondition;
		params.OverrideValue = OverrideValue;
		params.bConstant = bConstant;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutAlpha != nullptr)
			*OutAlpha = params.OutAlpha;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> Function Insurgency.ThirdPersonAnimInstance.BlueprintOnCharacterReset
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 */
	void UThirdPersonAnimInstance::BlueprintOnCharacterReset()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.ThirdPersonAnimInstance.BlueprintOnCharacterReset");
		
		UThirdPersonAnimInstance_BlueprintOnCharacterReset_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UThirdPersonAnimInstance.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UThirdPersonAnimInstance::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.ThirdPersonAnimInstance");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05741640
	 * 		Name   -> Function Insurgency.TutorialLesson.ShowLessonAfterDelay
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		float                                              Delay                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Duration                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bPlayVideo                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bForceShow                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UTutorialLesson::ShowLessonAfterDelay(float Delay, float Duration, bool bPlayVideo, bool bForceShow)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.TutorialLesson.ShowLessonAfterDelay");
		
		UTutorialLesson_ShowLessonAfterDelay_Params params {};
		params.Delay = Delay;
		params.Duration = Duration;
		params.bPlayVideo = bPlayVideo;
		params.bForceShow = bForceShow;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05741530
	 * 		Name   -> Function Insurgency.TutorialLesson.ShowLesson
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		float                                              Duration                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bPlayVideo                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bForceShow                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UTutorialLesson::ShowLesson(float Duration, bool bPlayVideo, bool bForceShow)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.TutorialLesson.ShowLesson");
		
		UTutorialLesson_ShowLesson_Params params {};
		params.Duration = Duration;
		params.bPlayVideo = bPlayVideo;
		params.bForceShow = bForceShow;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05741500
	 * 		Name   -> Function Insurgency.TutorialLesson.ShouldShowLesson
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	bool UTutorialLesson::ShouldShowLesson()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.TutorialLesson.ShouldShowLesson");
		
		UTutorialLesson_ShouldShowLesson_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05741470
	 * 		Name   -> Function Insurgency.TutorialLesson.ShouldBindEventDelegates
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		bool                                               bForceBindDelegates                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UTutorialLesson::ShouldBindEventDelegates(bool bForceBindDelegates)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.TutorialLesson.ShouldBindEventDelegates");
		
		UTutorialLesson_ShouldBindEventDelegates_Params params {};
		params.bForceBindDelegates = bForceBindDelegates;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05741440
	 * 		Name   -> Function Insurgency.TutorialLesson.IsAnotherHintInProgress
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
	 */
	bool UTutorialLesson::IsAnotherHintInProgress()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.TutorialLesson.IsAnotherHintInProgress");
		
		UTutorialLesson_IsAnotherHintInProgress_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00C76AB0
	 * 		Name   -> Function Insurgency.TutorialLesson.HideLesson
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void UTutorialLesson::HideLesson()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.TutorialLesson.HideLesson");
		
		UTutorialLesson_HideLesson_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05741410
	 * 		Name   -> Function Insurgency.TutorialLesson.HasValidPlayer
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool UTutorialLesson::HasValidPlayer()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.TutorialLesson.HasValidPlayer");
		
		UTutorialLesson_HasValidPlayer_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x057413E0
	 * 		Name   -> Function Insurgency.TutorialLesson.GetAssociatedPlayerState
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	class AINSPlayerState* UTutorialLesson::GetAssociatedPlayerState()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.TutorialLesson.GetAssociatedPlayerState");
		
		UTutorialLesson_GetAssociatedPlayerState_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x057413B0
	 * 		Name   -> Function Insurgency.TutorialLesson.GetAssociatedPlayerController
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	class AINSBasePlayerController* UTutorialLesson::GetAssociatedPlayerController()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.TutorialLesson.GetAssociatedPlayerController");
		
		UTutorialLesson_GetAssociatedPlayerController_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05741390
	 * 		Name   -> Function Insurgency.TutorialLesson.CompleteLesson
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void UTutorialLesson::CompleteLesson()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.TutorialLesson.CompleteLesson");
		
		UTutorialLesson_CompleteLesson_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> Function Insurgency.TutorialLesson.BlueprintOnInitialized
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		class AINSBasePlayerController*                    NewOwningPlayerController                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AINSPlayerState*                             NewPlayer                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UTutorialLesson::BlueprintOnInitialized(class AINSBasePlayerController* NewOwningPlayerController, class AINSPlayerState* NewPlayer)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.TutorialLesson.BlueprintOnInitialized");
		
		UTutorialLesson_BlueprintOnInitialized_Params params {};
		params.NewOwningPlayerController = NewOwningPlayerController;
		params.NewPlayer = NewPlayer;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UTutorialLesson.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UTutorialLesson::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.TutorialLesson");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UTutorialList.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UTutorialList::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.TutorialList");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05741D60
	 * 		Name   -> Function Insurgency.TutorialLevelScriptActor.SetTutorialProgress
	 * 		Flags  -> (Final, BlueprintAuthorityOnly, Native, Private, BlueprintCallable)
	 * Parameters:
	 * 		ETutorialStage                                     Stage                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void ATutorialLevelScriptActor::SetTutorialProgress(ETutorialStage Stage)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.TutorialLevelScriptActor.SetTutorialProgress");
		
		ATutorialLevelScriptActor_SetTutorialProgress_Params params {};
		params.Stage = Stage;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ATutorialLevelScriptActor.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ATutorialLevelScriptActor::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.TutorialLevelScriptActor");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AUICameraActor.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AUICameraActor::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.UICameraActor");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> DelegateFunction Insurgency.UsableComponent.OnUseDelegate__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate, HasOutParms)
	 * Parameters:
	 * 		class APawn*                                       User                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FHitResult                                  HitResult                                                  (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	void UUsableComponent::OnUseDelegate__DelegateSignature(class APawn* User, const struct FHitResult& HitResult)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction Insurgency.UsableComponent.OnUseDelegate__DelegateSignature");
		
		UUsableComponent_OnUseDelegate__DelegateSignature_Params params {};
		params.User = User;
		params.HitResult = HitResult;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05742190
	 * 		Name   -> Function Insurgency.UsableComponent.GetUseMessage
	 * 		Flags  -> (Native, Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		class AINSPlayerController*                        Controller                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class FText UUsableComponent::GetUseMessage(class AINSPlayerController* Controller)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.UsableComponent.GetUseMessage");
		
		UUsableComponent_GetUseMessage_Params params {};
		params.Controller = Controller;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UUsableComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UUsableComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.UsableComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UUsableInterface.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UUsableInterface::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.UsableInterface");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05744B60
	 * 		Name   -> Function Insurgency.VehicleBase.ToggleHeadlights
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void AVehicleBase::ToggleHeadlights()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.VehicleBase.ToggleHeadlights");
		
		AVehicleBase_ToggleHeadlights_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05744AD0
	 * 		Name   -> Function Insurgency.VehicleBase.ToggleEngineStatus
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bEnabled                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AVehicleBase::ToggleEngineStatus(bool bEnabled)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.VehicleBase.ToggleEngineStatus");
		
		AVehicleBase_ToggleEngineStatus_Params params {};
		params.bEnabled = bEnabled;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05744AA0
	 * 		Name   -> Function Insurgency.VehicleBase.ShouldEmergancyBreak
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AVehicleBase::ShouldEmergancyBreak()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.VehicleBase.ShouldEmergancyBreak");
		
		AVehicleBase_ShouldEmergancyBreak_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x057449F0
	 * 		Name   -> Function Insurgency.VehicleBase.ServerSetAcceleratorInput
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
	 * Parameters:
	 * 		float                                              Value                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AVehicleBase::ServerSetAcceleratorInput(float Value)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.VehicleBase.ServerSetAcceleratorInput");
		
		AVehicleBase_ServerSetAcceleratorInput_Params params {};
		params.Value = Value;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00C76AB0
	 * 		Name   -> Function Insurgency.VehicleBase.OnRep_TeamId
	 * 		Flags  -> (Final, Native, Public)
	 */
	void AVehicleBase::OnRep_TeamId()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.VehicleBase.OnRep_TeamId");
		
		AVehicleBase_OnRep_TeamId_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00C76AB0
	 * 		Name   -> Function Insurgency.VehicleBase.OnRep_Locked
	 * 		Flags  -> (Final, Native, Public)
	 */
	void AVehicleBase::OnRep_Locked()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.VehicleBase.OnRep_Locked");
		
		AVehicleBase_OnRep_Locked_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00C76AB0
	 * 		Name   -> Function Insurgency.VehicleBase.OnRep_InsertionVehicle
	 * 		Flags  -> (Final, Native, Public)
	 */
	void AVehicleBase::OnRep_InsertionVehicle()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.VehicleBase.OnRep_InsertionVehicle");
		
		AVehicleBase_OnRep_InsertionVehicle_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x057449D0
	 * 		Name   -> Function Insurgency.VehicleBase.OnRep_HornHeld
	 * 		Flags  -> (Final, Native, Public)
	 */
	void AVehicleBase::OnRep_HornHeld()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.VehicleBase.OnRep_HornHeld");
		
		AVehicleBase_OnRep_HornHeld_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x057449B0
	 * 		Name   -> Function Insurgency.VehicleBase.OnRep_EngineRunning
	 * 		Flags  -> (Final, Native, Protected)
	 */
	void AVehicleBase::OnRep_EngineRunning()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.VehicleBase.OnRep_EngineRunning");
		
		AVehicleBase_OnRep_EngineRunning_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05744990
	 * 		Name   -> Function Insurgency.VehicleBase.OnRep_Braking
	 * 		Flags  -> (Final, Native, Public)
	 */
	void AVehicleBase::OnRep_Braking()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.VehicleBase.OnRep_Braking");
		
		AVehicleBase_OnRep_Braking_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05744790
	 * 		Name   -> Function Insurgency.VehicleBase.OnKillBoxOverlap
	 * 		Flags  -> (Native, Public, HasOutParms)
	 * Parameters:
	 * 		class UPrimitiveComponent*                         OverlappedComponent                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      OtherActor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UPrimitiveComponent*                         OtherComp                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            OtherBodyIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bFromSweep                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FHitResult                                  SweepResult                                                (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	void AVehicleBase::OnKillBoxOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32_t OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.VehicleBase.OnKillBoxOverlap");
		
		AVehicleBase_OnKillBoxOverlap_Params params {};
		params.OverlappedComponent = OverlappedComponent;
		params.OtherActor = OtherActor;
		params.OtherComp = OtherComp;
		params.OtherBodyIndex = OtherBodyIndex;
		params.bFromSweep = bFromSweep;
		params.SweepResult = SweepResult;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05744600
	 * 		Name   -> Function Insurgency.VehicleBase.OnImpact
	 * 		Flags  -> (Final, Native, Public, HasOutParms, HasDefaults)
	 * Parameters:
	 * 		class AActor*                                      SelfActor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      OtherActor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     NormalImpulse                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FHitResult                                  Hit                                                        (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	void AVehicleBase::OnImpact(class AActor* SelfActor, class AActor* OtherActor, const struct FVector& NormalImpulse, const struct FHitResult& Hit)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.VehicleBase.OnImpact");
		
		AVehicleBase_OnImpact_Params params {};
		params.SelfActor = SelfActor;
		params.OtherActor = OtherActor;
		params.NormalImpulse = NormalImpulse;
		params.Hit = Hit;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> Function Insurgency.VehicleBase.OnHeadlightToggled
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		bool                                               bEnabled                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AVehicleBase::OnHeadlightToggled(bool bEnabled)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.VehicleBase.OnHeadlightToggled");
		
		AVehicleBase_OnHeadlightToggled_Params params {};
		params.bEnabled = bEnabled;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> DelegateFunction Insurgency.VehicleBase.OnGearChangeDelegate__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 */
	void AVehicleBase::OnGearChangeDelegate__DelegateSignature()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction Insurgency.VehicleBase.OnGearChangeDelegate__DelegateSignature");
		
		AVehicleBase_OnGearChangeDelegate__DelegateSignature_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x057445E0
	 * 		Name   -> Function Insurgency.VehicleBase.OnDestroyedMeshLoaded
	 * 		Flags  -> (Final, Native, Public)
	 */
	void AVehicleBase::OnDestroyedMeshLoaded()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.VehicleBase.OnDestroyedMeshLoaded");
		
		AVehicleBase_OnDestroyedMeshLoaded_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> Function Insurgency.VehicleBase.OnDamage
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		class AController*                                 Killer                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      DamageCauser                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Damage                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AVehicleBase::OnDamage(class AController* Killer, class AActor* DamageCauser, float Damage)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.VehicleBase.OnDamage");
		
		AVehicleBase_OnDamage_Params params {};
		params.Killer = Killer;
		params.DamageCauser = DamageCauser;
		params.Damage = Damage;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> Function Insurgency.VehicleBase.OnBrakelightToggled
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		bool                                               bEnabled                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AVehicleBase::OnBrakelightToggled(bool bEnabled)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.VehicleBase.OnBrakelightToggled");
		
		AVehicleBase_OnBrakelightToggled_Params params {};
		params.bEnabled = bEnabled;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x04DB3AE0
	 * 		Name   -> Function Insurgency.VehicleBase.OnAcceleratorStarted
	 * 		Flags  -> (Final, Net, NetReliable, Native, Event, NetMulticast, Private)
	 */
	void AVehicleBase::OnAcceleratorStarted()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.VehicleBase.OnAcceleratorStarted");
		
		AVehicleBase_OnAcceleratorStarted_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x04DB3C40
	 * 		Name   -> Function Insurgency.VehicleBase.OnAcceleratorReleased
	 * 		Flags  -> (Final, Net, NetReliable, Native, Event, NetMulticast, Private)
	 */
	void AVehicleBase::OnAcceleratorReleased()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.VehicleBase.OnAcceleratorReleased");
		
		AVehicleBase_OnAcceleratorReleased_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x04DB40A0
	 * 		Name   -> Function Insurgency.VehicleBase.OnAcceleratorContinue
	 * 		Flags  -> (Final, Net, NetReliable, Native, Event, NetMulticast, Private)
	 */
	void AVehicleBase::OnAcceleratorContinue()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.VehicleBase.OnAcceleratorContinue");
		
		AVehicleBase_OnAcceleratorContinue_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x057445B0
	 * 		Name   -> Function Insurgency.VehicleBase.IsVehicleUpsideDown
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
	 */
	bool AVehicleBase::IsVehicleUpsideDown()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.VehicleBase.IsVehicleUpsideDown");
		
		AVehicleBase_IsVehicleUpsideDown_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05744580
	 * 		Name   -> Function Insurgency.VehicleBase.IsVehicleOnSide
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
	 */
	bool AVehicleBase::IsVehicleOnSide()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.VehicleBase.IsVehicleOnSide");
		
		AVehicleBase_IsVehicleOnSide_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05744550
	 * 		Name   -> Function Insurgency.VehicleBase.IsVehicleDestroyed
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AVehicleBase::IsVehicleDestroyed()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.VehicleBase.IsVehicleDestroyed");
		
		AVehicleBase_IsVehicleDestroyed_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05744520
	 * 		Name   -> Function Insurgency.VehicleBase.IsPotentiallyAbandoned
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AVehicleBase::IsPotentiallyAbandoned()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.VehicleBase.IsPotentiallyAbandoned");
		
		AVehicleBase_IsPotentiallyAbandoned_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05744480
	 * 		Name   -> Function Insurgency.VehicleBase.IsPawnSeated
	 * 		Flags  -> (Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class APawn*                                       PassengerPawn                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool AVehicleBase::IsPawnSeated(class APawn* PassengerPawn)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.VehicleBase.IsPawnSeated");
		
		AVehicleBase_IsPawnSeated_Params params {};
		params.PassengerPawn = PassengerPawn;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05744460
	 * 		Name   -> Function Insurgency.VehicleBase.IsEngineRunning
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
	 */
	bool AVehicleBase::IsEngineRunning()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.VehicleBase.IsEngineRunning");
		
		AVehicleBase_IsEngineRunning_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05744440
	 * 		Name   -> Function Insurgency.VehicleBase.IsEngineEnabled
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
	 */
	bool AVehicleBase::IsEngineEnabled()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.VehicleBase.IsEngineEnabled");
		
		AVehicleBase_IsEngineEnabled_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05744420
	 * 		Name   -> Function Insurgency.VehicleBase.IsBurning
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
	 */
	bool AVehicleBase::IsBurning()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.VehicleBase.IsBurning");
		
		AVehicleBase_IsBurning_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x057443F0
	 * 		Name   -> Function Insurgency.VehicleBase.GetVehicleRPM
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	int32_t AVehicleBase::GetVehicleRPM()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.VehicleBase.GetVehicleRPM");
		
		AVehicleBase_GetVehicleRPM_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x057443D0
	 * 		Name   -> Function Insurgency.VehicleBase.GetVehicleOrientation
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
	 */
	EVehicleOrientation AVehicleBase::GetVehicleOrientation()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.VehicleBase.GetVehicleOrientation");
		
		AVehicleBase_GetVehicleOrientation_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x057443A0
	 * 		Name   -> Function Insurgency.VehicleBase.GetSteeringProgress
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	float AVehicleBase::GetSteeringProgress()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.VehicleBase.GetSteeringProgress");
		
		AVehicleBase_GetSteeringProgress_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05744260
	 * 		Name   -> Function Insurgency.VehicleBase.GetSteeringAngles
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		float                                              MinAngle                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              MaxAngle                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              CurrentAngle                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AVehicleBase::GetSteeringAngles(float* MinAngle, float* MaxAngle, float* CurrentAngle)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.VehicleBase.GetSteeringAngles");
		
		AVehicleBase_GetSteeringAngles_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (MinAngle != nullptr)
			*MinAngle = params.MinAngle;
		if (MaxAngle != nullptr)
			*MaxAngle = params.MaxAngle;
		if (CurrentAngle != nullptr)
			*CurrentAngle = params.CurrentAngle;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x057441A0
	 * 		Name   -> Function Insurgency.VehicleBase.GetSeatComponents
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		TArray<class UVehicleSeatComponent*>               OutSeatComponents                                          (Parm, OutParm, ZeroConstructor, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool AVehicleBase::GetSeatComponents(TArray<class UVehicleSeatComponent*>* OutSeatComponents)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.VehicleBase.GetSeatComponents");
		
		AVehicleBase_GetSeatComponents_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutSeatComponents != nullptr)
			*OutSeatComponents = params.OutSeatComponents;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x057440F0
	 * 		Name   -> Function Insurgency.VehicleBase.GetPassengers
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		TArray<class AINSCharacter*>                       OutPassengers                                              (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AVehicleBase::GetPassengers(TArray<class AINSCharacter*>* OutPassengers)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.VehicleBase.GetPassengers");
		
		AVehicleBase_GetPassengers_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutPassengers != nullptr)
			*OutPassengers = params.OutPassengers;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x057440C0
	 * 		Name   -> Function Insurgency.VehicleBase.GetPassengerCount
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	int32_t AVehicleBase::GetPassengerCount()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.VehicleBase.GetPassengerCount");
		
		AVehicleBase_GetPassengerCount_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05744090
	 * 		Name   -> Function Insurgency.VehicleBase.GetOccupiedSeats
	 * 		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	int32_t AVehicleBase::GetOccupiedSeats()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.VehicleBase.GetOccupiedSeats");
		
		AVehicleBase_GetOccupiedSeats_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05744060
	 * 		Name   -> Function Insurgency.VehicleBase.GetEmptySeats
	 * 		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	int32_t AVehicleBase::GetEmptySeats()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.VehicleBase.GetEmptySeats");
		
		AVehicleBase_GetEmptySeats_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05744030
	 * 		Name   -> Function Insurgency.VehicleBase.GetChasisStrainValue
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	float AVehicleBase::GetChasisStrainValue()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.VehicleBase.GetChasisStrainValue");
		
		AVehicleBase_GetChasisStrainValue_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05743FA0
	 * 		Name   -> Function Insurgency.VehicleBase.ForceStop
	 * 		Flags  -> (Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bDisableEngine                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AVehicleBase::ForceStop(bool bDisableEngine)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.VehicleBase.ForceStop");
		
		AVehicleBase_ForceStop_Params params {};
		params.bDisableEngine = bDisableEngine;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05743F10
	 * 		Name   -> Function Insurgency.VehicleBase.FindSeatByNumber
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		int8_t                                             SeatNumber                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UVehicleSeatComponent* AVehicleBase::FindSeatByNumber(int8_t SeatNumber)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.VehicleBase.FindSeatByNumber");
		
		AVehicleBase_FindSeatByNumber_Params params {};
		params.SeatNumber = SeatNumber;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05743E80
	 * 		Name   -> Function Insurgency.VehicleBase.FindNextSeat
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class AController*                                 PassengerController                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UVehicleSeatComponent* AVehicleBase::FindNextSeat(class AController* PassengerController)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.VehicleBase.FindNextSeat");
		
		AVehicleBase_FindNextSeat_Params params {};
		params.PassengerController = PassengerController;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05743DB0
	 * 		Name   -> Function Insurgency.VehicleBase.FindBestSeat
	 * 		Flags  -> (Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class AINSCharacter*                               Pawn                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		ESeatSearchPriorityType                            PriorityType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UVehicleSeatComponent* AVehicleBase::FindBestSeat(class AINSCharacter* Pawn, ESeatSearchPriorityType PriorityType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.VehicleBase.FindBestSeat");
		
		AVehicleBase_FindBestSeat_Params params {};
		params.Pawn = Pawn;
		params.PriorityType = PriorityType;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05743D90
	 * 		Name   -> Function Insurgency.VehicleBase.CheckAbandoned
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void AVehicleBase::CheckAbandoned()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.VehicleBase.CheckAbandoned");
		
		AVehicleBase_CheckAbandoned_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> Function Insurgency.VehicleBase.BlueprintOnGearChanged
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 */
	void AVehicleBase::BlueprintOnGearChanged()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.VehicleBase.BlueprintOnGearChanged");
		
		AVehicleBase_BlueprintOnGearChanged_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AVehicleBase.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AVehicleBase::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.VehicleBase");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x057474B0
	 * 		Name   -> Function Insurgency.VehiclePartComponent.SetHealthFrac
	 * 		Flags  -> (Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		float                                              HealthFrac                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UVehiclePartComponent::SetHealthFrac(float HealthFrac)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.VehiclePartComponent.SetHealthFrac");
		
		UVehiclePartComponent_SetHealthFrac_Params params {};
		params.HealthFrac = HealthFrac;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> Function Insurgency.VehiclePartComponent.OnTakeDamage
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		float                                              Damage                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AController*                                 EventInstigator                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      DamageCauser                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UVehiclePartComponent::OnTakeDamage(float Damage, class AController* EventInstigator, class AActor* DamageCauser)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.VehiclePartComponent.OnTakeDamage");
		
		UVehiclePartComponent_OnTakeDamage_Params params {};
		params.Damage = Damage;
		params.EventInstigator = EventInstigator;
		params.DamageCauser = DamageCauser;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x04DB5000
	 * 		Name   -> Function Insurgency.VehiclePartComponent.OnRep_Health
	 * 		Flags  -> (Native, Public)
	 */
	void UVehiclePartComponent::OnRep_Health()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.VehiclePartComponent.OnRep_Health");
		
		UVehiclePartComponent_OnRep_Health_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05747490
	 * 		Name   -> Function Insurgency.VehiclePartComponent.OnRep_Destroyed
	 * 		Flags  -> (Final, Native, Public)
	 */
	void UVehiclePartComponent::OnRep_Destroyed()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.VehiclePartComponent.OnRep_Destroyed");
		
		UVehiclePartComponent_OnRep_Destroyed_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05747470
	 * 		Name   -> Function Insurgency.VehiclePartComponent.OnDestroyed
	 * 		Flags  -> (Final, Native, Public)
	 */
	void UVehiclePartComponent::OnDestroyed()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.VehiclePartComponent.OnDestroyed");
		
		UVehiclePartComponent_OnDestroyed_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05747450
	 * 		Name   -> Function Insurgency.VehiclePartComponent.IsDestroyed
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
	 */
	bool UVehiclePartComponent::IsDestroyed()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.VehiclePartComponent.IsDestroyed");
		
		UVehiclePartComponent_IsDestroyed_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UVehiclePartComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UVehiclePartComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.VehiclePartComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UVehicleDestructablePart.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UVehicleDestructablePart::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.VehicleDestructablePart");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05746980
	 * 		Name   -> Function Insurgency.VehicleHoveringBase.TraceEnvironment
	 * 		Flags  -> (Final, Native, Protected)
	 */
	void AVehicleHoveringBase::TraceEnvironment()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.VehicleHoveringBase.TraceEnvironment");
		
		AVehicleHoveringBase_TraceEnvironment_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x04E1B5D0
	 * 		Name   -> Function Insurgency.VehicleHoveringBase.ToggleNoDamage
	 * 		Flags  -> (Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bEnabled                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AVehicleHoveringBase::ToggleNoDamage(bool bEnabled)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.VehicleHoveringBase.ToggleNoDamage");
		
		AVehicleHoveringBase_ToggleNoDamage_Params params {};
		params.bEnabled = bEnabled;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x04E1C4D0
	 * 		Name   -> Function Insurgency.VehicleHoveringBase.ToggleAI
	 * 		Flags  -> (Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bEnabled                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AVehicleHoveringBase::ToggleAI(bool bEnabled)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.VehicleHoveringBase.ToggleAI");
		
		AVehicleHoveringBase_ToggleAI_Params params {};
		params.bEnabled = bEnabled;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x057468F0
	 * 		Name   -> Function Insurgency.VehicleHoveringBase.StartFalling
	 * 		Flags  -> (Final, Native, Protected, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bSpin                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AVehicleHoveringBase::StartFalling(bool bSpin)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.VehicleHoveringBase.StartFalling");
		
		AVehicleHoveringBase_StartFalling_Params params {};
		params.bSpin = bSpin;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05746860
	 * 		Name   -> Function Insurgency.VehicleHoveringBase.SetOpenDoor
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bNewOpenDoor                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AVehicleHoveringBase::SetOpenDoor(bool bNewOpenDoor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.VehicleHoveringBase.SetOpenDoor");
		
		AVehicleHoveringBase_SetOpenDoor_Params params {};
		params.bNewOpenDoor = bNewOpenDoor;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x057467D0
	 * 		Name   -> Function Insurgency.VehicleHoveringBase.SetCinematicMode
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bNewSetting                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AVehicleHoveringBase::SetCinematicMode(bool bNewSetting)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.VehicleHoveringBase.SetCinematicMode");
		
		AVehicleHoveringBase_SetCinematicMode_Params params {};
		params.bNewSetting = bNewSetting;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05746740
	 * 		Name   -> Function Insurgency.VehicleHoveringBase.SeePawn
	 * 		Flags  -> (Native, Protected)
	 * Parameters:
	 * 		class APawn*                                       OtherPawn                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AVehicleHoveringBase::SeePawn(class APawn* OtherPawn)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.VehicleHoveringBase.SeePawn");
		
		AVehicleHoveringBase_SeePawn_Params params {};
		params.OtherPawn = OtherPawn;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05746720
	 * 		Name   -> Function Insurgency.VehicleHoveringBase.PlayDestroyedResponses
	 * 		Flags  -> (Final, Native, Protected)
	 */
	void AVehicleHoveringBase::PlayDestroyedResponses()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.VehicleHoveringBase.PlayDestroyedResponses");
		
		AVehicleHoveringBase_PlayDestroyedResponses_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05746660
	 * 		Name   -> Function Insurgency.VehicleHoveringBase.OnSeatEjected
	 * 		Flags  -> (Final, Native, Protected)
	 * Parameters:
	 * 		class AINSCharacter*                               Character                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UVehicleSeatComponent*                       Seat                                                       (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AVehicleHoveringBase::OnSeatEjected(class AINSCharacter* Character, class UVehicleSeatComponent* Seat)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.VehicleHoveringBase.OnSeatEjected");
		
		AVehicleHoveringBase_OnSeatEjected_Params params {};
		params.Character = Character;
		params.Seat = Seat;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05746640
	 * 		Name   -> Function Insurgency.VehicleHoveringBase.OnRep_Detonating
	 * 		Flags  -> (Final, Native, Protected)
	 */
	void AVehicleHoveringBase::OnRep_Detonating()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.VehicleHoveringBase.OnRep_Detonating");
		
		AVehicleHoveringBase_OnRep_Detonating_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05746620
	 * 		Name   -> Function Insurgency.VehicleHoveringBase.OnRep_DamageState
	 * 		Flags  -> (Final, Native, Private)
	 */
	void AVehicleHoveringBase::OnRep_DamageState()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.VehicleHoveringBase.OnRep_DamageState");
		
		AVehicleHoveringBase_OnRep_DamageState_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05746600
	 * 		Name   -> Function Insurgency.VehicleHoveringBase.OnRep_CinematicMode
	 * 		Flags  -> (Final, Native, Private)
	 */
	void AVehicleHoveringBase::OnRep_CinematicMode()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.VehicleHoveringBase.OnRep_CinematicMode");
		
		AVehicleHoveringBase_OnRep_CinematicMode_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05746470
	 * 		Name   -> Function Insurgency.VehicleHoveringBase.OnImpact
	 * 		Flags  -> (Final, Native, Protected, HasOutParms, HasDefaults)
	 * Parameters:
	 * 		class AActor*                                      SelfActor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      OtherActor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     NormalImpulse                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FHitResult                                  Hit                                                        (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	void AVehicleHoveringBase::OnImpact(class AActor* SelfActor, class AActor* OtherActor, const struct FVector& NormalImpulse, const struct FHitResult& Hit)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.VehicleHoveringBase.OnImpact");
		
		AVehicleHoveringBase_OnImpact_Params params {};
		params.SelfActor = SelfActor;
		params.OtherActor = OtherActor;
		params.NormalImpulse = NormalImpulse;
		params.Hit = Hit;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05746450
	 * 		Name   -> Function Insurgency.VehicleHoveringBase.OnFinishedDodge
	 * 		Flags  -> (Final, Native, Private)
	 */
	void AVehicleHoveringBase::OnFinishedDodge()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.VehicleHoveringBase.OnFinishedDodge");
		
		AVehicleHoveringBase_OnFinishedDodge_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> Function Insurgency.VehicleHoveringBase.OnExplode
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 */
	void AVehicleHoveringBase::OnExplode()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.VehicleHoveringBase.OnExplode");
		
		AVehicleHoveringBase_OnExplode_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x057463C0
	 * 		Name   -> Function Insurgency.VehicleHoveringBase.IsDodging
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		bool                                               bRecently                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool AVehicleHoveringBase::IsDodging(bool bRecently)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.VehicleHoveringBase.IsDodging");
		
		AVehicleHoveringBase_IsDodging_Params params {};
		params.bRecently = bRecently;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x057462B0
	 * 		Name   -> Function Insurgency.VehicleHoveringBase.HearNoise
	 * 		Flags  -> (Native, Protected, HasOutParms, HasDefaults)
	 * Parameters:
	 * 		class APawn*                                       OtherActor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     Location                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Volume                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AVehicleHoveringBase::HearNoise(class APawn* OtherActor, const struct FVector& Location, float Volume)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.VehicleHoveringBase.HearNoise");
		
		AVehicleHoveringBase_HearNoise_Params params {};
		params.OtherActor = OtherActor;
		params.Location = Location;
		params.Volume = Volume;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05746290
	 * 		Name   -> Function Insurgency.VehicleHoveringBase.GetDamageState
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	EHoverVehicleDamageState AVehicleHoveringBase::GetDamageState()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.VehicleHoveringBase.GetDamageState");
		
		AVehicleHoveringBase_GetDamageState_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05746260
	 * 		Name   -> Function Insurgency.VehicleHoveringBase.Explode
	 * 		Flags  -> (Native, Public)
	 */
	void AVehicleHoveringBase::Explode()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.VehicleHoveringBase.Explode");
		
		AVehicleHoveringBase_Explode_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05654A20
	 * 		Name   -> Function Insurgency.VehicleHoveringBase.DelayedDestroy
	 * 		Flags  -> (Final, Native, Protected)
	 */
	void AVehicleHoveringBase::DelayedDestroy()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.VehicleHoveringBase.DelayedDestroy");
		
		AVehicleHoveringBase_DelayedDestroy_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x057461E0
	 * 		Name   -> Function Insurgency.VehicleHoveringBase.BeginDetonate
	 * 		Flags  -> (Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		float                                              Delay                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void AVehicleHoveringBase::BeginDetonate(float Delay)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.VehicleHoveringBase.BeginDetonate");
		
		AVehicleHoveringBase_BeginDetonate_Params params {};
		params.Delay = Delay;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AVehicleHoveringBase.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AVehicleHoveringBase::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.VehicleHoveringBase");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05744EA0
	 * 		Name   -> Function Insurgency.VehicleDrone.GetDiveTarget
	 * 		Flags  -> (Final, Native, Protected, BlueprintCallable, BlueprintPure)
	 */
	class AActor* AVehicleDrone::GetDiveTarget()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.VehicleDrone.GetDiveTarget");
		
		AVehicleDrone_GetDiveTarget_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AVehicleDrone.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AVehicleDrone::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.VehicleDrone");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x04DB5320
	 * 		Name   -> Function Insurgency.VehicleEnginePart.BroadcastEngineBlowUp
	 * 		Flags  -> (Net, NetReliable, Native, Event, NetMulticast, Public)
	 */
	void UVehicleEnginePart::BroadcastEngineBlowUp()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.VehicleEnginePart.BroadcastEngineBlowUp");
		
		UVehicleEnginePart_BroadcastEngineBlowUp_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UVehicleEnginePart.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UVehicleEnginePart::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.VehicleEnginePart");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05745400
	 * 		Name   -> Function Insurgency.VehicleExitComponent.GetSeatExitLocation
	 * 		Flags  -> (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FVector                                     OutLocation                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FRotator                                    OutRotation                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UVehicleExitComponent::GetSeatExitLocation(struct FVector* OutLocation, struct FRotator* OutRotation)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.VehicleExitComponent.GetSeatExitLocation");
		
		UVehicleExitComponent_GetSeatExitLocation_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutLocation != nullptr)
			*OutLocation = params.OutLocation;
		if (OutRotation != nullptr)
			*OutRotation = params.OutRotation;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UVehicleExitComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UVehicleExitComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.VehicleExitComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UVehicleEmergencyExitComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UVehicleEmergencyExitComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.VehicleEmergencyExitComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05662740
	 * 		Name   -> Function Insurgency.VehicleInterface.Explode
	 * 		Flags  -> (Native, Public, BlueprintCallable)
	 */
	void UVehicleInterface::Explode()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.VehicleInterface.Explode");
		
		UVehicleInterface_Explode_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UVehicleInterface.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UVehicleInterface::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.VehicleInterface");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05746D00
	 * 		Name   -> Function Insurgency.VehicleLightPart.OnRep_IsToggled
	 * 		Flags  -> (Final, Native, Private)
	 */
	void UVehicleLightPart::OnRep_IsToggled()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.VehicleLightPart.OnRep_IsToggled");
		
		UVehicleLightPart_OnRep_IsToggled_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UVehicleLightPart.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UVehicleLightPart::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.VehicleLightPart");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UVehicleNavModifierComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UVehicleNavModifierComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.VehicleNavModifierComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AVehicleNavTarget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AVehicleNavTarget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.VehicleNavTarget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UVehiclePathFollowingComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UVehiclePathFollowingComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.VehiclePathFollowingComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x057485B0
	 * 		Name   -> Function Insurgency.VehicleSeatComponent.SetTurretComponents
	 * 		Flags  -> (Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class USceneComponent*                             NewPitchComponent                                          (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class USceneComponent*                             NewYawComponent                                            (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UVehicleSeatComponent::SetTurretComponents(class USceneComponent* NewPitchComponent, class USceneComponent* NewYawComponent)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.VehicleSeatComponent.SetTurretComponents");
		
		UVehicleSeatComponent_SetTurretComponents_Params params {};
		params.NewPitchComponent = NewPitchComponent;
		params.NewYawComponent = NewYawComponent;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05748530
	 * 		Name   -> Function Insurgency.VehicleSeatComponent.SetLocked
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bNewLocked                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UVehicleSeatComponent::SetLocked(bool bNewLocked)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.VehicleSeatComponent.SetLocked");
		
		UVehicleSeatComponent_SetLocked_Params params {};
		params.bNewLocked = bNewLocked;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x057484B0
	 * 		Name   -> Function Insurgency.VehicleSeatComponent.SetCharacterAttachmentMesh
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UMeshComponent*                              AttachmentMesh                                             (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UVehicleSeatComponent::SetCharacterAttachmentMesh(class UMeshComponent* AttachmentMesh)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.VehicleSeatComponent.SetCharacterAttachmentMesh");
		
		UVehicleSeatComponent_SetCharacterAttachmentMesh_Params params {};
		params.AttachmentMesh = AttachmentMesh;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x04E20840
	 * 		Name   -> Function Insurgency.VehicleSeatComponent.PlaySeatAudio
	 * 		Flags  -> (Net, Native, Event, NetMulticast, Public)
	 * Parameters:
	 * 		class UAkAudioEvent*                               Event                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UVehicleSeatComponent::PlaySeatAudio(class UAkAudioEvent* Event)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.VehicleSeatComponent.PlaySeatAudio");
		
		UVehicleSeatComponent_PlaySeatAudio_Params params {};
		params.Event = Event;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05748490
	 * 		Name   -> Function Insurgency.VehicleSeatComponent.OnRep_MountedWeapon
	 * 		Flags  -> (Final, Native, Protected)
	 */
	void UVehicleSeatComponent::OnRep_MountedWeapon()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.VehicleSeatComponent.OnRep_MountedWeapon");
		
		UVehicleSeatComponent_OnRep_MountedWeapon_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> Function Insurgency.VehicleSeatComponent.OnExited
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		class APawn*                                       ExitedPawn                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UVehicleSeatComponent::OnExited(class APawn* ExitedPawn)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.VehicleSeatComponent.OnExited");
		
		UVehicleSeatComponent_OnExited_Params params {};
		params.ExitedPawn = ExitedPawn;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> Function Insurgency.VehicleSeatComponent.OnEntered
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		class APawn*                                       EnteredPawn                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UVehicleSeatComponent::OnEntered(class APawn* EnteredPawn)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.VehicleSeatComponent.OnEntered");
		
		UVehicleSeatComponent_OnEntered_Params params {};
		params.EnteredPawn = EnteredPawn;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> Function Insurgency.VehicleSeatComponent.OnAction
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 */
	bool UVehicleSeatComponent::OnAction()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.VehicleSeatComponent.OnAction");
		
		UVehicleSeatComponent_OnAction_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x04DB4CE0
	 * 		Name   -> Function Insurgency.VehicleSeatComponent.Multicast_OnSoldierLeaned
	 * 		Flags  -> (Net, NetReliable, Native, Event, NetMulticast, Public)
	 */
	void UVehicleSeatComponent::Multicast_OnSoldierLeaned()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.VehicleSeatComponent.Multicast_OnSoldierLeaned");
		
		UVehicleSeatComponent_Multicast_OnSoldierLeaned_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05748460
	 * 		Name   -> Function Insurgency.VehicleSeatComponent.GetVehicle
	 * 		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	class AVehicleBase* UVehicleSeatComponent::GetVehicle()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.VehicleSeatComponent.GetVehicle");
		
		UVehicleSeatComponent_GetVehicle_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05748420
	 * 		Name   -> Function Insurgency.VehicleSeatComponent.GetTurretRotation
	 * 		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
	 */
	struct FRotator UVehicleSeatComponent::GetTurretRotation()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.VehicleSeatComponent.GetTurretRotation");
		
		UVehicleSeatComponent_GetTurretRotation_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x057483F0
	 * 		Name   -> Function Insurgency.VehicleSeatComponent.GetSeatedCharacter
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	class AINSCharacter* UVehicleSeatComponent::GetSeatedCharacter()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.VehicleSeatComponent.GetSeatedCharacter");
		
		UVehicleSeatComponent_GetSeatedCharacter_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x057483B0
	 * 		Name   -> Function Insurgency.VehicleSeatComponent.GetRelativeTurretRotation
	 * 		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
	 */
	struct FRotator UVehicleSeatComponent::GetRelativeTurretRotation()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.VehicleSeatComponent.GetRelativeTurretRotation");
		
		UVehicleSeatComponent_GetRelativeTurretRotation_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05748380
	 * 		Name   -> Function Insurgency.VehicleSeatComponent.GetMountedWeapon
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	class AItemFirearm* UVehicleSeatComponent::GetMountedWeapon()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.VehicleSeatComponent.GetMountedWeapon");
		
		UVehicleSeatComponent_GetMountedWeapon_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05748340
	 * 		Name   -> Function Insurgency.VehicleSeatComponent.GetDesiredTurretRotation
	 * 		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
	 */
	struct FRotator UVehicleSeatComponent::GetDesiredTurretRotation()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.VehicleSeatComponent.GetDesiredTurretRotation");
		
		UVehicleSeatComponent_GetDesiredTurretRotation_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x057482B0
	 * 		Name   -> Function Insurgency.VehicleSeatComponent.Fire
	 * 		Flags  -> (Net, NetReliable, Native, Event, NetMulticast, Public)
	 * Parameters:
	 * 		bool                                               TriggerDown                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UVehicleSeatComponent::Fire(bool TriggerDown)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.VehicleSeatComponent.Fire");
		
		UVehicleSeatComponent_Fire_Params params {};
		params.TriggerDown = TriggerDown;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x057481E0
	 * 		Name   -> Function Insurgency.VehicleSeatComponent.EnterSeat
	 * 		Flags  -> (Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class AINSCharacter*                               Pawn                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bFromReplication                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UVehicleSeatComponent::EnterSeat(class AINSCharacter* Pawn, bool bFromReplication)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.VehicleSeatComponent.EnterSeat");
		
		UVehicleSeatComponent_EnterSeat_Params params {};
		params.Pawn = Pawn;
		params.bFromReplication = bFromReplication;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x04E20E40
	 * 		Name   -> Function Insurgency.VehicleSeatComponent.EjectSeat
	 * 		Flags  -> (Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class AINSCharacter*                               PreviousPawn                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UVehicleSeatComponent::EjectSeat(class AINSCharacter* PreviousPawn)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.VehicleSeatComponent.EjectSeat");
		
		UVehicleSeatComponent_EjectSeat_Params params {};
		params.PreviousPawn = PreviousPawn;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05748140
	 * 		Name   -> Function Insurgency.VehicleSeatComponent.CanTurretAimAtLocation
	 * 		Flags  -> (Native, Public, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FVector                                     Location                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UVehicleSeatComponent::CanTurretAimAtLocation(const struct FVector& Location)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.VehicleSeatComponent.CanTurretAimAtLocation");
		
		UVehicleSeatComponent_CanTurretAimAtLocation_Params params {};
		params.Location = Location;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05748070
	 * 		Name   -> Function Insurgency.VehicleSeatComponent.CanEnterSeat
	 * 		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		class AINSCharacter*                               Character                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bFromReplication                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UVehicleSeatComponent::CanEnterSeat(class AINSCharacter* Character, bool bFromReplication)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.VehicleSeatComponent.CanEnterSeat");
		
		UVehicleSeatComponent_CanEnterSeat_Params params {};
		params.Character = Character;
		params.bFromReplication = bFromReplication;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UVehicleSeatComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UVehicleSeatComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.VehicleSeatComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AVehicleSpline.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AVehicleSpline::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.VehicleSpline");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UVehicleSplineFollowingComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UVehicleSplineFollowingComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.VehicleSplineFollowingComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UVehicleWeakPointPart.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UVehicleWeakPointPart::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.VehicleWeakPointPart");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UVehicleWheelPart.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UVehicleWheelPart::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.VehicleWheelPart");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UVehicleWindowPart.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UVehicleWindowPart::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.VehicleWindowPart");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05748DE0
	 * 		Name   -> Function Insurgency.VideoMenu.PopulateMenu
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void UVideoMenu::PopulateMenu()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.VideoMenu.PopulateMenu");
		
		UVideoMenu_PopulateMenu_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UVideoMenu.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UVideoMenu::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.VideoMenu");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AVisibilityBlockerVolume.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AVisibilityBlockerVolume::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.VisibilityBlockerVolume");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UVivoxSettings.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UVivoxSettings::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.VivoxSettings");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UVoiceComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UVoiceComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.VoiceComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UVoiceRouting.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UVoiceRouting::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.VoiceRouting");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> Function Insurgency.VoiceStatus.OnTalkingPlayersChanged
	 * 		Flags  -> (Event, Public, HasOutParms, BlueprintEvent)
	 * Parameters:
	 * 		TArray<class APlayerState*>                        InTalkingPlayers                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UVoiceStatus::OnTalkingPlayersChanged(TArray<class APlayerState*> InTalkingPlayers)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.VoiceStatus.OnTalkingPlayersChanged");
		
		UVoiceStatus_OnTalkingPlayersChanged_Params params {};
		params.InTalkingPlayers = InTalkingPlayers;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x057499C0
	 * 		Name   -> Function Insurgency.VoiceStatus.OnRemoteVoiceChatStateChanged
	 * 		Flags  -> (Final, Native, Private)
	 * Parameters:
	 * 		class FString                                      PlayerName                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FString                                      ChannelName                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AINSPlayerState*                             DetectedPlayerState                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bSpeaking                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bNonPositional                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UVoiceStatus::OnRemoteVoiceChatStateChanged(const class FString& PlayerName, const class FString& ChannelName, class AINSPlayerState* DetectedPlayerState, bool bSpeaking, bool bNonPositional)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.VoiceStatus.OnRemoteVoiceChatStateChanged");
		
		UVoiceStatus_OnRemoteVoiceChatStateChanged_Params params {};
		params.PlayerName = PlayerName;
		params.ChannelName = ChannelName;
		params.DetectedPlayerState = DetectedPlayerState;
		params.bSpeaking = bSpeaking;
		params.bNonPositional = bNonPositional;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x057498F0
	 * 		Name   -> Function Insurgency.VoiceStatus.OnPlayerTalkingStateChanged
	 * 		Flags  -> (Native, Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		class APlayerState*                                PlayerState                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bIsTalking                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UVoiceStatus::OnPlayerTalkingStateChanged(class APlayerState* PlayerState, bool bIsTalking)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.VoiceStatus.OnPlayerTalkingStateChanged");
		
		UVoiceStatus_OnPlayerTalkingStateChanged_Params params {};
		params.PlayerState = PlayerState;
		params.bIsTalking = bIsTalking;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UVoiceStatus.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UVoiceStatus::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.VoiceStatus");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UVoteCallResultMessage.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UVoteCallResultMessage::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.VoteCallResultMessage");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UVoteCastResultMessage.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UVoteCastResultMessage::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.VoteCastResultMessage");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UVoteIntentMessage.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UVoteIntentMessage::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.VoteIntentMessage");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0574B140
	 * 		Name   -> Function Insurgency.VoteIssue.UpdateVotingFigures
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		TArray<struct FReplicatedVoteChoice>               InOutVoteChoiceArray                                       (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UVoteIssue::UpdateVotingFigures(TArray<struct FReplicatedVoteChoice>* InOutVoteChoiceArray)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.VoteIssue.UpdateVotingFigures");
		
		UVoteIssue_UpdateVotingFigures_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (InOutVoteChoiceArray != nullptr)
			*InOutVoteChoiceArray = params.InOutVoteChoiceArray;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0574B020
	 * 		Name   -> Function Insurgency.VoteIssue.RegisterVoteIntent
	 * 		Flags  -> (Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class APlayerState*                                FromPlayer                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FString                                      Option                                                     (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class APlayerState*                                TargetPlayer                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	ECallVoteResult UVoteIssue::RegisterVoteIntent(class APlayerState* FromPlayer, const class FString& Option, class APlayerState* TargetPlayer)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.VoteIssue.RegisterVoteIntent");
		
		UVoteIssue_RegisterVoteIntent_Params params {};
		params.FromPlayer = FromPlayer;
		params.Option = Option;
		params.TargetPlayer = TargetPlayer;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0574B000
	 * 		Name   -> Function Insurgency.VoteIssue.OnVoteSuccess
	 * 		Flags  -> (Native, Event, Public, BlueprintEvent)
	 */
	void UVoteIssue::OnVoteSuccess()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.VoteIssue.OnVoteSuccess");
		
		UVoteIssue_OnVoteSuccess_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0574AF20
	 * 		Name   -> Function Insurgency.VoteIssue.OnVoteStarted
	 * 		Flags  -> (Native, Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		class FString                                      Option                                                     (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class APlayerState*                                TargetPlayer                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UVoteIssue::OnVoteStarted(const class FString& Option, class APlayerState* TargetPlayer)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.VoteIssue.OnVoteStarted");
		
		UVoteIssue_OnVoteStarted_Params params {};
		params.Option = Option;
		params.TargetPlayer = TargetPlayer;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0574AF00
	 * 		Name   -> Function Insurgency.VoteIssue.OnVoteReset
	 * 		Flags  -> (Native, Event, Public, BlueprintEvent)
	 */
	void UVoteIssue::OnVoteReset()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.VoteIssue.OnVoteReset");
		
		UVoteIssue_OnVoteReset_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0574AE30
	 * 		Name   -> Function Insurgency.VoteIssue.OnPlayerVote
	 * 		Flags  -> (Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class APlayerState*                                VotingPlayer                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            ChoiceIndex                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UVoteIssue::OnPlayerVote(class APlayerState* VotingPlayer, int32_t ChoiceIndex)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.VoteIssue.OnPlayerVote");
		
		UVoteIssue_OnPlayerVote_Params params {};
		params.VotingPlayer = VotingPlayer;
		params.ChoiceIndex = ChoiceIndex;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0574AD10
	 * 		Name   -> Function Insurgency.VoteIssue.IsVoteTooSoon
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		float                                              CheckTime                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UVoteIssue::IsVoteTooSoon(float CheckTime)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.VoteIssue.IsVoteTooSoon");
		
		UVoteIssue_IsVoteTooSoon_Params params {};
		params.CheckTime = CheckTime;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0574ADA0
	 * 		Name   -> Function Insurgency.VoteIssue.IsVoterServerAdmin
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		class APlayerState*                                Player                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UVoteIssue::IsVoterServerAdmin(class APlayerState* Player)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.VoteIssue.IsVoterServerAdmin");
		
		UVoteIssue_IsVoterServerAdmin_Params params {};
		params.Player = Player;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0574ACE0
	 * 		Name   -> Function Insurgency.VoteIssue.HasMajorityVoted
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool UVoteIssue::HasMajorityVoted()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.VoteIssue.HasMajorityVoted");
		
		UVoteIssue_HasMajorityVoted_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0574AC00
	 * 		Name   -> Function Insurgency.VoteIssue.GetYesNoVotes
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		int32_t                                            OutYesVotes                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            OutNoVotes                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UVoteIssue::GetYesNoVotes(int32_t* OutYesVotes, int32_t* OutNoVotes)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.VoteIssue.GetYesNoVotes");
		
		UVoteIssue_GetYesNoVotes_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutYesVotes != nullptr)
			*OutYesVotes = params.OutYesVotes;
		if (OutNoVotes != nullptr)
			*OutNoVotes = params.OutNoVotes;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0574ABD0
	 * 		Name   -> Function Insurgency.VoteIssue.GetVotingComponent
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	class UPlayerVotingComponent* UVoteIssue::GetVotingComponent()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.VoteIssue.GetVotingComponent");
		
		UVoteIssue_GetVotingComponent_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0574ABA0
	 * 		Name   -> Function Insurgency.VoteIssue.GetVotesRequiredToStart
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	int32_t UVoteIssue::GetVotesRequiredToStart()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.VoteIssue.GetVotesRequiredToStart");
		
		UVoteIssue_GetVotesRequiredToStart_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0574AB70
	 * 		Name   -> Function Insurgency.VoteIssue.GetVoteResultState
	 * 		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	EVoteState UVoteIssue::GetVoteResultState()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.VoteIssue.GetVoteResultState");
		
		UVoteIssue_GetVoteResultState_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0574AA90
	 * 		Name   -> Function Insurgency.VoteIssue.GetVoteChoices
	 * 		Flags  -> (Native, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		TArray<struct FReplicatedVoteChoice>               OutVoteChoices                                             (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UVoteIssue::GetVoteChoices(TArray<struct FReplicatedVoteChoice>* OutVoteChoices)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.VoteIssue.GetVoteChoices");
		
		UVoteIssue_GetVoteChoices_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutVoteChoices != nullptr)
			*OutVoteChoices = params.OutVoteChoices;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0574AA60
	 * 		Name   -> Function Insurgency.VoteIssue.GetOuterGameSession
	 * 		Flags  -> (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	class AGameSession* UVoteIssue::GetOuterGameSession()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.VoteIssue.GetOuterGameSession");
		
		UVoteIssue_GetOuterGameSession_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0574AA30
	 * 		Name   -> Function Insurgency.VoteIssue.GetOuterGameMode
	 * 		Flags  -> (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	class AGameModeBase* UVoteIssue::GetOuterGameMode()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.VoteIssue.GetOuterGameMode");
		
		UVoteIssue_GetOuterGameMode_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0574AA00
	 * 		Name   -> Function Insurgency.VoteIssue.GetMajorityCount
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	int32_t UVoteIssue::GetMajorityCount()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.VoteIssue.GetMajorityCount");
		
		UVoteIssue_GetMajorityCount_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0574A920
	 * 		Name   -> Function Insurgency.VoteIssue.GetCustomVoteChoices
	 * 		Flags  -> (Native, Event, Public, HasOutParms, BlueprintEvent)
	 * Parameters:
	 * 		TArray<struct FReplicatedVoteChoice>               OutVoteChoices                                             (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UVoteIssue::GetCustomVoteChoices(TArray<struct FReplicatedVoteChoice>* OutVoteChoices)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.VoteIssue.GetCustomVoteChoices");
		
		UVoteIssue_GetCustomVoteChoices_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutVoteChoices != nullptr)
			*OutVoteChoices = params.OutVoteChoices;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0574A830
	 * 		Name   -> Function Insurgency.VoteIssue.CountVoteIntentions
	 * 		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class FString                                      Option                                                     (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class APlayerState*                                TargetPlayer                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	int32_t UVoteIssue::CountVoteIntentions(const class FString& Option, class APlayerState* TargetPlayer)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.VoteIssue.CountVoteIntentions");
		
		UVoteIssue_CountVoteIntentions_Params params {};
		params.Option = Option;
		params.TargetPlayer = TargetPlayer;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UVoteIssue.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UVoteIssue::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.VoteIssue");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0574B8B0
	 * 		Name   -> Function Insurgency.VoteIssuePlayer.GetTargetPlayerController
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	class APlayerController* UVoteIssuePlayer::GetTargetPlayerController()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.VoteIssuePlayer.GetTargetPlayerController");
		
		UVoteIssuePlayer_GetTargetPlayerController_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UVoteIssuePlayer.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UVoteIssuePlayer::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.VoteIssuePlayer");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0574B3F0
	 * 		Name   -> Function Insurgency.VoteIssueKick.GetKickReason
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		bool                                               bBanning                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class FText UVoteIssueKick::GetKickReason(bool bBanning)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.VoteIssueKick.GetKickReason");
		
		UVoteIssueKick_GetKickReason_Params params {};
		params.bBanning = bBanning;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0574B3C0
	 * 		Name   -> Function Insurgency.VoteIssueKick.GetBanDuration
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	float UVoteIssueKick::GetBanDuration()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.VoteIssueKick.GetBanDuration");
		
		UVoteIssueKick_GetBanDuration_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UVoteIssueKick.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UVoteIssueKick::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.VoteIssueKick");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UVoteStartedEnemyTeamMessage.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UVoteStartedEnemyTeamMessage::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.VoteStartedEnemyTeamMessage");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UWeaponAmmoUpgradeComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UWeaponAmmoUpgradeComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.WeaponAmmoUpgradeComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0574C270
	 * 		Name   -> Function Insurgency.WeaponAnimInstance.OnReloadBeginFinish
	 * 		Flags  -> (Final, Native, Private)
	 * Parameters:
	 * 		bool                                               bFromSinglyLoaded                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UWeaponAnimInstance::OnReloadBeginFinish(bool bFromSinglyLoaded)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.WeaponAnimInstance.OnReloadBeginFinish");
		
		UWeaponAnimInstance_OnReloadBeginFinish_Params params {};
		params.bFromSinglyLoaded = bFromSinglyLoaded;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UWeaponAnimInstance.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UWeaponAnimInstance::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.WeaponAnimInstance");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UWeaponHandlingUpgradeComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UWeaponHandlingUpgradeComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.WeaponHandlingUpgradeComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UWeaponMuzzleComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UWeaponMuzzleComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.WeaponMuzzleComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UWeaponBayonetComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UWeaponBayonetComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.WeaponBayonetComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UWeaponForegripComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UWeaponForegripComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.WeaponForegripComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0574D120
	 * 		Name   -> Function Insurgency.WeaponBipodComponent.TryBipodDeploy
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void UWeaponBipodComponent::TryBipodDeploy()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.WeaponBipodComponent.TryBipodDeploy");
		
		UWeaponBipodComponent_TryBipodDeploy_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0574D100
	 * 		Name   -> Function Insurgency.WeaponBipodComponent.ToggleBipodLegsState
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void UWeaponBipodComponent::ToggleBipodLegsState()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.WeaponBipodComponent.ToggleBipodLegsState");
		
		UWeaponBipodComponent_ToggleBipodLegsState_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0574D0D0
	 * 		Name   -> Function Insurgency.WeaponBipodComponent.ShouldTryAutoBipod
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool UWeaponBipodComponent::ShouldTryAutoBipod()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.WeaponBipodComponent.ShouldTryAutoBipod");
		
		UWeaponBipodComponent_ShouldTryAutoBipod_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0574D000
	 * 		Name   -> Function Insurgency.WeaponBipodComponent.SetBipodLegsState
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		EBipodState                                        NewState                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bFromReplication                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UWeaponBipodComponent::SetBipodLegsState(EBipodState NewState, bool bFromReplication)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.WeaponBipodComponent.SetBipodLegsState");
		
		UWeaponBipodComponent_SetBipodLegsState_Params params {};
		params.NewState = NewState;
		params.bFromReplication = bFromReplication;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0574CF50
	 * 		Name   -> Function Insurgency.WeaponBipodComponent.Server_SetBipodLegsState
	 * 		Flags  -> (Net, NetReliable, Native, Event, Protected, NetServer, NetValidate)
	 * Parameters:
	 * 		EBipodState                                        NewState                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UWeaponBipodComponent::Server_SetBipodLegsState(EBipodState NewState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.WeaponBipodComponent.Server_SetBipodLegsState");
		
		UWeaponBipodComponent_Server_SetBipodLegsState_Params params {};
		params.NewState = NewState;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0574CEA0
	 * 		Name   -> Function Insurgency.WeaponBipodComponent.Server_SetBipodDeployedState
	 * 		Flags  -> (Net, NetReliable, Native, Event, Protected, NetServer, NetValidate)
	 * Parameters:
	 * 		EBipodState                                        NewState                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UWeaponBipodComponent::Server_SetBipodDeployedState(EBipodState NewState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.WeaponBipodComponent.Server_SetBipodDeployedState");
		
		UWeaponBipodComponent_Server_SetBipodDeployedState_Params params {};
		params.NewState = NewState;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0574CE80
	 * 		Name   -> Function Insurgency.WeaponBipodComponent.OnRep_BipodLegsState
	 * 		Flags  -> (Final, Native, Protected)
	 */
	void UWeaponBipodComponent::OnRep_BipodLegsState()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.WeaponBipodComponent.OnRep_BipodLegsState");
		
		UWeaponBipodComponent_OnRep_BipodLegsState_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0574CE60
	 * 		Name   -> Function Insurgency.WeaponBipodComponent.OnRep_BipodDeployedState
	 * 		Flags  -> (Final, Native, Protected)
	 */
	void UWeaponBipodComponent::OnRep_BipodDeployedState()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.WeaponBipodComponent.OnRep_BipodDeployedState");
		
		UWeaponBipodComponent_OnRep_BipodDeployedState_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0574CE30
	 * 		Name   -> Function Insurgency.WeaponBipodComponent.IsManualDeployment
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool UWeaponBipodComponent::IsManualDeployment()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.WeaponBipodComponent.IsManualDeployment");
		
		UWeaponBipodComponent_IsManualDeployment_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0574CE00
	 * 		Name   -> Function Insurgency.WeaponBipodComponent.IsDeployedOrDeploying
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool UWeaponBipodComponent::IsDeployedOrDeploying()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.WeaponBipodComponent.IsDeployedOrDeploying");
		
		UWeaponBipodComponent_IsDeployedOrDeploying_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0574CDD0
	 * 		Name   -> Function Insurgency.WeaponBipodComponent.IsDeployed
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool UWeaponBipodComponent::IsDeployed()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.WeaponBipodComponent.IsDeployed");
		
		UWeaponBipodComponent_IsDeployed_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0574CDA0
	 * 		Name   -> Function Insurgency.WeaponBipodComponent.InBipodTransition
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool UWeaponBipodComponent::InBipodTransition()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.WeaponBipodComponent.InBipodTransition");
		
		UWeaponBipodComponent_InBipodTransition_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0574CD70
	 * 		Name   -> Function Insurgency.WeaponBipodComponent.GetBipodViewTransitionFrac
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	float UWeaponBipodComponent::GetBipodViewTransitionFrac()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.WeaponBipodComponent.GetBipodViewTransitionFrac");
		
		UWeaponBipodComponent_GetBipodViewTransitionFrac_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0574CD40
	 * 		Name   -> Function Insurgency.WeaponBipodComponent.GetBipodToggleElapsedTime
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	float UWeaponBipodComponent::GetBipodToggleElapsedTime()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.WeaponBipodComponent.GetBipodToggleElapsedTime");
		
		UWeaponBipodComponent_GetBipodToggleElapsedTime_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0574CD10
	 * 		Name   -> Function Insurgency.WeaponBipodComponent.GetBipodLegsState
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	EBipodState UWeaponBipodComponent::GetBipodLegsState()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.WeaponBipodComponent.GetBipodLegsState");
		
		UWeaponBipodComponent_GetBipodLegsState_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0574CCE0
	 * 		Name   -> Function Insurgency.WeaponBipodComponent.GetBipodDeployedState
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	EBipodState UWeaponBipodComponent::GetBipodDeployedState()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.WeaponBipodComponent.GetBipodDeployedState");
		
		UWeaponBipodComponent_GetBipodDeployedState_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0574CCB0
	 * 		Name   -> Function Insurgency.WeaponBipodComponent.CanToggleLegState
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool UWeaponBipodComponent::CanToggleLegState()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.WeaponBipodComponent.CanToggleLegState");
		
		UWeaponBipodComponent_CanToggleLegState_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0574CC80
	 * 		Name   -> Function Insurgency.WeaponBipodComponent.CanDeploy
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool UWeaponBipodComponent::CanDeploy()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.WeaponBipodComponent.CanDeploy");
		
		UWeaponBipodComponent_CanDeploy_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> DelegateFunction Insurgency.WeaponBipodComponent.BipodStateChanged__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 * Parameters:
	 * 		EBipodState                                        OldState                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EBipodState                                        NewState                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UWeaponBipodComponent::BipodStateChanged__DelegateSignature(EBipodState OldState, EBipodState NewState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction Insurgency.WeaponBipodComponent.BipodStateChanged__DelegateSignature");
		
		UWeaponBipodComponent_BipodStateChanged__DelegateSignature_Params params {};
		params.OldState = OldState;
		params.NewState = NewState;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0574CC50
	 * 		Name   -> Function Insurgency.WeaponBipodComponent.AreBipodLegsInTransition
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool UWeaponBipodComponent::AreBipodLegsInTransition()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.WeaponBipodComponent.AreBipodLegsInTransition");
		
		UWeaponBipodComponent_AreBipodLegsInTransition_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0574CC20
	 * 		Name   -> Function Insurgency.WeaponBipodComponent.AreBipodLegsDown
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool UWeaponBipodComponent::AreBipodLegsDown()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.WeaponBipodComponent.AreBipodLegsDown");
		
		UWeaponBipodComponent_AreBipodLegsDown_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UWeaponBipodComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UWeaponBipodComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.WeaponBipodComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UWeaponBoltUpgradeComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UWeaponBoltUpgradeComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.WeaponBoltUpgradeComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05757110
	 * 		Name   -> Function Insurgency.WeaponStockComponent.Server_Toggle
	 * 		Flags  -> (Net, NetReliable, Native, Event, Protected, NetServer, NetValidate)
	 */
	void UWeaponStockComponent::Server_Toggle()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.WeaponStockComponent.Server_Toggle");
		
		UWeaponStockComponent_Server_Toggle_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UWeaponStockComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UWeaponStockComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.WeaponStockComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0574D5A0
	 * 		Name   -> Function Insurgency.WeaponFoldingStockComponent.Server_ToggleFold
	 * 		Flags  -> (Net, NetReliable, Native, Event, Protected, NetServer, NetValidate)
	 */
	void UWeaponFoldingStockComponent::Server_ToggleFold()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.WeaponFoldingStockComponent.Server_ToggleFold");
		
		UWeaponFoldingStockComponent_Server_ToggleFold_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UWeaponFoldingStockComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UWeaponFoldingStockComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.WeaponFoldingStockComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UWeaponMagazineUpgradeComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UWeaponMagazineUpgradeComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.WeaponMagazineUpgradeComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0574F200
	 * 		Name   -> Function Insurgency.WeaponModelViewer.UpdateWeaponModel
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		struct FStoredInventoryItem                        Item                                                       (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UWeaponModelViewer::UpdateWeaponModel(const struct FStoredInventoryItem& Item)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.WeaponModelViewer.UpdateWeaponModel");
		
		UWeaponModelViewer_UpdateWeaponModel_Params params {};
		params.Item = Item;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0574F1E0
	 * 		Name   -> Function Insurgency.WeaponModelViewer.UpdateItemModels
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void UWeaponModelViewer::UpdateItemModels()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.WeaponModelViewer.UpdateItemModels");
		
		UWeaponModelViewer_UpdateItemModels_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0574F1C0
	 * 		Name   -> Function Insurgency.WeaponModelViewer.TimedSetCameras
	 * 		Flags  -> (Final, Native, Private)
	 */
	void UWeaponModelViewer::TimedSetCameras()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.WeaponModelViewer.TimedSetCameras");
		
		UWeaponModelViewer_TimedSetCameras_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0574F0C0
	 * 		Name   -> Function Insurgency.WeaponModelViewer.SpawnWeaponModel
	 * 		Flags  -> (Final, Native, Private, HasOutParms)
	 * Parameters:
	 * 		struct FStoredInventoryItem                        Item                                                       (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		bool                                               FirstPerson                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class AItemBase* UWeaponModelViewer::SpawnWeaponModel(const struct FStoredInventoryItem& Item, bool FirstPerson)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.WeaponModelViewer.SpawnWeaponModel");
		
		UWeaponModelViewer_SpawnWeaponModel_Params params {};
		params.Item = Item;
		params.FirstPerson = FirstPerson;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0574EF80
	 * 		Name   -> Function Insurgency.WeaponModelViewer.SetWeaponModel
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		struct FStoredInventoryItem                        Item                                                       (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		bool                                               FirstPerson                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               ForceRefresh                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UWeaponModelViewer::SetWeaponModel(const struct FStoredInventoryItem& Item, bool FirstPerson, bool ForceRefresh)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.WeaponModelViewer.SetWeaponModel");
		
		UWeaponModelViewer_SetWeaponModel_Params params {};
		params.Item = Item;
		params.FirstPerson = FirstPerson;
		params.ForceRefresh = ForceRefresh;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0574EEB0
	 * 		Name   -> Function Insurgency.WeaponModelViewer.SetUpgradeCustomDepth
	 * 		Flags  -> (Final, Native, Private)
	 * Parameters:
	 * 		EWeaponUpgradeSlot                                 UpgradeSlot                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               RenderCustomDepth                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UWeaponModelViewer::SetUpgradeCustomDepth(EWeaponUpgradeSlot UpgradeSlot, bool RenderCustomDepth)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.WeaponModelViewer.SetUpgradeCustomDepth");
		
		UWeaponModelViewer_SetUpgradeCustomDepth_Params params {};
		params.UpgradeSlot = UpgradeSlot;
		params.RenderCustomDepth = RenderCustomDepth;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0574EE90
	 * 		Name   -> Function Insurgency.WeaponModelViewer.SetSoldierModel
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void UWeaponModelViewer::SetSoldierModel()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.WeaponModelViewer.SetSoldierModel");
		
		UWeaponModelViewer_SetSoldierModel_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0574EE70
	 * 		Name   -> Function Insurgency.WeaponModelViewer.SetCameras
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void UWeaponModelViewer::SetCameras()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.WeaponModelViewer.SetCameras");
		
		UWeaponModelViewer_SetCameras_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0574EE50
	 * 		Name   -> Function Insurgency.WeaponModelViewer.ResetCamera
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void UWeaponModelViewer::ResetCamera()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.WeaponModelViewer.ResetCamera");
		
		UWeaponModelViewer_ResetCamera_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0574ED80
	 * 		Name   -> Function Insurgency.WeaponModelViewer.OutlineUpgradeInSlot
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		EWeaponUpgradeSlot                                 UpgradeSlot                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bOutlineUpgradeInSameSlot                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UWeaponModelViewer::OutlineUpgradeInSlot(EWeaponUpgradeSlot UpgradeSlot, bool bOutlineUpgradeInSameSlot)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.WeaponModelViewer.OutlineUpgradeInSlot");
		
		UWeaponModelViewer_OutlineUpgradeInSlot_Params params {};
		params.UpgradeSlot = UpgradeSlot;
		params.bOutlineUpgradeInSameSlot = bOutlineUpgradeInSameSlot;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0574ECC0
	 * 		Name   -> Function Insurgency.WeaponModelViewer.OnTeamChanged
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		unsigned char                                      TeamId                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class ATeamInfo*                                   TeamInfo                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UWeaponModelViewer::OnTeamChanged(unsigned char TeamId, class ATeamInfo* TeamInfo)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.WeaponModelViewer.OnTeamChanged");
		
		UWeaponModelViewer_OnTeamChanged_Params params {};
		params.TeamId = TeamId;
		params.TeamInfo = TeamInfo;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0574EC40
	 * 		Name   -> Function Insurgency.WeaponModelViewer.OnSoldierMeshSet
	 * 		Flags  -> (Final, Native, Private)
	 * Parameters:
	 * 		class UINSSkeletalMeshComponent*                   NewMesh                                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UWeaponModelViewer::OnSoldierMeshSet(class UINSSkeletalMeshComponent* NewMesh)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.WeaponModelViewer.OnSoldierMeshSet");
		
		UWeaponModelViewer_OnSoldierMeshSet_Params params {};
		params.NewMesh = NewMesh;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0574EBC0
	 * 		Name   -> Function Insurgency.WeaponModelViewer.OnPlayerClassChanged
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		class UPlayerClass*                                PlayerClass                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UWeaponModelViewer::OnPlayerClassChanged(class UPlayerClass* PlayerClass)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.WeaponModelViewer.OnPlayerClassChanged");
		
		UWeaponModelViewer_OnPlayerClassChanged_Params params {};
		params.PlayerClass = PlayerClass;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0574EBA0
	 * 		Name   -> Function Insurgency.WeaponModelViewer.OnInventoryChanged
	 * 		Flags  -> (Final, Native, Public)
	 */
	void UWeaponModelViewer::OnInventoryChanged()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.WeaponModelViewer.OnInventoryChanged");
		
		UWeaponModelViewer_OnInventoryChanged_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0574EB20
	 * 		Name   -> Function Insurgency.WeaponModelViewer.OnFirstPersonWeaponMeshSet
	 * 		Flags  -> (Final, Native, Private)
	 * Parameters:
	 * 		class UINSSkeletalMeshComponent*                   NewMesh                                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UWeaponModelViewer::OnFirstPersonWeaponMeshSet(class UINSSkeletalMeshComponent* NewMesh)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.WeaponModelViewer.OnFirstPersonWeaponMeshSet");
		
		UWeaponModelViewer_OnFirstPersonWeaponMeshSet_Params params {};
		params.NewMesh = NewMesh;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0574EB00
	 * 		Name   -> Function Insurgency.WeaponModelViewer.HandleUpdateModelsTimer
	 * 		Flags  -> (Final, Native, Private)
	 */
	void UWeaponModelViewer::HandleUpdateModelsTimer()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.WeaponModelViewer.HandleUpdateModelsTimer");
		
		UWeaponModelViewer_HandleUpdateModelsTimer_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0574EA60
	 * 		Name   -> Function Insurgency.WeaponModelViewer.GetWorldPositionOfUpgrade
	 * 		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		EWeaponUpgradeSlot                                 UpgradeSlot                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FVector UWeaponModelViewer::GetWorldPositionOfUpgrade(EWeaponUpgradeSlot UpgradeSlot)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.WeaponModelViewer.GetWorldPositionOfUpgrade");
		
		UWeaponModelViewer_GetWorldPositionOfUpgrade_Params params {};
		params.UpgradeSlot = UpgradeSlot;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0574EA40
	 * 		Name   -> Function Insurgency.WeaponModelViewer.DestroyModels
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void UWeaponModelViewer::DestroyModels()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.WeaponModelViewer.DestroyModels");
		
		UWeaponModelViewer_DestroyModels_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0574EA20
	 * 		Name   -> Function Insurgency.WeaponModelViewer.DestroyModel1P
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void UWeaponModelViewer::DestroyModel1P()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.WeaponModelViewer.DestroyModel1P");
		
		UWeaponModelViewer_DestroyModel1P_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0574EA00
	 * 		Name   -> Function Insurgency.WeaponModelViewer.DestroyGearModels
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void UWeaponModelViewer::DestroyGearModels()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.WeaponModelViewer.DestroyGearModels");
		
		UWeaponModelViewer_DestroyGearModels_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0574E9E0
	 * 		Name   -> Function Insurgency.WeaponModelViewer.AttachWeaponModel
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void UWeaponModelViewer::AttachWeaponModel()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.WeaponModelViewer.AttachWeaponModel");
		
		UWeaponModelViewer_AttachWeaponModel_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UWeaponModelViewer.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UWeaponModelViewer::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.WeaponModelViewer");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0574FBA0
	 * 		Name   -> Function Insurgency.WeaponMountComponent.OnRep_MountedWeapons
	 * 		Flags  -> (Final, Native, Public)
	 */
	void UWeaponMountComponent::OnRep_MountedWeapons()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.WeaponMountComponent.OnRep_MountedWeapons");
		
		UWeaponMountComponent_OnRep_MountedWeapons_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0574FB80
	 * 		Name   -> Function Insurgency.WeaponMountComponent.AttachWeapons
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void UWeaponMountComponent::AttachWeapons()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.WeaponMountComponent.AttachWeapons");
		
		UWeaponMountComponent_AttachWeapons_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UWeaponMountComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UWeaponMountComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.WeaponMountComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05750910
	 * 		Name   -> Function Insurgency.WeaponOpticComponent.ServerCycleOptic
	 * 		Flags  -> (Final, Net, NetReliable, Native, Event, Private, NetServer, NetValidate)
	 */
	void UWeaponOpticComponent::ServerCycleOptic()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.WeaponOpticComponent.ServerCycleOptic");
		
		UWeaponOpticComponent_ServerCycleOptic_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05750890
	 * 		Name   -> Function Insurgency.WeaponOpticComponent.OnRep_CurrentOptic
	 * 		Flags  -> (Final, Native, Private)
	 * Parameters:
	 * 		int32_t                                            PreviousOptic                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UWeaponOpticComponent::OnRep_CurrentOptic(int32_t PreviousOptic)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.WeaponOpticComponent.OnRep_CurrentOptic");
		
		UWeaponOpticComponent_OnRep_CurrentOptic_Params params {};
		params.PreviousOptic = PreviousOptic;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> DelegateFunction Insurgency.WeaponOpticComponent.OnCycleOpticDelegate__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 * Parameters:
	 * 		int32_t                                            LatchedMode                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            DesiredMode                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UWeaponOpticComponent::OnCycleOpticDelegate__DelegateSignature(int32_t LatchedMode, int32_t DesiredMode)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("DelegateFunction Insurgency.WeaponOpticComponent.OnCycleOpticDelegate__DelegateSignature");
		
		UWeaponOpticComponent_OnCycleOpticDelegate__DelegateSignature_Params params {};
		params.LatchedMode = LatchedMode;
		params.DesiredMode = DesiredMode;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05750860
	 * 		Name   -> Function Insurgency.WeaponOpticComponent.IsHybridOptic
	 * 		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool UWeaponOpticComponent::IsHybridOptic()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.WeaponOpticComponent.IsHybridOptic");
		
		UWeaponOpticComponent_IsHybridOptic_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05750830
	 * 		Name   -> Function Insurgency.WeaponOpticComponent.IsCyclingOptic
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool UWeaponOpticComponent::IsCyclingOptic()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.WeaponOpticComponent.IsCyclingOptic");
		
		UWeaponOpticComponent_IsCyclingOptic_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05750800
	 * 		Name   -> Function Insurgency.WeaponOpticComponent.GetZoomLevelClassification
	 * 		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	EOpticZoomLevel UWeaponOpticComponent::GetZoomLevelClassification()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.WeaponOpticComponent.GetZoomLevelClassification");
		
		UWeaponOpticComponent_GetZoomLevelClassification_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x057507D0
	 * 		Name   -> Function Insurgency.WeaponOpticComponent.GetNumberOpticModes
	 * 		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	int32_t UWeaponOpticComponent::GetNumberOpticModes()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.WeaponOpticComponent.GetNumberOpticModes");
		
		UWeaponOpticComponent_GetNumberOpticModes_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x057507A0
	 * 		Name   -> Function Insurgency.WeaponOpticComponent.GetDefaultZoomLevelClassification
	 * 		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	EOpticZoomLevel UWeaponOpticComponent::GetDefaultZoomLevelClassification()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.WeaponOpticComponent.GetDefaultZoomLevelClassification");
		
		UWeaponOpticComponent_GetDefaultZoomLevelClassification_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05750700
	 * 		Name   -> Function Insurgency.WeaponOpticComponent.GetADSMultiplier
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		bool                                               bAimingDownSights                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	float UWeaponOpticComponent::GetADSMultiplier(bool bAimingDownSights)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.WeaponOpticComponent.GetADSMultiplier");
		
		UWeaponOpticComponent_GetADSMultiplier_Params params {};
		params.bAimingDownSights = bAimingDownSights;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x057506E0
	 * 		Name   -> Function Insurgency.WeaponOpticComponent.FinishOpticTransition
	 * 		Flags  -> (Final, Native, Private)
	 */
	void UWeaponOpticComponent::FinishOpticTransition()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.WeaponOpticComponent.FinishOpticTransition");
		
		UWeaponOpticComponent_FinishOpticTransition_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> Function Insurgency.WeaponOpticComponent.BlueprintOnCycleOptic
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		int32_t                                            LatchedMode                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            Mode                                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UWeaponOpticComponent::BlueprintOnCycleOptic(int32_t LatchedMode, int32_t Mode)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.WeaponOpticComponent.BlueprintOnCycleOptic");
		
		UWeaponOpticComponent_BlueprintOnCycleOptic_Params params {};
		params.LatchedMode = LatchedMode;
		params.Mode = Mode;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x057506C0
	 * 		Name   -> Function Insurgency.WeaponOpticComponent.BeginOpticTransition
	 * 		Flags  -> (Final, Native, Private)
	 */
	void UWeaponOpticComponent::BeginOpticTransition()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.WeaponOpticComponent.BeginOpticTransition");
		
		UWeaponOpticComponent_BeginOpticTransition_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05750690
	 * 		Name   -> Function Insurgency.WeaponOpticComponent.AllowPointShooting
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool UWeaponOpticComponent::AllowPointShooting()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.WeaponOpticComponent.AllowPointShooting");
		
		UWeaponOpticComponent_AllowPointShooting_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05750660
	 * 		Name   -> Function Insurgency.WeaponOpticComponent.AllowAimDownSights
	 * 		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool UWeaponOpticComponent::AllowAimDownSights()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.WeaponOpticComponent.AllowAimDownSights");
		
		UWeaponOpticComponent_AllowAimDownSights_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UWeaponOpticComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UWeaponOpticComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.WeaponOpticComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x056A9F60
	 * 		Name   -> Function Insurgency.WeaponPointShootGripComponent.WantsPointShoot
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool UWeaponPointShootGripComponent::WantsPointShoot()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.WeaponPointShootGripComponent.WantsPointShoot");
		
		UWeaponPointShootGripComponent_WantsPointShoot_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x057516D0
	 * 		Name   -> Function Insurgency.WeaponPointShootGripComponent.UpdateLightLocation
	 * 		Flags  -> (Final, Native, Public)
	 */
	void UWeaponPointShootGripComponent::UpdateLightLocation()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.WeaponPointShootGripComponent.UpdateLightLocation");
		
		UWeaponPointShootGripComponent_UpdateLightLocation_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x057516B0
	 * 		Name   -> Function Insurgency.WeaponPointShootGripComponent.UpdateLaserBeam
	 * 		Flags  -> (Final, Native, Public)
	 */
	void UWeaponPointShootGripComponent::UpdateLaserBeam()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.WeaponPointShootGripComponent.UpdateLaserBeam");
		
		UWeaponPointShootGripComponent_UpdateLaserBeam_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05751690
	 * 		Name   -> Function Insurgency.WeaponPointShootGripComponent.UpdateBlindingParticle
	 * 		Flags  -> (Final, Native, Public)
	 */
	void UWeaponPointShootGripComponent::UpdateBlindingParticle()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.WeaponPointShootGripComponent.UpdateBlindingParticle");
		
		UWeaponPointShootGripComponent_UpdateBlindingParticle_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05751670
	 * 		Name   -> Function Insurgency.WeaponPointShootGripComponent.UpdateBeam
	 * 		Flags  -> (Final, Native, Public)
	 */
	void UWeaponPointShootGripComponent::UpdateBeam()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.WeaponPointShootGripComponent.UpdateBeam");
		
		UWeaponPointShootGripComponent_UpdateBeam_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x057515B0
	 * 		Name   -> Function Insurgency.WeaponPointShootGripComponent.StartTraceTask
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		float                                              Interval                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		ECollisionChannel                                  Channel                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UWeaponPointShootGripComponent::StartTraceTask(float Interval, ECollisionChannel Channel)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.WeaponPointShootGripComponent.StartTraceTask");
		
		UWeaponPointShootGripComponent_StartTraceTask_Params params {};
		params.Interval = Interval;
		params.Channel = Channel;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05751450
	 * 		Name   -> Function Insurgency.WeaponPointShootGripComponent.SetWantsPointShoot
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bNewWantsPointShoot                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UWeaponPointShootGripComponent::SetWantsPointShoot(bool bNewWantsPointShoot)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.WeaponPointShootGripComponent.SetWantsPointShoot");
		
		UWeaponPointShootGripComponent_SetWantsPointShoot_Params params {};
		params.bNewWantsPointShoot = bNewWantsPointShoot;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x057514E0
	 * 		Name   -> Function Insurgency.WeaponPointShootGripComponent.SetLightMode
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		EWeaponLightMode                                   Mode                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bFromReplication                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UWeaponPointShootGripComponent::SetLightMode(EWeaponLightMode Mode, bool bFromReplication)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.WeaponPointShootGripComponent.SetLightMode");
		
		UWeaponPointShootGripComponent_SetLightMode_Params params {};
		params.Mode = Mode;
		params.bFromReplication = bFromReplication;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05751450
	 * 		Name   -> Function Insurgency.WeaponPointShootGripComponent.ServerSetWantsPointShoot
	 * 		Flags  -> (Final, Net, NetReliable, Native, Event, Private, NetServer)
	 * Parameters:
	 * 		bool                                               bNewWantsPointShoot                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UWeaponPointShootGripComponent::ServerSetWantsPointShoot(bool bNewWantsPointShoot)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.WeaponPointShootGripComponent.ServerSetWantsPointShoot");
		
		UWeaponPointShootGripComponent_ServerSetWantsPointShoot_Params params {};
		params.bNewWantsPointShoot = bNewWantsPointShoot;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x057513A0
	 * 		Name   -> Function Insurgency.WeaponPointShootGripComponent.ServerSetLightMode
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
	 * Parameters:
	 * 		EWeaponLightMode                                   Mode                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UWeaponPointShootGripComponent::ServerSetLightMode(EWeaponLightMode Mode)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.WeaponPointShootGripComponent.ServerSetLightMode");
		
		UWeaponPointShootGripComponent_ServerSetLightMode_Params params {};
		params.Mode = Mode;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05751380
	 * 		Name   -> Function Insurgency.WeaponPointShootGripComponent.RecreateEffects
	 * 		Flags  -> (Final, Native, Public)
	 */
	void UWeaponPointShootGripComponent::RecreateEffects()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.WeaponPointShootGripComponent.RecreateEffects");
		
		UWeaponPointShootGripComponent_RecreateEffects_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05751360
	 * 		Name   -> Function Insurgency.WeaponPointShootGripComponent.RecreateBeamEffects
	 * 		Flags  -> (Final, Native, Public)
	 */
	void UWeaponPointShootGripComponent::RecreateBeamEffects()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.WeaponPointShootGripComponent.RecreateBeamEffects");
		
		UWeaponPointShootGripComponent_RecreateBeamEffects_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05751320
	 * 		Name   -> Function Insurgency.WeaponPointShootGripComponent.OnRep_CurrentLightMode
	 * 		Flags  -> (Final, Native, Public)
	 */
	void UWeaponPointShootGripComponent::OnRep_CurrentLightMode()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.WeaponPointShootGripComponent.OnRep_CurrentLightMode");
		
		UWeaponPointShootGripComponent_OnRep_CurrentLightMode_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05751340
	 * 		Name   -> Function Insurgency.WeaponPointShootGripComponent.OnRep_bWantsPointShoot
	 * 		Flags  -> (Final, Native, Private)
	 */
	void UWeaponPointShootGripComponent::OnRep_bWantsPointShoot()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.WeaponPointShootGripComponent.OnRep_bWantsPointShoot");
		
		UWeaponPointShootGripComponent_OnRep_bWantsPointShoot_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x057512F0
	 * 		Name   -> Function Insurgency.WeaponPointShootGripComponent.LocalPlayerCanSeeInfrared
	 * 		Flags  -> (Final, Native, Protected, Const)
	 */
	bool UWeaponPointShootGripComponent::LocalPlayerCanSeeInfrared()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.WeaponPointShootGripComponent.LocalPlayerCanSeeInfrared");
		
		UWeaponPointShootGripComponent_LocalPlayerCanSeeInfrared_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x057512D0
	 * 		Name   -> Function Insurgency.WeaponPointShootGripComponent.KillLaserSightEffect
	 * 		Flags  -> (Final, Native, Public)
	 */
	void UWeaponPointShootGripComponent::KillLaserSightEffect()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.WeaponPointShootGripComponent.KillLaserSightEffect");
		
		UWeaponPointShootGripComponent_KillLaserSightEffect_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x057512B0
	 * 		Name   -> Function Insurgency.WeaponPointShootGripComponent.KillBlindingEffect
	 * 		Flags  -> (Final, Native, Public)
	 */
	void UWeaponPointShootGripComponent::KillBlindingEffect()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.WeaponPointShootGripComponent.KillBlindingEffect");
		
		UWeaponPointShootGripComponent_KillBlindingEffect_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05751290
	 * 		Name   -> Function Insurgency.WeaponPointShootGripComponent.KillAnyEffects
	 * 		Flags  -> (Final, Native, Public)
	 */
	void UWeaponPointShootGripComponent::KillAnyEffects()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.WeaponPointShootGripComponent.KillAnyEffects");
		
		UWeaponPointShootGripComponent_KillAnyEffects_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05751200
	 * 		Name   -> Function Insurgency.WeaponPointShootGripComponent.HasLightingMode
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		EWeaponLightMode                                   LightMode                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UWeaponPointShootGripComponent::HasLightingMode(EWeaponLightMode LightMode)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.WeaponPointShootGripComponent.HasLightingMode");
		
		UWeaponPointShootGripComponent_HasLightingMode_Params params {};
		params.LightMode = LightMode;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x057511D0
	 * 		Name   -> Function Insurgency.WeaponPointShootGripComponent.GetNextLightMode
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	EWeaponLightMode UWeaponPointShootGripComponent::GetNextLightMode()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.WeaponPointShootGripComponent.GetNextLightMode");
		
		UWeaponPointShootGripComponent_GetNextLightMode_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x057511A0
	 * 		Name   -> Function Insurgency.WeaponPointShootGripComponent.GetFirstLightMode
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	EWeaponLightMode UWeaponPointShootGripComponent::GetFirstLightMode()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.WeaponPointShootGripComponent.GetFirstLightMode");
		
		UWeaponPointShootGripComponent_GetFirstLightMode_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05751170
	 * 		Name   -> Function Insurgency.WeaponPointShootGripComponent.DoShouldEnterPointShootMode
	 * 		Flags  -> (Final, Native, Public, Const)
	 */
	bool UWeaponPointShootGripComponent::DoShouldEnterPointShootMode()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.WeaponPointShootGripComponent.DoShouldEnterPointShootMode");
		
		UWeaponPointShootGripComponent_DoShouldEnterPointShootMode_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05751150
	 * 		Name   -> Function Insurgency.WeaponPointShootGripComponent.CreateLaserSightEffect
	 * 		Flags  -> (Final, Native, Public)
	 */
	void UWeaponPointShootGripComponent::CreateLaserSightEffect()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.WeaponPointShootGripComponent.CreateLaserSightEffect");
		
		UWeaponPointShootGripComponent_CreateLaserSightEffect_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05751130
	 * 		Name   -> Function Insurgency.WeaponPointShootGripComponent.CalculateLightTargetVisibility
	 * 		Flags  -> (Final, Native, Public)
	 */
	void UWeaponPointShootGripComponent::CalculateLightTargetVisibility()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.WeaponPointShootGripComponent.CalculateLightTargetVisibility");
		
		UWeaponPointShootGripComponent_CalculateLightTargetVisibility_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05751110
	 * 		Name   -> Function Insurgency.WeaponPointShootGripComponent.CalculateLightTarget
	 * 		Flags  -> (Final, Native, Public)
	 */
	void UWeaponPointShootGripComponent::CalculateLightTarget()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.WeaponPointShootGripComponent.CalculateLightTarget");
		
		UWeaponPointShootGripComponent_CalculateLightTarget_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UWeaponPointShootGripComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UWeaponPointShootGripComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.WeaponPointShootGripComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UWeaponScopeComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UWeaponScopeComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.WeaponScopeComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UWeaponSelectionOption_Gamepad.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UWeaponSelectionOption_Gamepad::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.WeaponSelectionOption_Gamepad");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05751F00
	 * 		Name   -> Function Insurgency.WeaponSelection_Gamepad.UpdateWeaponCache
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void UWeaponSelection_Gamepad::UpdateWeaponCache()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.WeaponSelection_Gamepad.UpdateWeaponCache");
		
		UWeaponSelection_Gamepad_UpdateWeaponCache_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05751E40
	 * 		Name   -> Function Insurgency.WeaponSelection_Gamepad.OnSoldierInventoryItemAddedOrRemoved
	 * 		Flags  -> (Final, Native, Protected)
	 * Parameters:
	 * 		class AINSSoldier*                                 Soldier                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AItemBase*                                   Item                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UWeaponSelection_Gamepad::OnSoldierInventoryItemAddedOrRemoved(class AINSSoldier* Soldier, class AItemBase* Item)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.WeaponSelection_Gamepad.OnSoldierInventoryItemAddedOrRemoved");
		
		UWeaponSelection_Gamepad_OnSoldierInventoryItemAddedOrRemoved_Params params {};
		params.Soldier = Soldier;
		params.Item = Item;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05751D70
	 * 		Name   -> Function Insurgency.WeaponSelection_Gamepad.OnInventoryMenuVisible
	 * 		Flags  -> (Final, Native, Protected)
	 * Parameters:
	 * 		bool                                               bNewInventorySelectActive                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bUsingGamepad                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UWeaponSelection_Gamepad::OnInventoryMenuVisible(bool bNewInventorySelectActive, bool bUsingGamepad)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.WeaponSelection_Gamepad.OnInventoryMenuVisible");
		
		UWeaponSelection_Gamepad_OnInventoryMenuVisible_Params params {};
		params.bNewInventorySelectActive = bNewInventorySelectActive;
		params.bUsingGamepad = bUsingGamepad;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05751D50
	 * 		Name   -> Function Insurgency.WeaponSelection_Gamepad.OnInventoryChanged
	 * 		Flags  -> (Final, Native, Protected)
	 */
	void UWeaponSelection_Gamepad::OnInventoryChanged()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.WeaponSelection_Gamepad.OnInventoryChanged");
		
		UWeaponSelection_Gamepad_OnInventoryChanged_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05751D30
	 * 		Name   -> Function Insurgency.WeaponSelection_Gamepad.OnControllerRemovePawn
	 * 		Flags  -> (Final, Native, Protected)
	 */
	void UWeaponSelection_Gamepad::OnControllerRemovePawn()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.WeaponSelection_Gamepad.OnControllerRemovePawn");
		
		UWeaponSelection_Gamepad_OnControllerRemovePawn_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05751D10
	 * 		Name   -> Function Insurgency.WeaponSelection_Gamepad.OnControllerNewPawn
	 * 		Flags  -> (Final, Native, Protected)
	 */
	void UWeaponSelection_Gamepad::OnControllerNewPawn()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.WeaponSelection_Gamepad.OnControllerNewPawn");
		
		UWeaponSelection_Gamepad_OnControllerNewPawn_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UWeaponSelection_Gamepad.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UWeaponSelection_Gamepad::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.WeaponSelection_Gamepad");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05752130
	 * 		Name   -> Function Insurgency.WeaponSensitivityScaleInterface.ModifyLookInput
	 * 		Flags  -> (Native, Event, Public, HasOutParms, BlueprintEvent)
	 * Parameters:
	 * 		bool                                               bGamepad                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bIsXAxis                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              OutRate                                                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UWeaponSensitivityScaleInterface::ModifyLookInput(bool bGamepad, bool bIsXAxis, float* OutRate)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.WeaponSensitivityScaleInterface.ModifyLookInput");
		
		UWeaponSensitivityScaleInterface_ModifyLookInput_Params params {};
		params.bGamepad = bGamepad;
		params.bIsXAxis = bIsXAxis;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutRate != nullptr)
			*OutRate = params.OutRate;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UWeaponSensitivityScaleInterface.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UWeaponSensitivityScaleInterface::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.WeaponSensitivityScaleInterface");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x057526F0
	 * 		Name   -> Function Insurgency.WeaponSkinComponent.OnWeaponModelAttached
	 * 		Flags  -> (Final, Native, Public, HasOutParms)
	 * Parameters:
	 * 		struct FWeaponAttachedModel                        Model                                                      (Parm, OutParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 * 		class USkeletalMeshComponent*                      WeaponParentMesh                                           (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UWeaponSkinComponent::OnWeaponModelAttached(struct FWeaponAttachedModel* Model, class USkeletalMeshComponent* WeaponParentMesh)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.WeaponSkinComponent.OnWeaponModelAttached");
		
		UWeaponSkinComponent_OnWeaponModelAttached_Params params {};
		params.WeaponParentMesh = WeaponParentMesh;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (Model != nullptr)
			*Model = params.Model;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05752630
	 * 		Name   -> Function Insurgency.WeaponSkinComponent.OnUpgrade3PMeshLoaded
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		class UINSSkeletalMeshComponent*                   MeshComponent                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UWeaponVisualUpgradeComponent*               Upgrade                                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UWeaponSkinComponent::OnUpgrade3PMeshLoaded(class UINSSkeletalMeshComponent* MeshComponent, class UWeaponVisualUpgradeComponent* Upgrade)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.WeaponSkinComponent.OnUpgrade3PMeshLoaded");
		
		UWeaponSkinComponent_OnUpgrade3PMeshLoaded_Params params {};
		params.MeshComponent = MeshComponent;
		params.Upgrade = Upgrade;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05752630
	 * 		Name   -> Function Insurgency.WeaponSkinComponent.OnUpgrade1PMeshLoaded
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		class UINSSkeletalMeshComponent*                   MeshComponent                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UWeaponVisualUpgradeComponent*               Upgrade                                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UWeaponSkinComponent::OnUpgrade1PMeshLoaded(class UINSSkeletalMeshComponent* MeshComponent, class UWeaponVisualUpgradeComponent* Upgrade)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.WeaponSkinComponent.OnUpgrade1PMeshLoaded");
		
		UWeaponSkinComponent_OnUpgrade1PMeshLoaded_Params params {};
		params.MeshComponent = MeshComponent;
		params.Upgrade = Upgrade;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x057525B0
	 * 		Name   -> Function Insurgency.WeaponSkinComponent.OnOtherComponentChanged
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		class UWeaponUpgradeComponent*                     OtherUpgrade                                               (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UWeaponSkinComponent::OnOtherComponentChanged(class UWeaponUpgradeComponent* OtherUpgrade)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.WeaponSkinComponent.OnOtherComponentChanged");
		
		UWeaponSkinComponent_OnOtherComponentChanged_Params params {};
		params.OtherUpgrade = OtherUpgrade;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05752530
	 * 		Name   -> Function Insurgency.WeaponSkinComponent.OnAttachMesh3PToPawn
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		class UINSSkeletalMeshComponent*                   MeshComponent                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UWeaponSkinComponent::OnAttachMesh3PToPawn(class UINSSkeletalMeshComponent* MeshComponent)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.WeaponSkinComponent.OnAttachMesh3PToPawn");
		
		UWeaponSkinComponent_OnAttachMesh3PToPawn_Params params {};
		params.MeshComponent = MeshComponent;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x057524B0
	 * 		Name   -> Function Insurgency.WeaponSkinComponent.OnAttachMesh1PToPawn
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		class UINSSkeletalMeshComponent*                   MeshComponent                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UWeaponSkinComponent::OnAttachMesh1PToPawn(class UINSSkeletalMeshComponent* MeshComponent)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.WeaponSkinComponent.OnAttachMesh1PToPawn");
		
		UWeaponSkinComponent_OnAttachMesh1PToPawn_Params params {};
		params.MeshComponent = MeshComponent;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UWeaponSkinComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UWeaponSkinComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.WeaponSkinComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05756B70
	 * 		Name   -> Function Insurgency.WeaponStatics.TraceSuppression
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AINSSoldier*                                 Owner                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     StartLocation                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     EndLocation                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Radius                                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              Increment                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		ESuppressionContext                                Context                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UWeaponStatics::STATIC_TraceSuppression(class UObject* WorldContextObject, class AINSSoldier* Owner, const struct FVector& StartLocation, const struct FVector& EndLocation, float Radius, float Increment, ESuppressionContext Context)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.WeaponStatics.TraceSuppression");
		
		UWeaponStatics_TraceSuppression_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.Owner = Owner;
		params.StartLocation = StartLocation;
		params.EndLocation = EndLocation;
		params.Radius = Radius;
		params.Increment = Increment;
		params.Context = Context;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05756770
	 * 		Name   -> Function Insurgency.WeaponStatics.TestMeleeSwingIgnoreActors
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class APawn*                                       Instigator                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     Origin                                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FRotator                                    Rotation                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		struct FMeleeConfig                                MeleeConfig                                                (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 * 		struct FHitResult                                  OutHitResult                                               (Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 * 		TArray<class UPrimitiveComponent*>                 InIgnoreComponents                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		TArray<class UPrimitiveComponent*>                 InOutHitComponents                                         (Parm, OutParm, ZeroConstructor, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bApplyDamage                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      DamageCauser                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UWeaponStatics::STATIC_TestMeleeSwingIgnoreActors(class UObject* WorldContextObject, class APawn* Instigator, const struct FVector& Origin, const struct FRotator& Rotation, const struct FMeleeConfig& MeleeConfig, struct FHitResult* OutHitResult, TArray<class UPrimitiveComponent*> InIgnoreComponents, TArray<class UPrimitiveComponent*>* InOutHitComponents, bool bApplyDamage, class AActor* DamageCauser)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.WeaponStatics.TestMeleeSwingIgnoreActors");
		
		UWeaponStatics_TestMeleeSwingIgnoreActors_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.Instigator = Instigator;
		params.Origin = Origin;
		params.Rotation = Rotation;
		params.MeleeConfig = MeleeConfig;
		params.InIgnoreComponents = InIgnoreComponents;
		params.bApplyDamage = bApplyDamage;
		params.DamageCauser = DamageCauser;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutHitResult != nullptr)
			*OutHitResult = params.OutHitResult;
		if (InOutHitComponents != nullptr)
			*InOutHitComponents = params.InOutHitComponents;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05756430
	 * 		Name   -> Function Insurgency.WeaponStatics.TestMeleeSwing
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class APawn*                                       Instigator                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     Origin                                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FRotator                                    Rotation                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		struct FMeleeConfig                                MeleeConfig                                                (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 * 		struct FHitResult                                  OutHitResult                                               (Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 * 		bool                                               bApplyDamage                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      DamageCauser                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UWeaponStatics::STATIC_TestMeleeSwing(class UObject* WorldContextObject, class APawn* Instigator, const struct FVector& Origin, const struct FRotator& Rotation, const struct FMeleeConfig& MeleeConfig, struct FHitResult* OutHitResult, bool bApplyDamage, class AActor* DamageCauser)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.WeaponStatics.TestMeleeSwing");
		
		UWeaponStatics_TestMeleeSwing_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.Instigator = Instigator;
		params.Origin = Origin;
		params.Rotation = Rotation;
		params.MeleeConfig = MeleeConfig;
		params.bApplyDamage = bApplyDamage;
		params.DamageCauser = DamageCauser;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutHitResult != nullptr)
			*OutHitResult = params.OutHitResult;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05756140
	 * 		Name   -> Function Insurgency.WeaponStatics.SuppressPlayersInRadius
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     Epicenter                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              HoldTime                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		ESuppressionContext                                Context                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              InnerRadius                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              OuterRadius                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              InnerAmount                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              OuterAmount                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		TArray<class AController*>                         IgnoredControllers                                         (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UWeaponStatics::STATIC_SuppressPlayersInRadius(class UObject* WorldContextObject, const struct FVector& Epicenter, float HoldTime, ESuppressionContext Context, float InnerRadius, float OuterRadius, float InnerAmount, float OuterAmount, TArray<class AController*> IgnoredControllers)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.WeaponStatics.SuppressPlayersInRadius");
		
		UWeaponStatics_SuppressPlayersInRadius_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.Epicenter = Epicenter;
		params.HoldTime = HoldTime;
		params.Context = Context;
		params.InnerRadius = InnerRadius;
		params.OuterRadius = OuterRadius;
		params.InnerAmount = InnerAmount;
		params.OuterAmount = OuterAmount;
		params.IgnoredControllers = IgnoredControllers;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05755F20
	 * 		Name   -> Function Insurgency.WeaponStatics.SpawnSingleProjectileAtTransform
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UClass*                                      ProjectileClass                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class APawn*                                       Instigator                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FTransform                                  SpawnTransform                                             (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	 * 		class AItemWeapon*                                 Weapon                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bDeferSpawn                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class AProjectileBase* UWeaponStatics::STATIC_SpawnSingleProjectileAtTransform(class UObject* WorldContextObject, class UClass* ProjectileClass, class APawn* Instigator, const struct FTransform& SpawnTransform, class AItemWeapon* Weapon, bool bDeferSpawn)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.WeaponStatics.SpawnSingleProjectileAtTransform");
		
		UWeaponStatics_SpawnSingleProjectileAtTransform_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.ProjectileClass = ProjectileClass;
		params.Instigator = Instigator;
		params.SpawnTransform = SpawnTransform;
		params.Weapon = Weapon;
		params.bDeferSpawn = bDeferSpawn;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05755D10
	 * 		Name   -> Function Insurgency.WeaponStatics.SpawnSingleProjectile
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UClass*                                      ProjectileClass                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class APawn*                                       Instigator                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     SpawnLocation                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     Direction                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AItemWeapon*                                 Weapon                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bDeferSpawn                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class AProjectileBase* UWeaponStatics::STATIC_SpawnSingleProjectile(class UObject* WorldContextObject, class UClass* ProjectileClass, class APawn* Instigator, const struct FVector& SpawnLocation, const struct FVector& Direction, class AItemWeapon* Weapon, bool bDeferSpawn)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.WeaponStatics.SpawnSingleProjectile");
		
		UWeaponStatics_SpawnSingleProjectile_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.ProjectileClass = ProjectileClass;
		params.Instigator = Instigator;
		params.SpawnLocation = SpawnLocation;
		params.Direction = Direction;
		params.Weapon = Weapon;
		params.bDeferSpawn = bDeferSpawn;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05755A10
	 * 		Name   -> Function Insurgency.WeaponStatics.SpawnProjectiles
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UClass*                                      ProjectileClass                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class APawn*                                       Instigator                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     SpawnLocation                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     Direction                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		TArray<class AProjectileBase*>                     SpawnedProjectiles                                         (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              ProjectileSpread                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            Count                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            SpreadSeed                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AItemWeapon*                                 Weapon                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UWeaponStatics::STATIC_SpawnProjectiles(class UObject* WorldContextObject, class UClass* ProjectileClass, class APawn* Instigator, const struct FVector& SpawnLocation, const struct FVector& Direction, TArray<class AProjectileBase*>* SpawnedProjectiles, float ProjectileSpread, int32_t Count, int32_t SpreadSeed, class AItemWeapon* Weapon)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.WeaponStatics.SpawnProjectiles");
		
		UWeaponStatics_SpawnProjectiles_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.ProjectileClass = ProjectileClass;
		params.Instigator = Instigator;
		params.SpawnLocation = SpawnLocation;
		params.Direction = Direction;
		params.ProjectileSpread = ProjectileSpread;
		params.Count = Count;
		params.SpreadSeed = SpreadSeed;
		params.Weapon = Weapon;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (SpawnedProjectiles != nullptr)
			*SpawnedProjectiles = params.SpawnedProjectiles;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05755890
	 * 		Name   -> Function Insurgency.WeaponStatics.SpawnMountedWeapon
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UClass*                                      Weapon                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      OwnerActor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class USceneComponent*                             AttachComponent                                            (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FName                                        SocketName                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UVehicleSeatComponent*                       LinkedSeat                                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class AItemFirearm* UWeaponStatics::STATIC_SpawnMountedWeapon(class UClass* Weapon, class AActor* OwnerActor, class USceneComponent* AttachComponent, const class FName& SocketName, class UVehicleSeatComponent* LinkedSeat)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.WeaponStatics.SpawnMountedWeapon");
		
		UWeaponStatics_SpawnMountedWeapon_Params params {};
		params.Weapon = Weapon;
		params.OwnerActor = OwnerActor;
		params.AttachComponent = AttachComponent;
		params.SocketName = SocketName;
		params.LinkedSeat = LinkedSeat;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x057557B0
	 * 		Name   -> Function Insurgency.WeaponStatics.SpawnFireSupport
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FFireSupportSpawnParams                     InParams                                                   (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	class AFireSupportBase* UWeaponStatics::STATIC_SpawnFireSupport(class UObject* WorldContextObject, const struct FFireSupportSpawnParams& InParams)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.WeaponStatics.SpawnFireSupport");
		
		UWeaponStatics_SpawnFireSupport_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.InParams = InParams;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05755630
	 * 		Name   -> Function Insurgency.WeaponStatics.SetupMountedWeapon
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class AItemFirearm*                                MountedWeapon                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      OwnerActor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class USceneComponent*                             AttachComponent                                            (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class FName                                        SocketName                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class UVehicleSeatComponent*                       LinkedSeat                                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UWeaponStatics::STATIC_SetupMountedWeapon(class AItemFirearm* MountedWeapon, class AActor* OwnerActor, class USceneComponent* AttachComponent, const class FName& SocketName, class UVehicleSeatComponent* LinkedSeat)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.WeaponStatics.SetupMountedWeapon");
		
		UWeaponStatics_SetupMountedWeapon_Params params {};
		params.MountedWeapon = MountedWeapon;
		params.OwnerActor = OwnerActor;
		params.AttachComponent = AttachComponent;
		params.SocketName = SocketName;
		params.LinkedSeat = LinkedSeat;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05755390
	 * 		Name   -> Function Insurgency.WeaponStatics.PlayShellShock
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     Epicenter                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              InnerRadius                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              OuterRadius                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              InnerDuration                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              OuterDuration                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		TArray<class AController*>                         IgnoredControllers                                         (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      DamageCauser                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UWeaponStatics::STATIC_PlayShellShock(class UObject* WorldContextObject, const struct FVector& Epicenter, float InnerRadius, float OuterRadius, float InnerDuration, float OuterDuration, TArray<class AController*> IgnoredControllers, class AActor* DamageCauser)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.WeaponStatics.PlayShellShock");
		
		UWeaponStatics_PlayShellShock_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.Epicenter = Epicenter;
		params.InnerRadius = InnerRadius;
		params.OuterRadius = OuterRadius;
		params.InnerDuration = InnerDuration;
		params.OuterDuration = OuterDuration;
		params.IgnoredControllers = IgnoredControllers;
		params.DamageCauser = DamageCauser;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05755130
	 * 		Name   -> Function Insurgency.WeaponStatics.PlayExplosiveSurfaceReactionWithHit
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      Projectile                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class USurfaceReaction*                            InSurfaceReaction                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FHitResult                                  HitResult                                                  (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 * 		struct FSurfaceReactionOutput                      OutOutput                                                  (Parm, OutParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 * 		class FString                                      WeaponSwitch                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UWeaponStatics::STATIC_PlayExplosiveSurfaceReactionWithHit(class UObject* WorldContextObject, class AActor* Projectile, class USurfaceReaction* InSurfaceReaction, const struct FHitResult& HitResult, struct FSurfaceReactionOutput* OutOutput, const class FString& WeaponSwitch)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.WeaponStatics.PlayExplosiveSurfaceReactionWithHit");
		
		UWeaponStatics_PlayExplosiveSurfaceReactionWithHit_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.Projectile = Projectile;
		params.InSurfaceReaction = InSurfaceReaction;
		params.HitResult = HitResult;
		params.WeaponSwitch = WeaponSwitch;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutOutput != nullptr)
			*OutOutput = params.OutOutput;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05754F10
	 * 		Name   -> Function Insurgency.WeaponStatics.PlayExplosiveSurfaceReaction
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      Projectile                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class USurfaceReaction*                            InSurfaceReaction                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     HitLocation                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FSurfaceReactionOutput                      OutOutput                                                  (Parm, OutParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 * 		class FString                                      WeaponSwitch                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UWeaponStatics::STATIC_PlayExplosiveSurfaceReaction(class UObject* WorldContextObject, class AActor* Projectile, class USurfaceReaction* InSurfaceReaction, const struct FVector& HitLocation, struct FSurfaceReactionOutput* OutOutput, const class FString& WeaponSwitch)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.WeaponStatics.PlayExplosiveSurfaceReaction");
		
		UWeaponStatics_PlayExplosiveSurfaceReaction_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.Projectile = Projectile;
		params.InSurfaceReaction = InSurfaceReaction;
		params.HitLocation = HitLocation;
		params.WeaponSwitch = WeaponSwitch;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutOutput != nullptr)
			*OutOutput = params.OutOutput;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05754E90
	 * 		Name   -> Function Insurgency.WeaponStatics.IsAReloadingState
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		EFirearmState                                      TestState                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UWeaponStatics::STATIC_IsAReloadingState(EFirearmState TestState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.WeaponStatics.IsAReloadingState");
		
		UWeaponStatics_IsAReloadingState_Params params {};
		params.TestState = TestState;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05754D50
	 * 		Name   -> Function Insurgency.WeaponStatics.GetValidFireSupportForTeam
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		unsigned char                                      TeamId                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bRespectTeamRules                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	TArray<class UFireSupportDefinition*> UWeaponStatics::STATIC_GetValidFireSupportForTeam(class UObject* WorldContextObject, unsigned char TeamId, bool bRespectTeamRules)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.WeaponStatics.GetValidFireSupportForTeam");
		
		UWeaponStatics_GetValidFireSupportForTeam_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.TeamId = TeamId;
		params.bRespectTeamRules = bRespectTeamRules;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05754CD0
	 * 		Name   -> Function Insurgency.WeaponStatics.GetSwingYawMultiplierForDirection
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		EMeleeSwingDirection                               Direction                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	float UWeaponStatics::STATIC_GetSwingYawMultiplierForDirection(EMeleeSwingDirection Direction)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.WeaponStatics.GetSwingYawMultiplierForDirection");
		
		UWeaponStatics_GetSwingYawMultiplierForDirection_Params params {};
		params.Direction = Direction;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05754C50
	 * 		Name   -> Function Insurgency.WeaponStatics.GetSwingPitchMultiplierForDirection
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		EMeleeSwingDirection                               Direction                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	float UWeaponStatics::STATIC_GetSwingPitchMultiplierForDirection(EMeleeSwingDirection Direction)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.WeaponStatics.GetSwingPitchMultiplierForDirection");
		
		UWeaponStatics_GetSwingPitchMultiplierForDirection_Params params {};
		params.Direction = Direction;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05754950
	 * 		Name   -> Function Insurgency.WeaponStatics.GetReloadGroupFromMap
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class UClass*                                      Ammo                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		TMap<class UClass*, struct FReloadGroup>           Map                                                        (Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		bool                                               bOutFound                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FReloadGroup UWeaponStatics::STATIC_GetReloadGroupFromMap(class UClass* Ammo, TMap<class UClass*, struct FReloadGroup>* Map, bool* bOutFound)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.WeaponStatics.GetReloadGroupFromMap");
		
		UWeaponStatics_GetReloadGroupFromMap_Params params {};
		params.Ammo = Ammo;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (Map != nullptr)
			*Map = params.Map;
		if (bOutFound != nullptr)
			*bOutFound = params.bOutFound;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x057547B0
	 * 		Name   -> Function Insurgency.WeaponStatics.GetExplosiveDamageModifier
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class UPrimitiveComponent*                         VictimComp                                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FExplosiveDamageParams                      ExplosiveParameters                                        (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		struct FHitResult                                  OutHitResult                                               (Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	float UWeaponStatics::STATIC_GetExplosiveDamageModifier(class UPrimitiveComponent* VictimComp, const struct FExplosiveDamageParams& ExplosiveParameters, struct FHitResult* OutHitResult)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.WeaponStatics.GetExplosiveDamageModifier");
		
		UWeaponStatics_GetExplosiveDamageModifier_Params params {};
		params.VictimComp = VictimComp;
		params.ExplosiveParameters = ExplosiveParameters;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutHitResult != nullptr)
			*OutHitResult = params.OutHitResult;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05754730
	 * 		Name   -> Function Insurgency.WeaponStatics.GetBulletManager
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class ABulletManager* UWeaponStatics::STATIC_GetBulletManager(class UObject* WorldContextObject)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.WeaponStatics.GetBulletManager");
		
		UWeaponStatics_GetBulletManager_Params params {};
		params.WorldContextObject = WorldContextObject;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x057544A0
	 * 		Name   -> Function Insurgency.WeaponStatics.GetAnimSequenceRandomFromMap
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class UClass*                                      Ammo                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		TMap<class UClass*, struct FAnimSequenceRandom>    Map                                                        (Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		bool                                               bOutFound                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	struct FAnimSequenceRandom UWeaponStatics::STATIC_GetAnimSequenceRandomFromMap(class UClass* Ammo, TMap<class UClass*, struct FAnimSequenceRandom>* Map, bool* bOutFound)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.WeaponStatics.GetAnimSequenceRandomFromMap");
		
		UWeaponStatics_GetAnimSequenceRandomFromMap_Params params {};
		params.Ammo = Ammo;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (Map != nullptr)
			*Map = params.Map;
		if (bOutFound != nullptr)
			*bOutFound = params.bOutFound;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05754270
	 * 		Name   -> Function Insurgency.WeaponStatics.GetAnimSequenceFromMap
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class UClass*                                      Ammo                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		TMap<class UClass*, class UAnimSequence*>          Map                                                        (Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		bool                                               bOutFound                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UAnimSequence* UWeaponStatics::STATIC_GetAnimSequenceFromMap(class UClass* Ammo, TMap<class UClass*, class UAnimSequence*>* Map, bool* bOutFound)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.WeaponStatics.GetAnimSequenceFromMap");
		
		UWeaponStatics_GetAnimSequenceFromMap_Params params {};
		params.Ammo = Ammo;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (Map != nullptr)
			*Map = params.Map;
		if (bOutFound != nullptr)
			*bOutFound = params.bOutFound;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05754270
	 * 		Name   -> Function Insurgency.WeaponStatics.GetAnimMontageFromMap
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class UClass*                                      Ammo                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		TMap<class UClass*, class UAnimMontage*>           Map                                                        (Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		bool                                               bOutFound                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class UAnimMontage* UWeaponStatics::STATIC_GetAnimMontageFromMap(class UClass* Ammo, TMap<class UClass*, class UAnimMontage*>* Map, bool* bOutFound)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.WeaponStatics.GetAnimMontageFromMap");
		
		UWeaponStatics_GetAnimMontageFromMap_Params params {};
		params.Ammo = Ammo;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (Map != nullptr)
			*Map = params.Map;
		if (bOutFound != nullptr)
			*bOutFound = params.bOutFound;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05754140
	 * 		Name   -> Function Insurgency.WeaponStatics.GetAllWeaponUpgradeClassesForWeapon
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class UClass*                                      Weapon                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		TArray<class UClass*>                              OutUpgradeClasses                                          (Parm, OutParm, ZeroConstructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bSorted                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UWeaponStatics::STATIC_GetAllWeaponUpgradeClassesForWeapon(class UClass* Weapon, TArray<class UClass*>* OutUpgradeClasses, bool bSorted)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.WeaponStatics.GetAllWeaponUpgradeClassesForWeapon");
		
		UWeaponStatics_GetAllWeaponUpgradeClassesForWeapon_Params params {};
		params.Weapon = Weapon;
		params.bSorted = bSorted;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutUpgradeClasses != nullptr)
			*OutUpgradeClasses = params.OutUpgradeClasses;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05754050
	 * 		Name   -> Function Insurgency.WeaponStatics.GetAllWeaponUpgradeClasses
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		TArray<class UClass*>                              OutUpgradeClasses                                          (Parm, OutParm, ZeroConstructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bSorted                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UWeaponStatics::STATIC_GetAllWeaponUpgradeClasses(TArray<class UClass*>* OutUpgradeClasses, bool bSorted)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.WeaponStatics.GetAllWeaponUpgradeClasses");
		
		UWeaponStatics_GetAllWeaponUpgradeClasses_Params params {};
		params.bSorted = bSorted;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutUpgradeClasses != nullptr)
			*OutUpgradeClasses = params.OutUpgradeClasses;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05753F60
	 * 		Name   -> Function Insurgency.WeaponStatics.GetAllWeaponClasses
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		TArray<class UClass*>                              OutItemClasses                                             (Parm, OutParm, ZeroConstructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bSorted                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UWeaponStatics::STATIC_GetAllWeaponClasses(TArray<class UClass*>* OutItemClasses, bool bSorted)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.WeaponStatics.GetAllWeaponClasses");
		
		UWeaponStatics_GetAllWeaponClasses_Params params {};
		params.bSorted = bSorted;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutItemClasses != nullptr)
			*OutItemClasses = params.OutItemClasses;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05753E70
	 * 		Name   -> Function Insurgency.WeaponStatics.GetAllEquipableClasses
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		TArray<class UClass*>                              OutItemClasses                                             (Parm, OutParm, ZeroConstructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bSorted                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UWeaponStatics::STATIC_GetAllEquipableClasses(TArray<class UClass*>* OutItemClasses, bool bSorted)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.WeaponStatics.GetAllEquipableClasses");
		
		UWeaponStatics_GetAllEquipableClasses_Params params {};
		params.bSorted = bSorted;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutItemClasses != nullptr)
			*OutItemClasses = params.OutItemClasses;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05753BE0
	 * 		Name   -> Function Insurgency.WeaponStatics.FireBullets
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FSimulatedBullet                            BulletInfo                                                 (Parm, OutParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 * 		float                                              ProjectileSpread                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            Count                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            SpreadSeed                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UWeaponStatics::STATIC_FireBullets(class UObject* WorldContextObject, struct FSimulatedBullet* BulletInfo, float ProjectileSpread, int32_t Count, int32_t SpreadSeed)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.WeaponStatics.FireBullets");
		
		UWeaponStatics_FireBullets_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.ProjectileSpread = ProjectileSpread;
		params.Count = Count;
		params.SpreadSeed = SpreadSeed;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (BulletInfo != nullptr)
			*BulletInfo = params.BulletInfo;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05753840
	 * 		Name   -> Function Insurgency.WeaponStatics.DoMeleeSwingIgnoreActors
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AINSSoldier*                                 Instigator                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FMeleeConfig                                MeleeConfig                                                (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 * 		float                                              SwingPercent                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FHitResult                                  OutHitResults                                              (Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 * 		TArray<class UPrimitiveComponent*>                 InIgnoreComponents                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		TArray<class UPrimitiveComponent*>                 InOutHitComponents                                         (Parm, OutParm, ZeroConstructor, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bApplyDamage                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      DamagerCauser                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UWeaponStatics::STATIC_DoMeleeSwingIgnoreActors(class UObject* WorldContextObject, class AINSSoldier* Instigator, const struct FMeleeConfig& MeleeConfig, float SwingPercent, struct FHitResult* OutHitResults, TArray<class UPrimitiveComponent*> InIgnoreComponents, TArray<class UPrimitiveComponent*>* InOutHitComponents, bool bApplyDamage, class AActor* DamagerCauser)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.WeaponStatics.DoMeleeSwingIgnoreActors");
		
		UWeaponStatics_DoMeleeSwingIgnoreActors_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.Instigator = Instigator;
		params.MeleeConfig = MeleeConfig;
		params.SwingPercent = SwingPercent;
		params.InIgnoreComponents = InIgnoreComponents;
		params.bApplyDamage = bApplyDamage;
		params.DamagerCauser = DamagerCauser;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutHitResults != nullptr)
			*OutHitResults = params.OutHitResults;
		if (InOutHitComponents != nullptr)
			*InOutHitComponents = params.InOutHitComponents;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05753590
	 * 		Name   -> Function Insurgency.WeaponStatics.DoMeleeSwing
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AINSSoldier*                                 Instigator                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FMeleeConfig                                MeleeConfig                                                (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 * 		float                                              SwingPercent                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FHitResult                                  OutHitResults                                              (Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 * 		bool                                               bApplyDamage                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class AActor*                                      DamagerCauser                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	bool UWeaponStatics::STATIC_DoMeleeSwing(class UObject* WorldContextObject, class AINSSoldier* Instigator, const struct FMeleeConfig& MeleeConfig, float SwingPercent, struct FHitResult* OutHitResults, bool bApplyDamage, class AActor* DamagerCauser)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.WeaponStatics.DoMeleeSwing");
		
		UWeaponStatics_DoMeleeSwing_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.Instigator = Instigator;
		params.MeleeConfig = MeleeConfig;
		params.SwingPercent = SwingPercent;
		params.bApplyDamage = bApplyDamage;
		params.DamagerCauser = DamagerCauser;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutHitResults != nullptr)
			*OutHitResults = params.OutHitResults;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x057534E0
	 * 		Name   -> Function Insurgency.WeaponStatics.DoExplosiveDamage
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		struct FExplosiveDamageParams                      Parameters                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	bool UWeaponStatics::STATIC_DoExplosiveDamage(const struct FExplosiveDamageParams& Parameters)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.WeaponStatics.DoExplosiveDamage");
		
		UWeaponStatics_DoExplosiveDamage_Params params {};
		params.Parameters = Parameters;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05753280
	 * 		Name   -> Function Insurgency.WeaponStatics.DeafenPlayersInRadius
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		struct FVector                                     Epicenter                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              InnerRadius                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              OuterRadius                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              InnerDuration                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		float                                              OuterDuration                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		TArray<class AController*>                         IgnoredControllers                                         (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UWeaponStatics::STATIC_DeafenPlayersInRadius(class UObject* WorldContextObject, const struct FVector& Epicenter, float InnerRadius, float OuterRadius, float InnerDuration, float OuterDuration, TArray<class AController*> IgnoredControllers)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.WeaponStatics.DeafenPlayersInRadius");
		
		UWeaponStatics_DeafenPlayersInRadius_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.Epicenter = Epicenter;
		params.InnerRadius = InnerRadius;
		params.OuterRadius = OuterRadius;
		params.InnerDuration = InnerDuration;
		params.OuterDuration = OuterDuration;
		params.IgnoredControllers = IgnoredControllers;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UWeaponStatics.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UWeaponStatics::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.WeaponStatics");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UWeaponTrainingComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UWeaponTrainingComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.WeaponTrainingComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UWebImageDecorator.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UWebImageDecorator::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.WebImageDecorator");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05758860
	 * 		Name   -> Function Insurgency.WebImageWidget.SetLocalImage
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class FString                                      Path                                                       (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UWebImageWidget::SetLocalImage(const class FString& Path)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.WebImageWidget.SetLocalImage");
		
		UWebImageWidget_SetLocalImage_Params params {};
		params.Path = Path;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x057587C0
	 * 		Name   -> Function Insurgency.WebImageWidget.SetImageUrl
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class FString                                      NewUrl                                                     (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UWebImageWidget::SetImageUrl(const class FString& NewUrl)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.WebImageWidget.SetImageUrl");
		
		UWebImageWidget_SetImageUrl_Params params {};
		params.NewUrl = NewUrl;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x057586C0
	 * 		Name   -> Function Insurgency.WebImageWidget.SetImageFromTexturePath
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void UWebImageWidget::SetImageFromTexturePath()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.WebImageWidget.SetImageFromTexturePath");
		
		UWebImageWidget_SetImageFromTexturePath_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05758640
	 * 		Name   -> Function Insurgency.WebImageWidget.SetImageFromTexture
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UTexture2D*                                  Texture                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UWebImageWidget::SetImageFromTexture(class UTexture2D* Texture)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.WebImageWidget.SetImageFromTexture");
		
		UWebImageWidget_SetImageFromTexture_Params params {};
		params.Texture = Texture;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UWebImageWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UWebImageWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.WebImageWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05758AE0
	 * 		Name   -> Function Insurgency.WelcomeMenuWidget.PerformLogin
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		int32_t                                            UserIndex                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UWelcomeMenuWidget::PerformLogin(int32_t UserIndex)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.WelcomeMenuWidget.PerformLogin");
		
		UWelcomeMenuWidget_PerformLogin_Params params {};
		params.UserIndex = UserIndex;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05758AB0
	 * 		Name   -> Function Insurgency.WelcomeMenuWidget.CanFadeLegalText
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool UWelcomeMenuWidget::CanFadeLegalText()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.WelcomeMenuWidget.CanFadeLegalText");
		
		UWelcomeMenuWidget_CanFadeLegalText_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UWelcomeMenuWidget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UWelcomeMenuWidget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.WelcomeMenuWidget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UWheelParticleSystemComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UWheelParticleSystemComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.WheelParticleSystemComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05759190
	 * 		Name   -> Function Insurgency.WidgetGamemodeFilter.InitKeyOptionInWidget
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class FString                                      Key                                                        (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UWidgetGamemodeFilter::InitKeyOptionInWidget(const class FString& Key)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.WidgetGamemodeFilter.InitKeyOptionInWidget");
		
		UWidgetGamemodeFilter_InitKeyOptionInWidget_Params params {};
		params.Key = Key;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05759110
	 * 		Name   -> Function Insurgency.WidgetGamemodeFilter.GetFilterKeyAsCultureInvariant
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	class FString UWidgetGamemodeFilter::GetFilterKeyAsCultureInvariant()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.WidgetGamemodeFilter.GetFilterKeyAsCultureInvariant");
		
		UWidgetGamemodeFilter_GetFilterKeyAsCultureInvariant_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05759090
	 * 		Name   -> Function Insurgency.WidgetGamemodeFilter.GetFilterKey
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	class FString UWidgetGamemodeFilter::GetFilterKey()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.WidgetGamemodeFilter.GetFilterKey");
		
		UWidgetGamemodeFilter_GetFilterKey_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UWidgetGamemodeFilter.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UWidgetGamemodeFilter::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.WidgetGamemodeFilter");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05759590
	 * 		Name   -> Function Insurgency.WidgetNavigationStatics.SetUniformGridPanelNavigation
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UUniformGridPanel*                           Grid                                                       (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UWidgetNavigationStatics::STATIC_SetUniformGridPanelNavigation(class UUniformGridPanel* Grid)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.WidgetNavigationStatics.SetUniformGridPanelNavigation");
		
		UWidgetNavigationStatics_SetUniformGridPanelNavigation_Params params {};
		params.Grid = Grid;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x057593C0
	 * 		Name   -> Function Insurgency.WidgetNavigationStatics.GetUniformGridWidgetMap
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class UUniformGridPanel*                           Grid                                                       (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		TMap<struct FIntPoint, class UWidget*>             OutGridWidgetMap                                           (Parm, OutParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	 */
	void UWidgetNavigationStatics::STATIC_GetUniformGridWidgetMap(class UUniformGridPanel* Grid, TMap<struct FIntPoint, class UWidget*>* OutGridWidgetMap)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.WidgetNavigationStatics.GetUniformGridWidgetMap");
		
		UWidgetNavigationStatics_GetUniformGridWidgetMap_Params params {};
		params.Grid = Grid;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutGridWidgetMap != nullptr)
			*OutGridWidgetMap = params.OutGridWidgetMap;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UWidgetNavigationStatics.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UWidgetNavigationStatics::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.WidgetNavigationStatics");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05759CE0
	 * 		Name   -> Function Insurgency.Widget_Scoreboard.PeriodicTick
	 * 		Flags  -> (Final, Native, Protected)
	 */
	void UWidget_Scoreboard::PeriodicTick()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.Widget_Scoreboard.PeriodicTick");
		
		UWidget_Scoreboard_PeriodicTick_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05759C20
	 * 		Name   -> Function Insurgency.Widget_Scoreboard.OnTeamChanged
	 * 		Flags  -> (Final, Native, Protected)
	 * Parameters:
	 * 		unsigned char                                      TeamId                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		class ATeamInfo*                                   TeamInfo                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UWidget_Scoreboard::OnTeamChanged(unsigned char TeamId, class ATeamInfo* TeamInfo)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.Widget_Scoreboard.OnTeamChanged");
		
		UWidget_Scoreboard_OnTeamChanged_Params params {};
		params.TeamId = TeamId;
		params.TeamInfo = TeamInfo;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05759C00
	 * 		Name   -> Function Insurgency.Widget_Scoreboard.OnRefreshObjectives
	 * 		Flags  -> (Final, Native, Protected)
	 */
	void UWidget_Scoreboard::OnRefreshObjectives()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.Widget_Scoreboard.OnRefreshObjectives");
		
		UWidget_Scoreboard_OnRefreshObjectives_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05759BE0
	 * 		Name   -> Function Insurgency.Widget_Scoreboard.OnRefreshMutators
	 * 		Flags  -> (Final, Native, Protected)
	 */
	void UWidget_Scoreboard::OnRefreshMutators()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.Widget_Scoreboard.OnRefreshMutators");
		
		UWidget_Scoreboard_OnRefreshMutators_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05759BC0
	 * 		Name   -> Function Insurgency.Widget_Scoreboard.OnRefreshFactions
	 * 		Flags  -> (Final, Native, Protected)
	 */
	void UWidget_Scoreboard::OnRefreshFactions()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.Widget_Scoreboard.OnRefreshFactions");
		
		UWidget_Scoreboard_OnRefreshFactions_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05759B00
	 * 		Name   -> Function Insurgency.Widget_Scoreboard.OnPlayerControllerEndPlay
	 * 		Flags  -> (Final, Native, Protected)
	 * Parameters:
	 * 		class AActor*                                      InActor                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EEndPlayReason                                     InEndPlayReason                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UWidget_Scoreboard::OnPlayerControllerEndPlay(class AActor* InActor, EEndPlayReason InEndPlayReason)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.Widget_Scoreboard.OnPlayerControllerEndPlay");
		
		UWidget_Scoreboard_OnPlayerControllerEndPlay_Params params {};
		params.InActor = InActor;
		params.InEndPlayReason = InEndPlayReason;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> Function Insurgency.Widget_Scoreboard.GetFormatText
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 * Parameters:
	 * 		bool                                               bFirstElement                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	class FText UWidget_Scoreboard::GetFormatText(bool bFirstElement)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.Widget_Scoreboard.GetFormatText");
		
		UWidget_Scoreboard_GetFormatText_Params params {};
		params.bFirstElement = bFirstElement;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> Function Insurgency.Widget_Scoreboard.DoUpdateGameState
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 * Parameters:
	 * 		class AINSGameState*                               GameState                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UWidget_Scoreboard::DoUpdateGameState(class AINSGameState* GameState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.Widget_Scoreboard.DoUpdateGameState");
		
		UWidget_Scoreboard_DoUpdateGameState_Params params {};
		params.GameState = GameState;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> Function Insurgency.Widget_Scoreboard.DoUpdateGameModeText
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 */
	void UWidget_Scoreboard::DoUpdateGameModeText()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.Widget_Scoreboard.DoUpdateGameModeText");
		
		UWidget_Scoreboard_DoUpdateGameModeText_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> Function Insurgency.Widget_Scoreboard.DoBindTacticalMapPawnHowerStatusChanged
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 */
	void UWidget_Scoreboard::DoBindTacticalMapPawnHowerStatusChanged()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.Widget_Scoreboard.DoBindTacticalMapPawnHowerStatusChanged");
		
		UWidget_Scoreboard_DoBindTacticalMapPawnHowerStatusChanged_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05759AE0
	 * 		Name   -> Function Insurgency.Widget_Scoreboard.AssignTeams
	 * 		Flags  -> (Final, Native, Protected, BlueprintCallable)
	 */
	void UWidget_Scoreboard::AssignTeams()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.Widget_Scoreboard.AssignTeams");
		
		UWidget_Scoreboard_AssignTeams_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UWidget_Scoreboard.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UWidget_Scoreboard::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.Widget_Scoreboard");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0575A7B0
	 * 		Name   -> Function Insurgency.Widget_Scoreboard_Column.UpdateTeam
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class ATeamInfo*                                   InTeamInfo                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UWidget_Scoreboard_Column::UpdateTeam(class ATeamInfo* InTeamInfo)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.Widget_Scoreboard_Column.UpdateTeam");
		
		UWidget_Scoreboard_Column_UpdateTeam_Params params {};
		params.InTeamInfo = InTeamInfo;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> Function Insurgency.Widget_Scoreboard_Column.UpdateSelectButtonOnConsole
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 * Parameters:
	 * 		bool                                               bIsRowSelectable                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UWidget_Scoreboard_Column::UpdateSelectButtonOnConsole(bool bIsRowSelectable)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.Widget_Scoreboard_Column.UpdateSelectButtonOnConsole");
		
		UWidget_Scoreboard_Column_UpdateSelectButtonOnConsole_Params params {};
		params.bIsRowSelectable = bIsRowSelectable;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0575A6E0
	 * 		Name   -> Function Insurgency.Widget_Scoreboard_Column.UpdateScoreboardConfig
	 * 		Flags  -> (Final, Native, Protected, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		struct FScoreboardConfig                           Config                                                     (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UWidget_Scoreboard_Column::UpdateScoreboardConfig(const struct FScoreboardConfig& Config)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.Widget_Scoreboard_Column.UpdateScoreboardConfig");
		
		UWidget_Scoreboard_Column_UpdateScoreboardConfig_Params params {};
		params.Config = Config;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0575A6C0
	 * 		Name   -> Function Insurgency.Widget_Scoreboard_Column.UpdatePlayerRows
	 * 		Flags  -> (Final, Native, Protected, BlueprintCallable)
	 */
	void UWidget_Scoreboard_Column::UpdatePlayerRows()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.Widget_Scoreboard_Column.UpdatePlayerRows");
		
		UWidget_Scoreboard_Column_UpdatePlayerRows_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0575A6A0
	 * 		Name   -> Function Insurgency.Widget_Scoreboard_Column.UpdateColumnValues
	 * 		Flags  -> (Final, Native, Protected)
	 */
	void UWidget_Scoreboard_Column::UpdateColumnValues()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.Widget_Scoreboard_Column.UpdateColumnValues");
		
		UWidget_Scoreboard_Column_UpdateColumnValues_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0575A680
	 * 		Name   -> Function Insurgency.Widget_Scoreboard_Column.ToggleMuteAll
	 * 		Flags  -> (Final, Native, Protected, BlueprintCallable)
	 */
	void UWidget_Scoreboard_Column::ToggleMuteAll()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.Widget_Scoreboard_Column.ToggleMuteAll");
		
		UWidget_Scoreboard_Column_ToggleMuteAll_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0575A5B0
	 * 		Name   -> Function Insurgency.Widget_Scoreboard_Column.SetTeamRole
	 * 		Flags  -> (Final, Native, Protected, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		class FText                                        InTeamRole                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UWidget_Scoreboard_Column::SetTeamRole(const class FText& InTeamRole)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.Widget_Scoreboard_Column.SetTeamRole");
		
		UWidget_Scoreboard_Column_SetTeamRole_Params params {};
		params.InTeamRole = InTeamRole;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0575A4E0
	 * 		Name   -> Function Insurgency.Widget_Scoreboard_Column.SetTeamName
	 * 		Flags  -> (Final, Native, Protected, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		class FText                                        InTeamName                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UWidget_Scoreboard_Column::SetTeamName(const class FText& InTeamName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.Widget_Scoreboard_Column.SetTeamName");
		
		UWidget_Scoreboard_Column_SetTeamName_Params params {};
		params.InTeamName = InTeamName;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0575A450
	 * 		Name   -> Function Insurgency.Widget_Scoreboard_Column.SetFactionColor
	 * 		Flags  -> (Final, Native, Protected, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FLinearColor                                InFactionColor                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UWidget_Scoreboard_Column::SetFactionColor(const struct FLinearColor& InFactionColor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.Widget_Scoreboard_Column.SetFactionColor");
		
		UWidget_Scoreboard_Column_SetFactionColor_Params params {};
		params.InFactionColor = InFactionColor;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0575A430
	 * 		Name   -> Function Insurgency.Widget_Scoreboard_Column.PeriodicTick
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void UWidget_Scoreboard_Column::PeriodicTick()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.Widget_Scoreboard_Column.PeriodicTick");
		
		UWidget_Scoreboard_Column_PeriodicTick_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> Function Insurgency.Widget_Scoreboard_Column.OpenMenuForPlayer
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 * Parameters:
	 * 		class AINSPlayerState*                             InPlayerState                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UWidget_Scoreboard_Column::OpenMenuForPlayer(class AINSPlayerState* InPlayerState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.Widget_Scoreboard_Column.OpenMenuForPlayer");
		
		UWidget_Scoreboard_Column_OpenMenuForPlayer_Params params {};
		params.InPlayerState = InPlayerState;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0575A3A0
	 * 		Name   -> Function Insurgency.Widget_Scoreboard_Column.OnScoreboardShown
	 * 		Flags  -> (Final, Native, Protected)
	 * Parameters:
	 * 		bool                                               bShown                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UWidget_Scoreboard_Column::OnScoreboardShown(bool bShown)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.Widget_Scoreboard_Column.OnScoreboardShown");
		
		UWidget_Scoreboard_Column_OnScoreboardShown_Params params {};
		params.bShown = bShown;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0575A2E0
	 * 		Name   -> Function Insurgency.Widget_Scoreboard_Column.OnPlayerControllerEndPlay
	 * 		Flags  -> (Final, Native, Protected)
	 * Parameters:
	 * 		class AActor*                                      InActor                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EEndPlayReason                                     InEndPlayReason                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UWidget_Scoreboard_Column::OnPlayerControllerEndPlay(class AActor* InActor, EEndPlayReason InEndPlayReason)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.Widget_Scoreboard_Column.OnPlayerControllerEndPlay");
		
		UWidget_Scoreboard_Column_OnPlayerControllerEndPlay_Params params {};
		params.InActor = InActor;
		params.InEndPlayReason = InEndPlayReason;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0575A2C0
	 * 		Name   -> Function Insurgency.Widget_Scoreboard_Column.HideActiveMenu
	 * 		Flags  -> (Final, Native, Protected, BlueprintCallable)
	 */
	void UWidget_Scoreboard_Column::HideActiveMenu()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.Widget_Scoreboard_Column.HideActiveMenu");
		
		UWidget_Scoreboard_Column_HideActiveMenu_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0575A290
	 * 		Name   -> Function Insurgency.Widget_Scoreboard_Column.GetPlayerCount
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
	 */
	int32_t UWidget_Scoreboard_Column::GetPlayerCount()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.Widget_Scoreboard_Column.GetPlayerCount");
		
		UWidget_Scoreboard_Column_GetPlayerCount_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0575A260
	 * 		Name   -> Function Insurgency.Widget_Scoreboard_Column.GetBottomPlayerWidget
	 * 		Flags  -> (Final, Native, Protected, BlueprintCallable)
	 */
	class UWidget* UWidget_Scoreboard_Column::GetBottomPlayerWidget()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.Widget_Scoreboard_Column.GetBottomPlayerWidget");
		
		UWidget_Scoreboard_Column_GetBottomPlayerWidget_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> Function Insurgency.Widget_Scoreboard_Column.DoSetTacticalMapToPlayerWidget
	 * 		Flags  -> (Event, Protected, BlueprintEvent)
	 * Parameters:
	 * 		class UWidget*                                     InPlayerWidget                                             (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UWidget_Scoreboard_Column::DoSetTacticalMapToPlayerWidget(class UWidget* InPlayerWidget)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.Widget_Scoreboard_Column.DoSetTacticalMapToPlayerWidget");
		
		UWidget_Scoreboard_Column_DoSetTacticalMapToPlayerWidget_Params params {};
		params.InPlayerWidget = InPlayerWidget;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> Function Insurgency.Widget_Scoreboard_Column.DoCreatePlayerRowWidget
	 * 		Flags  -> (Event, Protected, BlueprintCallable, BlueprintEvent, BlueprintPure)
	 */
	class UWidget* UWidget_Scoreboard_Column::DoCreatePlayerRowWidget()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.Widget_Scoreboard_Column.DoCreatePlayerRowWidget");
		
		UWidget_Scoreboard_Column_DoCreatePlayerRowWidget_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UWidget_Scoreboard_Column.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UWidget_Scoreboard_Column::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.Widget_Scoreboard_Column");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0575BEC0
	 * 		Name   -> Function Insurgency.Widget_Scoreboard_PlayerRow.UpdateScoreboardBadge
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		int32_t                                            NewScoreboardBadge                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UWidget_Scoreboard_PlayerRow::UpdateScoreboardBadge(int32_t NewScoreboardBadge)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.Widget_Scoreboard_PlayerRow.UpdateScoreboardBadge");
		
		UWidget_Scoreboard_PlayerRow_UpdateScoreboardBadge_Params params {};
		params.NewScoreboardBadge = NewScoreboardBadge;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0575BE40
	 * 		Name   -> Function Insurgency.Widget_Scoreboard_PlayerRow.UpdatePlayerState
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class AINSPlayerState*                             NewPlayerState                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UWidget_Scoreboard_PlayerRow::UpdatePlayerState(class AINSPlayerState* NewPlayerState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.Widget_Scoreboard_PlayerRow.UpdatePlayerState");
		
		UWidget_Scoreboard_PlayerRow_UpdatePlayerState_Params params {};
		params.NewPlayerState = NewPlayerState;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0575BDA0
	 * 		Name   -> Function Insurgency.Widget_Scoreboard_PlayerRow.UpdatePlayerScore
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		struct FPlayerStatGroupMinimal                     UpdatedScore                                               (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	 */
	void UWidget_Scoreboard_PlayerRow::UpdatePlayerScore(const struct FPlayerStatGroupMinimal& UpdatedScore)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.Widget_Scoreboard_PlayerRow.UpdatePlayerScore");
		
		UWidget_Scoreboard_PlayerRow_UpdatePlayerScore_Params params {};
		params.UpdatedScore = UpdatedScore;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0575BD20
	 * 		Name   -> Function Insurgency.Widget_Scoreboard_PlayerRow.UpdatePlayerPing
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		int32_t                                            NewPingMs                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UWidget_Scoreboard_PlayerRow::UpdatePlayerPing(int32_t NewPingMs)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.Widget_Scoreboard_PlayerRow.UpdatePlayerPing");
		
		UWidget_Scoreboard_PlayerRow_UpdatePlayerPing_Params params {};
		params.NewPingMs = NewPingMs;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0575BC40
	 * 		Name   -> Function Insurgency.Widget_Scoreboard_PlayerRow.UpdatePlayerName
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class FString                                      NewName                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bForce                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UWidget_Scoreboard_PlayerRow::UpdatePlayerName(const class FString& NewName, bool bForce)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.Widget_Scoreboard_PlayerRow.UpdatePlayerName");
		
		UWidget_Scoreboard_PlayerRow_UpdatePlayerName_Params params {};
		params.NewName = NewName;
		params.bForce = bForce;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> Function Insurgency.Widget_Scoreboard_PlayerRow.UpdatePlayerExperience
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		class AINSPlayerState*                             InPlayerState                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            NewExperience                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UWidget_Scoreboard_PlayerRow::UpdatePlayerExperience(class AINSPlayerState* InPlayerState, int32_t NewExperience)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.Widget_Scoreboard_PlayerRow.UpdatePlayerExperience");
		
		UWidget_Scoreboard_PlayerRow_UpdatePlayerExperience_Params params {};
		params.InPlayerState = InPlayerState;
		params.NewExperience = NewExperience;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0575BBC0
	 * 		Name   -> Function Insurgency.Widget_Scoreboard_PlayerRow.UpdatePlayerClass
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UPlayerClass*                                InPlayerClass                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UWidget_Scoreboard_PlayerRow::UpdatePlayerClass(class UPlayerClass* InPlayerClass)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.Widget_Scoreboard_PlayerRow.UpdatePlayerClass");
		
		UWidget_Scoreboard_PlayerRow_UpdatePlayerClass_Params params {};
		params.InPlayerClass = InPlayerClass;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0575BAF0
	 * 		Name   -> Function Insurgency.Widget_Scoreboard_PlayerRow.UpdatePlayerAliveState
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class AINSPlayerState*                             InPlayerState                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bForce                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UWidget_Scoreboard_PlayerRow::UpdatePlayerAliveState(class AINSPlayerState* InPlayerState, bool bForce)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.Widget_Scoreboard_PlayerRow.UpdatePlayerAliveState");
		
		UWidget_Scoreboard_PlayerRow_UpdatePlayerAliveState_Params params {};
		params.InPlayerState = InPlayerState;
		params.bForce = bForce;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0575BAD0
	 * 		Name   -> Function Insurgency.Widget_Scoreboard_PlayerRow.UpdatePingAndKAD
	 * 		Flags  -> (Final, Native, Public)
	 */
	void UWidget_Scoreboard_PlayerRow::UpdatePingAndKAD()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.Widget_Scoreboard_PlayerRow.UpdatePingAndKAD");
		
		UWidget_Scoreboard_PlayerRow_UpdatePingAndKAD_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0575BA00
	 * 		Name   -> Function Insurgency.Widget_Scoreboard_PlayerRow.UpdateFromPlayerState
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class AINSPlayerState*                             InPlayerState                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bFromInit                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UWidget_Scoreboard_PlayerRow::UpdateFromPlayerState(class AINSPlayerState* InPlayerState, bool bFromInit)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.Widget_Scoreboard_PlayerRow.UpdateFromPlayerState");
		
		UWidget_Scoreboard_PlayerRow_UpdateFromPlayerState_Params params {};
		params.InPlayerState = InPlayerState;
		params.bFromInit = bFromInit;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0575B9E0
	 * 		Name   -> Function Insurgency.Widget_Scoreboard_PlayerRow.UpdateFactionStripeVisibility
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void UWidget_Scoreboard_PlayerRow::UpdateFactionStripeVisibility()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.Widget_Scoreboard_PlayerRow.UpdateFactionStripeVisibility");
		
		UWidget_Scoreboard_PlayerRow_UpdateFactionStripeVisibility_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> Function Insurgency.Widget_Scoreboard_PlayerRow.UpdateExtendedColumnVisiblity
	 * 		Flags  -> (Event, Public, BlueprintCallable, BlueprintEvent)
	 * Parameters:
	 * 		bool                                               bNewVisibility                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UWidget_Scoreboard_PlayerRow::UpdateExtendedColumnVisiblity(bool bNewVisibility)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.Widget_Scoreboard_PlayerRow.UpdateExtendedColumnVisiblity");
		
		UWidget_Scoreboard_PlayerRow_UpdateExtendedColumnVisiblity_Params params {};
		params.bNewVisibility = bNewVisibility;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> Function Insurgency.Widget_Scoreboard_PlayerRow.UpdateDeveloperStatus
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		class AINSPlayerState*                             InPlayerState                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		bool                                               bDeveloperStatus                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UWidget_Scoreboard_PlayerRow::UpdateDeveloperStatus(class AINSPlayerState* InPlayerState, bool bDeveloperStatus)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.Widget_Scoreboard_PlayerRow.UpdateDeveloperStatus");
		
		UWidget_Scoreboard_PlayerRow_UpdateDeveloperStatus_Params params {};
		params.InPlayerState = InPlayerState;
		params.bDeveloperStatus = bDeveloperStatus;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0575B8C0
	 * 		Name   -> Function Insurgency.Widget_Scoreboard_PlayerRow.UpdateBotName
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		class FText                                        NewName                                                    (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 * 		bool                                               bForce                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UWidget_Scoreboard_PlayerRow::UpdateBotName(const class FText& NewName, bool bForce)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.Widget_Scoreboard_PlayerRow.UpdateBotName");
		
		UWidget_Scoreboard_PlayerRow_UpdateBotName_Params params {};
		params.NewName = NewName;
		params.bForce = bForce;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0575B8A0
	 * 		Name   -> Function Insurgency.Widget_Scoreboard_PlayerRow.UpdateBackgroundColor
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void UWidget_Scoreboard_PlayerRow::UpdateBackgroundColor()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.Widget_Scoreboard_PlayerRow.UpdateBackgroundColor");
		
		UWidget_Scoreboard_PlayerRow_UpdateBackgroundColor_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0575B810
	 * 		Name   -> Function Insurgency.Widget_Scoreboard_PlayerRow.ToggleMute
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bShouldMute                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UWidget_Scoreboard_PlayerRow::ToggleMute(bool bShouldMute)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.Widget_Scoreboard_PlayerRow.ToggleMute");
		
		UWidget_Scoreboard_PlayerRow_ToggleMute_Params params {};
		params.bShouldMute = bShouldMute;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0575B710
	 * 		Name   -> Function Insurgency.Widget_Scoreboard_PlayerRow.SetPlayerState
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void UWidget_Scoreboard_PlayerRow::SetPlayerState()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.Widget_Scoreboard_PlayerRow.SetPlayerState");
		
		UWidget_Scoreboard_PlayerRow_SetPlayerState_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0575B680
	 * 		Name   -> Function Insurgency.Widget_Scoreboard_PlayerRow.SetPlayerIsTalking
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               InPlayerIsTalking                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UWidget_Scoreboard_PlayerRow::SetPlayerIsTalking(bool InPlayerIsTalking)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.Widget_Scoreboard_PlayerRow.SetPlayerIsTalking");
		
		UWidget_Scoreboard_PlayerRow_SetPlayerIsTalking_Params params {};
		params.InPlayerIsTalking = InPlayerIsTalking;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0575B5F0
	 * 		Name   -> Function Insurgency.Widget_Scoreboard_PlayerRow.SetFactionColor
	 * 		Flags  -> (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FLinearColor                                InNewFactionColor                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UWidget_Scoreboard_PlayerRow::SetFactionColor(const struct FLinearColor& InNewFactionColor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.Widget_Scoreboard_PlayerRow.SetFactionColor");
		
		UWidget_Scoreboard_PlayerRow_SetFactionColor_Params params {};
		params.InNewFactionColor = InNewFactionColor;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0575B5D0
	 * 		Name   -> Function Insurgency.Widget_Scoreboard_PlayerRow.RefreshColumnVisibility
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void UWidget_Scoreboard_PlayerRow::RefreshColumnVisibility()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.Widget_Scoreboard_PlayerRow.RefreshColumnVisibility");
		
		UWidget_Scoreboard_PlayerRow_RefreshColumnVisibility_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0575B530
	 * 		Name   -> Function Insurgency.Widget_Scoreboard_PlayerRow.OnSetPlayerName
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		class FString                                      NewPlayerName                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UWidget_Scoreboard_PlayerRow::OnSetPlayerName(const class FString& NewPlayerName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.Widget_Scoreboard_PlayerRow.OnSetPlayerName");
		
		UWidget_Scoreboard_PlayerRow_OnSetPlayerName_Params params {};
		params.NewPlayerName = NewPlayerName;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0575B470
	 * 		Name   -> Function Insurgency.Widget_Scoreboard_PlayerRow.OnPlayerUpdateScoreboardBadge
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		class AINSPlayerState*                             Player                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		int32_t                                            NewScoreboardBadge                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UWidget_Scoreboard_PlayerRow::OnPlayerUpdateScoreboardBadge(class AINSPlayerState* Player, int32_t NewScoreboardBadge)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.Widget_Scoreboard_PlayerRow.OnPlayerUpdateScoreboardBadge");
		
		UWidget_Scoreboard_PlayerRow_OnPlayerUpdateScoreboardBadge_Params params {};
		params.Player = Player;
		params.NewScoreboardBadge = NewScoreboardBadge;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0575B3B0
	 * 		Name   -> Function Insurgency.Widget_Scoreboard_PlayerRow.OnPlayerStateEndPlay
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		class AActor*                                      InActor                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 * 		EEndPlayReason                                     InEndPlayReason                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UWidget_Scoreboard_PlayerRow::OnPlayerStateEndPlay(class AActor* InActor, EEndPlayReason InEndPlayReason)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.Widget_Scoreboard_PlayerRow.OnPlayerStateEndPlay");
		
		UWidget_Scoreboard_PlayerRow_OnPlayerStateEndPlay_Params params {};
		params.InActor = InActor;
		params.InEndPlayReason = InEndPlayReason;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0575B330
	 * 		Name   -> Function Insurgency.Widget_Scoreboard_PlayerRow.OnPlayerSpawned
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		class AINSSoldier*                                 Player                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UWidget_Scoreboard_PlayerRow::OnPlayerSpawned(class AINSSoldier* Player)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.Widget_Scoreboard_PlayerRow.OnPlayerSpawned");
		
		UWidget_Scoreboard_PlayerRow_OnPlayerSpawned_Params params {};
		params.Player = Player;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0575B2A0
	 * 		Name   -> Function Insurgency.Widget_Scoreboard_PlayerRow.OnPlayerIsMutedChanged
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		bool                                               bNewIsPlayingState                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UWidget_Scoreboard_PlayerRow::OnPlayerIsMutedChanged(bool bNewIsPlayingState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.Widget_Scoreboard_PlayerRow.OnPlayerIsMutedChanged");
		
		UWidget_Scoreboard_PlayerRow_OnPlayerIsMutedChanged_Params params {};
		params.bNewIsPlayingState = bNewIsPlayingState;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0575B280
	 * 		Name   -> Function Insurgency.Widget_Scoreboard_PlayerRow.OnPlayerDeath
	 * 		Flags  -> (Final, Native, Public)
	 */
	void UWidget_Scoreboard_PlayerRow::OnPlayerDeath()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.Widget_Scoreboard_PlayerRow.OnPlayerDeath");
		
		UWidget_Scoreboard_PlayerRow_OnPlayerDeath_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0575B200
	 * 		Name   -> Function Insurgency.Widget_Scoreboard_PlayerRow.OnPlayerClassChanged
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		class AINSSoldier*                                 Player                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UWidget_Scoreboard_PlayerRow::OnPlayerClassChanged(class AINSSoldier* Player)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.Widget_Scoreboard_PlayerRow.OnPlayerClassChanged");
		
		UWidget_Scoreboard_PlayerRow_OnPlayerClassChanged_Params params {};
		params.Player = Player;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0575B170
	 * 		Name   -> Function Insurgency.Widget_Scoreboard_PlayerRow.OnIsPlayingStateChanged
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		bool                                               bNewIsPlayingState                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UWidget_Scoreboard_PlayerRow::OnIsPlayingStateChanged(bool bNewIsPlayingState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.Widget_Scoreboard_PlayerRow.OnIsPlayingStateChanged");
		
		UWidget_Scoreboard_PlayerRow_OnIsPlayingStateChanged_Params params {};
		params.bNewIsPlayingState = bNewIsPlayingState;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0575B0F0
	 * 		Name   -> Function Insurgency.Widget_Scoreboard_PlayerRow.InitFromPlayerState
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class AINSPlayerState*                             InPlayerState                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UWidget_Scoreboard_PlayerRow::InitFromPlayerState(class AINSPlayerState* InPlayerState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.Widget_Scoreboard_PlayerRow.InitFromPlayerState");
		
		UWidget_Scoreboard_PlayerRow_InitFromPlayerState_Params params {};
		params.InPlayerState = InPlayerState;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0575B0C0
	 * 		Name   -> Function Insurgency.Widget_Scoreboard_PlayerRow.GetPlayerState
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
	 */
	class AINSPlayerState* UWidget_Scoreboard_PlayerRow::GetPlayerState()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.Widget_Scoreboard_PlayerRow.GetPlayerState");
		
		UWidget_Scoreboard_PlayerRow_GetPlayerState_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x05A96E40
	 * 		Name   -> Function Insurgency.Widget_Scoreboard_PlayerRow.DoSetDefaultsToPlayerBadge
	 * 		Flags  -> (Event, Public, BlueprintEvent)
	 * Parameters:
	 * 		class AINSPlayerState*                             InPlayerState                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UWidget_Scoreboard_PlayerRow::DoSetDefaultsToPlayerBadge(class AINSPlayerState* InPlayerState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.Widget_Scoreboard_PlayerRow.DoSetDefaultsToPlayerBadge");
		
		UWidget_Scoreboard_PlayerRow_DoSetDefaultsToPlayerBadge_Params params {};
		params.InPlayerState = InPlayerState;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UWidget_Scoreboard_PlayerRow.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UWidget_Scoreboard_PlayerRow::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.Widget_Scoreboard_PlayerRow");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0575C2D0
	 * 		Name   -> Function Insurgency.Widget_Scoreboard_RowHeader.UpdateScoreboardConfig
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		struct FScoreboardConfig                           Config                                                     (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	 */
	void UWidget_Scoreboard_RowHeader::UpdateScoreboardConfig(const struct FScoreboardConfig& Config)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.Widget_Scoreboard_RowHeader.UpdateScoreboardConfig");
		
		UWidget_Scoreboard_RowHeader_UpdateScoreboardConfig_Params params {};
		params.Config = Config;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0575C2B0
	 * 		Name   -> Function Insurgency.Widget_Scoreboard_RowHeader.UpdatePlayerCountLabel
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void UWidget_Scoreboard_RowHeader::UpdatePlayerCountLabel()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.Widget_Scoreboard_RowHeader.UpdatePlayerCountLabel");
		
		UWidget_Scoreboard_RowHeader_UpdatePlayerCountLabel_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0575C230
	 * 		Name   -> Function Insurgency.Widget_Scoreboard_RowHeader.SetTeam
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class ATeamInfo*                                   NewTeam                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	void UWidget_Scoreboard_RowHeader::SetTeam(class ATeamInfo* NewTeam)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.Widget_Scoreboard_RowHeader.SetTeam");
		
		UWidget_Scoreboard_RowHeader_SetTeam_Params params {};
		params.NewTeam = NewTeam;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0575C210
	 * 		Name   -> Function Insurgency.Widget_Scoreboard_RowHeader.CheckPlayerCount
	 * 		Flags  -> (Final, Native, Public)
	 */
	void UWidget_Scoreboard_RowHeader::CheckPlayerCount()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.Widget_Scoreboard_RowHeader.CheckPlayerCount");
		
		UWidget_Scoreboard_RowHeader_CheckPlayerCount_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0575C180
	 * 		Name   -> Function Insurgency.Widget_Scoreboard_RowHeader.CheckObjectiveVisibility
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		bool                                               bCanShowObjectives                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	 */
	ESlateVisibility UWidget_Scoreboard_RowHeader::CheckObjectiveVisibility(bool bCanShowObjectives)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Insurgency.Widget_Scoreboard_RowHeader.CheckObjectiveVisibility");
		
		UWidget_Scoreboard_RowHeader_CheckObjectiveVisibility_Params params {};
		params.bCanShowObjectives = bCanShowObjectives;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UWidget_Scoreboard_RowHeader.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UWidget_Scoreboard_RowHeader::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Insurgency.Widget_Scoreboard_RowHeader");
		return ptr;
	}

}


